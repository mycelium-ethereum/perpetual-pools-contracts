{
    "address": "0x86aE3A70301705C6495Fd617787895C9A6238FfE",
    "abi": [
        {
            "inputs": [],
            "name": "MAX_DECIMALS",
            "outputs": [
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                }
            ],
            "stateMutability": "view",
            "type": "function"
        },
        {
            "inputs": [],
            "name": "WAD_PRECISION",
            "outputs": [
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                }
            ],
            "stateMutability": "view",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "uint256",
                    "name": "timestamp",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "lastPriceTimestamp",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "frontRunningInterval",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "updateInterval",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "currentUpdateIntervalId",
                    "type": "uint256"
                }
            ],
            "name": "appropriateUpdateIntervalId",
            "outputs": [
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                }
            ],
            "stateMutability": "pure",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "components": [
                        {
                            "internalType": "int256",
                            "name": "oldPrice",
                            "type": "int256"
                        },
                        {
                            "internalType": "int256",
                            "name": "newPrice",
                            "type": "int256"
                        },
                        {
                            "internalType": "uint256",
                            "name": "longBalance",
                            "type": "uint256"
                        },
                        {
                            "internalType": "uint256",
                            "name": "shortBalance",
                            "type": "uint256"
                        },
                        {
                            "internalType": "bytes16",
                            "name": "leverageAmount",
                            "type": "bytes16"
                        },
                        {
                            "internalType": "bytes16",
                            "name": "fee",
                            "type": "bytes16"
                        }
                    ],
                    "internalType": "struct PoolSwapLibrary.PriceChangeData",
                    "name": "priceChange",
                    "type": "tuple"
                }
            ],
            "name": "calculatePriceChange",
            "outputs": [
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                }
            ],
            "stateMutability": "pure",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "bytes16",
                    "name": "x",
                    "type": "bytes16"
                },
                {
                    "internalType": "bytes16",
                    "name": "y",
                    "type": "bytes16"
                }
            ],
            "name": "compareDecimals",
            "outputs": [
                {
                    "internalType": "int8",
                    "name": "",
                    "type": "int8"
                }
            ],
            "stateMutability": "pure",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "bytes16",
                    "name": "ratio",
                    "type": "bytes16"
                }
            ],
            "name": "convertDecimalToUInt",
            "outputs": [
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                }
            ],
            "stateMutability": "pure",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "uint256",
                    "name": "amount",
                    "type": "uint256"
                }
            ],
            "name": "convertUIntToDecimal",
            "outputs": [
                {
                    "internalType": "bytes16",
                    "name": "",
                    "type": "bytes16"
                }
            ],
            "stateMutability": "pure",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "int256",
                    "name": "a",
                    "type": "int256"
                },
                {
                    "internalType": "int256",
                    "name": "b",
                    "type": "int256"
                }
            ],
            "name": "divInt",
            "outputs": [
                {
                    "internalType": "bytes16",
                    "name": "",
                    "type": "bytes16"
                }
            ],
            "stateMutability": "pure",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "uint256",
                    "name": "_wadValue",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "_decimals",
                    "type": "uint256"
                }
            ],
            "name": "fromWad",
            "outputs": [
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                }
            ],
            "stateMutability": "pure",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "uint256",
                    "name": "reward",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "shortBalance",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "longBalance",
                    "type": "uint256"
                }
            ],
            "name": "getBalancesAfterFees",
            "outputs": [
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                }
            ],
            "stateMutability": "pure",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "bytes16",
                    "name": "price",
                    "type": "bytes16"
                },
                {
                    "internalType": "uint256",
                    "name": "amount",
                    "type": "uint256"
                }
            ],
            "name": "getBurn",
            "outputs": [
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                }
            ],
            "stateMutability": "pure",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "bytes16",
                    "name": "lossMultiplier",
                    "type": "bytes16"
                },
                {
                    "internalType": "uint256",
                    "name": "balance",
                    "type": "uint256"
                }
            ],
            "name": "getLossAmount",
            "outputs": [
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                }
            ],
            "stateMutability": "pure",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "bytes16",
                    "name": "ratio",
                    "type": "bytes16"
                },
                {
                    "internalType": "int8",
                    "name": "direction",
                    "type": "int8"
                },
                {
                    "internalType": "bytes16",
                    "name": "leverage",
                    "type": "bytes16"
                }
            ],
            "name": "getLossMultiplier",
            "outputs": [
                {
                    "internalType": "bytes16",
                    "name": "",
                    "type": "bytes16"
                }
            ],
            "stateMutability": "pure",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "bytes16",
                    "name": "price",
                    "type": "bytes16"
                },
                {
                    "internalType": "uint256",
                    "name": "amount",
                    "type": "uint256"
                }
            ],
            "name": "getMint",
            "outputs": [
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                }
            ],
            "stateMutability": "pure",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "uint256",
                    "name": "tokenSupply",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "amountIn",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "balance",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "shadowBalance",
                    "type": "uint256"
                }
            ],
            "name": "getMintAmount",
            "outputs": [
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                }
            ],
            "stateMutability": "pure",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "bytes16",
                    "name": "price",
                    "type": "bytes16"
                },
                {
                    "internalType": "bytes16",
                    "name": "oppositePrice",
                    "type": "bytes16"
                },
                {
                    "internalType": "uint256",
                    "name": "amount",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "amountBurnedInstantMint",
                    "type": "uint256"
                }
            ],
            "name": "getMintWithBurns",
            "outputs": [
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                }
            ],
            "stateMutability": "pure",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "uint256",
                    "name": "sideBalance",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "tokenSupply",
                    "type": "uint256"
                }
            ],
            "name": "getPrice",
            "outputs": [
                {
                    "internalType": "bytes16",
                    "name": "",
                    "type": "bytes16"
                }
            ],
            "stateMutability": "pure",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "uint256",
                    "name": "_numerator",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "_denominator",
                    "type": "uint256"
                }
            ],
            "name": "getRatio",
            "outputs": [
                {
                    "internalType": "bytes16",
                    "name": "",
                    "type": "bytes16"
                }
            ],
            "stateMutability": "pure",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "components": [
                        {
                            "internalType": "bytes16",
                            "name": "longPrice",
                            "type": "bytes16"
                        },
                        {
                            "internalType": "bytes16",
                            "name": "shortPrice",
                            "type": "bytes16"
                        },
                        {
                            "internalType": "uint256",
                            "name": "currentUpdateIntervalId",
                            "type": "uint256"
                        },
                        {
                            "internalType": "uint256",
                            "name": "updateIntervalId",
                            "type": "uint256"
                        },
                        {
                            "internalType": "uint256",
                            "name": "longMintAmount",
                            "type": "uint256"
                        },
                        {
                            "internalType": "uint256",
                            "name": "longBurnAmount",
                            "type": "uint256"
                        },
                        {
                            "internalType": "uint256",
                            "name": "shortMintAmount",
                            "type": "uint256"
                        },
                        {
                            "internalType": "uint256",
                            "name": "shortBurnAmount",
                            "type": "uint256"
                        },
                        {
                            "internalType": "uint256",
                            "name": "longBurnShortMintAmount",
                            "type": "uint256"
                        },
                        {
                            "internalType": "uint256",
                            "name": "shortBurnLongMintAmount",
                            "type": "uint256"
                        },
                        {
                            "internalType": "bytes16",
                            "name": "burnFee",
                            "type": "bytes16"
                        }
                    ],
                    "internalType": "struct PoolSwapLibrary.UpdateData",
                    "name": "data",
                    "type": "tuple"
                }
            ],
            "name": "getUpdatedAggregateBalance",
            "outputs": [
                {
                    "internalType": "uint256",
                    "name": "_newLongTokens",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "_newShortTokens",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "_longBurnFee",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "_shortBurnFee",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "_newSettlementTokens",
                    "type": "uint256"
                }
            ],
            "stateMutability": "pure",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "uint256",
                    "name": "tokenSupply",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "amountIn",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "balance",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "shadowBalance",
                    "type": "uint256"
                }
            ],
            "name": "getWithdrawAmountOnBurn",
            "outputs": [
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                }
            ],
            "stateMutability": "pure",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "uint256",
                    "name": "subjectTime",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "lastPriceTimestamp",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "updateInterval",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "frontRunningInterval",
                    "type": "uint256"
                }
            ],
            "name": "isBeforeFrontRunningInterval",
            "outputs": [
                {
                    "internalType": "bool",
                    "name": "",
                    "type": "bool"
                }
            ],
            "stateMutability": "pure",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "uint256",
                    "name": "number",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "numerator",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "denominator",
                    "type": "uint256"
                }
            ],
            "name": "mulFraction",
            "outputs": [
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                }
            ],
            "stateMutability": "pure",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "bytes16",
                    "name": "a",
                    "type": "bytes16"
                },
                {
                    "internalType": "uint256",
                    "name": "b",
                    "type": "uint256"
                }
            ],
            "name": "multiplyDecimalByUInt",
            "outputs": [
                {
                    "internalType": "bytes16",
                    "name": "",
                    "type": "bytes16"
                }
            ],
            "stateMutability": "pure",
            "type": "function"
        },
        {
            "inputs": [],
            "name": "one",
            "outputs": [
                {
                    "internalType": "bytes16",
                    "name": "",
                    "type": "bytes16"
                }
            ],
            "stateMutability": "view",
            "type": "function"
        }
    ],
    "transactionHash": "0x3a6f0b07e72b68ad868e150796b53cc417470103cb317944cbf755e2b2b3266a",
    "receipt": {
        "to": null,
        "from": "0xfb59B91646cd0890F3E5343384FEb746989B66C7",
        "contractAddress": "0x86aE3A70301705C6495Fd617787895C9A6238FfE",
        "transactionIndex": 0,
        "gasUsed": "99689564",
        "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
        "blockHash": "0x0d612f88e5b26e27d1258fe280dbc1ee47f8ea1486761c4aedc7c78a1edc19be",
        "transactionHash": "0x3a6f0b07e72b68ad868e150796b53cc417470103cb317944cbf755e2b2b3266a",
        "logs": [],
        "blockNumber": 7327046,
        "cumulativeGasUsed": "78236543",
        "status": 1,
        "byzantium": true
    },
    "args": [],
    "solcInputHash": "2618b71259c48e264b944568d24817df",
    "metadata": "{\"compiler\":{\"version\":\"0.8.7+commit.e28d00a7\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"MAX_DECIMALS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WAD_PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastPriceTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"frontRunningInterval\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updateInterval\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentUpdateIntervalId\",\"type\":\"uint256\"}],\"name\":\"appropriateUpdateIntervalId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"int256\",\"name\":\"oldPrice\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"newPrice\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"longBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shortBalance\",\"type\":\"uint256\"},{\"internalType\":\"bytes16\",\"name\":\"leverageAmount\",\"type\":\"bytes16\"},{\"internalType\":\"bytes16\",\"name\":\"fee\",\"type\":\"bytes16\"}],\"internalType\":\"struct PoolSwapLibrary.PriceChangeData\",\"name\":\"priceChange\",\"type\":\"tuple\"}],\"name\":\"calculatePriceChange\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"x\",\"type\":\"bytes16\"},{\"internalType\":\"bytes16\",\"name\":\"y\",\"type\":\"bytes16\"}],\"name\":\"compareDecimals\",\"outputs\":[{\"internalType\":\"int8\",\"name\":\"\",\"type\":\"int8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"ratio\",\"type\":\"bytes16\"}],\"name\":\"convertDecimalToUInt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"convertUIntToDecimal\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"a\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"b\",\"type\":\"int256\"}],\"name\":\"divInt\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_wadValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_decimals\",\"type\":\"uint256\"}],\"name\":\"fromWad\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shortBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"longBalance\",\"type\":\"uint256\"}],\"name\":\"getBalancesAfterFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"price\",\"type\":\"bytes16\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getBurn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"lossMultiplier\",\"type\":\"bytes16\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"getLossAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"ratio\",\"type\":\"bytes16\"},{\"internalType\":\"int8\",\"name\":\"direction\",\"type\":\"int8\"},{\"internalType\":\"bytes16\",\"name\":\"leverage\",\"type\":\"bytes16\"}],\"name\":\"getLossMultiplier\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"price\",\"type\":\"bytes16\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getMint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shadowBalance\",\"type\":\"uint256\"}],\"name\":\"getMintAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"price\",\"type\":\"bytes16\"},{\"internalType\":\"bytes16\",\"name\":\"oppositePrice\",\"type\":\"bytes16\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountBurnedInstantMint\",\"type\":\"uint256\"}],\"name\":\"getMintWithBurns\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sideBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenSupply\",\"type\":\"uint256\"}],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_numerator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_denominator\",\"type\":\"uint256\"}],\"name\":\"getRatio\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes16\",\"name\":\"longPrice\",\"type\":\"bytes16\"},{\"internalType\":\"bytes16\",\"name\":\"shortPrice\",\"type\":\"bytes16\"},{\"internalType\":\"uint256\",\"name\":\"currentUpdateIntervalId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updateIntervalId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"longMintAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"longBurnAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shortMintAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shortBurnAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"longBurnShortMintAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shortBurnLongMintAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes16\",\"name\":\"burnFee\",\"type\":\"bytes16\"}],\"internalType\":\"struct PoolSwapLibrary.UpdateData\",\"name\":\"data\",\"type\":\"tuple\"}],\"name\":\"getUpdatedAggregateBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_newLongTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_newShortTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_longBurnFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_shortBurnFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_newSettlementTokens\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shadowBalance\",\"type\":\"uint256\"}],\"name\":\"getWithdrawAmountOnBurn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"subjectTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastPriceTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updateInterval\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"frontRunningInterval\",\"type\":\"uint256\"}],\"name\":\"isBeforeFrontRunningInterval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"number\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numerator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"denominator\",\"type\":\"uint256\"}],\"name\":\"mulFraction\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"a\",\"type\":\"bytes16\"},{\"internalType\":\"uint256\",\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"multiplyDecimalByUInt\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"one\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"appropriateUpdateIntervalId(uint256,uint256,uint256,uint256,uint256)\":{\"details\":\"Note that the timestamp parameter is required to be >= lastPriceTimestamp\",\"params\":{\"currentUpdateIntervalId\":\"The current update interval's ID\",\"frontRunningInterval\":\"The frontrunning interval of a pool - The amount of time before an update interval that you must commit to get included in that update\",\"lastPriceTimestamp\":\"The timestamp of the last price update\",\"timestamp\":\"Current block.timestamp\",\"updateInterval\":\"The frequency of a pool's updates\"},\"returns\":{\"_0\":\"The update interval ID in which a commit being made at time timestamp should be included\"}},\"calculatePriceChange(PoolSwapLibrary.PriceChangeData)\":{\"details\":\"This function should be called by the LeveragedPool.\",\"params\":{\"priceChange\":\"The struct containing necessary data to calculate price change\"},\"returns\":{\"_0\":\"Resulting long balance\",\"_1\":\"Resulting short balance\",\"_2\":\"Total fees (across both long and short sides) resulting from this price change\"}},\"compareDecimals(bytes16,bytes16)\":{\"params\":{\"x\":\"The first number to compare\",\"y\":\"The second number to compare\"},\"returns\":{\"_0\":\"-1 if x < y, 0 if x = y, or 1 if x > y\"}},\"convertDecimalToUInt(bytes16)\":{\"params\":{\"ratio\":\"The value to convert\"},\"returns\":{\"_0\":\"The converted value\"}},\"convertUIntToDecimal(uint256)\":{\"params\":{\"amount\":\"The amount to convert\"},\"returns\":{\"_0\":\"The amount as a IEEE754 quadruple precision number\"}},\"divInt(int256,int256)\":{\"params\":{\"a\":\"The dividend\",\"b\":\"The divisor\"},\"returns\":{\"_0\":\"The quotient\"}},\"fromWad(uint256,uint256)\":{\"params\":{\"_decimals\":\"Quantity of decimal places to support\",\"_wadValue\":\"wad number\"},\"returns\":{\"_0\":\"Converted (non-WAD) value\"}},\"getBalancesAfterFees(uint256,uint256,uint256)\":{\"details\":\"Assumes shortBalance + longBalance >= reward\",\"params\":{\"longBalance\":\"Long balance of the pool\",\"reward\":\"Amount of keeper reward\",\"shortBalance\":\"Short balance of the pool\"},\"returns\":{\"_0\":\"shortBalanceAfterFees Short balance of the pool after the keeper reward has been paid\",\"_1\":\"longBalanceAfterFees Long balance of the pool after the keeper reward has been paid\"}},\"getBurn(bytes16,uint256)\":{\"details\":\"amount * price, where amount is in PoolToken and price is in USD/PoolTokenThrows if price is zero`getMint()`\",\"params\":{\"amount\":\"Amount of settlement tokens being used to burn\",\"price\":\"Price of a pool token\"},\"returns\":{\"_0\":\"Quantity of pool tokens to burn\"}},\"getLossAmount(bytes16,uint256)\":{\"params\":{\"balance\":\"The balance of the losing pool\",\"lossMultiplier\":\"The multiplier to use\"}},\"getLossMultiplier(bytes16,int8,bytes16)\":{\"params\":{\"direction\":\"The direction of the change. -1 if it's decreased, 0 if it hasn't changed, and 1 if it's increased\",\"leverage\":\"The amount of leverage to apply\",\"ratio\":\"The ratio of new price to old price\"},\"returns\":{\"_0\":\"The multiplier\"}},\"getMint(bytes16,uint256)\":{\"details\":\"Throws if price is zero`getBurn()`\",\"params\":{\"amount\":\"Amount of settlement tokens being used to mint\",\"price\":\"Price of a pool token\"},\"returns\":{\"_0\":\"Quantity of pool tokens to mint\"}},\"getMintAmount(uint256,uint256,uint256,uint256)\":{\"details\":\"Calculated as (tokenSupply + shadowBalance) * amountIn / balance\",\"params\":{\"amountIn\":\"Commitment amount of collateral tokens going into the pool\",\"balance\":\"Balance of the pool (no. of underlying collateral tokens in pool)\",\"shadowBalance\":\"Balance the shadow pool at time of mint\",\"tokenSupply\":\"Total supply of pool tokens\"},\"returns\":{\"_0\":\"Number of pool tokens to be minted\"}},\"getMintWithBurns(bytes16,bytes16,uint256,uint256)\":{\"details\":\"Throws if price is zero\",\"params\":{\"amount\":\"The amount of settlement tokens being used to mint\",\"amountBurnedInstantMint\":\"The amount of pool tokens that were burnt from the opposite side for an instant mint in this side\",\"oppositePrice\":\"The price of the opposite side's pool token\",\"price\":\"The price of a pool token\"},\"returns\":{\"_0\":\"Quantity of pool tokens to mint\"}},\"getPrice(uint256,uint256)\":{\"details\":\"Divide the side balance by the pool token's total supply\",\"params\":{\"sideBalance\":\"no. of underlying collateral tokens on that side of the pool\",\"tokenSupply\":\"Total supply of pool tokens\"}},\"getRatio(uint256,uint256)\":{\"details\":\"Rounds any overflow towards 0. If either parameter is zero, the ratio is 0\",\"params\":{\"_denominator\":\"The \\\"per part\\\" side of the equation. If this is zero, the ratio is zero\",\"_numerator\":\"The \\\"parts per\\\" side of the equation. If this is zero, the ratio is zero\"},\"returns\":{\"_0\":\"the ratio, as an ABDKMathQuad number (IEEE 754 quadruple precision floating point)\"}},\"getUpdatedAggregateBalance(PoolSwapLibrary.UpdateData)\":{\"params\":{\"data\":\"Information needed for updating the balance including prices and recent commit amounts\"},\"returns\":{\"_longBurnFee\":\"Quantity of settlement tokens taken as a fee from long burns\",\"_newLongTokens\":\"Quantity of additional long tokens the user would receive\",\"_newSettlementTokens\":\"Quantity of additional settlement tokens the user would receive\",\"_newShortTokens\":\"Quantity of additional short tokens the user would receive\",\"_shortBurnFee\":\"Quantity of settlement tokens taken as a fee from short burns\"}},\"getWithdrawAmountOnBurn(uint256,uint256,uint256,uint256)\":{\"details\":\"Calculates as `balance * amountIn / (tokenSupply + shadowBalance)\",\"params\":{\"amountIn\":\"Commitment amount of pool tokens going into the pool\",\"balance\":\"Balance of the pool (no. of underlying collateral tokens in pool)\",\"shadowBalance\":\"Balance the shadow pool at time of mint\",\"tokenSupply\":\"Total supply of pool tokens\"},\"returns\":{\"_0\":\"Number of settlement tokens to be withdrawn on a burn\"}},\"isBeforeFrontRunningInterval(uint256,uint256,uint256,uint256)\":{\"details\":\"If you try to uncommit AFTER the frontRunningInterval, it should revert.\",\"params\":{\"frontRunningInterval\":\"The window of time before a price udpate users can not uncommit or have their commit executed from\",\"lastPriceTimestamp\":\"The timestamp of the last price update\",\"subjectTime\":\"The timestamp for which you want to calculate if it was beforeFrontRunningInterval\",\"updateInterval\":\"The interval between price updates\"}},\"mulFraction(uint256,uint256,uint256)\":{\"returns\":{\"_0\":\"The result as an integer\"}},\"multiplyDecimalByUInt(bytes16,uint256)\":{\"params\":{\"a\":\"The first term\",\"b\":\"The second term\"},\"returns\":{\"_0\":\"The product of a*b as a decimal\"}}},\"title\":\"Library for various useful (mostly) mathematical functions\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"MAX_DECIMALS()\":{\"notice\":\"Maximum number of decimal places supported by this contract (ABDKMathQuad defines this but it's private)\"},\"WAD_PRECISION()\":{\"notice\":\"Maximum precision supportable via wad arithmetic (for this contract)\"},\"appropriateUpdateIntervalId(uint256,uint256,uint256,uint256,uint256)\":{\"notice\":\"Calculates the update interval ID that a commitment should be placed in.\"},\"calculatePriceChange(PoolSwapLibrary.PriceChangeData)\":{\"notice\":\"Calculates the effect of a price change. This involves calculating how many funds to transfer from the losing pool to the other.\"},\"compareDecimals(bytes16,bytes16)\":{\"notice\":\"Compares two decimal numbers\"},\"convertDecimalToUInt(bytes16)\":{\"notice\":\"Converts a raw decimal value to a more readable uint256 value\"},\"convertUIntToDecimal(uint256)\":{\"notice\":\"Converts an integer value to a compatible decimal value\"},\"divInt(int256,int256)\":{\"notice\":\"Divides two integers\"},\"fromWad(uint256,uint256)\":{\"notice\":\"Converts from a WAD to normal value\"},\"getBalancesAfterFees(uint256,uint256,uint256)\":{\"notice\":\"Gets the short and long balances after the keeper rewards have been paid out         Keeper rewards are paid proportionally to the short and long pool\"},\"getBurn(bytes16,uint256)\":{\"notice\":\"Calculate the number of settlement tokens to burn, based on a price and an amount of pool tokens\"},\"getLossAmount(bytes16,uint256)\":{\"notice\":\"Calculates the amount to take from the losing pool\"},\"getLossMultiplier(bytes16,int8,bytes16)\":{\"notice\":\"Calculates the loss multiplier to apply to the losing pool. Includes the power leverage\"},\"getMint(bytes16,uint256)\":{\"notice\":\"Calculates the number of pool tokens to mint, given some settlement token amount and a price\"},\"getMintAmount(uint256,uint256,uint256,uint256)\":{\"notice\":\"Gets the number of pool tokens to be minted based on existing tokens\"},\"getMintWithBurns(bytes16,bytes16,uint256,uint256)\":{\"notice\":\"Calculate the number of pool tokens to mint, given some settlement token amount, a price, and a burn amount from other side for instant mint\"},\"getPrice(uint256,uint256)\":{\"notice\":\"Get the Settlement/PoolToken price, in ABDK IEE754 precision\"},\"getRatio(uint256,uint256)\":{\"notice\":\"Calculates the ratio between two numbers\"},\"getUpdatedAggregateBalance(PoolSwapLibrary.UpdateData)\":{\"notice\":\"Calculate the change in a user's balance based on recent commit(s)\"},\"getWithdrawAmountOnBurn(uint256,uint256,uint256,uint256)\":{\"notice\":\"Gets the number of settlement tokens to be withdrawn based on a pool token burn amount\"},\"isBeforeFrontRunningInterval(uint256,uint256,uint256,uint256)\":{\"notice\":\"Returns true if the given timestamp is BEFORE the frontRunningInterval starts,         which is allowed for uncommitment.\"},\"mulFraction(uint256,uint256,uint256)\":{\"notice\":\"Multiply an integer by a fraction\"},\"multiplyDecimalByUInt(bytes16,uint256)\":{\"notice\":\"Multiplies a decimal and an unsigned integer\"},\"one()\":{\"notice\":\"ABDKMathQuad-formatted representation of the number one\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/implementation/PoolSwapLibrary.sol\":\"PoolSwapLibrary\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"abdk-libraries-solidity/ABDKMathQuad.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-4-Clause\\n/*\\n * ABDK Math Quad Smart Contract Library.  Copyright \\u00a9 2019 by ABDK Consulting.\\n * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\\n */\\npragma solidity ^0.8.0;\\n\\n/**\\n * Smart contract library of mathematical functions operating with IEEE 754\\n * quadruple-precision binary floating-point numbers (quadruple precision\\n * numbers).  As long as quadruple precision numbers are 16-bytes long, they are\\n * represented by bytes16 type.\\n */\\nlibrary ABDKMathQuad {\\n  /*\\n   * 0.\\n   */\\n  bytes16 private constant POSITIVE_ZERO = 0x00000000000000000000000000000000;\\n\\n  /*\\n   * -0.\\n   */\\n  bytes16 private constant NEGATIVE_ZERO = 0x80000000000000000000000000000000;\\n\\n  /*\\n   * +Infinity.\\n   */\\n  bytes16 private constant POSITIVE_INFINITY = 0x7FFF0000000000000000000000000000;\\n\\n  /*\\n   * -Infinity.\\n   */\\n  bytes16 private constant NEGATIVE_INFINITY = 0xFFFF0000000000000000000000000000;\\n\\n  /*\\n   * Canonical NaN value.\\n   */\\n  bytes16 private constant NaN = 0x7FFF8000000000000000000000000000;\\n\\n  /**\\n   * Convert signed 256-bit integer number into quadruple precision number.\\n   *\\n   * @param x signed 256-bit integer number\\n   * @return quadruple precision number\\n   */\\n  function fromInt (int256 x) internal pure returns (bytes16) {\\n    unchecked {\\n      if (x == 0) return bytes16 (0);\\n      else {\\n        // We rely on overflow behavior here\\n        uint256 result = uint256 (x > 0 ? x : -x);\\n\\n        uint256 msb = mostSignificantBit (result);\\n        if (msb < 112) result <<= 112 - msb;\\n        else if (msb > 112) result >>= msb - 112;\\n\\n        result = result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF | 16383 + msb << 112;\\n        if (x < 0) result |= 0x80000000000000000000000000000000;\\n\\n        return bytes16 (uint128 (result));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert quadruple precision number into signed 256-bit integer number\\n   * rounding towards zero.  Revert on overflow.\\n   *\\n   * @param x quadruple precision number\\n   * @return signed 256-bit integer number\\n   */\\n  function toInt (bytes16 x) internal pure returns (int256) {\\n    unchecked {\\n      uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\\n\\n      require (exponent <= 16638); // Overflow\\n      if (exponent < 16383) return 0; // Underflow\\n\\n      uint256 result = uint256 (uint128 (x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF |\\n        0x10000000000000000000000000000;\\n\\n      if (exponent < 16495) result >>= 16495 - exponent;\\n      else if (exponent > 16495) result <<= exponent - 16495;\\n\\n      if (uint128 (x) >= 0x80000000000000000000000000000000) { // Negative\\n        require (result <= 0x8000000000000000000000000000000000000000000000000000000000000000);\\n        return -int256 (result); // We rely on overflow behavior here\\n      } else {\\n        require (result <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n        return int256 (result);\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert unsigned 256-bit integer number into quadruple precision number.\\n   *\\n   * @param x unsigned 256-bit integer number\\n   * @return quadruple precision number\\n   */\\n  function fromUInt (uint256 x) internal pure returns (bytes16) {\\n    unchecked {\\n      if (x == 0) return bytes16 (0);\\n      else {\\n        uint256 result = x;\\n\\n        uint256 msb = mostSignificantBit (result);\\n        if (msb < 112) result <<= 112 - msb;\\n        else if (msb > 112) result >>= msb - 112;\\n\\n        result = result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF | 16383 + msb << 112;\\n\\n        return bytes16 (uint128 (result));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert quadruple precision number into unsigned 256-bit integer number\\n   * rounding towards zero.  Revert on underflow.  Note, that negative floating\\n   * point numbers in range (-1.0 .. 0.0) may be converted to unsigned integer\\n   * without error, because they are rounded to zero.\\n   *\\n   * @param x quadruple precision number\\n   * @return unsigned 256-bit integer number\\n   */\\n  function toUInt (bytes16 x) internal pure returns (uint256) {\\n    unchecked {\\n      uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\\n\\n      if (exponent < 16383) return 0; // Underflow\\n\\n      require (uint128 (x) < 0x80000000000000000000000000000000); // Negative\\n\\n      require (exponent <= 16638); // Overflow\\n      uint256 result = uint256 (uint128 (x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF |\\n        0x10000000000000000000000000000;\\n\\n      if (exponent < 16495) result >>= 16495 - exponent;\\n      else if (exponent > 16495) result <<= exponent - 16495;\\n\\n      return result;\\n    }\\n  }\\n\\n  /**\\n   * Convert signed 128.128 bit fixed point number into quadruple precision\\n   * number.\\n   *\\n   * @param x signed 128.128 bit fixed point number\\n   * @return quadruple precision number\\n   */\\n  function from128x128 (int256 x) internal pure returns (bytes16) {\\n    unchecked {\\n      if (x == 0) return bytes16 (0);\\n      else {\\n        // We rely on overflow behavior here\\n        uint256 result = uint256 (x > 0 ? x : -x);\\n\\n        uint256 msb = mostSignificantBit (result);\\n        if (msb < 112) result <<= 112 - msb;\\n        else if (msb > 112) result >>= msb - 112;\\n\\n        result = result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF | 16255 + msb << 112;\\n        if (x < 0) result |= 0x80000000000000000000000000000000;\\n\\n        return bytes16 (uint128 (result));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert quadruple precision number into signed 128.128 bit fixed point\\n   * number.  Revert on overflow.\\n   *\\n   * @param x quadruple precision number\\n   * @return signed 128.128 bit fixed point number\\n   */\\n  function to128x128 (bytes16 x) internal pure returns (int256) {\\n    unchecked {\\n      uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\\n\\n      require (exponent <= 16510); // Overflow\\n      if (exponent < 16255) return 0; // Underflow\\n\\n      uint256 result = uint256 (uint128 (x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF |\\n        0x10000000000000000000000000000;\\n\\n      if (exponent < 16367) result >>= 16367 - exponent;\\n      else if (exponent > 16367) result <<= exponent - 16367;\\n\\n      if (uint128 (x) >= 0x80000000000000000000000000000000) { // Negative\\n        require (result <= 0x8000000000000000000000000000000000000000000000000000000000000000);\\n        return -int256 (result); // We rely on overflow behavior here\\n      } else {\\n        require (result <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n        return int256 (result);\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert signed 64.64 bit fixed point number into quadruple precision\\n   * number.\\n   *\\n   * @param x signed 64.64 bit fixed point number\\n   * @return quadruple precision number\\n   */\\n  function from64x64 (int128 x) internal pure returns (bytes16) {\\n    unchecked {\\n      if (x == 0) return bytes16 (0);\\n      else {\\n        // We rely on overflow behavior here\\n        uint256 result = uint128 (x > 0 ? x : -x);\\n\\n        uint256 msb = mostSignificantBit (result);\\n        if (msb < 112) result <<= 112 - msb;\\n        else if (msb > 112) result >>= msb - 112;\\n\\n        result = result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF | 16319 + msb << 112;\\n        if (x < 0) result |= 0x80000000000000000000000000000000;\\n\\n        return bytes16 (uint128 (result));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert quadruple precision number into signed 64.64 bit fixed point\\n   * number.  Revert on overflow.\\n   *\\n   * @param x quadruple precision number\\n   * @return signed 64.64 bit fixed point number\\n   */\\n  function to64x64 (bytes16 x) internal pure returns (int128) {\\n    unchecked {\\n      uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\\n\\n      require (exponent <= 16446); // Overflow\\n      if (exponent < 16319) return 0; // Underflow\\n\\n      uint256 result = uint256 (uint128 (x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF |\\n        0x10000000000000000000000000000;\\n\\n      if (exponent < 16431) result >>= 16431 - exponent;\\n      else if (exponent > 16431) result <<= exponent - 16431;\\n\\n      if (uint128 (x) >= 0x80000000000000000000000000000000) { // Negative\\n        require (result <= 0x80000000000000000000000000000000);\\n        return -int128 (int256 (result)); // We rely on overflow behavior here\\n      } else {\\n        require (result <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n        return int128 (int256 (result));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert octuple precision number into quadruple precision number.\\n   *\\n   * @param x octuple precision number\\n   * @return quadruple precision number\\n   */\\n  function fromOctuple (bytes32 x) internal pure returns (bytes16) {\\n    unchecked {\\n      bool negative = x & 0x8000000000000000000000000000000000000000000000000000000000000000 > 0;\\n\\n      uint256 exponent = uint256 (x) >> 236 & 0x7FFFF;\\n      uint256 significand = uint256 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      if (exponent == 0x7FFFF) {\\n        if (significand > 0) return NaN;\\n        else return negative ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\\n      }\\n\\n      if (exponent > 278526)\\n        return negative ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\\n      else if (exponent < 245649)\\n        return negative ? NEGATIVE_ZERO : POSITIVE_ZERO;\\n      else if (exponent < 245761) {\\n        significand = (significand | 0x100000000000000000000000000000000000000000000000000000000000) >> 245885 - exponent;\\n        exponent = 0;\\n      } else {\\n        significand >>= 124;\\n        exponent -= 245760;\\n      }\\n\\n      uint128 result = uint128 (significand | exponent << 112);\\n      if (negative) result |= 0x80000000000000000000000000000000;\\n\\n      return bytes16 (result);\\n    }\\n  }\\n\\n  /**\\n   * Convert quadruple precision number into octuple precision number.\\n   *\\n   * @param x quadruple precision number\\n   * @return octuple precision number\\n   */\\n  function toOctuple (bytes16 x) internal pure returns (bytes32) {\\n    unchecked {\\n      uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\\n\\n      uint256 result = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      if (exponent == 0x7FFF) exponent = 0x7FFFF; // Infinity or NaN\\n      else if (exponent == 0) {\\n        if (result > 0) {\\n          uint256 msb = mostSignificantBit (result);\\n          result = result << 236 - msb & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n          exponent = 245649 + msb;\\n        }\\n      } else {\\n        result <<= 124;\\n        exponent += 245760;\\n      }\\n\\n      result |= exponent << 236;\\n      if (uint128 (x) >= 0x80000000000000000000000000000000)\\n        result |= 0x8000000000000000000000000000000000000000000000000000000000000000;\\n\\n      return bytes32 (result);\\n    }\\n  }\\n\\n  /**\\n   * Convert double precision number into quadruple precision number.\\n   *\\n   * @param x double precision number\\n   * @return quadruple precision number\\n   */\\n  function fromDouble (bytes8 x) internal pure returns (bytes16) {\\n    unchecked {\\n      uint256 exponent = uint64 (x) >> 52 & 0x7FF;\\n\\n      uint256 result = uint64 (x) & 0xFFFFFFFFFFFFF;\\n\\n      if (exponent == 0x7FF) exponent = 0x7FFF; // Infinity or NaN\\n      else if (exponent == 0) {\\n        if (result > 0) {\\n          uint256 msb = mostSignificantBit (result);\\n          result = result << 112 - msb & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n          exponent = 15309 + msb;\\n        }\\n      } else {\\n        result <<= 60;\\n        exponent += 15360;\\n      }\\n\\n      result |= exponent << 112;\\n      if (x & 0x8000000000000000 > 0)\\n        result |= 0x80000000000000000000000000000000;\\n\\n      return bytes16 (uint128 (result));\\n    }\\n  }\\n\\n  /**\\n   * Convert quadruple precision number into double precision number.\\n   *\\n   * @param x quadruple precision number\\n   * @return double precision number\\n   */\\n  function toDouble (bytes16 x) internal pure returns (bytes8) {\\n    unchecked {\\n      bool negative = uint128 (x) >= 0x80000000000000000000000000000000;\\n\\n      uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\\n      uint256 significand = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      if (exponent == 0x7FFF) {\\n        if (significand > 0) return 0x7FF8000000000000; // NaN\\n        else return negative ?\\n            bytes8 (0xFFF0000000000000) : // -Infinity\\n            bytes8 (0x7FF0000000000000); // Infinity\\n      }\\n\\n      if (exponent > 17406)\\n        return negative ?\\n            bytes8 (0xFFF0000000000000) : // -Infinity\\n            bytes8 (0x7FF0000000000000); // Infinity\\n      else if (exponent < 15309)\\n        return negative ?\\n            bytes8 (0x8000000000000000) : // -0\\n            bytes8 (0x0000000000000000); // 0\\n      else if (exponent < 15361) {\\n        significand = (significand | 0x10000000000000000000000000000) >> 15421 - exponent;\\n        exponent = 0;\\n      } else {\\n        significand >>= 60;\\n        exponent -= 15360;\\n      }\\n\\n      uint64 result = uint64 (significand | exponent << 52);\\n      if (negative) result |= 0x8000000000000000;\\n\\n      return bytes8 (result);\\n    }\\n  }\\n\\n  /**\\n   * Test whether given quadruple precision number is NaN.\\n   *\\n   * @param x quadruple precision number\\n   * @return true if x is NaN, false otherwise\\n   */\\n  function isNaN (bytes16 x) internal pure returns (bool) {\\n    unchecked {\\n      return uint128 (x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF >\\n        0x7FFF0000000000000000000000000000;\\n    }\\n  }\\n\\n  /**\\n   * Test whether given quadruple precision number is positive or negative\\n   * infinity.\\n   *\\n   * @param x quadruple precision number\\n   * @return true if x is positive or negative infinity, false otherwise\\n   */\\n  function isInfinity (bytes16 x) internal pure returns (bool) {\\n    unchecked {\\n      return uint128 (x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF ==\\n        0x7FFF0000000000000000000000000000;\\n    }\\n  }\\n\\n  /**\\n   * Calculate sign of x, i.e. -1 if x is negative, 0 if x if zero, and 1 if x\\n   * is positive.  Note that sign (-0) is zero.  Revert if x is NaN. \\n   *\\n   * @param x quadruple precision number\\n   * @return sign of x\\n   */\\n  function sign (bytes16 x) internal pure returns (int8) {\\n    unchecked {\\n      uint128 absoluteX = uint128 (x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      require (absoluteX <= 0x7FFF0000000000000000000000000000); // Not NaN\\n\\n      if (absoluteX == 0) return 0;\\n      else if (uint128 (x) >= 0x80000000000000000000000000000000) return -1;\\n      else return 1;\\n    }\\n  }\\n\\n  /**\\n   * Calculate sign (x - y).  Revert if either argument is NaN, or both\\n   * arguments are infinities of the same sign. \\n   *\\n   * @param x quadruple precision number\\n   * @param y quadruple precision number\\n   * @return sign (x - y)\\n   */\\n  function cmp (bytes16 x, bytes16 y) internal pure returns (int8) {\\n    unchecked {\\n      uint128 absoluteX = uint128 (x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      require (absoluteX <= 0x7FFF0000000000000000000000000000); // Not NaN\\n\\n      uint128 absoluteY = uint128 (y) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      require (absoluteY <= 0x7FFF0000000000000000000000000000); // Not NaN\\n\\n      // Not infinities of the same sign\\n      require (x != y || absoluteX < 0x7FFF0000000000000000000000000000);\\n\\n      if (x == y) return 0;\\n      else {\\n        bool negativeX = uint128 (x) >= 0x80000000000000000000000000000000;\\n        bool negativeY = uint128 (y) >= 0x80000000000000000000000000000000;\\n\\n        if (negativeX) {\\n          if (negativeY) return absoluteX > absoluteY ? -1 : int8 (1);\\n          else return -1; \\n        } else {\\n          if (negativeY) return 1;\\n          else return absoluteX > absoluteY ? int8 (1) : -1;\\n        }\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Test whether x equals y.  NaN, infinity, and -infinity are not equal to\\n   * anything. \\n   *\\n   * @param x quadruple precision number\\n   * @param y quadruple precision number\\n   * @return true if x equals to y, false otherwise\\n   */\\n  function eq (bytes16 x, bytes16 y) internal pure returns (bool) {\\n    unchecked {\\n      if (x == y) {\\n        return uint128 (x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF <\\n          0x7FFF0000000000000000000000000000;\\n      } else return false;\\n    }\\n  }\\n\\n  /**\\n   * Calculate x + y.  Special values behave in the following way:\\n   *\\n   * NaN + x = NaN for any x.\\n   * Infinity + x = Infinity for any finite x.\\n   * -Infinity + x = -Infinity for any finite x.\\n   * Infinity + Infinity = Infinity.\\n   * -Infinity + -Infinity = -Infinity.\\n   * Infinity + -Infinity = -Infinity + Infinity = NaN.\\n   *\\n   * @param x quadruple precision number\\n   * @param y quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function add (bytes16 x, bytes16 y) internal pure returns (bytes16) {\\n    unchecked {\\n      uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\\n      uint256 yExponent = uint128 (y) >> 112 & 0x7FFF;\\n\\n      if (xExponent == 0x7FFF) {\\n        if (yExponent == 0x7FFF) { \\n          if (x == y) return x;\\n          else return NaN;\\n        } else return x; \\n      } else if (yExponent == 0x7FFF) return y;\\n      else {\\n        bool xSign = uint128 (x) >= 0x80000000000000000000000000000000;\\n        uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (xExponent == 0) xExponent = 1;\\n        else xSignifier |= 0x10000000000000000000000000000;\\n\\n        bool ySign = uint128 (y) >= 0x80000000000000000000000000000000;\\n        uint256 ySignifier = uint128 (y) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (yExponent == 0) yExponent = 1;\\n        else ySignifier |= 0x10000000000000000000000000000;\\n\\n        if (xSignifier == 0) return y == NEGATIVE_ZERO ? POSITIVE_ZERO : y;\\n        else if (ySignifier == 0) return x == NEGATIVE_ZERO ? POSITIVE_ZERO : x;\\n        else {\\n          int256 delta = int256 (xExponent) - int256 (yExponent);\\n  \\n          if (xSign == ySign) {\\n            if (delta > 112) return x;\\n            else if (delta > 0) ySignifier >>= uint256 (delta);\\n            else if (delta < -112) return y;\\n            else if (delta < 0) {\\n              xSignifier >>= uint256 (-delta);\\n              xExponent = yExponent;\\n            }\\n  \\n            xSignifier += ySignifier;\\n  \\n            if (xSignifier >= 0x20000000000000000000000000000) {\\n              xSignifier >>= 1;\\n              xExponent += 1;\\n            }\\n  \\n            if (xExponent == 0x7FFF)\\n              return xSign ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\\n            else {\\n              if (xSignifier < 0x10000000000000000000000000000) xExponent = 0;\\n              else xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n  \\n              return bytes16 (uint128 (\\n                  (xSign ? 0x80000000000000000000000000000000 : 0) |\\n                  (xExponent << 112) |\\n                  xSignifier)); \\n            }\\n          } else {\\n            if (delta > 0) {\\n              xSignifier <<= 1;\\n              xExponent -= 1;\\n            } else if (delta < 0) {\\n              ySignifier <<= 1;\\n              xExponent = yExponent - 1;\\n            }\\n\\n            if (delta > 112) ySignifier = 1;\\n            else if (delta > 1) ySignifier = (ySignifier - 1 >> uint256 (delta - 1)) + 1;\\n            else if (delta < -112) xSignifier = 1;\\n            else if (delta < -1) xSignifier = (xSignifier - 1 >> uint256 (-delta - 1)) + 1;\\n\\n            if (xSignifier >= ySignifier) xSignifier -= ySignifier;\\n            else {\\n              xSignifier = ySignifier - xSignifier;\\n              xSign = ySign;\\n            }\\n\\n            if (xSignifier == 0)\\n              return POSITIVE_ZERO;\\n\\n            uint256 msb = mostSignificantBit (xSignifier);\\n\\n            if (msb == 113) {\\n              xSignifier = xSignifier >> 1 & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n              xExponent += 1;\\n            } else if (msb < 112) {\\n              uint256 shift = 112 - msb;\\n              if (xExponent > shift) {\\n                xSignifier = xSignifier << shift & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n                xExponent -= shift;\\n              } else {\\n                xSignifier <<= xExponent - 1;\\n                xExponent = 0;\\n              }\\n            } else xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n            if (xExponent == 0x7FFF)\\n              return xSign ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\\n            else return bytes16 (uint128 (\\n                (xSign ? 0x80000000000000000000000000000000 : 0) |\\n                (xExponent << 112) |\\n                xSignifier));\\n          }\\n        }\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate x - y.  Special values behave in the following way:\\n   *\\n   * NaN - x = NaN for any x.\\n   * Infinity - x = Infinity for any finite x.\\n   * -Infinity - x = -Infinity for any finite x.\\n   * Infinity - -Infinity = Infinity.\\n   * -Infinity - Infinity = -Infinity.\\n   * Infinity - Infinity = -Infinity - -Infinity = NaN.\\n   *\\n   * @param x quadruple precision number\\n   * @param y quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function sub (bytes16 x, bytes16 y) internal pure returns (bytes16) {\\n    unchecked {\\n      return add (x, y ^ 0x80000000000000000000000000000000);\\n    }\\n  }\\n\\n  /**\\n   * Calculate x * y.  Special values behave in the following way:\\n   *\\n   * NaN * x = NaN for any x.\\n   * Infinity * x = Infinity for any finite positive x.\\n   * Infinity * x = -Infinity for any finite negative x.\\n   * -Infinity * x = -Infinity for any finite positive x.\\n   * -Infinity * x = Infinity for any finite negative x.\\n   * Infinity * 0 = NaN.\\n   * -Infinity * 0 = NaN.\\n   * Infinity * Infinity = Infinity.\\n   * Infinity * -Infinity = -Infinity.\\n   * -Infinity * Infinity = -Infinity.\\n   * -Infinity * -Infinity = Infinity.\\n   *\\n   * @param x quadruple precision number\\n   * @param y quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function mul (bytes16 x, bytes16 y) internal pure returns (bytes16) {\\n    unchecked {\\n      uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\\n      uint256 yExponent = uint128 (y) >> 112 & 0x7FFF;\\n\\n      if (xExponent == 0x7FFF) {\\n        if (yExponent == 0x7FFF) {\\n          if (x == y) return x ^ y & 0x80000000000000000000000000000000;\\n          else if (x ^ y == 0x80000000000000000000000000000000) return x | y;\\n          else return NaN;\\n        } else {\\n          if (y & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) return NaN;\\n          else return x ^ y & 0x80000000000000000000000000000000;\\n        }\\n      } else if (yExponent == 0x7FFF) {\\n          if (x & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) return NaN;\\n          else return y ^ x & 0x80000000000000000000000000000000;\\n      } else {\\n        uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (xExponent == 0) xExponent = 1;\\n        else xSignifier |= 0x10000000000000000000000000000;\\n\\n        uint256 ySignifier = uint128 (y) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (yExponent == 0) yExponent = 1;\\n        else ySignifier |= 0x10000000000000000000000000000;\\n\\n        xSignifier *= ySignifier;\\n        if (xSignifier == 0)\\n          return (x ^ y) & 0x80000000000000000000000000000000 > 0 ?\\n              NEGATIVE_ZERO : POSITIVE_ZERO;\\n\\n        xExponent += yExponent;\\n\\n        uint256 msb =\\n          xSignifier >= 0x200000000000000000000000000000000000000000000000000000000 ? 225 :\\n          xSignifier >= 0x100000000000000000000000000000000000000000000000000000000 ? 224 :\\n          mostSignificantBit (xSignifier);\\n\\n        if (xExponent + msb < 16496) { // Underflow\\n          xExponent = 0;\\n          xSignifier = 0;\\n        } else if (xExponent + msb < 16608) { // Subnormal\\n          if (xExponent < 16496)\\n            xSignifier >>= 16496 - xExponent;\\n          else if (xExponent > 16496)\\n            xSignifier <<= xExponent - 16496;\\n          xExponent = 0;\\n        } else if (xExponent + msb > 49373) {\\n          xExponent = 0x7FFF;\\n          xSignifier = 0;\\n        } else {\\n          if (msb > 112)\\n            xSignifier >>= msb - 112;\\n          else if (msb < 112)\\n            xSignifier <<= 112 - msb;\\n\\n          xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n          xExponent = xExponent + msb - 16607;\\n        }\\n\\n        return bytes16 (uint128 (uint128 ((x ^ y) & 0x80000000000000000000000000000000) |\\n            xExponent << 112 | xSignifier));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate x / y.  Special values behave in the following way:\\n   *\\n   * NaN / x = NaN for any x.\\n   * x / NaN = NaN for any x.\\n   * Infinity / x = Infinity for any finite non-negative x.\\n   * Infinity / x = -Infinity for any finite negative x including -0.\\n   * -Infinity / x = -Infinity for any finite non-negative x.\\n   * -Infinity / x = Infinity for any finite negative x including -0.\\n   * x / Infinity = 0 for any finite non-negative x.\\n   * x / -Infinity = -0 for any finite non-negative x.\\n   * x / Infinity = -0 for any finite non-negative x including -0.\\n   * x / -Infinity = 0 for any finite non-negative x including -0.\\n   * \\n   * Infinity / Infinity = NaN.\\n   * Infinity / -Infinity = -NaN.\\n   * -Infinity / Infinity = -NaN.\\n   * -Infinity / -Infinity = NaN.\\n   *\\n   * Division by zero behaves in the following way:\\n   *\\n   * x / 0 = Infinity for any finite positive x.\\n   * x / -0 = -Infinity for any finite positive x.\\n   * x / 0 = -Infinity for any finite negative x.\\n   * x / -0 = Infinity for any finite negative x.\\n   * 0 / 0 = NaN.\\n   * 0 / -0 = NaN.\\n   * -0 / 0 = NaN.\\n   * -0 / -0 = NaN.\\n   *\\n   * @param x quadruple precision number\\n   * @param y quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function div (bytes16 x, bytes16 y) internal pure returns (bytes16) {\\n    unchecked {\\n      uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\\n      uint256 yExponent = uint128 (y) >> 112 & 0x7FFF;\\n\\n      if (xExponent == 0x7FFF) {\\n        if (yExponent == 0x7FFF) return NaN;\\n        else return x ^ y & 0x80000000000000000000000000000000;\\n      } else if (yExponent == 0x7FFF) {\\n        if (y & 0x0000FFFFFFFFFFFFFFFFFFFFFFFFFFFF != 0) return NaN;\\n        else return POSITIVE_ZERO | (x ^ y) & 0x80000000000000000000000000000000;\\n      } else if (y & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) {\\n        if (x & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) return NaN;\\n        else return POSITIVE_INFINITY | (x ^ y) & 0x80000000000000000000000000000000;\\n      } else {\\n        uint256 ySignifier = uint128 (y) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (yExponent == 0) yExponent = 1;\\n        else ySignifier |= 0x10000000000000000000000000000;\\n\\n        uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (xExponent == 0) {\\n          if (xSignifier != 0) {\\n            uint shift = 226 - mostSignificantBit (xSignifier);\\n\\n            xSignifier <<= shift;\\n\\n            xExponent = 1;\\n            yExponent += shift - 114;\\n          }\\n        }\\n        else {\\n          xSignifier = (xSignifier | 0x10000000000000000000000000000) << 114;\\n        }\\n\\n        xSignifier = xSignifier / ySignifier;\\n        if (xSignifier == 0)\\n          return (x ^ y) & 0x80000000000000000000000000000000 > 0 ?\\n              NEGATIVE_ZERO : POSITIVE_ZERO;\\n\\n        assert (xSignifier >= 0x1000000000000000000000000000);\\n\\n        uint256 msb =\\n          xSignifier >= 0x80000000000000000000000000000 ? mostSignificantBit (xSignifier) :\\n          xSignifier >= 0x40000000000000000000000000000 ? 114 :\\n          xSignifier >= 0x20000000000000000000000000000 ? 113 : 112;\\n\\n        if (xExponent + msb > yExponent + 16497) { // Overflow\\n          xExponent = 0x7FFF;\\n          xSignifier = 0;\\n        } else if (xExponent + msb + 16380  < yExponent) { // Underflow\\n          xExponent = 0;\\n          xSignifier = 0;\\n        } else if (xExponent + msb + 16268  < yExponent) { // Subnormal\\n          if (xExponent + 16380 > yExponent)\\n            xSignifier <<= xExponent + 16380 - yExponent;\\n          else if (xExponent + 16380 < yExponent)\\n            xSignifier >>= yExponent - xExponent - 16380;\\n\\n          xExponent = 0;\\n        } else { // Normal\\n          if (msb > 112)\\n            xSignifier >>= msb - 112;\\n\\n          xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n          xExponent = xExponent + msb + 16269 - yExponent;\\n        }\\n\\n        return bytes16 (uint128 (uint128 ((x ^ y) & 0x80000000000000000000000000000000) |\\n            xExponent << 112 | xSignifier));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate -x.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function neg (bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      return x ^ 0x80000000000000000000000000000000;\\n    }\\n  }\\n\\n  /**\\n   * Calculate |x|.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function abs (bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      return x & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n    }\\n  }\\n\\n  /**\\n   * Calculate square root of x.  Return NaN on negative x excluding -0.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function sqrt (bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      if (uint128 (x) >  0x80000000000000000000000000000000) return NaN;\\n      else {\\n        uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\\n        if (xExponent == 0x7FFF) return x;\\n        else {\\n          uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n          if (xExponent == 0) xExponent = 1;\\n          else xSignifier |= 0x10000000000000000000000000000;\\n\\n          if (xSignifier == 0) return POSITIVE_ZERO;\\n\\n          bool oddExponent = xExponent & 0x1 == 0;\\n          xExponent = xExponent + 16383 >> 1;\\n\\n          if (oddExponent) {\\n            if (xSignifier >= 0x10000000000000000000000000000)\\n              xSignifier <<= 113;\\n            else {\\n              uint256 msb = mostSignificantBit (xSignifier);\\n              uint256 shift = (226 - msb) & 0xFE;\\n              xSignifier <<= shift;\\n              xExponent -= shift - 112 >> 1;\\n            }\\n          } else {\\n            if (xSignifier >= 0x10000000000000000000000000000)\\n              xSignifier <<= 112;\\n            else {\\n              uint256 msb = mostSignificantBit (xSignifier);\\n              uint256 shift = (225 - msb) & 0xFE;\\n              xSignifier <<= shift;\\n              xExponent -= shift - 112 >> 1;\\n            }\\n          }\\n\\n          uint256 r = 0x10000000000000000000000000000;\\n          r = (r + xSignifier / r) >> 1;\\n          r = (r + xSignifier / r) >> 1;\\n          r = (r + xSignifier / r) >> 1;\\n          r = (r + xSignifier / r) >> 1;\\n          r = (r + xSignifier / r) >> 1;\\n          r = (r + xSignifier / r) >> 1;\\n          r = (r + xSignifier / r) >> 1; // Seven iterations should be enough\\n          uint256 r1 = xSignifier / r;\\n          if (r1 < r) r = r1;\\n\\n          return bytes16 (uint128 (xExponent << 112 | r & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF));\\n        }\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate binary logarithm of x.  Return NaN on negative x excluding -0.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function log_2 (bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      if (uint128 (x) > 0x80000000000000000000000000000000) return NaN;\\n      else if (x == 0x3FFF0000000000000000000000000000) return POSITIVE_ZERO; \\n      else {\\n        uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\\n        if (xExponent == 0x7FFF) return x;\\n        else {\\n          uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n          if (xExponent == 0) xExponent = 1;\\n          else xSignifier |= 0x10000000000000000000000000000;\\n\\n          if (xSignifier == 0) return NEGATIVE_INFINITY;\\n\\n          bool resultNegative;\\n          uint256 resultExponent = 16495;\\n          uint256 resultSignifier;\\n\\n          if (xExponent >= 0x3FFF) {\\n            resultNegative = false;\\n            resultSignifier = xExponent - 0x3FFF;\\n            xSignifier <<= 15;\\n          } else {\\n            resultNegative = true;\\n            if (xSignifier >= 0x10000000000000000000000000000) {\\n              resultSignifier = 0x3FFE - xExponent;\\n              xSignifier <<= 15;\\n            } else {\\n              uint256 msb = mostSignificantBit (xSignifier);\\n              resultSignifier = 16493 - msb;\\n              xSignifier <<= 127 - msb;\\n            }\\n          }\\n\\n          if (xSignifier == 0x80000000000000000000000000000000) {\\n            if (resultNegative) resultSignifier += 1;\\n            uint256 shift = 112 - mostSignificantBit (resultSignifier);\\n            resultSignifier <<= shift;\\n            resultExponent -= shift;\\n          } else {\\n            uint256 bb = resultNegative ? 1 : 0;\\n            while (resultSignifier < 0x10000000000000000000000000000) {\\n              resultSignifier <<= 1;\\n              resultExponent -= 1;\\n  \\n              xSignifier *= xSignifier;\\n              uint256 b = xSignifier >> 255;\\n              resultSignifier += b ^ bb;\\n              xSignifier >>= 127 + b;\\n            }\\n          }\\n\\n          return bytes16 (uint128 ((resultNegative ? 0x80000000000000000000000000000000 : 0) |\\n              resultExponent << 112 | resultSignifier & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF));\\n        }\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate natural logarithm of x.  Return NaN on negative x excluding -0.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function ln (bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      return mul (log_2 (x), 0x3FFE62E42FEFA39EF35793C7673007E5);\\n    }\\n  }\\n\\n  /**\\n   * Calculate 2^x.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function pow_2 (bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      bool xNegative = uint128 (x) > 0x80000000000000000000000000000000;\\n      uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\\n      uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      if (xExponent == 0x7FFF && xSignifier != 0) return NaN;\\n      else if (xExponent > 16397)\\n        return xNegative ? POSITIVE_ZERO : POSITIVE_INFINITY;\\n      else if (xExponent < 16255)\\n        return 0x3FFF0000000000000000000000000000;\\n      else {\\n        if (xExponent == 0) xExponent = 1;\\n        else xSignifier |= 0x10000000000000000000000000000;\\n\\n        if (xExponent > 16367)\\n          xSignifier <<= xExponent - 16367;\\n        else if (xExponent < 16367)\\n          xSignifier >>= 16367 - xExponent;\\n\\n        if (xNegative && xSignifier > 0x406E00000000000000000000000000000000)\\n          return POSITIVE_ZERO;\\n\\n        if (!xNegative && xSignifier > 0x3FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\\n          return POSITIVE_INFINITY;\\n\\n        uint256 resultExponent = xSignifier >> 128;\\n        xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (xNegative && xSignifier != 0) {\\n          xSignifier = ~xSignifier;\\n          resultExponent += 1;\\n        }\\n\\n        uint256 resultSignifier = 0x80000000000000000000000000000000;\\n        if (xSignifier & 0x80000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x16A09E667F3BCC908B2FB1366EA957D3E >> 128;\\n        if (xSignifier & 0x40000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1306FE0A31B7152DE8D5A46305C85EDEC >> 128;\\n        if (xSignifier & 0x20000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1172B83C7D517ADCDF7C8C50EB14A791F >> 128;\\n        if (xSignifier & 0x10000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10B5586CF9890F6298B92B71842A98363 >> 128;\\n        if (xSignifier & 0x8000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1059B0D31585743AE7C548EB68CA417FD >> 128;\\n        if (xSignifier & 0x4000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x102C9A3E778060EE6F7CACA4F7A29BDE8 >> 128;\\n        if (xSignifier & 0x2000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10163DA9FB33356D84A66AE336DCDFA3F >> 128;\\n        if (xSignifier & 0x1000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100B1AFA5ABCBED6129AB13EC11DC9543 >> 128;\\n        if (xSignifier & 0x800000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10058C86DA1C09EA1FF19D294CF2F679B >> 128;\\n        if (xSignifier & 0x400000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1002C605E2E8CEC506D21BFC89A23A00F >> 128;\\n        if (xSignifier & 0x200000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100162F3904051FA128BCA9C55C31E5DF >> 128;\\n        if (xSignifier & 0x100000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000B175EFFDC76BA38E31671CA939725 >> 128;\\n        if (xSignifier & 0x80000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100058BA01FB9F96D6CACD4B180917C3D >> 128;\\n        if (xSignifier & 0x40000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10002C5CC37DA9491D0985C348C68E7B3 >> 128;\\n        if (xSignifier & 0x20000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000162E525EE054754457D5995292026 >> 128;\\n        if (xSignifier & 0x10000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000B17255775C040618BF4A4ADE83FC >> 128;\\n        if (xSignifier & 0x8000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000058B91B5BC9AE2EED81E9B7D4CFAB >> 128;\\n        if (xSignifier & 0x4000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100002C5C89D5EC6CA4D7C8ACC017B7C9 >> 128;\\n        if (xSignifier & 0x2000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000162E43F4F831060E02D839A9D16D >> 128;\\n        if (xSignifier & 0x1000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000B1721BCFC99D9F890EA06911763 >> 128;\\n        if (xSignifier & 0x800000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000058B90CF1E6D97F9CA14DBCC1628 >> 128;\\n        if (xSignifier & 0x400000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000002C5C863B73F016468F6BAC5CA2B >> 128;\\n        if (xSignifier & 0x200000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000162E430E5A18F6119E3C02282A5 >> 128;\\n        if (xSignifier & 0x100000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000B1721835514B86E6D96EFD1BFE >> 128;\\n        if (xSignifier & 0x80000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000058B90C0B48C6BE5DF846C5B2EF >> 128;\\n        if (xSignifier & 0x40000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000002C5C8601CC6B9E94213C72737A >> 128;\\n        if (xSignifier & 0x20000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000162E42FFF037DF38AA2B219F06 >> 128;\\n        if (xSignifier & 0x10000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000B17217FBA9C739AA5819F44F9 >> 128;\\n        if (xSignifier & 0x8000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000058B90BFCDEE5ACD3C1CEDC823 >> 128;\\n        if (xSignifier & 0x4000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000002C5C85FE31F35A6A30DA1BE50 >> 128;\\n        if (xSignifier & 0x2000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000162E42FF0999CE3541B9FFFCF >> 128;\\n        if (xSignifier & 0x1000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000B17217F80F4EF5AADDA45554 >> 128;\\n        if (xSignifier & 0x800000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000058B90BFBF8479BD5A81B51AD >> 128;\\n        if (xSignifier & 0x400000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000002C5C85FDF84BD62AE30A74CC >> 128;\\n        if (xSignifier & 0x200000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000162E42FEFB2FED257559BDAA >> 128;\\n        if (xSignifier & 0x100000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000B17217F7D5A7716BBA4A9AE >> 128;\\n        if (xSignifier & 0x80000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000058B90BFBE9DDBAC5E109CCE >> 128;\\n        if (xSignifier & 0x40000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000002C5C85FDF4B15DE6F17EB0D >> 128;\\n        if (xSignifier & 0x20000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000162E42FEFA494F1478FDE05 >> 128;\\n        if (xSignifier & 0x10000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000B17217F7D20CF927C8E94C >> 128;\\n        if (xSignifier & 0x8000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000058B90BFBE8F71CB4E4B33D >> 128;\\n        if (xSignifier & 0x4000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000002C5C85FDF477B662B26945 >> 128;\\n        if (xSignifier & 0x2000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000162E42FEFA3AE53369388C >> 128;\\n        if (xSignifier & 0x1000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000B17217F7D1D351A389D40 >> 128;\\n        if (xSignifier & 0x800000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000058B90BFBE8E8B2D3D4EDE >> 128;\\n        if (xSignifier & 0x400000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000002C5C85FDF4741BEA6E77E >> 128;\\n        if (xSignifier & 0x200000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000162E42FEFA39FE95583C2 >> 128;\\n        if (xSignifier & 0x100000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000B17217F7D1CFB72B45E1 >> 128;\\n        if (xSignifier & 0x80000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000058B90BFBE8E7CC35C3F0 >> 128;\\n        if (xSignifier & 0x40000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000002C5C85FDF473E242EA38 >> 128;\\n        if (xSignifier & 0x20000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000162E42FEFA39F02B772C >> 128;\\n        if (xSignifier & 0x10000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000B17217F7D1CF7D83C1A >> 128;\\n        if (xSignifier & 0x8000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000058B90BFBE8E7BDCBE2E >> 128;\\n        if (xSignifier & 0x4000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000002C5C85FDF473DEA871F >> 128;\\n        if (xSignifier & 0x2000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000162E42FEFA39EF44D91 >> 128;\\n        if (xSignifier & 0x1000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000B17217F7D1CF79E949 >> 128;\\n        if (xSignifier & 0x800000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000058B90BFBE8E7BCE544 >> 128;\\n        if (xSignifier & 0x400000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000002C5C85FDF473DE6ECA >> 128;\\n        if (xSignifier & 0x200000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000162E42FEFA39EF366F >> 128;\\n        if (xSignifier & 0x100000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000B17217F7D1CF79AFA >> 128;\\n        if (xSignifier & 0x80000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000058B90BFBE8E7BCD6D >> 128;\\n        if (xSignifier & 0x40000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000002C5C85FDF473DE6B2 >> 128;\\n        if (xSignifier & 0x20000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000162E42FEFA39EF358 >> 128;\\n        if (xSignifier & 0x10000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000B17217F7D1CF79AB >> 128;\\n        if (xSignifier & 0x8000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000058B90BFBE8E7BCD5 >> 128;\\n        if (xSignifier & 0x4000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000002C5C85FDF473DE6A >> 128;\\n        if (xSignifier & 0x2000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000162E42FEFA39EF34 >> 128;\\n        if (xSignifier & 0x1000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000B17217F7D1CF799 >> 128;\\n        if (xSignifier & 0x800000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000058B90BFBE8E7BCC >> 128;\\n        if (xSignifier & 0x400000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000002C5C85FDF473DE5 >> 128;\\n        if (xSignifier & 0x200000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000162E42FEFA39EF2 >> 128;\\n        if (xSignifier & 0x100000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000B17217F7D1CF78 >> 128;\\n        if (xSignifier & 0x80000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000058B90BFBE8E7BB >> 128;\\n        if (xSignifier & 0x40000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000002C5C85FDF473DD >> 128;\\n        if (xSignifier & 0x20000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000162E42FEFA39EE >> 128;\\n        if (xSignifier & 0x10000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000B17217F7D1CF6 >> 128;\\n        if (xSignifier & 0x8000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000058B90BFBE8E7A >> 128;\\n        if (xSignifier & 0x4000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000002C5C85FDF473C >> 128;\\n        if (xSignifier & 0x2000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000162E42FEFA39D >> 128;\\n        if (xSignifier & 0x1000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000B17217F7D1CE >> 128;\\n        if (xSignifier & 0x800000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000058B90BFBE8E6 >> 128;\\n        if (xSignifier & 0x400000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000002C5C85FDF472 >> 128;\\n        if (xSignifier & 0x200000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000162E42FEFA38 >> 128;\\n        if (xSignifier & 0x100000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000B17217F7D1B >> 128;\\n        if (xSignifier & 0x80000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000058B90BFBE8D >> 128;\\n        if (xSignifier & 0x40000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000002C5C85FDF46 >> 128;\\n        if (xSignifier & 0x20000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000162E42FEFA2 >> 128;\\n        if (xSignifier & 0x10000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000B17217F7D0 >> 128;\\n        if (xSignifier & 0x8000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000058B90BFBE7 >> 128;\\n        if (xSignifier & 0x4000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000002C5C85FDF3 >> 128;\\n        if (xSignifier & 0x2000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000162E42FEF9 >> 128;\\n        if (xSignifier & 0x1000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000B17217F7C >> 128;\\n        if (xSignifier & 0x800000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000058B90BFBD >> 128;\\n        if (xSignifier & 0x400000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000002C5C85FDE >> 128;\\n        if (xSignifier & 0x200000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000162E42FEE >> 128;\\n        if (xSignifier & 0x100000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000B17217F6 >> 128;\\n        if (xSignifier & 0x80000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000058B90BFA >> 128;\\n        if (xSignifier & 0x40000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000002C5C85FC >> 128;\\n        if (xSignifier & 0x20000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000162E42FD >> 128;\\n        if (xSignifier & 0x10000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000B17217E >> 128;\\n        if (xSignifier & 0x8000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000058B90BE >> 128;\\n        if (xSignifier & 0x4000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000002C5C85E >> 128;\\n        if (xSignifier & 0x2000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000162E42E >> 128;\\n        if (xSignifier & 0x1000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000B17216 >> 128;\\n        if (xSignifier & 0x800000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000058B90A >> 128;\\n        if (xSignifier & 0x400000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000002C5C84 >> 128;\\n        if (xSignifier & 0x200000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000162E41 >> 128;\\n        if (xSignifier & 0x100000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000000B1720 >> 128;\\n        if (xSignifier & 0x80000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000058B8F >> 128;\\n        if (xSignifier & 0x40000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000002C5C7 >> 128;\\n        if (xSignifier & 0x20000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000000162E3 >> 128;\\n        if (xSignifier & 0x10000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000000B171 >> 128;\\n        if (xSignifier & 0x8000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000000058B8 >> 128;\\n        if (xSignifier & 0x4000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000002C5B >> 128;\\n        if (xSignifier & 0x2000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000000162D >> 128;\\n        if (xSignifier & 0x1000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000B16 >> 128;\\n        if (xSignifier & 0x800 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000000058A >> 128;\\n        if (xSignifier & 0x400 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000000002C4 >> 128;\\n        if (xSignifier & 0x200 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000161 >> 128;\\n        if (xSignifier & 0x100 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000000000B0 >> 128;\\n        if (xSignifier & 0x80 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000057 >> 128;\\n        if (xSignifier & 0x40 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000000002B >> 128;\\n        if (xSignifier & 0x20 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000015 >> 128;\\n        if (xSignifier & 0x10 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000000000A >> 128;\\n        if (xSignifier & 0x8 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000004 >> 128;\\n        if (xSignifier & 0x4 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000001 >> 128;\\n\\n        if (!xNegative) {\\n          resultSignifier = resultSignifier >> 15 & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n          resultExponent += 0x3FFF;\\n        } else if (resultExponent <= 0x3FFE) {\\n          resultSignifier = resultSignifier >> 15 & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n          resultExponent = 0x3FFF - resultExponent;\\n        } else {\\n          resultSignifier = resultSignifier >> resultExponent - 16367;\\n          resultExponent = 0;\\n        }\\n\\n        return bytes16 (uint128 (resultExponent << 112 | resultSignifier));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate e^x.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function exp (bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      return pow_2 (mul (x, 0x3FFF71547652B82FE1777D0FFDA0D23A));\\n    }\\n  }\\n\\n  /**\\n   * Get index of the most significant non-zero bit in binary representation of\\n   * x.  Reverts if x is zero.\\n   *\\n   * @return index of the most significant non-zero bit in binary representation\\n   *         of x\\n   */\\n  function mostSignificantBit (uint256 x) private pure returns (uint256) {\\n    unchecked {\\n      require (x > 0);\\n\\n      uint256 result = 0;\\n\\n      if (x >= 0x100000000000000000000000000000000) { x >>= 128; result += 128; }\\n      if (x >= 0x10000000000000000) { x >>= 64; result += 64; }\\n      if (x >= 0x100000000) { x >>= 32; result += 32; }\\n      if (x >= 0x10000) { x >>= 16; result += 16; }\\n      if (x >= 0x100) { x >>= 8; result += 8; }\\n      if (x >= 0x10) { x >>= 4; result += 4; }\\n      if (x >= 0x4) { x >>= 2; result += 2; }\\n      if (x >= 0x2) result += 1; // No need to shift x anymore\\n\\n      return result;\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0x9694a9f6fcadd4fa917efa674de42a74b8fbab8d68924f771ea5cc5e1a301434\",\"license\":\"BSD-4-Clause\"},\"contracts/implementation/PoolSwapLibrary.sol\":{\"content\":\"//SPDX-License-Identifier: CC-BY-NC-ND-4.0\\npragma solidity 0.8.7;\\n\\nimport \\\"abdk-libraries-solidity/ABDKMathQuad.sol\\\";\\n\\n/// @title Library for various useful (mostly) mathematical functions\\nlibrary PoolSwapLibrary {\\n    /// ABDKMathQuad-formatted representation of the number one\\n    bytes16 public constant one = 0x3fff0000000000000000000000000000;\\n\\n    /// Maximum number of decimal places supported by this contract\\n    /// (ABDKMathQuad defines this but it's private)\\n    uint256 public constant MAX_DECIMALS = 18;\\n\\n    /// Maximum precision supportable via wad arithmetic (for this contract)\\n    uint256 public constant WAD_PRECISION = 10**18;\\n\\n    /// Information required to update a given user's aggregated balance\\n    struct UpdateData {\\n        bytes16 longPrice;\\n        bytes16 shortPrice;\\n        uint256 currentUpdateIntervalId;\\n        uint256 updateIntervalId;\\n        uint256 longMintAmount;\\n        uint256 longBurnAmount;\\n        uint256 shortMintAmount;\\n        uint256 shortBurnAmount;\\n        uint256 longBurnShortMintAmount;\\n        uint256 shortBurnLongMintAmount;\\n        bytes16 burnFee;\\n    }\\n\\n    /// Information required to perform a price change (of the underlying asset)\\n    struct PriceChangeData {\\n        int256 oldPrice;\\n        int256 newPrice;\\n        uint256 longBalance;\\n        uint256 shortBalance;\\n        bytes16 leverageAmount;\\n        bytes16 fee;\\n    }\\n\\n    /**\\n     * @notice Calculates the ratio between two numbers\\n     * @dev Rounds any overflow towards 0. If either parameter is zero, the ratio is 0\\n     * @param _numerator The \\\"parts per\\\" side of the equation. If this is zero, the ratio is zero\\n     * @param _denominator The \\\"per part\\\" side of the equation. If this is zero, the ratio is zero\\n     * @return the ratio, as an ABDKMathQuad number (IEEE 754 quadruple precision floating point)\\n     */\\n    function getRatio(uint256 _numerator, uint256 _denominator) public pure returns (bytes16) {\\n        // Catch the divide by zero error.\\n        if (_denominator == 0) {\\n            return 0;\\n        }\\n        return ABDKMathQuad.div(ABDKMathQuad.fromUInt(_numerator), ABDKMathQuad.fromUInt(_denominator));\\n    }\\n\\n    /**\\n     * @notice Gets the short and long balances after the keeper rewards have been paid out\\n     *         Keeper rewards are paid proportionally to the short and long pool\\n     * @dev Assumes shortBalance + longBalance >= reward\\n     * @param reward Amount of keeper reward\\n     * @param shortBalance Short balance of the pool\\n     * @param longBalance Long balance of the pool\\n     * @return shortBalanceAfterFees Short balance of the pool after the keeper reward has been paid\\n     * @return longBalanceAfterFees Long balance of the pool after the keeper reward has been paid\\n     */\\n    function getBalancesAfterFees(\\n        uint256 reward,\\n        uint256 shortBalance,\\n        uint256 longBalance\\n    ) external pure returns (uint256, uint256) {\\n        bytes16 ratioShort = getRatio(shortBalance, shortBalance + longBalance);\\n\\n        uint256 shortFees = convertDecimalToUInt(multiplyDecimalByUInt(ratioShort, reward));\\n\\n        uint256 shortBalanceAfterFees = shortBalance - shortFees;\\n        uint256 longBalanceAfterFees = longBalance - (reward - shortFees);\\n\\n        // Return shortBalance and longBalance after rewards are paid out\\n        return (shortBalanceAfterFees, longBalanceAfterFees);\\n    }\\n\\n    /**\\n     * @notice Compares two decimal numbers\\n     * @param x The first number to compare\\n     * @param y The second number to compare\\n     * @return -1 if x < y, 0 if x = y, or 1 if x > y\\n     */\\n    function compareDecimals(bytes16 x, bytes16 y) public pure returns (int8) {\\n        return ABDKMathQuad.cmp(x, y);\\n    }\\n\\n    /**\\n     * @notice Converts an integer value to a compatible decimal value\\n     * @param amount The amount to convert\\n     * @return The amount as a IEEE754 quadruple precision number\\n     */\\n    function convertUIntToDecimal(uint256 amount) external pure returns (bytes16) {\\n        return ABDKMathQuad.fromUInt(amount);\\n    }\\n\\n    /**\\n     * @notice Converts a raw decimal value to a more readable uint256 value\\n     * @param ratio The value to convert\\n     * @return The converted value\\n     */\\n    function convertDecimalToUInt(bytes16 ratio) public pure returns (uint256) {\\n        return ABDKMathQuad.toUInt(ratio);\\n    }\\n\\n    /**\\n     * @notice Multiplies a decimal and an unsigned integer\\n     * @param a The first term\\n     * @param b The second term\\n     * @return The product of a*b as a decimal\\n     */\\n    function multiplyDecimalByUInt(bytes16 a, uint256 b) public pure returns (bytes16) {\\n        return ABDKMathQuad.mul(a, ABDKMathQuad.fromUInt(b));\\n    }\\n\\n    /**\\n     * @notice Divides two unsigned integers\\n     * @param a The dividend\\n     * @param b The divisor\\n     * @return The quotient\\n     */\\n    function divUInt(uint256 a, uint256 b) private pure returns (bytes16) {\\n        return ABDKMathQuad.div(ABDKMathQuad.fromUInt(a), ABDKMathQuad.fromUInt(b));\\n    }\\n\\n    /**\\n     * @notice Divides two integers\\n     * @param a The dividend\\n     * @param b The divisor\\n     * @return The quotient\\n     */\\n    function divInt(int256 a, int256 b) public pure returns (bytes16) {\\n        return ABDKMathQuad.div(ABDKMathQuad.fromInt(a), ABDKMathQuad.fromInt(b));\\n    }\\n\\n    /**\\n     * @notice Multiply an integer by a fraction\\n     * @return The result as an integer\\n     */\\n    function mulFraction(\\n        uint256 number,\\n        uint256 numerator,\\n        uint256 denominator\\n    ) public pure returns (uint256) {\\n        if (denominator == 0) {\\n            return 0;\\n        }\\n        bytes16 multiplyResult = ABDKMathQuad.mul(ABDKMathQuad.fromUInt(number), ABDKMathQuad.fromUInt(numerator));\\n        bytes16 result = ABDKMathQuad.div(multiplyResult, ABDKMathQuad.fromUInt(denominator));\\n        return convertDecimalToUInt(result);\\n    }\\n\\n    /**\\n     * @notice Calculates the loss multiplier to apply to the losing pool. Includes the power leverage\\n     * @param ratio The ratio of new price to old price\\n     * @param direction The direction of the change. -1 if it's decreased, 0 if it hasn't changed, and 1 if it's increased\\n     * @param leverage The amount of leverage to apply\\n     * @return The multiplier\\n     */\\n    function getLossMultiplier(\\n        bytes16 ratio,\\n        int8 direction,\\n        bytes16 leverage\\n    ) public pure returns (bytes16) {\\n        // If decreased:  2 ^ (leverage * log2[(1 * new/old) + [(0 * 1) / new/old]])\\n        //              = 2 ^ (leverage * log2[(new/old)])\\n        // If increased:  2 ^ (leverage * log2[(0 * new/old) + [(1 * 1) / new/old]])\\n        //              = 2 ^ (leverage * log2([1 / new/old]))\\n        //              = 2 ^ (leverage * log2([old/new]))\\n        return\\n            ABDKMathQuad.pow_2(\\n                ABDKMathQuad.mul(leverage, ABDKMathQuad.log_2(direction < 0 ? ratio : ABDKMathQuad.div(one, ratio)))\\n            );\\n    }\\n\\n    /**\\n     * @notice Calculates the amount to take from the losing pool\\n     * @param lossMultiplier The multiplier to use\\n     * @param balance The balance of the losing pool\\n     */\\n    function getLossAmount(bytes16 lossMultiplier, uint256 balance) public pure returns (uint256) {\\n        return\\n            ABDKMathQuad.toUInt(\\n                ABDKMathQuad.mul(ABDKMathQuad.sub(one, lossMultiplier), ABDKMathQuad.fromUInt(balance))\\n            );\\n    }\\n\\n    /**\\n     * @notice Calculates the effect of a price change. This involves calculating how many funds to transfer from the losing pool to the other.\\n     * @dev This function should be called by the LeveragedPool.\\n     * @param priceChange The struct containing necessary data to calculate price change\\n     * @return Resulting long balance\\n     * @return Resulting short balance\\n     * @return Total fees (across both long and short sides) resulting from this price change\\n     */\\n    function calculatePriceChange(PriceChangeData calldata priceChange)\\n        external\\n        pure\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        uint256 shortBalance = priceChange.shortBalance;\\n        uint256 longBalance = priceChange.longBalance;\\n        bytes16 leverageAmount = priceChange.leverageAmount;\\n        int256 oldPrice = priceChange.oldPrice;\\n        int256 newPrice = priceChange.newPrice;\\n        bytes16 fee = priceChange.fee;\\n\\n        // Calculate fees from long and short sides\\n        uint256 longFeeAmount = convertDecimalToUInt(multiplyDecimalByUInt(fee, longBalance)) /\\n            PoolSwapLibrary.WAD_PRECISION;\\n        uint256 shortFeeAmount = convertDecimalToUInt(multiplyDecimalByUInt(fee, shortBalance)) /\\n            PoolSwapLibrary.WAD_PRECISION;\\n\\n        shortBalance = shortBalance - shortFeeAmount;\\n        longBalance = longBalance - longFeeAmount;\\n        uint256 totalFeeAmount = shortFeeAmount + longFeeAmount;\\n\\n        // Use the ratio to determine if the price increased or decreased and therefore which direction\\n        // the funds should be transferred towards.\\n\\n        bytes16 ratio = divInt(newPrice, oldPrice);\\n        int8 direction = compareDecimals(ratio, PoolSwapLibrary.one);\\n        // Take into account the leverage\\n        bytes16 lossMultiplier = getLossMultiplier(ratio, direction, leverageAmount);\\n\\n        if (direction >= 0 && shortBalance > 0) {\\n            // Move funds from short to long pair\\n            uint256 lossAmount = getLossAmount(lossMultiplier, shortBalance);\\n            shortBalance = shortBalance - lossAmount;\\n            longBalance = longBalance + lossAmount;\\n        } else if (direction < 0 && longBalance > 0) {\\n            // Move funds from long to short pair\\n            uint256 lossAmount = getLossAmount(lossMultiplier, longBalance);\\n            shortBalance = shortBalance + lossAmount;\\n            longBalance = longBalance - lossAmount;\\n        }\\n\\n        return (longBalance, shortBalance, totalFeeAmount);\\n    }\\n\\n    /**\\n     * @notice Returns true if the given timestamp is BEFORE the frontRunningInterval starts,\\n     *         which is allowed for uncommitment.\\n     * @dev If you try to uncommit AFTER the frontRunningInterval, it should revert.\\n     * @param subjectTime The timestamp for which you want to calculate if it was beforeFrontRunningInterval\\n     * @param lastPriceTimestamp The timestamp of the last price update\\n     * @param updateInterval The interval between price updates\\n     * @param frontRunningInterval The window of time before a price udpate users can not uncommit or have their commit executed from\\n     */\\n    function isBeforeFrontRunningInterval(\\n        uint256 subjectTime,\\n        uint256 lastPriceTimestamp,\\n        uint256 updateInterval,\\n        uint256 frontRunningInterval\\n    ) public pure returns (bool) {\\n        return lastPriceTimestamp + updateInterval - frontRunningInterval > subjectTime;\\n    }\\n\\n    /**\\n     * @notice Calculates the update interval ID that a commitment should be placed in.\\n     * @param timestamp Current block.timestamp\\n     * @param lastPriceTimestamp The timestamp of the last price update\\n     * @param frontRunningInterval The frontrunning interval of a pool - The amount of time before an update interval that you must commit to get included in that update\\n     * @param updateInterval The frequency of a pool's updates\\n     * @param currentUpdateIntervalId The current update interval's ID\\n     * @dev Note that the timestamp parameter is required to be >= lastPriceTimestamp\\n     * @return The update interval ID in which a commit being made at time timestamp should be included\\n     */\\n    function appropriateUpdateIntervalId(\\n        uint256 timestamp,\\n        uint256 lastPriceTimestamp,\\n        uint256 frontRunningInterval,\\n        uint256 updateInterval,\\n        uint256 currentUpdateIntervalId\\n    ) external pure returns (uint256) {\\n        // Since lastPriceTimestamp <= block.timestamp, the below also confirms that timestamp >= block.timestamp\\n        require(timestamp >= lastPriceTimestamp, \\\"timestamp in the past\\\");\\n        if (frontRunningInterval <= updateInterval) {\\n            // This is the \\\"simple\\\" case where we either want the current update interval or the next one\\n            if (isBeforeFrontRunningInterval(timestamp, lastPriceTimestamp, updateInterval, frontRunningInterval)) {\\n                // We are before the frontRunning interval\\n                return currentUpdateIntervalId;\\n            } else {\\n                return currentUpdateIntervalId + 1;\\n            }\\n        } else {\\n            // frontRunningInterval > updateInterval\\n            // This is the generalised case, where it could be any number of update intervals in the future\\n            uint256 factorDifference = ABDKMathQuad.toUInt(divUInt(frontRunningInterval, updateInterval));\\n            uint256 timeOfNextAvailableInterval = lastPriceTimestamp + (updateInterval * (factorDifference + 1));\\n            // frontRunningInterval is factorDifference times larger than updateInterval\\n            uint256 minimumUpdateIntervalId = currentUpdateIntervalId + factorDifference;\\n            // but, if timestamp is still within minimumUpdateInterval's frontRunningInterval we need to go to the next one\\n            return\\n                timestamp + frontRunningInterval > timeOfNextAvailableInterval\\n                    ? minimumUpdateIntervalId + 1\\n                    : minimumUpdateIntervalId;\\n        }\\n    }\\n\\n    /**\\n     * @notice Gets the number of settlement tokens to be withdrawn based on a pool token burn amount\\n     * @dev Calculates as `balance * amountIn / (tokenSupply + shadowBalance)\\n     * @param tokenSupply Total supply of pool tokens\\n     * @param amountIn Commitment amount of pool tokens going into the pool\\n     * @param balance Balance of the pool (no. of underlying collateral tokens in pool)\\n     * @param shadowBalance Balance the shadow pool at time of mint\\n     * @return Number of settlement tokens to be withdrawn on a burn\\n     */\\n    function getWithdrawAmountOnBurn(\\n        uint256 tokenSupply,\\n        uint256 amountIn,\\n        uint256 balance,\\n        uint256 shadowBalance\\n    ) external pure returns (uint256) {\\n        // Catch the divide by zero error, or return 0 if amountIn is 0\\n        if ((balance == 0) || (tokenSupply + shadowBalance == 0) || (amountIn == 0)) {\\n            return amountIn;\\n        }\\n        bytes16 numerator = ABDKMathQuad.mul(ABDKMathQuad.fromUInt(balance), ABDKMathQuad.fromUInt(amountIn));\\n        return ABDKMathQuad.toUInt(ABDKMathQuad.div(numerator, ABDKMathQuad.fromUInt(tokenSupply + shadowBalance)));\\n    }\\n\\n    /**\\n     * @notice Gets the number of pool tokens to be minted based on existing tokens\\n     * @dev Calculated as (tokenSupply + shadowBalance) * amountIn / balance\\n     * @param tokenSupply Total supply of pool tokens\\n     * @param amountIn Commitment amount of collateral tokens going into the pool\\n     * @param balance Balance of the pool (no. of underlying collateral tokens in pool)\\n     * @param shadowBalance Balance the shadow pool at time of mint\\n     * @return Number of pool tokens to be minted\\n     */\\n    function getMintAmount(\\n        uint256 tokenSupply,\\n        uint256 amountIn,\\n        uint256 balance,\\n        uint256 shadowBalance\\n    ) external pure returns (uint256) {\\n        // Catch the divide by zero error, or return 0 if amountIn is 0\\n        if (balance == 0 || tokenSupply + shadowBalance == 0 || amountIn == 0) {\\n            return amountIn;\\n        }\\n\\n        bytes16 numerator = ABDKMathQuad.mul(\\n            ABDKMathQuad.fromUInt(tokenSupply + shadowBalance),\\n            ABDKMathQuad.fromUInt(amountIn)\\n        );\\n        return ABDKMathQuad.toUInt(ABDKMathQuad.div(numerator, ABDKMathQuad.fromUInt(balance)));\\n    }\\n\\n    /**\\n     * @notice Get the Settlement/PoolToken price, in ABDK IEE754 precision\\n     * @dev Divide the side balance by the pool token's total supply\\n     * @param sideBalance no. of underlying collateral tokens on that side of the pool\\n     * @param tokenSupply Total supply of pool tokens\\n     */\\n    function getPrice(uint256 sideBalance, uint256 tokenSupply) external pure returns (bytes16) {\\n        if (tokenSupply == 0) {\\n            return one;\\n        }\\n        return ABDKMathQuad.div(ABDKMathQuad.fromUInt(sideBalance), ABDKMathQuad.fromUInt(tokenSupply));\\n    }\\n\\n    /**\\n     * @notice Calculates the number of pool tokens to mint, given some settlement token amount and a price\\n     * @param price Price of a pool token\\n     * @param amount Amount of settlement tokens being used to mint\\n     * @return Quantity of pool tokens to mint\\n     * @dev Throws if price is zero\\n     * @dev `getBurn()`\\n     */\\n    function getMint(bytes16 price, uint256 amount) public pure returns (uint256) {\\n        require(price != 0, \\\"price == 0\\\");\\n        return ABDKMathQuad.toUInt(ABDKMathQuad.div(ABDKMathQuad.fromUInt(amount), price));\\n    }\\n\\n    /**\\n     * @notice Calculate the number of settlement tokens to burn, based on a price and an amount of pool tokens\\n     * @param price Price of a pool token\\n     * @param amount Amount of settlement tokens being used to burn\\n     * @return Quantity of pool tokens to burn\\n     * @dev amount * price, where amount is in PoolToken and price is in USD/PoolToken\\n     * @dev Throws if price is zero\\n     * @dev `getMint()`\\n     */\\n    function getBurn(bytes16 price, uint256 amount) public pure returns (uint256) {\\n        require(price != 0, \\\"price == 0\\\");\\n        return ABDKMathQuad.toUInt(ABDKMathQuad.mul(ABDKMathQuad.fromUInt(amount), price));\\n    }\\n\\n    /**\\n     * @notice Calculate the number of pool tokens to mint, given some settlement token amount, a price, and a burn amount from other side for instant mint\\n     * @param price The price of a pool token\\n     * @param amount The amount of settlement tokens being used to mint\\n     * @param oppositePrice The price of the opposite side's pool token\\n     * @param amountBurnedInstantMint The amount of pool tokens that were burnt from the opposite side for an instant mint in this side\\n     * @return Quantity of pool tokens to mint\\n     * @dev Throws if price is zero\\n     */\\n    function getMintWithBurns(\\n        bytes16 price,\\n        bytes16 oppositePrice,\\n        uint256 amount,\\n        uint256 amountBurnedInstantMint\\n    ) public pure returns (uint256) {\\n        require(price != 0, \\\"price == 0\\\");\\n        if (amountBurnedInstantMint > 0) {\\n            // Calculate amount of settlement tokens generated from the burn.\\n            amount += getBurn(oppositePrice, amountBurnedInstantMint);\\n        }\\n        return getMint(price, amount);\\n    }\\n\\n    /**\\n     * @notice Converts from a WAD to normal value\\n     * @param _wadValue wad number\\n     * @param _decimals Quantity of decimal places to support\\n     * @return Converted (non-WAD) value\\n     */\\n    function fromWad(uint256 _wadValue, uint256 _decimals) external pure returns (uint256) {\\n        uint256 scaler = 10**(MAX_DECIMALS - _decimals);\\n        return _wadValue / scaler;\\n    }\\n\\n    /**\\n     * @notice Calculate the change in a user's balance based on recent commit(s)\\n     * @param data Information needed for updating the balance including prices and recent commit amounts\\n     * @return _newLongTokens Quantity of additional long tokens the user would receive\\n     * @return _newShortTokens Quantity of additional short tokens the user would receive\\n     * @return _longBurnFee Quantity of settlement tokens taken as a fee from long burns\\n     * @return _shortBurnFee Quantity of settlement tokens taken as a fee from short burns\\n     * @return _newSettlementTokens Quantity of additional settlement tokens the user would receive\\n     */\\n    function getUpdatedAggregateBalance(UpdateData calldata data)\\n        external\\n        pure\\n        returns (\\n            uint256 _newLongTokens,\\n            uint256 _newShortTokens,\\n            uint256 _longBurnFee,\\n            uint256 _shortBurnFee,\\n            uint256 _newSettlementTokens\\n        )\\n    {\\n        if (data.updateIntervalId == data.currentUpdateIntervalId) {\\n            // Update interval has not passed: No change\\n            return (0, 0, 0, 0, 0);\\n        }\\n        uint256 longBurnResult; // The amount of settlement tokens to withdraw based on long token burn\\n        uint256 shortBurnResult; // The amount of settlement tokens to withdraw based on short token burn\\n        if (data.longMintAmount > 0 || data.shortBurnLongMintAmount > 0) {\\n            _newLongTokens = getMintWithBurns(\\n                data.longPrice,\\n                data.shortPrice,\\n                data.longMintAmount,\\n                data.shortBurnLongMintAmount\\n            );\\n        }\\n\\n        if (data.longBurnAmount > 0) {\\n            // Calculate the amount of settlement tokens earned from burning long tokens\\n            longBurnResult = getBurn(data.longPrice, data.longBurnAmount);\\n            // Calculate the fee\\n            _longBurnFee = convertDecimalToUInt(multiplyDecimalByUInt(data.burnFee, longBurnResult)) / WAD_PRECISION;\\n            // Subtract the fee from settlement token amount\\n            longBurnResult -= _longBurnFee;\\n        }\\n\\n        if (data.shortMintAmount > 0 || data.longBurnShortMintAmount > 0) {\\n            _newShortTokens = getMintWithBurns(\\n                data.shortPrice,\\n                data.longPrice,\\n                data.shortMintAmount,\\n                data.longBurnShortMintAmount\\n            );\\n        }\\n\\n        if (data.shortBurnAmount > 0) {\\n            // Calculate the amount of settlement tokens earned from burning short tokens\\n            shortBurnResult = getBurn(data.shortPrice, data.shortBurnAmount);\\n            // Calculate the fee\\n            _shortBurnFee = convertDecimalToUInt(multiplyDecimalByUInt(data.burnFee, shortBurnResult)) / WAD_PRECISION;\\n            // Subtract the fee from settlement token amount\\n            shortBurnResult -= _shortBurnFee;\\n        }\\n\\n        _newSettlementTokens = shortBurnResult + longBurnResult;\\n    }\\n}\\n\",\"keccak256\":\"0x64dd610a0ee51d6a1aa18ee018d6c498ae9524ffec2ca05797069d06cf35fa46\",\"license\":\"CC-BY-NC-ND-4.0\"}},\"version\":1}",
    "bytecode": "0x61308c61003a600b82828239805160001a60731461002d57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600436106101625760003560e01c8063aeb64d7d116100cd578063debb52df11610086578063debb52df1461034e578063dfdbe4da14610361578063e456394514610374578063fc31158114610387578063fea3de331461039a578063ff9afe87146103ad57600080fd5b8063aeb64d7d146102c7578063bf36f0e9146102da578063c15172d2146102ed578063c3ff809114610300578063cff7000114610313578063dc35bc131461032657600080fd5b806381a799db1161011f57806381a799db14610209578063901717d11461022c5780639eb17fa314610238578063a481c1b414610273578063a818c0d2146102a1578063ab41556f146102b457600080fd5b80630417cf8e146101675780631842c9d814610182578063202f1257146101a8578063422051e7146101d45780635cf4ee91146101e7578063664808a8146101fa575b600080fd5b61016f601281565b6040519081526020015b60405180910390f35b610195610190366004612cac565b6103c0565b60405160009190910b8152602001610179565b6101bb6101b6366004612d96565b6103d5565b6040516001600160801b03199091168152602001610179565b6101bb6101e2366004612d6c565b6103f1565b6101bb6101f5366004612d96565b610405565b61016f670de0b6b3a764000081565b61021c610217366004612e28565b61042d565b6040519015158152602001610179565b6101bb613fff60f01b81565b61024b610246366004612dd0565b610451565b604080519586526020860194909452928401919091526060830152608082015260a001610179565b610286610281366004612db8565b610607565b60408051938452602084019290925290820152606001610179565b61016f6102af366004612d6c565b61077d565b61016f6102c2366004612e28565b6107a2565b61016f6102d5366004612c91565b610809565b61016f6102e8366004612d96565b610814565b61016f6102fb366004612cdf565b610839565b6101bb61030e366004612d21565b61089b565b6101bb610321366004612d96565b6108db565b610339610334366004612dfc565b6108ea565b60408051928352602083019190915201610179565b61016f61035c366004612e28565b610943565b6101bb61036f366004612de3565b610992565b61016f610382366004612d6c565b61099d565b61016f610395366004612d6c565b6109db565b61016f6103a8366004612dfc565b610a19565b61016f6103bb366004612e5a565b610a5b565b60006103cc8383610b46565b90505b92915050565b60006103cc6103e384610c6d565b6103ec84610c6d565b610d00565b60006103cc8361040084610fb7565b61101b565b6000816104185750613fff60f01b6103cf565b6103cc61042484610fb7565b6103ec84610fb7565b6000848261043b8587612eb9565b6104459190612ffd565b1190505b949350505050565b600080600080600085604001358660600135141561047d575060009350839250829150819050806105fe565b60008060008860800135118061049857506000886101200135115b156104d0576104cd6104ad60208a018a612c91565b6104bd60408b0160208c01612c91565b8a608001358b6101200135610839565b96505b60a088013515610536576104f46104ea60208a018a612c91565b8960a001356109db565b9150670de0b6b3a764000061051d6102d56105176101608c016101408d01612c91565b856103f1565b6105279190612ed1565b94506105338583612ffd565b91505b60008860c00135118061054e57506000886101000135115b156105865761058361056660408a0160208b01612c91565b61057360208b018b612c91565b8a60c001358b6101000135610839565b95505b60e0880135156105ef576105ad6105a360408a0160208b01612c91565b8960e001356109db565b9050670de0b6b3a76400006105d66102d56105d06101608c016101408d01612c91565b846103f1565b6105e09190612ed1565b93506105ec8482612ffd565b90505b6105f98282612eb9565b925050505b91939590929450565b60008080606084013560408501358261062660a0880160808901612c91565b905086356020880135600061064160c08b0160a08c01612c91565b90506000670de0b6b3a764000061065b6102d584896103f1565b6106659190612ed1565b90506000670de0b6b3a764000061067f6102d5858b6103f1565b6106899190612ed1565b90506106958189612ffd565b97506106a18288612ffd565b965060006106af8383612eb9565b905060006106bd86886103d5565b905060006106d082613fff60f01b6103c0565b905060006106df83838c61089b565b905060008260000b121580156106f5575060008c115b15610726576000610706828e61077d565b9050610712818e612ffd565b9c5061071e818d612eb9565b9b5050610766565b60008260000b128015610739575060008b115b1561076657600061074a828d61077d565b9050610756818e612eb9565b9c50610762818d612ffd565b9b50505b50989e999d50909b50979950505050505050505050565b60006103cc61079d610794613fff60f01b86611276565b61040085610fb7565b611288565b60008215806107b857506107b68286612eb9565b155b806107c1575083155b156107cd575082610449565b60006107ed6107e46107df8589612eb9565b610fb7565b61040087610fb7565b90506107ff61079d826103ec87610fb7565b9695505050505050565b60006103cf82611288565b600080610822836012612ffd565b61082d90600a612f36565b90506104498185612ed1565b60006001600160801b0319851661086b5760405162461bcd60e51b815260040161086290612e95565b60405180910390fd5b81156108885761087b84836109db565b6108859084612eb9565b92505b610892858461099d565b95945050505050565b60006108d16108cc8361040060008760000b126108c6576108c1613fff60f01b89610d00565b61130b565b8761130b565b6114bb565b90505b9392505050565b600081610418575060006103cf565b600080806108fc856103218682612eb9565b9050600061090d6102d583896103f1565b9050600061091b8288612ffd565b90506000610929838a612ffd565b6109339088612ffd565b9199919850909650505050505050565b600082158061095957506109578286612eb9565b155b80610962575083155b1561096e575082610449565b600061097c6107e485610fb7565b90506107ff61079d826103ec6107df878b612eb9565b60006103cf82610fb7565b60006001600160801b031983166109c65760405162461bcd60e51b815260040161086290612e95565b6103cc61079d6109d584610fb7565b85610d00565b60006001600160801b03198316610a045760405162461bcd60e51b815260040161086290612e95565b6103cc61079d610a1384610fb7565b8561101b565b600081610a28575060006108d4565b6000610a3f610a3686610fb7565b61040086610fb7565b90506000610a50826103ec86610fb7565b90506107ff81610809565b600084861015610aa55760405162461bcd60e51b81526020600482015260156024820152741d1a5b595cdd185b5c081a5b881d1a19481c185cdd605a1b6044820152606401610862565b828411610ad657610ab88686858761042d565b15610ac4575080610892565b610acf826001612eb9565b9050610892565b6000610ae561079d868661280d565b90506000610af4826001612eb9565b610afe9086612fde565b610b089088612eb9565b90506000610b168386612eb9565b905081610b23888b612eb9565b11610b2e5780610b39565b610b39816001612eb9565b9998505050505050505050565b600060016001607f1b03608084901c16617fff60701b811115610b6857600080fd5b60016001607f1b03608084901c16617fff60701b811115610b8857600080fd5b6001600160801b0319858116908516141580610bb15750617fff60701b826001600160801b0316105b610bba57600080fd5b6001600160801b03198581169085161415610bda576000925050506103cf565b6001607f1b608086811c82118015929187901c919091101590610c2c578015610c1d57826001600160801b0316846001600160801b031611610c1d576001610c21565b6000195b9450505050506103cf565b8015610c3f5760019450505050506103cf565b826001600160801b0316846001600160801b031611610c6057600019610c21565b60019450505050506103cf565b600081610c7c57506000919050565b6000808313610c8e5782600003610c90565b825b90506000610c9d8261281b565b90506070811015610cb6578060700382901b9150610cc9565b6070811115610cc9576070810382901c91505b6001600160701b03909116613fff820160701b17906000841215610cf1576001607f1b821791505b5060801b92915050565b919050565b6000617fff60f084811c8216919084901c811690821415610d465780617fff1415610d35575061ffff60ef1b91506103cf9050565b505050600160ff1b811682186103cf565b80617fff1415610d8a576dffffffffffffffffffffffffffff60801b841615610d79575061ffff60ef1b91506103cf9050565b505050808218600160ff1b166103cf565b600160801b600160ff1b038416610dd457600160801b600160ff1b038516610dbc575061ffff60ef1b91506103cf9050565b505050808218600160ff1b16617fff60f01b176103cf565b6001600160701b03608085901c1681610df05760019150610df7565b600160701b175b6001600160701b03608087901c1683610e36578015610e31576000610e1b8261281b565b6001955060e20393840160711901939190911b90505b610e40565b600160701b1760721b5b818181610e4f57610e4f613040565b04905080610e7b57600160ff1b87871816610e6b576000610c21565b600160ff1b9450505050506103cf565b6001606c1b811015610e8f57610e8f613014565b6000600160731b821015610ece57600160721b821015610ec357600160711b821015610ebc576070610ec6565b6071610ec6565b60725b60ff16610ed7565b610ed78261281b565b905083614071018186011115610ef557617fff945060009150610f88565b83818601613ffc011015610f10576000945060009150610f88565b83818601613f8c011015610f5d578385613ffc011115610f3b578385613ffc010382901b9150610f54565b8385613ffc011015610f5457613ffc8585030382901c91505b60009450610f88565b6070811115610f70576070810382901c91505b6001600160701b038216915083818601613f8d010394505b81607086901b888a186001607f1b60801b1660801c6001600160801b0316171760801b955050505050506103cf565b600081610fc657506000919050565b816000610fd28261281b565b90506070811015610feb578060700382901b9150610ffe565b6070811115610ffe576070810382901c91505b613fff0160701b6001600160701b03919091161760801b92915050565b6000617fff60f084811c8216919084901c8116908214156110ba5780617fff1415611099576001600160801b0319858116908516141561106657505050600160ff1b811682186103cf565b600160ff1b6001600160801b0319868618161415611089575050508181176103cf565b5061ffff60ef1b91506103cf9050565b600160801b600160ff1b038416610d35575061ffff60ef1b91506103cf9050565b80617fff14156110f657600160801b600160ff1b0385166110e5575061ffff60ef1b91506103cf9050565b505050600160ff1b821681186103cf565b6001600160701b03608086901c16826111125760019250611119565b600160701b175b6001600160701b03608086901c1682611135576001925061113c565b600160701b175b908102908161115957600160ff1b87871816610e6b576000610c21565b928201926000600160e11b83101561118c57600160e01b831015611185576111808361281b565b61118f565b60e061118f565b60e15b905061407081860110156111aa576000945060009250611247565b6140e081860110156111ed576140708510156111cf57846140700383901c92506111e4565b6140708511156111e457614070850383901b92505b60009450611247565b61c0dd818601111561120757617fff945060009250611247565b607081111561121e576070810383901c9250611231565b6070811015611231578060700383901b92505b6001600160701b03831692506140df8186010394505b82607086901b888a186001607f1b60801b1660801c6001600160801b0316171760801b955050505050506103cf565b60006103cc83600160ff1b84186128b9565b6000617fff60f083901c16613fff8110156112a65750600092915050565b6001607f1b608084901c106112ba57600080fd5b6140fe8111156112c957600080fd5b600160701b6001600160701b03608085901c161761406f8210156112f35761406f8290031c6108d4565b61406f8211156108d45761406e1982011b9392505050565b60006001607f1b608083901c1115611329575061ffff60ef1b919050565b613fff60f01b6001600160801b03198316141561134857506000919050565b617fff60f083901c811690811415611361575090919050565b6001600160701b03608084901c168161137d5760019150611384565b600160701b175b8061139a57506001600160f01b03199392505050565b600061406f81613fff85106113c05750600f9290921b9160009150613ffe1984016113ff565b60019250600160701b84106113e25784613ffe039050600f84901b93506113ff565b60006113ed8561281b565b607f8190039590951b9461406d039150505b836001607f1b1415611433578215611415576001015b60006114208261281b565b60700392839003929190911b9050611481565b600083611441576000611444565b60015b60ff1690505b600160701b82101561147f5793800260ff81901c607f81019190911c94600019939093019260019290921b908218019061144a565b505b806001600160701b0316607083901b8461149c5760006114a2565b6001607f1b5b6001600160801b0316171760801b979650505050505050565b60006001607f1b608083901c90811190617fff60f085901c8116916001600160701b031690821480156114ed57508015155b15611501575061ffff60ef1b949350505050565b61400d821115611526578261151b57617fff60f01b610892565b600095945050505050565b613f7f82101561153f5750613fff60f01b949350505050565b8161154d5760019150611554565b600160701b175b613fef82111561156a57613fee1982011b61157c565b613fef82101561157c57613fef8290031c5b82801561158d575061203760811b81115b1561159d57506000949350505050565b821580156115bc5750713fffffffffffffffffffffffffffffffffff81115b156115d05750617fff60f01b949350505050565b6001600160801b0381169060801c8380156115ea57508115155b156115f6579019906001015b6001607f1b8281161561161a5770016a09e667f3bcc908b2fb1366ea957d3e0260801c5b6001607e1b83161561163d577001306fe0a31b7152de8d5a46305c85edec0260801c5b6001607d1b831615611660577001172b83c7d517adcdf7c8c50eb14a791f0260801c5b6001607c1b8316156116835770010b5586cf9890f6298b92b71842a983630260801c5b6001607b1b8316156116a6577001059b0d31585743ae7c548eb68ca417fd0260801c5b6001607a1b8316156116c957700102c9a3e778060ee6f7caca4f7a29bde80260801c5b600160791b8316156116ec5770010163da9fb33356d84a66ae336dcdfa3f0260801c5b600160781b83161561170f57700100b1afa5abcbed6129ab13ec11dc95430260801c5b600160771b8316156117325770010058c86da1c09ea1ff19d294cf2f679b0260801c5b600160761b831615611755577001002c605e2e8cec506d21bfc89a23a00f0260801c5b600160751b83161561177857700100162f3904051fa128bca9c55c31e5df0260801c5b600160741b83161561179b577001000b175effdc76ba38e31671ca9397250260801c5b600160731b8316156117be57700100058ba01fb9f96d6cacd4b180917c3d0260801c5b600160721b8316156117e15770010002c5cc37da9491d0985c348c68e7b30260801c5b600160711b831615611804577001000162e525ee054754457d59952920260260801c5b600160701b8316156118275770010000b17255775c040618bf4a4ade83fc0260801c5b6001606f1b83161561184a577001000058b91b5bc9ae2eed81e9b7d4cfab0260801c5b6001606e1b83161561186d57700100002c5c89d5ec6ca4d7c8acc017b7c90260801c5b6001606d1b8316156118905770010000162e43f4f831060e02d839a9d16d0260801c5b6001606c1b8316156118b357700100000b1721bcfc99d9f890ea069117630260801c5b6001606b1b8316156118d65770010000058b90cf1e6d97f9ca14dbcc16280260801c5b6001606a1b8316156118f9577001000002c5c863b73f016468f6bac5ca2b0260801c5b600160691b83161561191c57700100000162e430e5a18f6119e3c02282a50260801c5b600160681b83161561193f577001000000b1721835514b86e6d96efd1bfe0260801c5b600160671b83161561196257700100000058b90c0b48c6be5df846c5b2ef0260801c5b600160661b8316156119855770010000002c5c8601cc6b9e94213c72737a0260801c5b600160651b8316156119a8577001000000162e42fff037df38aa2b219f060260801c5b600160641b8316156119cb5770010000000b17217fba9c739aa5819f44f90260801c5b600160631b8316156119ee577001000000058b90bfcdee5acd3c1cedc8230260801c5b600160621b831615611a1157700100000002c5c85fe31f35a6a30da1be500260801c5b600160611b831615611a345770010000000162e42ff0999ce3541b9fffcf0260801c5b600160601b831615611a5757700100000000b17217f80f4ef5aadda455540260801c5b6001605f1b831615611a7a5770010000000058b90bfbf8479bd5a81b51ad0260801c5b6001605e1b831615611a9d577001000000002c5c85fdf84bd62ae30a74cc0260801c5b6001605d1b831615611ac057700100000000162e42fefb2fed257559bdaa0260801c5b6001605c1b831615611ae3577001000000000b17217f7d5a7716bba4a9ae0260801c5b6001605b1b831615611b0657700100000000058b90bfbe9ddbac5e109cce0260801c5b6001605a1b831615611b295770010000000002c5c85fdf4b15de6f17eb0d0260801c5b600160591b831615611b4c577001000000000162e42fefa494f1478fde050260801c5b600160581b831615611b6f5770010000000000b17217f7d20cf927c8e94c0260801c5b600160571b831615611b92577001000000000058b90bfbe8f71cb4e4b33d0260801c5b600160561b831615611bb557700100000000002c5c85fdf477b662b269450260801c5b600160551b831615611bd85770010000000000162e42fefa3ae53369388c0260801c5b600160541b831615611bfb57700100000000000b17217f7d1d351a389d400260801c5b600160531b831615611c1e5770010000000000058b90bfbe8e8b2d3d4ede0260801c5b600160521b831615611c41577001000000000002c5c85fdf4741bea6e77e0260801c5b600160511b831615611c6457700100000000000162e42fefa39fe95583c20260801c5b600160501b831615611c87577001000000000000b17217f7d1cfb72b45e10260801c5b6980000000000000000000831615611cb057700100000000000058b90bfbe8e7cc35c3f00260801c5b6940000000000000000000831615611cd95770010000000000002c5c85fdf473e242ea380260801c5b6920000000000000000000831615611d02577001000000000000162e42fefa39f02b772c0260801c5b6910000000000000000000831615611d2b5770010000000000000b17217f7d1cf7d83c1a0260801c5b6908000000000000000000831615611d54577001000000000000058b90bfbe8e7bdcbe2e0260801c5b6904000000000000000000831615611d7d57700100000000000002c5c85fdf473dea871f0260801c5b6902000000000000000000831615611da65770010000000000000162e42fefa39ef44d910260801c5b6901000000000000000000831615611dcf57700100000000000000b17217f7d1cf79e9490260801c5b68800000000000000000831615611df75770010000000000000058b90bfbe8e7bce5440260801c5b68400000000000000000831615611e1f577001000000000000002c5c85fdf473de6eca0260801c5b68200000000000000000831615611e4757700100000000000000162e42fefa39ef366f0260801c5b68100000000000000000831615611e6f577001000000000000000b17217f7d1cf79afa0260801c5b68080000000000000000831615611e9757700100000000000000058b90bfbe8e7bcd6d0260801c5b68040000000000000000831615611ebf5770010000000000000002c5c85fdf473de6b20260801c5b68020000000000000000831615611ee7577001000000000000000162e42fefa39ef3580260801c5b600160401b831615611f0a5770010000000000000000b17217f7d1cf79ab0260801c5b678000000000000000831615611f31577001000000000000000058b90bfbe8e7bcd50260801c5b674000000000000000831615611f5857700100000000000000002c5c85fdf473de6a0260801c5b672000000000000000831615611f7f5770010000000000000000162e42fefa39ef340260801c5b671000000000000000831615611fa657700100000000000000000b17217f7d1cf7990260801c5b670800000000000000831615611fcd5770010000000000000000058b90bfbe8e7bcc0260801c5b670400000000000000831615611ff4577001000000000000000002c5c85fdf473de50260801c5b67020000000000000083161561201b57700100000000000000000162e42fefa39ef20260801c5b670100000000000000831615612042577001000000000000000000b17217f7d1cf780260801c5b668000000000000083161561206857700100000000000000000058b90bfbe8e7bb0260801c5b664000000000000083161561208e5770010000000000000000002c5c85fdf473dd0260801c5b66200000000000008316156120b4577001000000000000000000162e42fefa39ee0260801c5b66100000000000008316156120da5770010000000000000000000b17217f7d1cf60260801c5b6608000000000000831615612100577001000000000000000000058b90bfbe8e7a0260801c5b660400000000000083161561212657700100000000000000000002c5c85fdf473c0260801c5b660200000000000083161561214c5770010000000000000000000162e42fefa39d0260801c5b660100000000000083161561217257700100000000000000000000b17217f7d1ce0260801c5b658000000000008316156121975770010000000000000000000058b90bfbe8e60260801c5b654000000000008316156121bc577001000000000000000000002c5c85fdf4720260801c5b652000000000008316156121e157700100000000000000000000162e42fefa380260801c5b65100000000000831615612206577001000000000000000000000b17217f7d1b0260801c5b6508000000000083161561222b57700100000000000000000000058b90bfbe8d0260801c5b650400000000008316156122505770010000000000000000000002c5c85fdf460260801c5b65020000000000831615612275577001000000000000000000000162e42fefa20260801c5b6501000000000083161561229a5770010000000000000000000000b17217f7d00260801c5b6480000000008316156122be577001000000000000000000000058b90bfbe70260801c5b6440000000008316156122e257700100000000000000000000002c5c85fdf30260801c5b6420000000008316156123065770010000000000000000000000162e42fef90260801c5b64100000000083161561232a57700100000000000000000000000b17217f7c0260801c5b64080000000083161561234e5770010000000000000000000000058b90bfbd0260801c5b640400000000831615612372577001000000000000000000000002c5c85fde0260801c5b64020000000083161561239657700100000000000000000000000162e42fee0260801c5b6401000000008316156123ba577001000000000000000000000000b17217f60260801c5b63800000008316156123dd57700100000000000000000000000058b90bfa0260801c5b63400000008316156124005770010000000000000000000000002c5c85fc0260801c5b6320000000831615612423577001000000000000000000000000162e42fd0260801c5b63100000008316156124465770010000000000000000000000000b17217e0260801c5b6308000000831615612469577001000000000000000000000000058b90be0260801c5b630400000083161561248c57700100000000000000000000000002c5c85e0260801c5b63020000008316156124af5770010000000000000000000000000162e42e0260801c5b63010000008316156124d257700100000000000000000000000000b172160260801c5b628000008316156124f45770010000000000000000000000000058b90a0260801c5b62400000831615612516577001000000000000000000000000002c5c840260801c5b6220000083161561253857700100000000000000000000000000162e410260801c5b6210000083161561255a577001000000000000000000000000000b17200260801c5b6208000083161561257c57700100000000000000000000000000058b8f0260801c5b6204000083161561259e5770010000000000000000000000000002c5c70260801c5b620200008316156125c0577001000000000000000000000000000162e30260801c5b620100008316156125e25770010000000000000000000000000000b1710260801c5b618000831615612603577001000000000000000000000000000058b80260801c5b61400083161561262457700100000000000000000000000000002c5b0260801c5b6120008316156126455770010000000000000000000000000000162d0260801c5b61100083161561266657700100000000000000000000000000000b160260801c5b6108008316156126875770010000000000000000000000000000058a0260801c5b6104008316156126a8577001000000000000000000000000000002c40260801c5b6102008316156126c9577001000000000000000000000000000001610260801c5b6101008316156126ea577001000000000000000000000000000000b00260801c5b608083161561270a577001000000000000000000000000000000570260801c5b604083161561272a5770010000000000000000000000000000002b0260801c5b602083161561274a577001000000000000000000000000000000150260801c5b601083161561276a5770010000000000000000000000000000000a0260801c5b600883161561278a577001000000000000000000000000000000040260801c5b60048316156127aa577001000000000000000000000000000000010260801c5b846127cb57600f81901c6001600160701b03169050613fff820191506127fa565b613ffe82116127f057600f81901c6001600160701b0316905081613fff0391506127fa565b600091613fee19011c5b60709190911b1760801b95945050505050565b60006103cc61042484610fb7565b600080821161282957600080fd5b6000600160801b831061283e57608092831c92015b600160401b831061285157604092831c92015b640100000000831061286557602092831c92015b62010000831061287757601092831c92015b610100831061288857600892831c92015b6010831061289857600492831c92015b600483106128a857600292831c92015b600283106103cf5760010192915050565b6000617fff60f084811c8216919084901c8116908214156129075780617fff14156128fd576001600160801b031985811690851614156110895784925050506103cf565b84925050506103cf565b80617fff141561291b5783925050506103cf565b6001607f1b608086901c90811015906001600160701b0316836129415760019350612948565b600160701b175b6001607f1b608087901c90811015906001600160701b03168461296e5760019450612975565b600160701b175b826129a5576001600160801b03198816600160ff1b146129955787612998565b60005b96505050505050506103cf565b806129c5576001600160801b03198916600160ff1b146129955788612998565b8486038415158315151415612ad05760708113156129ec57899750505050505050506103cf565b60008113156129fe5790811c90612a2d565b606f19811215612a1757889750505050505050506103cf565b6000811215612a2d578060000384901c93508596505b92810192600160711b8410612a48576001968701969390931c925b86617fff1415612a7a5784612a6257617fff60f01b612a6c565b6001600160f01b03195b9750505050505050506103cf565b600160701b841015612a8f5760009650612a9c565b6001600160701b03841693505b83607088901b86612aae576000612ab4565b6001607f1b5b6001600160801b0316171760801b9750505050505050506103cf565b6000811315612aeb57600184901b9350600187039650612b02565b6000811215612b0257600182901b91506001860396505b6070811315612b145760019150612b61565b6001811315612b31576001810360018303901c6001019150612b61565b606f19811215612b445760019350612b61565b600019811215612b61576001816000030360018503901c60010193505b818410612b72578184039350612b7b565b83820393508294505b83612b915750600096506103cf95505050505050565b6000612b9c8561281b565b90508060711415612bc257600185901c6001600160701b03169450600188019750612c11565b6070811015612c0457607081900380891115612bf1578086901b6001600160701b031695508089039850612bfe565b600098600019019590951b945b50612c11565b6001600160701b03851694505b87617fff1415612c445785612c2b57617fff60f01b612c35565b6001600160f01b03195b985050505050505050506103cf565b84607089901b87612c56576000612c5c565b6001607f1b5b6001600160801b0316171760801b985050505050505050506103cf565b80356001600160801b031981168114610cfb57600080fd5b600060208284031215612ca357600080fd5b6103cc82612c79565b60008060408385031215612cbf57600080fd5b612cc883612c79565b9150612cd660208401612c79565b90509250929050565b60008060008060808587031215612cf557600080fd5b612cfe85612c79565b9350612d0c60208601612c79565b93969395505050506040820135916060013590565b600080600060608486031215612d3657600080fd5b612d3f84612c79565b925060208401358060000b8114612d5557600080fd5b9150612d6360408501612c79565b90509250925092565b60008060408385031215612d7f57600080fd5b612d8883612c79565b946020939093013593505050565b60008060408385031215612da957600080fd5b50508035926020909101359150565b600060c08284031215612dca57600080fd5b50919050565b60006101608284031215612dca57600080fd5b600060208284031215612df557600080fd5b5035919050565b600080600060608486031215612e1157600080fd5b505081359360208301359350604090920135919050565b60008060008060808587031215612e3e57600080fd5b5050823594602084013594506040840135936060013592509050565b600080600080600060a08688031215612e7257600080fd5b505083359560208501359550604085013594606081013594506080013592509050565b6020808252600a908201526907072696365203d3d20360b41b604082015260600190565b60008219821115612ecc57612ecc61302a565b500190565b600082612eee57634e487b7160e01b600052601260045260246000fd5b500490565b600181815b80851115612f2e578160001904821115612f1457612f1461302a565b80851615612f2157918102915b93841c9390800290612ef8565b509250929050565b60006103cc8383600082612f4c575060016103cf565b81612f59575060006103cf565b8160018114612f6f5760028114612f7957612f95565b60019150506103cf565b60ff841115612f8a57612f8a61302a565b50506001821b6103cf565b5060208310610133831016604e8410600b8410161715612fb8575081810a6103cf565b612fc28383612ef3565b8060001904821115612fd657612fd661302a565b029392505050565b6000816000190483118215151615612ff857612ff861302a565b500290565b60008282101561300f5761300f61302a565b500390565b634e487b7160e01b600052600160045260246000fd5b634e487b7160e01b600052601160045260246000fd5b634e487b7160e01b600052601260045260246000fdfea26469706673582212205cf0973277e128216a65fbe96c261b85d0a8da3862c9ef25e3c6175a139cc2b064736f6c63430008070033",
    "deployedBytecode": "0x73000000000000000000000000000000000000000030146080604052600436106101625760003560e01c8063aeb64d7d116100cd578063debb52df11610086578063debb52df1461034e578063dfdbe4da14610361578063e456394514610374578063fc31158114610387578063fea3de331461039a578063ff9afe87146103ad57600080fd5b8063aeb64d7d146102c7578063bf36f0e9146102da578063c15172d2146102ed578063c3ff809114610300578063cff7000114610313578063dc35bc131461032657600080fd5b806381a799db1161011f57806381a799db14610209578063901717d11461022c5780639eb17fa314610238578063a481c1b414610273578063a818c0d2146102a1578063ab41556f146102b457600080fd5b80630417cf8e146101675780631842c9d814610182578063202f1257146101a8578063422051e7146101d45780635cf4ee91146101e7578063664808a8146101fa575b600080fd5b61016f601281565b6040519081526020015b60405180910390f35b610195610190366004612cac565b6103c0565b60405160009190910b8152602001610179565b6101bb6101b6366004612d96565b6103d5565b6040516001600160801b03199091168152602001610179565b6101bb6101e2366004612d6c565b6103f1565b6101bb6101f5366004612d96565b610405565b61016f670de0b6b3a764000081565b61021c610217366004612e28565b61042d565b6040519015158152602001610179565b6101bb613fff60f01b81565b61024b610246366004612dd0565b610451565b604080519586526020860194909452928401919091526060830152608082015260a001610179565b610286610281366004612db8565b610607565b60408051938452602084019290925290820152606001610179565b61016f6102af366004612d6c565b61077d565b61016f6102c2366004612e28565b6107a2565b61016f6102d5366004612c91565b610809565b61016f6102e8366004612d96565b610814565b61016f6102fb366004612cdf565b610839565b6101bb61030e366004612d21565b61089b565b6101bb610321366004612d96565b6108db565b610339610334366004612dfc565b6108ea565b60408051928352602083019190915201610179565b61016f61035c366004612e28565b610943565b6101bb61036f366004612de3565b610992565b61016f610382366004612d6c565b61099d565b61016f610395366004612d6c565b6109db565b61016f6103a8366004612dfc565b610a19565b61016f6103bb366004612e5a565b610a5b565b60006103cc8383610b46565b90505b92915050565b60006103cc6103e384610c6d565b6103ec84610c6d565b610d00565b60006103cc8361040084610fb7565b61101b565b6000816104185750613fff60f01b6103cf565b6103cc61042484610fb7565b6103ec84610fb7565b6000848261043b8587612eb9565b6104459190612ffd565b1190505b949350505050565b600080600080600085604001358660600135141561047d575060009350839250829150819050806105fe565b60008060008860800135118061049857506000886101200135115b156104d0576104cd6104ad60208a018a612c91565b6104bd60408b0160208c01612c91565b8a608001358b6101200135610839565b96505b60a088013515610536576104f46104ea60208a018a612c91565b8960a001356109db565b9150670de0b6b3a764000061051d6102d56105176101608c016101408d01612c91565b856103f1565b6105279190612ed1565b94506105338583612ffd565b91505b60008860c00135118061054e57506000886101000135115b156105865761058361056660408a0160208b01612c91565b61057360208b018b612c91565b8a60c001358b6101000135610839565b95505b60e0880135156105ef576105ad6105a360408a0160208b01612c91565b8960e001356109db565b9050670de0b6b3a76400006105d66102d56105d06101608c016101408d01612c91565b846103f1565b6105e09190612ed1565b93506105ec8482612ffd565b90505b6105f98282612eb9565b925050505b91939590929450565b60008080606084013560408501358261062660a0880160808901612c91565b905086356020880135600061064160c08b0160a08c01612c91565b90506000670de0b6b3a764000061065b6102d584896103f1565b6106659190612ed1565b90506000670de0b6b3a764000061067f6102d5858b6103f1565b6106899190612ed1565b90506106958189612ffd565b97506106a18288612ffd565b965060006106af8383612eb9565b905060006106bd86886103d5565b905060006106d082613fff60f01b6103c0565b905060006106df83838c61089b565b905060008260000b121580156106f5575060008c115b15610726576000610706828e61077d565b9050610712818e612ffd565b9c5061071e818d612eb9565b9b5050610766565b60008260000b128015610739575060008b115b1561076657600061074a828d61077d565b9050610756818e612eb9565b9c50610762818d612ffd565b9b50505b50989e999d50909b50979950505050505050505050565b60006103cc61079d610794613fff60f01b86611276565b61040085610fb7565b611288565b60008215806107b857506107b68286612eb9565b155b806107c1575083155b156107cd575082610449565b60006107ed6107e46107df8589612eb9565b610fb7565b61040087610fb7565b90506107ff61079d826103ec87610fb7565b9695505050505050565b60006103cf82611288565b600080610822836012612ffd565b61082d90600a612f36565b90506104498185612ed1565b60006001600160801b0319851661086b5760405162461bcd60e51b815260040161086290612e95565b60405180910390fd5b81156108885761087b84836109db565b6108859084612eb9565b92505b610892858461099d565b95945050505050565b60006108d16108cc8361040060008760000b126108c6576108c1613fff60f01b89610d00565b61130b565b8761130b565b6114bb565b90505b9392505050565b600081610418575060006103cf565b600080806108fc856103218682612eb9565b9050600061090d6102d583896103f1565b9050600061091b8288612ffd565b90506000610929838a612ffd565b6109339088612ffd565b9199919850909650505050505050565b600082158061095957506109578286612eb9565b155b80610962575083155b1561096e575082610449565b600061097c6107e485610fb7565b90506107ff61079d826103ec6107df878b612eb9565b60006103cf82610fb7565b60006001600160801b031983166109c65760405162461bcd60e51b815260040161086290612e95565b6103cc61079d6109d584610fb7565b85610d00565b60006001600160801b03198316610a045760405162461bcd60e51b815260040161086290612e95565b6103cc61079d610a1384610fb7565b8561101b565b600081610a28575060006108d4565b6000610a3f610a3686610fb7565b61040086610fb7565b90506000610a50826103ec86610fb7565b90506107ff81610809565b600084861015610aa55760405162461bcd60e51b81526020600482015260156024820152741d1a5b595cdd185b5c081a5b881d1a19481c185cdd605a1b6044820152606401610862565b828411610ad657610ab88686858761042d565b15610ac4575080610892565b610acf826001612eb9565b9050610892565b6000610ae561079d868661280d565b90506000610af4826001612eb9565b610afe9086612fde565b610b089088612eb9565b90506000610b168386612eb9565b905081610b23888b612eb9565b11610b2e5780610b39565b610b39816001612eb9565b9998505050505050505050565b600060016001607f1b03608084901c16617fff60701b811115610b6857600080fd5b60016001607f1b03608084901c16617fff60701b811115610b8857600080fd5b6001600160801b0319858116908516141580610bb15750617fff60701b826001600160801b0316105b610bba57600080fd5b6001600160801b03198581169085161415610bda576000925050506103cf565b6001607f1b608086811c82118015929187901c919091101590610c2c578015610c1d57826001600160801b0316846001600160801b031611610c1d576001610c21565b6000195b9450505050506103cf565b8015610c3f5760019450505050506103cf565b826001600160801b0316846001600160801b031611610c6057600019610c21565b60019450505050506103cf565b600081610c7c57506000919050565b6000808313610c8e5782600003610c90565b825b90506000610c9d8261281b565b90506070811015610cb6578060700382901b9150610cc9565b6070811115610cc9576070810382901c91505b6001600160701b03909116613fff820160701b17906000841215610cf1576001607f1b821791505b5060801b92915050565b919050565b6000617fff60f084811c8216919084901c811690821415610d465780617fff1415610d35575061ffff60ef1b91506103cf9050565b505050600160ff1b811682186103cf565b80617fff1415610d8a576dffffffffffffffffffffffffffff60801b841615610d79575061ffff60ef1b91506103cf9050565b505050808218600160ff1b166103cf565b600160801b600160ff1b038416610dd457600160801b600160ff1b038516610dbc575061ffff60ef1b91506103cf9050565b505050808218600160ff1b16617fff60f01b176103cf565b6001600160701b03608085901c1681610df05760019150610df7565b600160701b175b6001600160701b03608087901c1683610e36578015610e31576000610e1b8261281b565b6001955060e20393840160711901939190911b90505b610e40565b600160701b1760721b5b818181610e4f57610e4f613040565b04905080610e7b57600160ff1b87871816610e6b576000610c21565b600160ff1b9450505050506103cf565b6001606c1b811015610e8f57610e8f613014565b6000600160731b821015610ece57600160721b821015610ec357600160711b821015610ebc576070610ec6565b6071610ec6565b60725b60ff16610ed7565b610ed78261281b565b905083614071018186011115610ef557617fff945060009150610f88565b83818601613ffc011015610f10576000945060009150610f88565b83818601613f8c011015610f5d578385613ffc011115610f3b578385613ffc010382901b9150610f54565b8385613ffc011015610f5457613ffc8585030382901c91505b60009450610f88565b6070811115610f70576070810382901c91505b6001600160701b038216915083818601613f8d010394505b81607086901b888a186001607f1b60801b1660801c6001600160801b0316171760801b955050505050506103cf565b600081610fc657506000919050565b816000610fd28261281b565b90506070811015610feb578060700382901b9150610ffe565b6070811115610ffe576070810382901c91505b613fff0160701b6001600160701b03919091161760801b92915050565b6000617fff60f084811c8216919084901c8116908214156110ba5780617fff1415611099576001600160801b0319858116908516141561106657505050600160ff1b811682186103cf565b600160ff1b6001600160801b0319868618161415611089575050508181176103cf565b5061ffff60ef1b91506103cf9050565b600160801b600160ff1b038416610d35575061ffff60ef1b91506103cf9050565b80617fff14156110f657600160801b600160ff1b0385166110e5575061ffff60ef1b91506103cf9050565b505050600160ff1b821681186103cf565b6001600160701b03608086901c16826111125760019250611119565b600160701b175b6001600160701b03608086901c1682611135576001925061113c565b600160701b175b908102908161115957600160ff1b87871816610e6b576000610c21565b928201926000600160e11b83101561118c57600160e01b831015611185576111808361281b565b61118f565b60e061118f565b60e15b905061407081860110156111aa576000945060009250611247565b6140e081860110156111ed576140708510156111cf57846140700383901c92506111e4565b6140708511156111e457614070850383901b92505b60009450611247565b61c0dd818601111561120757617fff945060009250611247565b607081111561121e576070810383901c9250611231565b6070811015611231578060700383901b92505b6001600160701b03831692506140df8186010394505b82607086901b888a186001607f1b60801b1660801c6001600160801b0316171760801b955050505050506103cf565b60006103cc83600160ff1b84186128b9565b6000617fff60f083901c16613fff8110156112a65750600092915050565b6001607f1b608084901c106112ba57600080fd5b6140fe8111156112c957600080fd5b600160701b6001600160701b03608085901c161761406f8210156112f35761406f8290031c6108d4565b61406f8211156108d45761406e1982011b9392505050565b60006001607f1b608083901c1115611329575061ffff60ef1b919050565b613fff60f01b6001600160801b03198316141561134857506000919050565b617fff60f083901c811690811415611361575090919050565b6001600160701b03608084901c168161137d5760019150611384565b600160701b175b8061139a57506001600160f01b03199392505050565b600061406f81613fff85106113c05750600f9290921b9160009150613ffe1984016113ff565b60019250600160701b84106113e25784613ffe039050600f84901b93506113ff565b60006113ed8561281b565b607f8190039590951b9461406d039150505b836001607f1b1415611433578215611415576001015b60006114208261281b565b60700392839003929190911b9050611481565b600083611441576000611444565b60015b60ff1690505b600160701b82101561147f5793800260ff81901c607f81019190911c94600019939093019260019290921b908218019061144a565b505b806001600160701b0316607083901b8461149c5760006114a2565b6001607f1b5b6001600160801b0316171760801b979650505050505050565b60006001607f1b608083901c90811190617fff60f085901c8116916001600160701b031690821480156114ed57508015155b15611501575061ffff60ef1b949350505050565b61400d821115611526578261151b57617fff60f01b610892565b600095945050505050565b613f7f82101561153f5750613fff60f01b949350505050565b8161154d5760019150611554565b600160701b175b613fef82111561156a57613fee1982011b61157c565b613fef82101561157c57613fef8290031c5b82801561158d575061203760811b81115b1561159d57506000949350505050565b821580156115bc5750713fffffffffffffffffffffffffffffffffff81115b156115d05750617fff60f01b949350505050565b6001600160801b0381169060801c8380156115ea57508115155b156115f6579019906001015b6001607f1b8281161561161a5770016a09e667f3bcc908b2fb1366ea957d3e0260801c5b6001607e1b83161561163d577001306fe0a31b7152de8d5a46305c85edec0260801c5b6001607d1b831615611660577001172b83c7d517adcdf7c8c50eb14a791f0260801c5b6001607c1b8316156116835770010b5586cf9890f6298b92b71842a983630260801c5b6001607b1b8316156116a6577001059b0d31585743ae7c548eb68ca417fd0260801c5b6001607a1b8316156116c957700102c9a3e778060ee6f7caca4f7a29bde80260801c5b600160791b8316156116ec5770010163da9fb33356d84a66ae336dcdfa3f0260801c5b600160781b83161561170f57700100b1afa5abcbed6129ab13ec11dc95430260801c5b600160771b8316156117325770010058c86da1c09ea1ff19d294cf2f679b0260801c5b600160761b831615611755577001002c605e2e8cec506d21bfc89a23a00f0260801c5b600160751b83161561177857700100162f3904051fa128bca9c55c31e5df0260801c5b600160741b83161561179b577001000b175effdc76ba38e31671ca9397250260801c5b600160731b8316156117be57700100058ba01fb9f96d6cacd4b180917c3d0260801c5b600160721b8316156117e15770010002c5cc37da9491d0985c348c68e7b30260801c5b600160711b831615611804577001000162e525ee054754457d59952920260260801c5b600160701b8316156118275770010000b17255775c040618bf4a4ade83fc0260801c5b6001606f1b83161561184a577001000058b91b5bc9ae2eed81e9b7d4cfab0260801c5b6001606e1b83161561186d57700100002c5c89d5ec6ca4d7c8acc017b7c90260801c5b6001606d1b8316156118905770010000162e43f4f831060e02d839a9d16d0260801c5b6001606c1b8316156118b357700100000b1721bcfc99d9f890ea069117630260801c5b6001606b1b8316156118d65770010000058b90cf1e6d97f9ca14dbcc16280260801c5b6001606a1b8316156118f9577001000002c5c863b73f016468f6bac5ca2b0260801c5b600160691b83161561191c57700100000162e430e5a18f6119e3c02282a50260801c5b600160681b83161561193f577001000000b1721835514b86e6d96efd1bfe0260801c5b600160671b83161561196257700100000058b90c0b48c6be5df846c5b2ef0260801c5b600160661b8316156119855770010000002c5c8601cc6b9e94213c72737a0260801c5b600160651b8316156119a8577001000000162e42fff037df38aa2b219f060260801c5b600160641b8316156119cb5770010000000b17217fba9c739aa5819f44f90260801c5b600160631b8316156119ee577001000000058b90bfcdee5acd3c1cedc8230260801c5b600160621b831615611a1157700100000002c5c85fe31f35a6a30da1be500260801c5b600160611b831615611a345770010000000162e42ff0999ce3541b9fffcf0260801c5b600160601b831615611a5757700100000000b17217f80f4ef5aadda455540260801c5b6001605f1b831615611a7a5770010000000058b90bfbf8479bd5a81b51ad0260801c5b6001605e1b831615611a9d577001000000002c5c85fdf84bd62ae30a74cc0260801c5b6001605d1b831615611ac057700100000000162e42fefb2fed257559bdaa0260801c5b6001605c1b831615611ae3577001000000000b17217f7d5a7716bba4a9ae0260801c5b6001605b1b831615611b0657700100000000058b90bfbe9ddbac5e109cce0260801c5b6001605a1b831615611b295770010000000002c5c85fdf4b15de6f17eb0d0260801c5b600160591b831615611b4c577001000000000162e42fefa494f1478fde050260801c5b600160581b831615611b6f5770010000000000b17217f7d20cf927c8e94c0260801c5b600160571b831615611b92577001000000000058b90bfbe8f71cb4e4b33d0260801c5b600160561b831615611bb557700100000000002c5c85fdf477b662b269450260801c5b600160551b831615611bd85770010000000000162e42fefa3ae53369388c0260801c5b600160541b831615611bfb57700100000000000b17217f7d1d351a389d400260801c5b600160531b831615611c1e5770010000000000058b90bfbe8e8b2d3d4ede0260801c5b600160521b831615611c41577001000000000002c5c85fdf4741bea6e77e0260801c5b600160511b831615611c6457700100000000000162e42fefa39fe95583c20260801c5b600160501b831615611c87577001000000000000b17217f7d1cfb72b45e10260801c5b6980000000000000000000831615611cb057700100000000000058b90bfbe8e7cc35c3f00260801c5b6940000000000000000000831615611cd95770010000000000002c5c85fdf473e242ea380260801c5b6920000000000000000000831615611d02577001000000000000162e42fefa39f02b772c0260801c5b6910000000000000000000831615611d2b5770010000000000000b17217f7d1cf7d83c1a0260801c5b6908000000000000000000831615611d54577001000000000000058b90bfbe8e7bdcbe2e0260801c5b6904000000000000000000831615611d7d57700100000000000002c5c85fdf473dea871f0260801c5b6902000000000000000000831615611da65770010000000000000162e42fefa39ef44d910260801c5b6901000000000000000000831615611dcf57700100000000000000b17217f7d1cf79e9490260801c5b68800000000000000000831615611df75770010000000000000058b90bfbe8e7bce5440260801c5b68400000000000000000831615611e1f577001000000000000002c5c85fdf473de6eca0260801c5b68200000000000000000831615611e4757700100000000000000162e42fefa39ef366f0260801c5b68100000000000000000831615611e6f577001000000000000000b17217f7d1cf79afa0260801c5b68080000000000000000831615611e9757700100000000000000058b90bfbe8e7bcd6d0260801c5b68040000000000000000831615611ebf5770010000000000000002c5c85fdf473de6b20260801c5b68020000000000000000831615611ee7577001000000000000000162e42fefa39ef3580260801c5b600160401b831615611f0a5770010000000000000000b17217f7d1cf79ab0260801c5b678000000000000000831615611f31577001000000000000000058b90bfbe8e7bcd50260801c5b674000000000000000831615611f5857700100000000000000002c5c85fdf473de6a0260801c5b672000000000000000831615611f7f5770010000000000000000162e42fefa39ef340260801c5b671000000000000000831615611fa657700100000000000000000b17217f7d1cf7990260801c5b670800000000000000831615611fcd5770010000000000000000058b90bfbe8e7bcc0260801c5b670400000000000000831615611ff4577001000000000000000002c5c85fdf473de50260801c5b67020000000000000083161561201b57700100000000000000000162e42fefa39ef20260801c5b670100000000000000831615612042577001000000000000000000b17217f7d1cf780260801c5b668000000000000083161561206857700100000000000000000058b90bfbe8e7bb0260801c5b664000000000000083161561208e5770010000000000000000002c5c85fdf473dd0260801c5b66200000000000008316156120b4577001000000000000000000162e42fefa39ee0260801c5b66100000000000008316156120da5770010000000000000000000b17217f7d1cf60260801c5b6608000000000000831615612100577001000000000000000000058b90bfbe8e7a0260801c5b660400000000000083161561212657700100000000000000000002c5c85fdf473c0260801c5b660200000000000083161561214c5770010000000000000000000162e42fefa39d0260801c5b660100000000000083161561217257700100000000000000000000b17217f7d1ce0260801c5b658000000000008316156121975770010000000000000000000058b90bfbe8e60260801c5b654000000000008316156121bc577001000000000000000000002c5c85fdf4720260801c5b652000000000008316156121e157700100000000000000000000162e42fefa380260801c5b65100000000000831615612206577001000000000000000000000b17217f7d1b0260801c5b6508000000000083161561222b57700100000000000000000000058b90bfbe8d0260801c5b650400000000008316156122505770010000000000000000000002c5c85fdf460260801c5b65020000000000831615612275577001000000000000000000000162e42fefa20260801c5b6501000000000083161561229a5770010000000000000000000000b17217f7d00260801c5b6480000000008316156122be577001000000000000000000000058b90bfbe70260801c5b6440000000008316156122e257700100000000000000000000002c5c85fdf30260801c5b6420000000008316156123065770010000000000000000000000162e42fef90260801c5b64100000000083161561232a57700100000000000000000000000b17217f7c0260801c5b64080000000083161561234e5770010000000000000000000000058b90bfbd0260801c5b640400000000831615612372577001000000000000000000000002c5c85fde0260801c5b64020000000083161561239657700100000000000000000000000162e42fee0260801c5b6401000000008316156123ba577001000000000000000000000000b17217f60260801c5b63800000008316156123dd57700100000000000000000000000058b90bfa0260801c5b63400000008316156124005770010000000000000000000000002c5c85fc0260801c5b6320000000831615612423577001000000000000000000000000162e42fd0260801c5b63100000008316156124465770010000000000000000000000000b17217e0260801c5b6308000000831615612469577001000000000000000000000000058b90be0260801c5b630400000083161561248c57700100000000000000000000000002c5c85e0260801c5b63020000008316156124af5770010000000000000000000000000162e42e0260801c5b63010000008316156124d257700100000000000000000000000000b172160260801c5b628000008316156124f45770010000000000000000000000000058b90a0260801c5b62400000831615612516577001000000000000000000000000002c5c840260801c5b6220000083161561253857700100000000000000000000000000162e410260801c5b6210000083161561255a577001000000000000000000000000000b17200260801c5b6208000083161561257c57700100000000000000000000000000058b8f0260801c5b6204000083161561259e5770010000000000000000000000000002c5c70260801c5b620200008316156125c0577001000000000000000000000000000162e30260801c5b620100008316156125e25770010000000000000000000000000000b1710260801c5b618000831615612603577001000000000000000000000000000058b80260801c5b61400083161561262457700100000000000000000000000000002c5b0260801c5b6120008316156126455770010000000000000000000000000000162d0260801c5b61100083161561266657700100000000000000000000000000000b160260801c5b6108008316156126875770010000000000000000000000000000058a0260801c5b6104008316156126a8577001000000000000000000000000000002c40260801c5b6102008316156126c9577001000000000000000000000000000001610260801c5b6101008316156126ea577001000000000000000000000000000000b00260801c5b608083161561270a577001000000000000000000000000000000570260801c5b604083161561272a5770010000000000000000000000000000002b0260801c5b602083161561274a577001000000000000000000000000000000150260801c5b601083161561276a5770010000000000000000000000000000000a0260801c5b600883161561278a577001000000000000000000000000000000040260801c5b60048316156127aa577001000000000000000000000000000000010260801c5b846127cb57600f81901c6001600160701b03169050613fff820191506127fa565b613ffe82116127f057600f81901c6001600160701b0316905081613fff0391506127fa565b600091613fee19011c5b60709190911b1760801b95945050505050565b60006103cc61042484610fb7565b600080821161282957600080fd5b6000600160801b831061283e57608092831c92015b600160401b831061285157604092831c92015b640100000000831061286557602092831c92015b62010000831061287757601092831c92015b610100831061288857600892831c92015b6010831061289857600492831c92015b600483106128a857600292831c92015b600283106103cf5760010192915050565b6000617fff60f084811c8216919084901c8116908214156129075780617fff14156128fd576001600160801b031985811690851614156110895784925050506103cf565b84925050506103cf565b80617fff141561291b5783925050506103cf565b6001607f1b608086901c90811015906001600160701b0316836129415760019350612948565b600160701b175b6001607f1b608087901c90811015906001600160701b03168461296e5760019450612975565b600160701b175b826129a5576001600160801b03198816600160ff1b146129955787612998565b60005b96505050505050506103cf565b806129c5576001600160801b03198916600160ff1b146129955788612998565b8486038415158315151415612ad05760708113156129ec57899750505050505050506103cf565b60008113156129fe5790811c90612a2d565b606f19811215612a1757889750505050505050506103cf565b6000811215612a2d578060000384901c93508596505b92810192600160711b8410612a48576001968701969390931c925b86617fff1415612a7a5784612a6257617fff60f01b612a6c565b6001600160f01b03195b9750505050505050506103cf565b600160701b841015612a8f5760009650612a9c565b6001600160701b03841693505b83607088901b86612aae576000612ab4565b6001607f1b5b6001600160801b0316171760801b9750505050505050506103cf565b6000811315612aeb57600184901b9350600187039650612b02565b6000811215612b0257600182901b91506001860396505b6070811315612b145760019150612b61565b6001811315612b31576001810360018303901c6001019150612b61565b606f19811215612b445760019350612b61565b600019811215612b61576001816000030360018503901c60010193505b818410612b72578184039350612b7b565b83820393508294505b83612b915750600096506103cf95505050505050565b6000612b9c8561281b565b90508060711415612bc257600185901c6001600160701b03169450600188019750612c11565b6070811015612c0457607081900380891115612bf1578086901b6001600160701b031695508089039850612bfe565b600098600019019590951b945b50612c11565b6001600160701b03851694505b87617fff1415612c445785612c2b57617fff60f01b612c35565b6001600160f01b03195b985050505050505050506103cf565b84607089901b87612c56576000612c5c565b6001607f1b5b6001600160801b0316171760801b985050505050505050506103cf565b80356001600160801b031981168114610cfb57600080fd5b600060208284031215612ca357600080fd5b6103cc82612c79565b60008060408385031215612cbf57600080fd5b612cc883612c79565b9150612cd660208401612c79565b90509250929050565b60008060008060808587031215612cf557600080fd5b612cfe85612c79565b9350612d0c60208601612c79565b93969395505050506040820135916060013590565b600080600060608486031215612d3657600080fd5b612d3f84612c79565b925060208401358060000b8114612d5557600080fd5b9150612d6360408501612c79565b90509250925092565b60008060408385031215612d7f57600080fd5b612d8883612c79565b946020939093013593505050565b60008060408385031215612da957600080fd5b50508035926020909101359150565b600060c08284031215612dca57600080fd5b50919050565b60006101608284031215612dca57600080fd5b600060208284031215612df557600080fd5b5035919050565b600080600060608486031215612e1157600080fd5b505081359360208301359350604090920135919050565b60008060008060808587031215612e3e57600080fd5b5050823594602084013594506040840135936060013592509050565b600080600080600060a08688031215612e7257600080fd5b505083359560208501359550604085013594606081013594506080013592509050565b6020808252600a908201526907072696365203d3d20360b41b604082015260600190565b60008219821115612ecc57612ecc61302a565b500190565b600082612eee57634e487b7160e01b600052601260045260246000fd5b500490565b600181815b80851115612f2e578160001904821115612f1457612f1461302a565b80851615612f2157918102915b93841c9390800290612ef8565b509250929050565b60006103cc8383600082612f4c575060016103cf565b81612f59575060006103cf565b8160018114612f6f5760028114612f7957612f95565b60019150506103cf565b60ff841115612f8a57612f8a61302a565b50506001821b6103cf565b5060208310610133831016604e8410600b8410161715612fb8575081810a6103cf565b612fc28383612ef3565b8060001904821115612fd657612fd661302a565b029392505050565b6000816000190483118215151615612ff857612ff861302a565b500290565b60008282101561300f5761300f61302a565b500390565b634e487b7160e01b600052600160045260246000fd5b634e487b7160e01b600052601160045260246000fd5b634e487b7160e01b600052601260045260246000fdfea26469706673582212205cf0973277e128216a65fbe96c261b85d0a8da3862c9ef25e3c6175a139cc2b064736f6c63430008070033",
    "devdoc": {
        "kind": "dev",
        "methods": {
            "appropriateUpdateIntervalId(uint256,uint256,uint256,uint256,uint256)": {
                "details": "Note that the timestamp parameter is required to be >= lastPriceTimestamp",
                "params": {
                    "currentUpdateIntervalId": "The current update interval's ID",
                    "frontRunningInterval": "The frontrunning interval of a pool - The amount of time before an update interval that you must commit to get included in that update",
                    "lastPriceTimestamp": "The timestamp of the last price update",
                    "timestamp": "Current block.timestamp",
                    "updateInterval": "The frequency of a pool's updates"
                },
                "returns": {
                    "_0": "The update interval ID in which a commit being made at time timestamp should be included"
                }
            },
            "calculatePriceChange(PoolSwapLibrary.PriceChangeData)": {
                "details": "This function should be called by the LeveragedPool.",
                "params": {
                    "priceChange": "The struct containing necessary data to calculate price change"
                },
                "returns": {
                    "_0": "Resulting long balance",
                    "_1": "Resulting short balance",
                    "_2": "Total fees (across both long and short sides) resulting from this price change"
                }
            },
            "compareDecimals(bytes16,bytes16)": {
                "params": {
                    "x": "The first number to compare",
                    "y": "The second number to compare"
                },
                "returns": {
                    "_0": "-1 if x < y, 0 if x = y, or 1 if x > y"
                }
            },
            "convertDecimalToUInt(bytes16)": {
                "params": {
                    "ratio": "The value to convert"
                },
                "returns": {
                    "_0": "The converted value"
                }
            },
            "convertUIntToDecimal(uint256)": {
                "params": {
                    "amount": "The amount to convert"
                },
                "returns": {
                    "_0": "The amount as a IEEE754 quadruple precision number"
                }
            },
            "divInt(int256,int256)": {
                "params": {
                    "a": "The dividend",
                    "b": "The divisor"
                },
                "returns": {
                    "_0": "The quotient"
                }
            },
            "fromWad(uint256,uint256)": {
                "params": {
                    "_decimals": "Quantity of decimal places to support",
                    "_wadValue": "wad number"
                },
                "returns": {
                    "_0": "Converted (non-WAD) value"
                }
            },
            "getBalancesAfterFees(uint256,uint256,uint256)": {
                "details": "Assumes shortBalance + longBalance >= reward",
                "params": {
                    "longBalance": "Long balance of the pool",
                    "reward": "Amount of keeper reward",
                    "shortBalance": "Short balance of the pool"
                },
                "returns": {
                    "_0": "shortBalanceAfterFees Short balance of the pool after the keeper reward has been paid",
                    "_1": "longBalanceAfterFees Long balance of the pool after the keeper reward has been paid"
                }
            },
            "getBurn(bytes16,uint256)": {
                "details": "amount * price, where amount is in PoolToken and price is in USD/PoolTokenThrows if price is zero`getMint()`",
                "params": {
                    "amount": "Amount of settlement tokens being used to burn",
                    "price": "Price of a pool token"
                },
                "returns": {
                    "_0": "Quantity of pool tokens to burn"
                }
            },
            "getLossAmount(bytes16,uint256)": {
                "params": {
                    "balance": "The balance of the losing pool",
                    "lossMultiplier": "The multiplier to use"
                }
            },
            "getLossMultiplier(bytes16,int8,bytes16)": {
                "params": {
                    "direction": "The direction of the change. -1 if it's decreased, 0 if it hasn't changed, and 1 if it's increased",
                    "leverage": "The amount of leverage to apply",
                    "ratio": "The ratio of new price to old price"
                },
                "returns": {
                    "_0": "The multiplier"
                }
            },
            "getMint(bytes16,uint256)": {
                "details": "Throws if price is zero`getBurn()`",
                "params": {
                    "amount": "Amount of settlement tokens being used to mint",
                    "price": "Price of a pool token"
                },
                "returns": {
                    "_0": "Quantity of pool tokens to mint"
                }
            },
            "getMintAmount(uint256,uint256,uint256,uint256)": {
                "details": "Calculated as (tokenSupply + shadowBalance) * amountIn / balance",
                "params": {
                    "amountIn": "Commitment amount of collateral tokens going into the pool",
                    "balance": "Balance of the pool (no. of underlying collateral tokens in pool)",
                    "shadowBalance": "Balance the shadow pool at time of mint",
                    "tokenSupply": "Total supply of pool tokens"
                },
                "returns": {
                    "_0": "Number of pool tokens to be minted"
                }
            },
            "getMintWithBurns(bytes16,bytes16,uint256,uint256)": {
                "details": "Throws if price is zero",
                "params": {
                    "amount": "The amount of settlement tokens being used to mint",
                    "amountBurnedInstantMint": "The amount of pool tokens that were burnt from the opposite side for an instant mint in this side",
                    "oppositePrice": "The price of the opposite side's pool token",
                    "price": "The price of a pool token"
                },
                "returns": {
                    "_0": "Quantity of pool tokens to mint"
                }
            },
            "getPrice(uint256,uint256)": {
                "details": "Divide the side balance by the pool token's total supply",
                "params": {
                    "sideBalance": "no. of underlying collateral tokens on that side of the pool",
                    "tokenSupply": "Total supply of pool tokens"
                }
            },
            "getRatio(uint256,uint256)": {
                "details": "Rounds any overflow towards 0. If either parameter is zero, the ratio is 0",
                "params": {
                    "_denominator": "The \"per part\" side of the equation. If this is zero, the ratio is zero",
                    "_numerator": "The \"parts per\" side of the equation. If this is zero, the ratio is zero"
                },
                "returns": {
                    "_0": "the ratio, as an ABDKMathQuad number (IEEE 754 quadruple precision floating point)"
                }
            },
            "getUpdatedAggregateBalance(PoolSwapLibrary.UpdateData)": {
                "params": {
                    "data": "Information needed for updating the balance including prices and recent commit amounts"
                },
                "returns": {
                    "_longBurnFee": "Quantity of settlement tokens taken as a fee from long burns",
                    "_newLongTokens": "Quantity of additional long tokens the user would receive",
                    "_newSettlementTokens": "Quantity of additional settlement tokens the user would receive",
                    "_newShortTokens": "Quantity of additional short tokens the user would receive",
                    "_shortBurnFee": "Quantity of settlement tokens taken as a fee from short burns"
                }
            },
            "getWithdrawAmountOnBurn(uint256,uint256,uint256,uint256)": {
                "details": "Calculates as `balance * amountIn / (tokenSupply + shadowBalance)",
                "params": {
                    "amountIn": "Commitment amount of pool tokens going into the pool",
                    "balance": "Balance of the pool (no. of underlying collateral tokens in pool)",
                    "shadowBalance": "Balance the shadow pool at time of mint",
                    "tokenSupply": "Total supply of pool tokens"
                },
                "returns": {
                    "_0": "Number of settlement tokens to be withdrawn on a burn"
                }
            },
            "isBeforeFrontRunningInterval(uint256,uint256,uint256,uint256)": {
                "details": "If you try to uncommit AFTER the frontRunningInterval, it should revert.",
                "params": {
                    "frontRunningInterval": "The window of time before a price udpate users can not uncommit or have their commit executed from",
                    "lastPriceTimestamp": "The timestamp of the last price update",
                    "subjectTime": "The timestamp for which you want to calculate if it was beforeFrontRunningInterval",
                    "updateInterval": "The interval between price updates"
                }
            },
            "mulFraction(uint256,uint256,uint256)": {
                "returns": {
                    "_0": "The result as an integer"
                }
            },
            "multiplyDecimalByUInt(bytes16,uint256)": {
                "params": {
                    "a": "The first term",
                    "b": "The second term"
                },
                "returns": {
                    "_0": "The product of a*b as a decimal"
                }
            }
        },
        "title": "Library for various useful (mostly) mathematical functions",
        "version": 1
    },
    "userdoc": {
        "kind": "user",
        "methods": {
            "MAX_DECIMALS()": {
                "notice": "Maximum number of decimal places supported by this contract (ABDKMathQuad defines this but it's private)"
            },
            "WAD_PRECISION()": {
                "notice": "Maximum precision supportable via wad arithmetic (for this contract)"
            },
            "appropriateUpdateIntervalId(uint256,uint256,uint256,uint256,uint256)": {
                "notice": "Calculates the update interval ID that a commitment should be placed in."
            },
            "calculatePriceChange(PoolSwapLibrary.PriceChangeData)": {
                "notice": "Calculates the effect of a price change. This involves calculating how many funds to transfer from the losing pool to the other."
            },
            "compareDecimals(bytes16,bytes16)": {
                "notice": "Compares two decimal numbers"
            },
            "convertDecimalToUInt(bytes16)": {
                "notice": "Converts a raw decimal value to a more readable uint256 value"
            },
            "convertUIntToDecimal(uint256)": {
                "notice": "Converts an integer value to a compatible decimal value"
            },
            "divInt(int256,int256)": {
                "notice": "Divides two integers"
            },
            "fromWad(uint256,uint256)": {
                "notice": "Converts from a WAD to normal value"
            },
            "getBalancesAfterFees(uint256,uint256,uint256)": {
                "notice": "Gets the short and long balances after the keeper rewards have been paid out         Keeper rewards are paid proportionally to the short and long pool"
            },
            "getBurn(bytes16,uint256)": {
                "notice": "Calculate the number of settlement tokens to burn, based on a price and an amount of pool tokens"
            },
            "getLossAmount(bytes16,uint256)": {
                "notice": "Calculates the amount to take from the losing pool"
            },
            "getLossMultiplier(bytes16,int8,bytes16)": {
                "notice": "Calculates the loss multiplier to apply to the losing pool. Includes the power leverage"
            },
            "getMint(bytes16,uint256)": {
                "notice": "Calculates the number of pool tokens to mint, given some settlement token amount and a price"
            },
            "getMintAmount(uint256,uint256,uint256,uint256)": {
                "notice": "Gets the number of pool tokens to be minted based on existing tokens"
            },
            "getMintWithBurns(bytes16,bytes16,uint256,uint256)": {
                "notice": "Calculate the number of pool tokens to mint, given some settlement token amount, a price, and a burn amount from other side for instant mint"
            },
            "getPrice(uint256,uint256)": {
                "notice": "Get the Settlement/PoolToken price, in ABDK IEE754 precision"
            },
            "getRatio(uint256,uint256)": {
                "notice": "Calculates the ratio between two numbers"
            },
            "getUpdatedAggregateBalance(PoolSwapLibrary.UpdateData)": {
                "notice": "Calculate the change in a user's balance based on recent commit(s)"
            },
            "getWithdrawAmountOnBurn(uint256,uint256,uint256,uint256)": {
                "notice": "Gets the number of settlement tokens to be withdrawn based on a pool token burn amount"
            },
            "isBeforeFrontRunningInterval(uint256,uint256,uint256,uint256)": {
                "notice": "Returns true if the given timestamp is BEFORE the frontRunningInterval starts,         which is allowed for uncommitment."
            },
            "mulFraction(uint256,uint256,uint256)": {
                "notice": "Multiply an integer by a fraction"
            },
            "multiplyDecimalByUInt(bytes16,uint256)": {
                "notice": "Multiplies a decimal and an unsigned integer"
            },
            "one()": {
                "notice": "ABDKMathQuad-formatted representation of the number one"
            }
        },
        "version": 1
    },
    "storageLayout": {
        "storage": [],
        "types": null
    }
}
