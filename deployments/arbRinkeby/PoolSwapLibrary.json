{
  "address": "0x2fB38A21cC1cE33a4a49c034893eaA5Fb3D0Dc76",
  "abi": [
    {
      "inputs": [],
      "name": "MAX_DECIMALS",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "WAD_PRECISION",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes16",
          "name": "x",
          "type": "bytes16"
        },
        {
          "internalType": "bytes16",
          "name": "y",
          "type": "bytes16"
        }
      ],
      "name": "addBytes",
      "outputs": [
        {
          "internalType": "bytes16",
          "name": "",
          "type": "bytes16"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "timestamp",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "lastPriceTimestamp",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "frontRunningInterval",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "updateInterval",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "currentUpdateIntervalId",
          "type": "uint256"
        }
      ],
      "name": "appropriateUpdateIntervalId",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "int256",
              "name": "oldPrice",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "newPrice",
              "type": "int256"
            },
            {
              "internalType": "uint256",
              "name": "longBalance",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "shortBalance",
              "type": "uint256"
            },
            {
              "internalType": "bytes16",
              "name": "leverageAmount",
              "type": "bytes16"
            },
            {
              "internalType": "bytes16",
              "name": "fee",
              "type": "bytes16"
            }
          ],
          "internalType": "struct PoolSwapLibrary.PriceChangeData",
          "name": "priceChange",
          "type": "tuple"
        }
      ],
      "name": "calculatePriceChange",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes16",
          "name": "x",
          "type": "bytes16"
        },
        {
          "internalType": "bytes16",
          "name": "y",
          "type": "bytes16"
        }
      ],
      "name": "compareDecimals",
      "outputs": [
        {
          "internalType": "int8",
          "name": "",
          "type": "int8"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes16",
          "name": "ratio",
          "type": "bytes16"
        }
      ],
      "name": "convertDecimalToUInt",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "convertUIntToDecimal",
      "outputs": [
        {
          "internalType": "bytes16",
          "name": "",
          "type": "bytes16"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "int256",
          "name": "a",
          "type": "int256"
        },
        {
          "internalType": "int256",
          "name": "b",
          "type": "int256"
        }
      ],
      "name": "divInt",
      "outputs": [
        {
          "internalType": "bytes16",
          "name": "",
          "type": "bytes16"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_wadValue",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_decimals",
          "type": "uint256"
        }
      ],
      "name": "fromWad",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "reward",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "shortBalance",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "longBalance",
          "type": "uint256"
        }
      ],
      "name": "getBalancesAfterFees",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes16",
          "name": "price",
          "type": "bytes16"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "getBurn",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes16",
          "name": "lossMultiplier",
          "type": "bytes16"
        },
        {
          "internalType": "uint256",
          "name": "balance",
          "type": "uint256"
        }
      ],
      "name": "getLossAmount",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes16",
          "name": "ratio",
          "type": "bytes16"
        },
        {
          "internalType": "int8",
          "name": "direction",
          "type": "int8"
        },
        {
          "internalType": "bytes16",
          "name": "leverage",
          "type": "bytes16"
        }
      ],
      "name": "getLossMultiplier",
      "outputs": [
        {
          "internalType": "bytes16",
          "name": "",
          "type": "bytes16"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes16",
          "name": "price",
          "type": "bytes16"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "getMint",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenSupply",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amountIn",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "balance",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "shadowBalance",
          "type": "uint256"
        }
      ],
      "name": "getMintAmount",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes16",
          "name": "price",
          "type": "bytes16"
        },
        {
          "internalType": "bytes16",
          "name": "oppositePrice",
          "type": "bytes16"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amountBurnedInstantMint",
          "type": "uint256"
        }
      ],
      "name": "getMintWithBurns",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "sideBalance",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "tokenSupply",
          "type": "uint256"
        }
      ],
      "name": "getPrice",
      "outputs": [
        {
          "internalType": "bytes16",
          "name": "",
          "type": "bytes16"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_numerator",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_denominator",
          "type": "uint256"
        }
      ],
      "name": "getRatio",
      "outputs": [
        {
          "internalType": "bytes16",
          "name": "",
          "type": "bytes16"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "bytes16",
              "name": "longPrice",
              "type": "bytes16"
            },
            {
              "internalType": "bytes16",
              "name": "shortPrice",
              "type": "bytes16"
            },
            {
              "internalType": "uint256",
              "name": "currentUpdateIntervalId",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "updateIntervalId",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "longMintAmount",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "longBurnAmount",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "shortMintAmount",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "shortBurnAmount",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "longBurnShortMintAmount",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "shortBurnLongMintAmount",
              "type": "uint256"
            },
            {
              "internalType": "bytes16",
              "name": "burnFee",
              "type": "bytes16"
            }
          ],
          "internalType": "struct PoolSwapLibrary.UpdateData",
          "name": "data",
          "type": "tuple"
        }
      ],
      "name": "getUpdatedAggregateBalance",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "_newLongTokens",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_newShortTokens",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_longBurnFee",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_shortBurnFee",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_newSettlementTokens",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenSupply",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amountIn",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "balance",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "shadowBalance",
          "type": "uint256"
        }
      ],
      "name": "getWithdrawAmountOnBurn",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "subjectTime",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "lastPriceTimestamp",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "updateInterval",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "frontRunningInterval",
          "type": "uint256"
        }
      ],
      "name": "isBeforeFrontRunningInterval",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "number",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "numerator",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "denominator",
          "type": "uint256"
        }
      ],
      "name": "mulFraction",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes16",
          "name": "x",
          "type": "bytes16"
        },
        {
          "internalType": "bytes16",
          "name": "y",
          "type": "bytes16"
        }
      ],
      "name": "multiplyBytes",
      "outputs": [
        {
          "internalType": "bytes16",
          "name": "",
          "type": "bytes16"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes16",
          "name": "a",
          "type": "bytes16"
        },
        {
          "internalType": "uint256",
          "name": "b",
          "type": "uint256"
        }
      ],
      "name": "multiplyDecimalByUInt",
      "outputs": [
        {
          "internalType": "bytes16",
          "name": "",
          "type": "bytes16"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "one",
      "outputs": [
        {
          "internalType": "bytes16",
          "name": "",
          "type": "bytes16"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes16",
          "name": "x",
          "type": "bytes16"
        },
        {
          "internalType": "bytes16",
          "name": "y",
          "type": "bytes16"
        }
      ],
      "name": "subtractBytes",
      "outputs": [
        {
          "internalType": "bytes16",
          "name": "",
          "type": "bytes16"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    }
  ],
  "transactionHash": "0x904a1e137e6166efd774e4ce42bdea9604cc46d8d5741718a7372090c14435a5",
  "receipt": {
    "to": null,
    "from": "0xc18fcFFD8c9173faB1684Ec1EEE32976f780B13E",
    "contractAddress": "0x2fB38A21cC1cE33a4a49c034893eaA5Fb3D0Dc76",
    "transactionIndex": 0,
    "gasUsed": "41556141",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x2f6aec11ccbf201d5a86ab08914f43681aad659441a57dfca49e1c62975fc565",
    "transactionHash": "0x904a1e137e6166efd774e4ce42bdea9604cc46d8d5741718a7372090c14435a5",
    "logs": [],
    "blockNumber": 8969823,
    "cumulativeGasUsed": "20029521",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "solcInputHash": "4e236762a3d0441b39001e87e67104bc",
  "metadata": "{\"compiler\":{\"version\":\"0.8.7+commit.e28d00a7\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"MAX_DECIMALS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WAD_PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"x\",\"type\":\"bytes16\"},{\"internalType\":\"bytes16\",\"name\":\"y\",\"type\":\"bytes16\"}],\"name\":\"addBytes\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastPriceTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"frontRunningInterval\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updateInterval\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentUpdateIntervalId\",\"type\":\"uint256\"}],\"name\":\"appropriateUpdateIntervalId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"int256\",\"name\":\"oldPrice\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"newPrice\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"longBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shortBalance\",\"type\":\"uint256\"},{\"internalType\":\"bytes16\",\"name\":\"leverageAmount\",\"type\":\"bytes16\"},{\"internalType\":\"bytes16\",\"name\":\"fee\",\"type\":\"bytes16\"}],\"internalType\":\"struct PoolSwapLibrary.PriceChangeData\",\"name\":\"priceChange\",\"type\":\"tuple\"}],\"name\":\"calculatePriceChange\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"x\",\"type\":\"bytes16\"},{\"internalType\":\"bytes16\",\"name\":\"y\",\"type\":\"bytes16\"}],\"name\":\"compareDecimals\",\"outputs\":[{\"internalType\":\"int8\",\"name\":\"\",\"type\":\"int8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"ratio\",\"type\":\"bytes16\"}],\"name\":\"convertDecimalToUInt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"convertUIntToDecimal\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"a\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"b\",\"type\":\"int256\"}],\"name\":\"divInt\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_wadValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_decimals\",\"type\":\"uint256\"}],\"name\":\"fromWad\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shortBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"longBalance\",\"type\":\"uint256\"}],\"name\":\"getBalancesAfterFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"price\",\"type\":\"bytes16\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getBurn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"lossMultiplier\",\"type\":\"bytes16\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"getLossAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"ratio\",\"type\":\"bytes16\"},{\"internalType\":\"int8\",\"name\":\"direction\",\"type\":\"int8\"},{\"internalType\":\"bytes16\",\"name\":\"leverage\",\"type\":\"bytes16\"}],\"name\":\"getLossMultiplier\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"price\",\"type\":\"bytes16\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getMint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shadowBalance\",\"type\":\"uint256\"}],\"name\":\"getMintAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"price\",\"type\":\"bytes16\"},{\"internalType\":\"bytes16\",\"name\":\"oppositePrice\",\"type\":\"bytes16\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountBurnedInstantMint\",\"type\":\"uint256\"}],\"name\":\"getMintWithBurns\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sideBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenSupply\",\"type\":\"uint256\"}],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_numerator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_denominator\",\"type\":\"uint256\"}],\"name\":\"getRatio\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes16\",\"name\":\"longPrice\",\"type\":\"bytes16\"},{\"internalType\":\"bytes16\",\"name\":\"shortPrice\",\"type\":\"bytes16\"},{\"internalType\":\"uint256\",\"name\":\"currentUpdateIntervalId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updateIntervalId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"longMintAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"longBurnAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shortMintAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shortBurnAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"longBurnShortMintAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shortBurnLongMintAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes16\",\"name\":\"burnFee\",\"type\":\"bytes16\"}],\"internalType\":\"struct PoolSwapLibrary.UpdateData\",\"name\":\"data\",\"type\":\"tuple\"}],\"name\":\"getUpdatedAggregateBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_newLongTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_newShortTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_longBurnFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_shortBurnFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_newSettlementTokens\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shadowBalance\",\"type\":\"uint256\"}],\"name\":\"getWithdrawAmountOnBurn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"subjectTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastPriceTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updateInterval\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"frontRunningInterval\",\"type\":\"uint256\"}],\"name\":\"isBeforeFrontRunningInterval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"number\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numerator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"denominator\",\"type\":\"uint256\"}],\"name\":\"mulFraction\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"x\",\"type\":\"bytes16\"},{\"internalType\":\"bytes16\",\"name\":\"y\",\"type\":\"bytes16\"}],\"name\":\"multiplyBytes\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"a\",\"type\":\"bytes16\"},{\"internalType\":\"uint256\",\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"multiplyDecimalByUInt\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"one\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"x\",\"type\":\"bytes16\"},{\"internalType\":\"bytes16\",\"name\":\"y\",\"type\":\"bytes16\"}],\"name\":\"subtractBytes\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"addBytes(bytes16,bytes16)\":{\"params\":{\"x\":\"The number to be added with `y`\",\"y\":\"The number to be added with `x`\"}},\"appropriateUpdateIntervalId(uint256,uint256,uint256,uint256,uint256)\":{\"details\":\"Note that the timestamp parameter is required to be >= lastPriceTimestamp\",\"params\":{\"currentUpdateIntervalId\":\"The current update interval's ID\",\"frontRunningInterval\":\"The frontrunning interval of a pool - The amount of time before an update interval that you must commit to get included in that update\",\"lastPriceTimestamp\":\"The timestamp of the last price update\",\"timestamp\":\"Current block.timestamp\",\"updateInterval\":\"The frequency of a pool's updates\"},\"returns\":{\"_0\":\"The update interval ID in which a commit being made at time timestamp should be included\"}},\"calculatePriceChange(PoolSwapLibrary.PriceChangeData)\":{\"details\":\"This function should be called by the LeveragedPool.\",\"params\":{\"priceChange\":\"The struct containing necessary data to calculate price change\"},\"returns\":{\"_0\":\"Resulting long balance\",\"_1\":\"Resulting short balance\",\"_2\":\"Resulting fees taken from long balance\",\"_3\":\"Resulting fees taken from short balance\"}},\"compareDecimals(bytes16,bytes16)\":{\"params\":{\"x\":\"The first number to compare\",\"y\":\"The second number to compare\"},\"returns\":{\"_0\":\"-1 if x < y, 0 if x = y, or 1 if x > y\"}},\"convertDecimalToUInt(bytes16)\":{\"params\":{\"ratio\":\"The value to convert\"},\"returns\":{\"_0\":\"The converted value\"}},\"convertUIntToDecimal(uint256)\":{\"params\":{\"amount\":\"The amount to convert\"},\"returns\":{\"_0\":\"The amount as a IEEE754 quadruple precision number\"}},\"divInt(int256,int256)\":{\"params\":{\"a\":\"The dividend\",\"b\":\"The divisor\"},\"returns\":{\"_0\":\"The quotient\"}},\"fromWad(uint256,uint256)\":{\"params\":{\"_decimals\":\"Quantity of decimal places to support\",\"_wadValue\":\"wad number\"},\"returns\":{\"_0\":\"Converted (non-WAD) value\"}},\"getBalancesAfterFees(uint256,uint256,uint256)\":{\"details\":\"Assumes shortBalance + longBalance >= reward\",\"params\":{\"longBalance\":\"Long balance of the pool\",\"reward\":\"Amount of keeper reward\",\"shortBalance\":\"Short balance of the pool\"},\"returns\":{\"_0\":\"shortBalanceAfterFees Short balance of the pool after the keeper reward has been paid\",\"_1\":\"longBalanceAfterFees Long balance of the pool after the keeper reward has been paid\"}},\"getBurn(bytes16,uint256)\":{\"details\":\"amount * price, where amount is in PoolToken and price is in USD/PoolTokenThrows if price is zero`getMint()`\",\"params\":{\"amount\":\"Amount of settlement tokens being used to burn\",\"price\":\"Price of a pool token\"},\"returns\":{\"_0\":\"Quantity of pool tokens to burn\"}},\"getLossAmount(bytes16,uint256)\":{\"params\":{\"balance\":\"The balance of the losing pool\",\"lossMultiplier\":\"The multiplier to use\"}},\"getLossMultiplier(bytes16,int8,bytes16)\":{\"params\":{\"direction\":\"The direction of the change. -1 if it's decreased, 0 if it hasn't changed, and 1 if it's increased\",\"leverage\":\"The amount of leverage to apply\",\"ratio\":\"The ratio of new price to old price\"},\"returns\":{\"_0\":\"The multiplier\"}},\"getMint(bytes16,uint256)\":{\"details\":\"Throws if price is zero`getBurn()`\",\"params\":{\"amount\":\"Amount of settlement tokens being used to mint\",\"price\":\"Price of a pool token\"},\"returns\":{\"_0\":\"Quantity of pool tokens to mint\"}},\"getMintAmount(uint256,uint256,uint256,uint256)\":{\"details\":\"Calculated as (tokenSupply + shadowBalance) * amountIn / balance\",\"params\":{\"amountIn\":\"Commitment amount of collateral tokens going into the pool\",\"balance\":\"Balance of the pool (no. of underlying collateral tokens in pool)\",\"shadowBalance\":\"Balance the shadow pool at time of mint\",\"tokenSupply\":\"Total supply of pool tokens\"},\"returns\":{\"_0\":\"Number of pool tokens to be minted\"}},\"getMintWithBurns(bytes16,bytes16,uint256,uint256)\":{\"details\":\"Throws if price is zero\",\"params\":{\"amount\":\"The amount of settlement tokens being used to mint\",\"amountBurnedInstantMint\":\"The amount of pool tokens that were burnt from the opposite side for an instant mint in this side\",\"oppositePrice\":\"The price of the opposite side's pool token\",\"price\":\"The price of a pool token\"},\"returns\":{\"_0\":\"Quantity of pool tokens to mint\"}},\"getPrice(uint256,uint256)\":{\"details\":\"Divide the side balance by the pool token's total supply\",\"params\":{\"sideBalance\":\"no. of underlying collateral tokens on that side of the pool\",\"tokenSupply\":\"Total supply of pool tokens\"}},\"getRatio(uint256,uint256)\":{\"details\":\"Rounds any overflow towards 0. If either parameter is zero, the ratio is 0\",\"params\":{\"_denominator\":\"The \\\"per part\\\" side of the equation. If this is zero, the ratio is zero\",\"_numerator\":\"The \\\"parts per\\\" side of the equation. If this is zero, the ratio is zero\"},\"returns\":{\"_0\":\"the ratio, as an ABDKMathQuad number (IEEE 754 quadruple precision floating point)\"}},\"getUpdatedAggregateBalance(PoolSwapLibrary.UpdateData)\":{\"params\":{\"data\":\"Information needed for updating the balance including prices and recent commit amounts\"},\"returns\":{\"_longBurnFee\":\"Quantity of settlement tokens taken as a fee from long burns\",\"_newLongTokens\":\"Quantity of additional long tokens the user would receive\",\"_newSettlementTokens\":\"Quantity of additional settlement tokens the user would receive\",\"_newShortTokens\":\"Quantity of additional short tokens the user would receive\",\"_shortBurnFee\":\"Quantity of settlement tokens taken as a fee from short burns\"}},\"getWithdrawAmountOnBurn(uint256,uint256,uint256,uint256)\":{\"details\":\"Calculates as `balance * amountIn / (tokenSupply + shadowBalance)\",\"params\":{\"amountIn\":\"Commitment amount of pool tokens going into the pool\",\"balance\":\"Balance of the pool (no. of underlying collateral tokens in pool)\",\"shadowBalance\":\"Balance the shadow pool at time of mint\",\"tokenSupply\":\"Total supply of pool tokens\"},\"returns\":{\"_0\":\"Number of settlement tokens to be withdrawn on a burn\"}},\"isBeforeFrontRunningInterval(uint256,uint256,uint256,uint256)\":{\"details\":\"If you try to uncommit AFTER the frontRunningInterval, it should revert.\",\"params\":{\"frontRunningInterval\":\"The window of time before a price udpate users can not uncommit or have their commit executed from\",\"lastPriceTimestamp\":\"The timestamp of the last price update\",\"subjectTime\":\"The timestamp for which you want to calculate if it was beforeFrontRunningInterval\",\"updateInterval\":\"The interval between price updates\"}},\"mulFraction(uint256,uint256,uint256)\":{\"returns\":{\"_0\":\"The result as an integer\"}},\"multiplyBytes(bytes16,bytes16)\":{\"params\":{\"x\":\"The number to be multiplied by `y`\",\"y\":\"The number to be multiplied by `x`\"}},\"multiplyDecimalByUInt(bytes16,uint256)\":{\"params\":{\"a\":\"The first term\",\"b\":\"The second term\"},\"returns\":{\"_0\":\"The product of a*b as a decimal\"}},\"subtractBytes(bytes16,bytes16)\":{\"params\":{\"x\":\"The number to be subtracted by `y`\",\"y\":\"The number to subtract from `x`\"}}},\"title\":\"Library for various useful (mostly) mathematical functions\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"MAX_DECIMALS()\":{\"notice\":\"Maximum number of decimal places supported by this contract (ABDKMathQuad defines this but it's private)\"},\"WAD_PRECISION()\":{\"notice\":\"Maximum precision supportable via wad arithmetic (for this contract)\"},\"addBytes(bytes16,bytes16)\":{\"notice\":\"Performs an addition on two bytes16 numbers\"},\"appropriateUpdateIntervalId(uint256,uint256,uint256,uint256,uint256)\":{\"notice\":\"Calculates the update interval ID that a commitment should be placed in.\"},\"calculatePriceChange(PoolSwapLibrary.PriceChangeData)\":{\"notice\":\"Calculates the effect of a price change. This involves calculating how many funds to transfer from the losing pool to the other.\"},\"compareDecimals(bytes16,bytes16)\":{\"notice\":\"Compares two decimal numbers\"},\"convertDecimalToUInt(bytes16)\":{\"notice\":\"Converts a raw decimal value to a more readable uint256 value\"},\"convertUIntToDecimal(uint256)\":{\"notice\":\"Converts an integer value to a compatible decimal value\"},\"divInt(int256,int256)\":{\"notice\":\"Divides two integers\"},\"fromWad(uint256,uint256)\":{\"notice\":\"Converts from a WAD to normal value\"},\"getBalancesAfterFees(uint256,uint256,uint256)\":{\"notice\":\"Gets the short and long balances after the keeper rewards have been paid out         Keeper rewards are paid proportionally to the short and long pool\"},\"getBurn(bytes16,uint256)\":{\"notice\":\"Calculate the number of settlement tokens to burn, based on a price and an amount of pool tokens\"},\"getLossAmount(bytes16,uint256)\":{\"notice\":\"Calculates the amount to take from the losing pool\"},\"getLossMultiplier(bytes16,int8,bytes16)\":{\"notice\":\"Calculates the loss multiplier to apply to the losing pool. Includes the power leverage\"},\"getMint(bytes16,uint256)\":{\"notice\":\"Calculates the number of pool tokens to mint, given some settlement token amount and a price\"},\"getMintAmount(uint256,uint256,uint256,uint256)\":{\"notice\":\"Gets the number of pool tokens to be minted based on existing tokens\"},\"getMintWithBurns(bytes16,bytes16,uint256,uint256)\":{\"notice\":\"Calculate the number of pool tokens to mint, given some settlement token amount, a price, and a burn amount from other side for instant mint\"},\"getPrice(uint256,uint256)\":{\"notice\":\"Get the Settlement/PoolToken price, in ABDK IEE754 precision\"},\"getRatio(uint256,uint256)\":{\"notice\":\"Calculates the ratio between two numbers\"},\"getUpdatedAggregateBalance(PoolSwapLibrary.UpdateData)\":{\"notice\":\"Calculate the change in a user's balance based on recent commit(s)\"},\"getWithdrawAmountOnBurn(uint256,uint256,uint256,uint256)\":{\"notice\":\"Gets the number of settlement tokens to be withdrawn based on a pool token burn amount\"},\"isBeforeFrontRunningInterval(uint256,uint256,uint256,uint256)\":{\"notice\":\"Returns true if the given timestamp is BEFORE the frontRunningInterval starts,         which is allowed for uncommitment.\"},\"mulFraction(uint256,uint256,uint256)\":{\"notice\":\"Multiply an integer by a fraction\"},\"multiplyBytes(bytes16,bytes16)\":{\"notice\":\"Multiplies two numbers\"},\"multiplyDecimalByUInt(bytes16,uint256)\":{\"notice\":\"Multiplies a decimal and an unsigned integer\"},\"one()\":{\"notice\":\"ABDKMathQuad-formatted representation of the number one\"},\"subtractBytes(bytes16,bytes16)\":{\"notice\":\"Performs a subtraction on two bytes16 numbers\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/implementation/PoolSwapLibrary.sol\":\"PoolSwapLibrary\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"abdk-libraries-solidity/ABDKMathQuad.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-4-Clause\\n/*\\n * ABDK Math Quad Smart Contract Library.  Copyright \\u00a9 2019 by ABDK Consulting.\\n * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\\n */\\npragma solidity ^0.8.0;\\n\\n/**\\n * Smart contract library of mathematical functions operating with IEEE 754\\n * quadruple-precision binary floating-point numbers (quadruple precision\\n * numbers).  As long as quadruple precision numbers are 16-bytes long, they are\\n * represented by bytes16 type.\\n */\\nlibrary ABDKMathQuad {\\n  /*\\n   * 0.\\n   */\\n  bytes16 private constant POSITIVE_ZERO = 0x00000000000000000000000000000000;\\n\\n  /*\\n   * -0.\\n   */\\n  bytes16 private constant NEGATIVE_ZERO = 0x80000000000000000000000000000000;\\n\\n  /*\\n   * +Infinity.\\n   */\\n  bytes16 private constant POSITIVE_INFINITY = 0x7FFF0000000000000000000000000000;\\n\\n  /*\\n   * -Infinity.\\n   */\\n  bytes16 private constant NEGATIVE_INFINITY = 0xFFFF0000000000000000000000000000;\\n\\n  /*\\n   * Canonical NaN value.\\n   */\\n  bytes16 private constant NaN = 0x7FFF8000000000000000000000000000;\\n\\n  /**\\n   * Convert signed 256-bit integer number into quadruple precision number.\\n   *\\n   * @param x signed 256-bit integer number\\n   * @return quadruple precision number\\n   */\\n  function fromInt (int256 x) internal pure returns (bytes16) {\\n    unchecked {\\n      if (x == 0) return bytes16 (0);\\n      else {\\n        // We rely on overflow behavior here\\n        uint256 result = uint256 (x > 0 ? x : -x);\\n\\n        uint256 msb = mostSignificantBit (result);\\n        if (msb < 112) result <<= 112 - msb;\\n        else if (msb > 112) result >>= msb - 112;\\n\\n        result = result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF | 16383 + msb << 112;\\n        if (x < 0) result |= 0x80000000000000000000000000000000;\\n\\n        return bytes16 (uint128 (result));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert quadruple precision number into signed 256-bit integer number\\n   * rounding towards zero.  Revert on overflow.\\n   *\\n   * @param x quadruple precision number\\n   * @return signed 256-bit integer number\\n   */\\n  function toInt (bytes16 x) internal pure returns (int256) {\\n    unchecked {\\n      uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\\n\\n      require (exponent <= 16638); // Overflow\\n      if (exponent < 16383) return 0; // Underflow\\n\\n      uint256 result = uint256 (uint128 (x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF |\\n        0x10000000000000000000000000000;\\n\\n      if (exponent < 16495) result >>= 16495 - exponent;\\n      else if (exponent > 16495) result <<= exponent - 16495;\\n\\n      if (uint128 (x) >= 0x80000000000000000000000000000000) { // Negative\\n        require (result <= 0x8000000000000000000000000000000000000000000000000000000000000000);\\n        return -int256 (result); // We rely on overflow behavior here\\n      } else {\\n        require (result <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n        return int256 (result);\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert unsigned 256-bit integer number into quadruple precision number.\\n   *\\n   * @param x unsigned 256-bit integer number\\n   * @return quadruple precision number\\n   */\\n  function fromUInt (uint256 x) internal pure returns (bytes16) {\\n    unchecked {\\n      if (x == 0) return bytes16 (0);\\n      else {\\n        uint256 result = x;\\n\\n        uint256 msb = mostSignificantBit (result);\\n        if (msb < 112) result <<= 112 - msb;\\n        else if (msb > 112) result >>= msb - 112;\\n\\n        result = result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF | 16383 + msb << 112;\\n\\n        return bytes16 (uint128 (result));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert quadruple precision number into unsigned 256-bit integer number\\n   * rounding towards zero.  Revert on underflow.  Note, that negative floating\\n   * point numbers in range (-1.0 .. 0.0) may be converted to unsigned integer\\n   * without error, because they are rounded to zero.\\n   *\\n   * @param x quadruple precision number\\n   * @return unsigned 256-bit integer number\\n   */\\n  function toUInt (bytes16 x) internal pure returns (uint256) {\\n    unchecked {\\n      uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\\n\\n      if (exponent < 16383) return 0; // Underflow\\n\\n      require (uint128 (x) < 0x80000000000000000000000000000000); // Negative\\n\\n      require (exponent <= 16638); // Overflow\\n      uint256 result = uint256 (uint128 (x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF |\\n        0x10000000000000000000000000000;\\n\\n      if (exponent < 16495) result >>= 16495 - exponent;\\n      else if (exponent > 16495) result <<= exponent - 16495;\\n\\n      return result;\\n    }\\n  }\\n\\n  /**\\n   * Convert signed 128.128 bit fixed point number into quadruple precision\\n   * number.\\n   *\\n   * @param x signed 128.128 bit fixed point number\\n   * @return quadruple precision number\\n   */\\n  function from128x128 (int256 x) internal pure returns (bytes16) {\\n    unchecked {\\n      if (x == 0) return bytes16 (0);\\n      else {\\n        // We rely on overflow behavior here\\n        uint256 result = uint256 (x > 0 ? x : -x);\\n\\n        uint256 msb = mostSignificantBit (result);\\n        if (msb < 112) result <<= 112 - msb;\\n        else if (msb > 112) result >>= msb - 112;\\n\\n        result = result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF | 16255 + msb << 112;\\n        if (x < 0) result |= 0x80000000000000000000000000000000;\\n\\n        return bytes16 (uint128 (result));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert quadruple precision number into signed 128.128 bit fixed point\\n   * number.  Revert on overflow.\\n   *\\n   * @param x quadruple precision number\\n   * @return signed 128.128 bit fixed point number\\n   */\\n  function to128x128 (bytes16 x) internal pure returns (int256) {\\n    unchecked {\\n      uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\\n\\n      require (exponent <= 16510); // Overflow\\n      if (exponent < 16255) return 0; // Underflow\\n\\n      uint256 result = uint256 (uint128 (x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF |\\n        0x10000000000000000000000000000;\\n\\n      if (exponent < 16367) result >>= 16367 - exponent;\\n      else if (exponent > 16367) result <<= exponent - 16367;\\n\\n      if (uint128 (x) >= 0x80000000000000000000000000000000) { // Negative\\n        require (result <= 0x8000000000000000000000000000000000000000000000000000000000000000);\\n        return -int256 (result); // We rely on overflow behavior here\\n      } else {\\n        require (result <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n        return int256 (result);\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert signed 64.64 bit fixed point number into quadruple precision\\n   * number.\\n   *\\n   * @param x signed 64.64 bit fixed point number\\n   * @return quadruple precision number\\n   */\\n  function from64x64 (int128 x) internal pure returns (bytes16) {\\n    unchecked {\\n      if (x == 0) return bytes16 (0);\\n      else {\\n        // We rely on overflow behavior here\\n        uint256 result = uint128 (x > 0 ? x : -x);\\n\\n        uint256 msb = mostSignificantBit (result);\\n        if (msb < 112) result <<= 112 - msb;\\n        else if (msb > 112) result >>= msb - 112;\\n\\n        result = result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF | 16319 + msb << 112;\\n        if (x < 0) result |= 0x80000000000000000000000000000000;\\n\\n        return bytes16 (uint128 (result));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert quadruple precision number into signed 64.64 bit fixed point\\n   * number.  Revert on overflow.\\n   *\\n   * @param x quadruple precision number\\n   * @return signed 64.64 bit fixed point number\\n   */\\n  function to64x64 (bytes16 x) internal pure returns (int128) {\\n    unchecked {\\n      uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\\n\\n      require (exponent <= 16446); // Overflow\\n      if (exponent < 16319) return 0; // Underflow\\n\\n      uint256 result = uint256 (uint128 (x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF |\\n        0x10000000000000000000000000000;\\n\\n      if (exponent < 16431) result >>= 16431 - exponent;\\n      else if (exponent > 16431) result <<= exponent - 16431;\\n\\n      if (uint128 (x) >= 0x80000000000000000000000000000000) { // Negative\\n        require (result <= 0x80000000000000000000000000000000);\\n        return -int128 (int256 (result)); // We rely on overflow behavior here\\n      } else {\\n        require (result <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n        return int128 (int256 (result));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert octuple precision number into quadruple precision number.\\n   *\\n   * @param x octuple precision number\\n   * @return quadruple precision number\\n   */\\n  function fromOctuple (bytes32 x) internal pure returns (bytes16) {\\n    unchecked {\\n      bool negative = x & 0x8000000000000000000000000000000000000000000000000000000000000000 > 0;\\n\\n      uint256 exponent = uint256 (x) >> 236 & 0x7FFFF;\\n      uint256 significand = uint256 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      if (exponent == 0x7FFFF) {\\n        if (significand > 0) return NaN;\\n        else return negative ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\\n      }\\n\\n      if (exponent > 278526)\\n        return negative ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\\n      else if (exponent < 245649)\\n        return negative ? NEGATIVE_ZERO : POSITIVE_ZERO;\\n      else if (exponent < 245761) {\\n        significand = (significand | 0x100000000000000000000000000000000000000000000000000000000000) >> 245885 - exponent;\\n        exponent = 0;\\n      } else {\\n        significand >>= 124;\\n        exponent -= 245760;\\n      }\\n\\n      uint128 result = uint128 (significand | exponent << 112);\\n      if (negative) result |= 0x80000000000000000000000000000000;\\n\\n      return bytes16 (result);\\n    }\\n  }\\n\\n  /**\\n   * Convert quadruple precision number into octuple precision number.\\n   *\\n   * @param x quadruple precision number\\n   * @return octuple precision number\\n   */\\n  function toOctuple (bytes16 x) internal pure returns (bytes32) {\\n    unchecked {\\n      uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\\n\\n      uint256 result = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      if (exponent == 0x7FFF) exponent = 0x7FFFF; // Infinity or NaN\\n      else if (exponent == 0) {\\n        if (result > 0) {\\n          uint256 msb = mostSignificantBit (result);\\n          result = result << 236 - msb & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n          exponent = 245649 + msb;\\n        }\\n      } else {\\n        result <<= 124;\\n        exponent += 245760;\\n      }\\n\\n      result |= exponent << 236;\\n      if (uint128 (x) >= 0x80000000000000000000000000000000)\\n        result |= 0x8000000000000000000000000000000000000000000000000000000000000000;\\n\\n      return bytes32 (result);\\n    }\\n  }\\n\\n  /**\\n   * Convert double precision number into quadruple precision number.\\n   *\\n   * @param x double precision number\\n   * @return quadruple precision number\\n   */\\n  function fromDouble (bytes8 x) internal pure returns (bytes16) {\\n    unchecked {\\n      uint256 exponent = uint64 (x) >> 52 & 0x7FF;\\n\\n      uint256 result = uint64 (x) & 0xFFFFFFFFFFFFF;\\n\\n      if (exponent == 0x7FF) exponent = 0x7FFF; // Infinity or NaN\\n      else if (exponent == 0) {\\n        if (result > 0) {\\n          uint256 msb = mostSignificantBit (result);\\n          result = result << 112 - msb & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n          exponent = 15309 + msb;\\n        }\\n      } else {\\n        result <<= 60;\\n        exponent += 15360;\\n      }\\n\\n      result |= exponent << 112;\\n      if (x & 0x8000000000000000 > 0)\\n        result |= 0x80000000000000000000000000000000;\\n\\n      return bytes16 (uint128 (result));\\n    }\\n  }\\n\\n  /**\\n   * Convert quadruple precision number into double precision number.\\n   *\\n   * @param x quadruple precision number\\n   * @return double precision number\\n   */\\n  function toDouble (bytes16 x) internal pure returns (bytes8) {\\n    unchecked {\\n      bool negative = uint128 (x) >= 0x80000000000000000000000000000000;\\n\\n      uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\\n      uint256 significand = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      if (exponent == 0x7FFF) {\\n        if (significand > 0) return 0x7FF8000000000000; // NaN\\n        else return negative ?\\n            bytes8 (0xFFF0000000000000) : // -Infinity\\n            bytes8 (0x7FF0000000000000); // Infinity\\n      }\\n\\n      if (exponent > 17406)\\n        return negative ?\\n            bytes8 (0xFFF0000000000000) : // -Infinity\\n            bytes8 (0x7FF0000000000000); // Infinity\\n      else if (exponent < 15309)\\n        return negative ?\\n            bytes8 (0x8000000000000000) : // -0\\n            bytes8 (0x0000000000000000); // 0\\n      else if (exponent < 15361) {\\n        significand = (significand | 0x10000000000000000000000000000) >> 15421 - exponent;\\n        exponent = 0;\\n      } else {\\n        significand >>= 60;\\n        exponent -= 15360;\\n      }\\n\\n      uint64 result = uint64 (significand | exponent << 52);\\n      if (negative) result |= 0x8000000000000000;\\n\\n      return bytes8 (result);\\n    }\\n  }\\n\\n  /**\\n   * Test whether given quadruple precision number is NaN.\\n   *\\n   * @param x quadruple precision number\\n   * @return true if x is NaN, false otherwise\\n   */\\n  function isNaN (bytes16 x) internal pure returns (bool) {\\n    unchecked {\\n      return uint128 (x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF >\\n        0x7FFF0000000000000000000000000000;\\n    }\\n  }\\n\\n  /**\\n   * Test whether given quadruple precision number is positive or negative\\n   * infinity.\\n   *\\n   * @param x quadruple precision number\\n   * @return true if x is positive or negative infinity, false otherwise\\n   */\\n  function isInfinity (bytes16 x) internal pure returns (bool) {\\n    unchecked {\\n      return uint128 (x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF ==\\n        0x7FFF0000000000000000000000000000;\\n    }\\n  }\\n\\n  /**\\n   * Calculate sign of x, i.e. -1 if x is negative, 0 if x if zero, and 1 if x\\n   * is positive.  Note that sign (-0) is zero.  Revert if x is NaN. \\n   *\\n   * @param x quadruple precision number\\n   * @return sign of x\\n   */\\n  function sign (bytes16 x) internal pure returns (int8) {\\n    unchecked {\\n      uint128 absoluteX = uint128 (x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      require (absoluteX <= 0x7FFF0000000000000000000000000000); // Not NaN\\n\\n      if (absoluteX == 0) return 0;\\n      else if (uint128 (x) >= 0x80000000000000000000000000000000) return -1;\\n      else return 1;\\n    }\\n  }\\n\\n  /**\\n   * Calculate sign (x - y).  Revert if either argument is NaN, or both\\n   * arguments are infinities of the same sign. \\n   *\\n   * @param x quadruple precision number\\n   * @param y quadruple precision number\\n   * @return sign (x - y)\\n   */\\n  function cmp (bytes16 x, bytes16 y) internal pure returns (int8) {\\n    unchecked {\\n      uint128 absoluteX = uint128 (x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      require (absoluteX <= 0x7FFF0000000000000000000000000000); // Not NaN\\n\\n      uint128 absoluteY = uint128 (y) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      require (absoluteY <= 0x7FFF0000000000000000000000000000); // Not NaN\\n\\n      // Not infinities of the same sign\\n      require (x != y || absoluteX < 0x7FFF0000000000000000000000000000);\\n\\n      if (x == y) return 0;\\n      else {\\n        bool negativeX = uint128 (x) >= 0x80000000000000000000000000000000;\\n        bool negativeY = uint128 (y) >= 0x80000000000000000000000000000000;\\n\\n        if (negativeX) {\\n          if (negativeY) return absoluteX > absoluteY ? -1 : int8 (1);\\n          else return -1; \\n        } else {\\n          if (negativeY) return 1;\\n          else return absoluteX > absoluteY ? int8 (1) : -1;\\n        }\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Test whether x equals y.  NaN, infinity, and -infinity are not equal to\\n   * anything. \\n   *\\n   * @param x quadruple precision number\\n   * @param y quadruple precision number\\n   * @return true if x equals to y, false otherwise\\n   */\\n  function eq (bytes16 x, bytes16 y) internal pure returns (bool) {\\n    unchecked {\\n      if (x == y) {\\n        return uint128 (x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF <\\n          0x7FFF0000000000000000000000000000;\\n      } else return false;\\n    }\\n  }\\n\\n  /**\\n   * Calculate x + y.  Special values behave in the following way:\\n   *\\n   * NaN + x = NaN for any x.\\n   * Infinity + x = Infinity for any finite x.\\n   * -Infinity + x = -Infinity for any finite x.\\n   * Infinity + Infinity = Infinity.\\n   * -Infinity + -Infinity = -Infinity.\\n   * Infinity + -Infinity = -Infinity + Infinity = NaN.\\n   *\\n   * @param x quadruple precision number\\n   * @param y quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function add (bytes16 x, bytes16 y) internal pure returns (bytes16) {\\n    unchecked {\\n      uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\\n      uint256 yExponent = uint128 (y) >> 112 & 0x7FFF;\\n\\n      if (xExponent == 0x7FFF) {\\n        if (yExponent == 0x7FFF) { \\n          if (x == y) return x;\\n          else return NaN;\\n        } else return x; \\n      } else if (yExponent == 0x7FFF) return y;\\n      else {\\n        bool xSign = uint128 (x) >= 0x80000000000000000000000000000000;\\n        uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (xExponent == 0) xExponent = 1;\\n        else xSignifier |= 0x10000000000000000000000000000;\\n\\n        bool ySign = uint128 (y) >= 0x80000000000000000000000000000000;\\n        uint256 ySignifier = uint128 (y) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (yExponent == 0) yExponent = 1;\\n        else ySignifier |= 0x10000000000000000000000000000;\\n\\n        if (xSignifier == 0) return y == NEGATIVE_ZERO ? POSITIVE_ZERO : y;\\n        else if (ySignifier == 0) return x == NEGATIVE_ZERO ? POSITIVE_ZERO : x;\\n        else {\\n          int256 delta = int256 (xExponent) - int256 (yExponent);\\n  \\n          if (xSign == ySign) {\\n            if (delta > 112) return x;\\n            else if (delta > 0) ySignifier >>= uint256 (delta);\\n            else if (delta < -112) return y;\\n            else if (delta < 0) {\\n              xSignifier >>= uint256 (-delta);\\n              xExponent = yExponent;\\n            }\\n  \\n            xSignifier += ySignifier;\\n  \\n            if (xSignifier >= 0x20000000000000000000000000000) {\\n              xSignifier >>= 1;\\n              xExponent += 1;\\n            }\\n  \\n            if (xExponent == 0x7FFF)\\n              return xSign ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\\n            else {\\n              if (xSignifier < 0x10000000000000000000000000000) xExponent = 0;\\n              else xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n  \\n              return bytes16 (uint128 (\\n                  (xSign ? 0x80000000000000000000000000000000 : 0) |\\n                  (xExponent << 112) |\\n                  xSignifier)); \\n            }\\n          } else {\\n            if (delta > 0) {\\n              xSignifier <<= 1;\\n              xExponent -= 1;\\n            } else if (delta < 0) {\\n              ySignifier <<= 1;\\n              xExponent = yExponent - 1;\\n            }\\n\\n            if (delta > 112) ySignifier = 1;\\n            else if (delta > 1) ySignifier = (ySignifier - 1 >> uint256 (delta - 1)) + 1;\\n            else if (delta < -112) xSignifier = 1;\\n            else if (delta < -1) xSignifier = (xSignifier - 1 >> uint256 (-delta - 1)) + 1;\\n\\n            if (xSignifier >= ySignifier) xSignifier -= ySignifier;\\n            else {\\n              xSignifier = ySignifier - xSignifier;\\n              xSign = ySign;\\n            }\\n\\n            if (xSignifier == 0)\\n              return POSITIVE_ZERO;\\n\\n            uint256 msb = mostSignificantBit (xSignifier);\\n\\n            if (msb == 113) {\\n              xSignifier = xSignifier >> 1 & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n              xExponent += 1;\\n            } else if (msb < 112) {\\n              uint256 shift = 112 - msb;\\n              if (xExponent > shift) {\\n                xSignifier = xSignifier << shift & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n                xExponent -= shift;\\n              } else {\\n                xSignifier <<= xExponent - 1;\\n                xExponent = 0;\\n              }\\n            } else xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n            if (xExponent == 0x7FFF)\\n              return xSign ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\\n            else return bytes16 (uint128 (\\n                (xSign ? 0x80000000000000000000000000000000 : 0) |\\n                (xExponent << 112) |\\n                xSignifier));\\n          }\\n        }\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate x - y.  Special values behave in the following way:\\n   *\\n   * NaN - x = NaN for any x.\\n   * Infinity - x = Infinity for any finite x.\\n   * -Infinity - x = -Infinity for any finite x.\\n   * Infinity - -Infinity = Infinity.\\n   * -Infinity - Infinity = -Infinity.\\n   * Infinity - Infinity = -Infinity - -Infinity = NaN.\\n   *\\n   * @param x quadruple precision number\\n   * @param y quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function sub (bytes16 x, bytes16 y) internal pure returns (bytes16) {\\n    unchecked {\\n      return add (x, y ^ 0x80000000000000000000000000000000);\\n    }\\n  }\\n\\n  /**\\n   * Calculate x * y.  Special values behave in the following way:\\n   *\\n   * NaN * x = NaN for any x.\\n   * Infinity * x = Infinity for any finite positive x.\\n   * Infinity * x = -Infinity for any finite negative x.\\n   * -Infinity * x = -Infinity for any finite positive x.\\n   * -Infinity * x = Infinity for any finite negative x.\\n   * Infinity * 0 = NaN.\\n   * -Infinity * 0 = NaN.\\n   * Infinity * Infinity = Infinity.\\n   * Infinity * -Infinity = -Infinity.\\n   * -Infinity * Infinity = -Infinity.\\n   * -Infinity * -Infinity = Infinity.\\n   *\\n   * @param x quadruple precision number\\n   * @param y quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function mul (bytes16 x, bytes16 y) internal pure returns (bytes16) {\\n    unchecked {\\n      uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\\n      uint256 yExponent = uint128 (y) >> 112 & 0x7FFF;\\n\\n      if (xExponent == 0x7FFF) {\\n        if (yExponent == 0x7FFF) {\\n          if (x == y) return x ^ y & 0x80000000000000000000000000000000;\\n          else if (x ^ y == 0x80000000000000000000000000000000) return x | y;\\n          else return NaN;\\n        } else {\\n          if (y & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) return NaN;\\n          else return x ^ y & 0x80000000000000000000000000000000;\\n        }\\n      } else if (yExponent == 0x7FFF) {\\n          if (x & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) return NaN;\\n          else return y ^ x & 0x80000000000000000000000000000000;\\n      } else {\\n        uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (xExponent == 0) xExponent = 1;\\n        else xSignifier |= 0x10000000000000000000000000000;\\n\\n        uint256 ySignifier = uint128 (y) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (yExponent == 0) yExponent = 1;\\n        else ySignifier |= 0x10000000000000000000000000000;\\n\\n        xSignifier *= ySignifier;\\n        if (xSignifier == 0)\\n          return (x ^ y) & 0x80000000000000000000000000000000 > 0 ?\\n              NEGATIVE_ZERO : POSITIVE_ZERO;\\n\\n        xExponent += yExponent;\\n\\n        uint256 msb =\\n          xSignifier >= 0x200000000000000000000000000000000000000000000000000000000 ? 225 :\\n          xSignifier >= 0x100000000000000000000000000000000000000000000000000000000 ? 224 :\\n          mostSignificantBit (xSignifier);\\n\\n        if (xExponent + msb < 16496) { // Underflow\\n          xExponent = 0;\\n          xSignifier = 0;\\n        } else if (xExponent + msb < 16608) { // Subnormal\\n          if (xExponent < 16496)\\n            xSignifier >>= 16496 - xExponent;\\n          else if (xExponent > 16496)\\n            xSignifier <<= xExponent - 16496;\\n          xExponent = 0;\\n        } else if (xExponent + msb > 49373) {\\n          xExponent = 0x7FFF;\\n          xSignifier = 0;\\n        } else {\\n          if (msb > 112)\\n            xSignifier >>= msb - 112;\\n          else if (msb < 112)\\n            xSignifier <<= 112 - msb;\\n\\n          xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n          xExponent = xExponent + msb - 16607;\\n        }\\n\\n        return bytes16 (uint128 (uint128 ((x ^ y) & 0x80000000000000000000000000000000) |\\n            xExponent << 112 | xSignifier));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate x / y.  Special values behave in the following way:\\n   *\\n   * NaN / x = NaN for any x.\\n   * x / NaN = NaN for any x.\\n   * Infinity / x = Infinity for any finite non-negative x.\\n   * Infinity / x = -Infinity for any finite negative x including -0.\\n   * -Infinity / x = -Infinity for any finite non-negative x.\\n   * -Infinity / x = Infinity for any finite negative x including -0.\\n   * x / Infinity = 0 for any finite non-negative x.\\n   * x / -Infinity = -0 for any finite non-negative x.\\n   * x / Infinity = -0 for any finite non-negative x including -0.\\n   * x / -Infinity = 0 for any finite non-negative x including -0.\\n   * \\n   * Infinity / Infinity = NaN.\\n   * Infinity / -Infinity = -NaN.\\n   * -Infinity / Infinity = -NaN.\\n   * -Infinity / -Infinity = NaN.\\n   *\\n   * Division by zero behaves in the following way:\\n   *\\n   * x / 0 = Infinity for any finite positive x.\\n   * x / -0 = -Infinity for any finite positive x.\\n   * x / 0 = -Infinity for any finite negative x.\\n   * x / -0 = Infinity for any finite negative x.\\n   * 0 / 0 = NaN.\\n   * 0 / -0 = NaN.\\n   * -0 / 0 = NaN.\\n   * -0 / -0 = NaN.\\n   *\\n   * @param x quadruple precision number\\n   * @param y quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function div (bytes16 x, bytes16 y) internal pure returns (bytes16) {\\n    unchecked {\\n      uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\\n      uint256 yExponent = uint128 (y) >> 112 & 0x7FFF;\\n\\n      if (xExponent == 0x7FFF) {\\n        if (yExponent == 0x7FFF) return NaN;\\n        else return x ^ y & 0x80000000000000000000000000000000;\\n      } else if (yExponent == 0x7FFF) {\\n        if (y & 0x0000FFFFFFFFFFFFFFFFFFFFFFFFFFFF != 0) return NaN;\\n        else return POSITIVE_ZERO | (x ^ y) & 0x80000000000000000000000000000000;\\n      } else if (y & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) {\\n        if (x & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) return NaN;\\n        else return POSITIVE_INFINITY | (x ^ y) & 0x80000000000000000000000000000000;\\n      } else {\\n        uint256 ySignifier = uint128 (y) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (yExponent == 0) yExponent = 1;\\n        else ySignifier |= 0x10000000000000000000000000000;\\n\\n        uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (xExponent == 0) {\\n          if (xSignifier != 0) {\\n            uint shift = 226 - mostSignificantBit (xSignifier);\\n\\n            xSignifier <<= shift;\\n\\n            xExponent = 1;\\n            yExponent += shift - 114;\\n          }\\n        }\\n        else {\\n          xSignifier = (xSignifier | 0x10000000000000000000000000000) << 114;\\n        }\\n\\n        xSignifier = xSignifier / ySignifier;\\n        if (xSignifier == 0)\\n          return (x ^ y) & 0x80000000000000000000000000000000 > 0 ?\\n              NEGATIVE_ZERO : POSITIVE_ZERO;\\n\\n        assert (xSignifier >= 0x1000000000000000000000000000);\\n\\n        uint256 msb =\\n          xSignifier >= 0x80000000000000000000000000000 ? mostSignificantBit (xSignifier) :\\n          xSignifier >= 0x40000000000000000000000000000 ? 114 :\\n          xSignifier >= 0x20000000000000000000000000000 ? 113 : 112;\\n\\n        if (xExponent + msb > yExponent + 16497) { // Overflow\\n          xExponent = 0x7FFF;\\n          xSignifier = 0;\\n        } else if (xExponent + msb + 16380  < yExponent) { // Underflow\\n          xExponent = 0;\\n          xSignifier = 0;\\n        } else if (xExponent + msb + 16268  < yExponent) { // Subnormal\\n          if (xExponent + 16380 > yExponent)\\n            xSignifier <<= xExponent + 16380 - yExponent;\\n          else if (xExponent + 16380 < yExponent)\\n            xSignifier >>= yExponent - xExponent - 16380;\\n\\n          xExponent = 0;\\n        } else { // Normal\\n          if (msb > 112)\\n            xSignifier >>= msb - 112;\\n\\n          xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n          xExponent = xExponent + msb + 16269 - yExponent;\\n        }\\n\\n        return bytes16 (uint128 (uint128 ((x ^ y) & 0x80000000000000000000000000000000) |\\n            xExponent << 112 | xSignifier));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate -x.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function neg (bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      return x ^ 0x80000000000000000000000000000000;\\n    }\\n  }\\n\\n  /**\\n   * Calculate |x|.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function abs (bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      return x & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n    }\\n  }\\n\\n  /**\\n   * Calculate square root of x.  Return NaN on negative x excluding -0.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function sqrt (bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      if (uint128 (x) >  0x80000000000000000000000000000000) return NaN;\\n      else {\\n        uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\\n        if (xExponent == 0x7FFF) return x;\\n        else {\\n          uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n          if (xExponent == 0) xExponent = 1;\\n          else xSignifier |= 0x10000000000000000000000000000;\\n\\n          if (xSignifier == 0) return POSITIVE_ZERO;\\n\\n          bool oddExponent = xExponent & 0x1 == 0;\\n          xExponent = xExponent + 16383 >> 1;\\n\\n          if (oddExponent) {\\n            if (xSignifier >= 0x10000000000000000000000000000)\\n              xSignifier <<= 113;\\n            else {\\n              uint256 msb = mostSignificantBit (xSignifier);\\n              uint256 shift = (226 - msb) & 0xFE;\\n              xSignifier <<= shift;\\n              xExponent -= shift - 112 >> 1;\\n            }\\n          } else {\\n            if (xSignifier >= 0x10000000000000000000000000000)\\n              xSignifier <<= 112;\\n            else {\\n              uint256 msb = mostSignificantBit (xSignifier);\\n              uint256 shift = (225 - msb) & 0xFE;\\n              xSignifier <<= shift;\\n              xExponent -= shift - 112 >> 1;\\n            }\\n          }\\n\\n          uint256 r = 0x10000000000000000000000000000;\\n          r = (r + xSignifier / r) >> 1;\\n          r = (r + xSignifier / r) >> 1;\\n          r = (r + xSignifier / r) >> 1;\\n          r = (r + xSignifier / r) >> 1;\\n          r = (r + xSignifier / r) >> 1;\\n          r = (r + xSignifier / r) >> 1;\\n          r = (r + xSignifier / r) >> 1; // Seven iterations should be enough\\n          uint256 r1 = xSignifier / r;\\n          if (r1 < r) r = r1;\\n\\n          return bytes16 (uint128 (xExponent << 112 | r & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF));\\n        }\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate binary logarithm of x.  Return NaN on negative x excluding -0.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function log_2 (bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      if (uint128 (x) > 0x80000000000000000000000000000000) return NaN;\\n      else if (x == 0x3FFF0000000000000000000000000000) return POSITIVE_ZERO; \\n      else {\\n        uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\\n        if (xExponent == 0x7FFF) return x;\\n        else {\\n          uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n          if (xExponent == 0) xExponent = 1;\\n          else xSignifier |= 0x10000000000000000000000000000;\\n\\n          if (xSignifier == 0) return NEGATIVE_INFINITY;\\n\\n          bool resultNegative;\\n          uint256 resultExponent = 16495;\\n          uint256 resultSignifier;\\n\\n          if (xExponent >= 0x3FFF) {\\n            resultNegative = false;\\n            resultSignifier = xExponent - 0x3FFF;\\n            xSignifier <<= 15;\\n          } else {\\n            resultNegative = true;\\n            if (xSignifier >= 0x10000000000000000000000000000) {\\n              resultSignifier = 0x3FFE - xExponent;\\n              xSignifier <<= 15;\\n            } else {\\n              uint256 msb = mostSignificantBit (xSignifier);\\n              resultSignifier = 16493 - msb;\\n              xSignifier <<= 127 - msb;\\n            }\\n          }\\n\\n          if (xSignifier == 0x80000000000000000000000000000000) {\\n            if (resultNegative) resultSignifier += 1;\\n            uint256 shift = 112 - mostSignificantBit (resultSignifier);\\n            resultSignifier <<= shift;\\n            resultExponent -= shift;\\n          } else {\\n            uint256 bb = resultNegative ? 1 : 0;\\n            while (resultSignifier < 0x10000000000000000000000000000) {\\n              resultSignifier <<= 1;\\n              resultExponent -= 1;\\n  \\n              xSignifier *= xSignifier;\\n              uint256 b = xSignifier >> 255;\\n              resultSignifier += b ^ bb;\\n              xSignifier >>= 127 + b;\\n            }\\n          }\\n\\n          return bytes16 (uint128 ((resultNegative ? 0x80000000000000000000000000000000 : 0) |\\n              resultExponent << 112 | resultSignifier & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF));\\n        }\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate natural logarithm of x.  Return NaN on negative x excluding -0.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function ln (bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      return mul (log_2 (x), 0x3FFE62E42FEFA39EF35793C7673007E5);\\n    }\\n  }\\n\\n  /**\\n   * Calculate 2^x.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function pow_2 (bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      bool xNegative = uint128 (x) > 0x80000000000000000000000000000000;\\n      uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\\n      uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      if (xExponent == 0x7FFF && xSignifier != 0) return NaN;\\n      else if (xExponent > 16397)\\n        return xNegative ? POSITIVE_ZERO : POSITIVE_INFINITY;\\n      else if (xExponent < 16255)\\n        return 0x3FFF0000000000000000000000000000;\\n      else {\\n        if (xExponent == 0) xExponent = 1;\\n        else xSignifier |= 0x10000000000000000000000000000;\\n\\n        if (xExponent > 16367)\\n          xSignifier <<= xExponent - 16367;\\n        else if (xExponent < 16367)\\n          xSignifier >>= 16367 - xExponent;\\n\\n        if (xNegative && xSignifier > 0x406E00000000000000000000000000000000)\\n          return POSITIVE_ZERO;\\n\\n        if (!xNegative && xSignifier > 0x3FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\\n          return POSITIVE_INFINITY;\\n\\n        uint256 resultExponent = xSignifier >> 128;\\n        xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (xNegative && xSignifier != 0) {\\n          xSignifier = ~xSignifier;\\n          resultExponent += 1;\\n        }\\n\\n        uint256 resultSignifier = 0x80000000000000000000000000000000;\\n        if (xSignifier & 0x80000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x16A09E667F3BCC908B2FB1366EA957D3E >> 128;\\n        if (xSignifier & 0x40000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1306FE0A31B7152DE8D5A46305C85EDEC >> 128;\\n        if (xSignifier & 0x20000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1172B83C7D517ADCDF7C8C50EB14A791F >> 128;\\n        if (xSignifier & 0x10000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10B5586CF9890F6298B92B71842A98363 >> 128;\\n        if (xSignifier & 0x8000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1059B0D31585743AE7C548EB68CA417FD >> 128;\\n        if (xSignifier & 0x4000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x102C9A3E778060EE6F7CACA4F7A29BDE8 >> 128;\\n        if (xSignifier & 0x2000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10163DA9FB33356D84A66AE336DCDFA3F >> 128;\\n        if (xSignifier & 0x1000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100B1AFA5ABCBED6129AB13EC11DC9543 >> 128;\\n        if (xSignifier & 0x800000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10058C86DA1C09EA1FF19D294CF2F679B >> 128;\\n        if (xSignifier & 0x400000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1002C605E2E8CEC506D21BFC89A23A00F >> 128;\\n        if (xSignifier & 0x200000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100162F3904051FA128BCA9C55C31E5DF >> 128;\\n        if (xSignifier & 0x100000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000B175EFFDC76BA38E31671CA939725 >> 128;\\n        if (xSignifier & 0x80000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100058BA01FB9F96D6CACD4B180917C3D >> 128;\\n        if (xSignifier & 0x40000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10002C5CC37DA9491D0985C348C68E7B3 >> 128;\\n        if (xSignifier & 0x20000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000162E525EE054754457D5995292026 >> 128;\\n        if (xSignifier & 0x10000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000B17255775C040618BF4A4ADE83FC >> 128;\\n        if (xSignifier & 0x8000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000058B91B5BC9AE2EED81E9B7D4CFAB >> 128;\\n        if (xSignifier & 0x4000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100002C5C89D5EC6CA4D7C8ACC017B7C9 >> 128;\\n        if (xSignifier & 0x2000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000162E43F4F831060E02D839A9D16D >> 128;\\n        if (xSignifier & 0x1000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000B1721BCFC99D9F890EA06911763 >> 128;\\n        if (xSignifier & 0x800000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000058B90CF1E6D97F9CA14DBCC1628 >> 128;\\n        if (xSignifier & 0x400000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000002C5C863B73F016468F6BAC5CA2B >> 128;\\n        if (xSignifier & 0x200000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000162E430E5A18F6119E3C02282A5 >> 128;\\n        if (xSignifier & 0x100000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000B1721835514B86E6D96EFD1BFE >> 128;\\n        if (xSignifier & 0x80000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000058B90C0B48C6BE5DF846C5B2EF >> 128;\\n        if (xSignifier & 0x40000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000002C5C8601CC6B9E94213C72737A >> 128;\\n        if (xSignifier & 0x20000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000162E42FFF037DF38AA2B219F06 >> 128;\\n        if (xSignifier & 0x10000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000B17217FBA9C739AA5819F44F9 >> 128;\\n        if (xSignifier & 0x8000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000058B90BFCDEE5ACD3C1CEDC823 >> 128;\\n        if (xSignifier & 0x4000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000002C5C85FE31F35A6A30DA1BE50 >> 128;\\n        if (xSignifier & 0x2000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000162E42FF0999CE3541B9FFFCF >> 128;\\n        if (xSignifier & 0x1000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000B17217F80F4EF5AADDA45554 >> 128;\\n        if (xSignifier & 0x800000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000058B90BFBF8479BD5A81B51AD >> 128;\\n        if (xSignifier & 0x400000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000002C5C85FDF84BD62AE30A74CC >> 128;\\n        if (xSignifier & 0x200000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000162E42FEFB2FED257559BDAA >> 128;\\n        if (xSignifier & 0x100000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000B17217F7D5A7716BBA4A9AE >> 128;\\n        if (xSignifier & 0x80000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000058B90BFBE9DDBAC5E109CCE >> 128;\\n        if (xSignifier & 0x40000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000002C5C85FDF4B15DE6F17EB0D >> 128;\\n        if (xSignifier & 0x20000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000162E42FEFA494F1478FDE05 >> 128;\\n        if (xSignifier & 0x10000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000B17217F7D20CF927C8E94C >> 128;\\n        if (xSignifier & 0x8000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000058B90BFBE8F71CB4E4B33D >> 128;\\n        if (xSignifier & 0x4000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000002C5C85FDF477B662B26945 >> 128;\\n        if (xSignifier & 0x2000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000162E42FEFA3AE53369388C >> 128;\\n        if (xSignifier & 0x1000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000B17217F7D1D351A389D40 >> 128;\\n        if (xSignifier & 0x800000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000058B90BFBE8E8B2D3D4EDE >> 128;\\n        if (xSignifier & 0x400000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000002C5C85FDF4741BEA6E77E >> 128;\\n        if (xSignifier & 0x200000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000162E42FEFA39FE95583C2 >> 128;\\n        if (xSignifier & 0x100000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000B17217F7D1CFB72B45E1 >> 128;\\n        if (xSignifier & 0x80000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000058B90BFBE8E7CC35C3F0 >> 128;\\n        if (xSignifier & 0x40000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000002C5C85FDF473E242EA38 >> 128;\\n        if (xSignifier & 0x20000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000162E42FEFA39F02B772C >> 128;\\n        if (xSignifier & 0x10000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000B17217F7D1CF7D83C1A >> 128;\\n        if (xSignifier & 0x8000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000058B90BFBE8E7BDCBE2E >> 128;\\n        if (xSignifier & 0x4000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000002C5C85FDF473DEA871F >> 128;\\n        if (xSignifier & 0x2000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000162E42FEFA39EF44D91 >> 128;\\n        if (xSignifier & 0x1000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000B17217F7D1CF79E949 >> 128;\\n        if (xSignifier & 0x800000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000058B90BFBE8E7BCE544 >> 128;\\n        if (xSignifier & 0x400000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000002C5C85FDF473DE6ECA >> 128;\\n        if (xSignifier & 0x200000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000162E42FEFA39EF366F >> 128;\\n        if (xSignifier & 0x100000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000B17217F7D1CF79AFA >> 128;\\n        if (xSignifier & 0x80000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000058B90BFBE8E7BCD6D >> 128;\\n        if (xSignifier & 0x40000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000002C5C85FDF473DE6B2 >> 128;\\n        if (xSignifier & 0x20000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000162E42FEFA39EF358 >> 128;\\n        if (xSignifier & 0x10000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000B17217F7D1CF79AB >> 128;\\n        if (xSignifier & 0x8000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000058B90BFBE8E7BCD5 >> 128;\\n        if (xSignifier & 0x4000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000002C5C85FDF473DE6A >> 128;\\n        if (xSignifier & 0x2000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000162E42FEFA39EF34 >> 128;\\n        if (xSignifier & 0x1000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000B17217F7D1CF799 >> 128;\\n        if (xSignifier & 0x800000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000058B90BFBE8E7BCC >> 128;\\n        if (xSignifier & 0x400000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000002C5C85FDF473DE5 >> 128;\\n        if (xSignifier & 0x200000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000162E42FEFA39EF2 >> 128;\\n        if (xSignifier & 0x100000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000B17217F7D1CF78 >> 128;\\n        if (xSignifier & 0x80000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000058B90BFBE8E7BB >> 128;\\n        if (xSignifier & 0x40000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000002C5C85FDF473DD >> 128;\\n        if (xSignifier & 0x20000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000162E42FEFA39EE >> 128;\\n        if (xSignifier & 0x10000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000B17217F7D1CF6 >> 128;\\n        if (xSignifier & 0x8000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000058B90BFBE8E7A >> 128;\\n        if (xSignifier & 0x4000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000002C5C85FDF473C >> 128;\\n        if (xSignifier & 0x2000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000162E42FEFA39D >> 128;\\n        if (xSignifier & 0x1000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000B17217F7D1CE >> 128;\\n        if (xSignifier & 0x800000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000058B90BFBE8E6 >> 128;\\n        if (xSignifier & 0x400000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000002C5C85FDF472 >> 128;\\n        if (xSignifier & 0x200000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000162E42FEFA38 >> 128;\\n        if (xSignifier & 0x100000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000B17217F7D1B >> 128;\\n        if (xSignifier & 0x80000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000058B90BFBE8D >> 128;\\n        if (xSignifier & 0x40000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000002C5C85FDF46 >> 128;\\n        if (xSignifier & 0x20000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000162E42FEFA2 >> 128;\\n        if (xSignifier & 0x10000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000B17217F7D0 >> 128;\\n        if (xSignifier & 0x8000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000058B90BFBE7 >> 128;\\n        if (xSignifier & 0x4000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000002C5C85FDF3 >> 128;\\n        if (xSignifier & 0x2000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000162E42FEF9 >> 128;\\n        if (xSignifier & 0x1000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000B17217F7C >> 128;\\n        if (xSignifier & 0x800000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000058B90BFBD >> 128;\\n        if (xSignifier & 0x400000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000002C5C85FDE >> 128;\\n        if (xSignifier & 0x200000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000162E42FEE >> 128;\\n        if (xSignifier & 0x100000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000B17217F6 >> 128;\\n        if (xSignifier & 0x80000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000058B90BFA >> 128;\\n        if (xSignifier & 0x40000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000002C5C85FC >> 128;\\n        if (xSignifier & 0x20000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000162E42FD >> 128;\\n        if (xSignifier & 0x10000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000B17217E >> 128;\\n        if (xSignifier & 0x8000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000058B90BE >> 128;\\n        if (xSignifier & 0x4000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000002C5C85E >> 128;\\n        if (xSignifier & 0x2000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000162E42E >> 128;\\n        if (xSignifier & 0x1000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000B17216 >> 128;\\n        if (xSignifier & 0x800000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000058B90A >> 128;\\n        if (xSignifier & 0x400000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000002C5C84 >> 128;\\n        if (xSignifier & 0x200000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000162E41 >> 128;\\n        if (xSignifier & 0x100000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000000B1720 >> 128;\\n        if (xSignifier & 0x80000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000058B8F >> 128;\\n        if (xSignifier & 0x40000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000002C5C7 >> 128;\\n        if (xSignifier & 0x20000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000000162E3 >> 128;\\n        if (xSignifier & 0x10000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000000B171 >> 128;\\n        if (xSignifier & 0x8000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000000058B8 >> 128;\\n        if (xSignifier & 0x4000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000002C5B >> 128;\\n        if (xSignifier & 0x2000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000000162D >> 128;\\n        if (xSignifier & 0x1000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000B16 >> 128;\\n        if (xSignifier & 0x800 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000000058A >> 128;\\n        if (xSignifier & 0x400 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000000002C4 >> 128;\\n        if (xSignifier & 0x200 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000161 >> 128;\\n        if (xSignifier & 0x100 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000000000B0 >> 128;\\n        if (xSignifier & 0x80 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000057 >> 128;\\n        if (xSignifier & 0x40 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000000002B >> 128;\\n        if (xSignifier & 0x20 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000015 >> 128;\\n        if (xSignifier & 0x10 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000000000A >> 128;\\n        if (xSignifier & 0x8 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000004 >> 128;\\n        if (xSignifier & 0x4 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000001 >> 128;\\n\\n        if (!xNegative) {\\n          resultSignifier = resultSignifier >> 15 & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n          resultExponent += 0x3FFF;\\n        } else if (resultExponent <= 0x3FFE) {\\n          resultSignifier = resultSignifier >> 15 & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n          resultExponent = 0x3FFF - resultExponent;\\n        } else {\\n          resultSignifier = resultSignifier >> resultExponent - 16367;\\n          resultExponent = 0;\\n        }\\n\\n        return bytes16 (uint128 (resultExponent << 112 | resultSignifier));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate e^x.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function exp (bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      return pow_2 (mul (x, 0x3FFF71547652B82FE1777D0FFDA0D23A));\\n    }\\n  }\\n\\n  /**\\n   * Get index of the most significant non-zero bit in binary representation of\\n   * x.  Reverts if x is zero.\\n   *\\n   * @return index of the most significant non-zero bit in binary representation\\n   *         of x\\n   */\\n  function mostSignificantBit (uint256 x) private pure returns (uint256) {\\n    unchecked {\\n      require (x > 0);\\n\\n      uint256 result = 0;\\n\\n      if (x >= 0x100000000000000000000000000000000) { x >>= 128; result += 128; }\\n      if (x >= 0x10000000000000000) { x >>= 64; result += 64; }\\n      if (x >= 0x100000000) { x >>= 32; result += 32; }\\n      if (x >= 0x10000) { x >>= 16; result += 16; }\\n      if (x >= 0x100) { x >>= 8; result += 8; }\\n      if (x >= 0x10) { x >>= 4; result += 4; }\\n      if (x >= 0x4) { x >>= 2; result += 2; }\\n      if (x >= 0x2) result += 1; // No need to shift x anymore\\n\\n      return result;\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0x9694a9f6fcadd4fa917efa674de42a74b8fbab8d68924f771ea5cc5e1a301434\",\"license\":\"BSD-4-Clause\"},\"contracts/implementation/PoolSwapLibrary.sol\":{\"content\":\"//SPDX-License-Identifier: CC-BY-NC-ND-4.0\\npragma solidity 0.8.7;\\n\\nimport \\\"abdk-libraries-solidity/ABDKMathQuad.sol\\\";\\n\\n/// @title Library for various useful (mostly) mathematical functions\\nlibrary PoolSwapLibrary {\\n    /// ABDKMathQuad-formatted representation of the number one\\n    bytes16 public constant one = 0x3fff0000000000000000000000000000;\\n\\n    /// Maximum number of decimal places supported by this contract\\n    /// (ABDKMathQuad defines this but it's private)\\n    uint256 public constant MAX_DECIMALS = 18;\\n\\n    /// Maximum precision supportable via wad arithmetic (for this contract)\\n    uint256 public constant WAD_PRECISION = 10**18;\\n\\n    /// Information required to update a given user's aggregated balance\\n    struct UpdateData {\\n        bytes16 longPrice;\\n        bytes16 shortPrice;\\n        uint256 currentUpdateIntervalId;\\n        uint256 updateIntervalId;\\n        uint256 longMintAmount;\\n        uint256 longBurnAmount;\\n        uint256 shortMintAmount;\\n        uint256 shortBurnAmount;\\n        uint256 longBurnShortMintAmount;\\n        uint256 shortBurnLongMintAmount;\\n        bytes16 burnFee;\\n    }\\n\\n    /// Information required to perform a price change (of the underlying asset)\\n    struct PriceChangeData {\\n        int256 oldPrice;\\n        int256 newPrice;\\n        uint256 longBalance;\\n        uint256 shortBalance;\\n        bytes16 leverageAmount;\\n        bytes16 fee;\\n    }\\n\\n    /**\\n     * @notice Calculates the ratio between two numbers\\n     * @dev Rounds any overflow towards 0. If either parameter is zero, the ratio is 0\\n     * @param _numerator The \\\"parts per\\\" side of the equation. If this is zero, the ratio is zero\\n     * @param _denominator The \\\"per part\\\" side of the equation. If this is zero, the ratio is zero\\n     * @return the ratio, as an ABDKMathQuad number (IEEE 754 quadruple precision floating point)\\n     */\\n    function getRatio(uint256 _numerator, uint256 _denominator) public pure returns (bytes16) {\\n        // Catch the divide by zero error.\\n        if (_denominator == 0) {\\n            return 0;\\n        }\\n        return ABDKMathQuad.div(ABDKMathQuad.fromUInt(_numerator), ABDKMathQuad.fromUInt(_denominator));\\n    }\\n\\n    /**\\n     * @notice Multiplies two numbers\\n     * @param x The number to be multiplied by `y`\\n     * @param y The number to be multiplied by `x`\\n     */\\n    function multiplyBytes(bytes16 x, bytes16 y) external pure returns (bytes16) {\\n        return ABDKMathQuad.mul(x, y);\\n    }\\n\\n    /**\\n     * @notice Performs a subtraction on two bytes16 numbers\\n     * @param x The number to be subtracted by `y`\\n     * @param y The number to subtract from `x`\\n     */\\n    function subtractBytes(bytes16 x, bytes16 y) external pure returns (bytes16) {\\n        return ABDKMathQuad.sub(x, y);\\n    }\\n\\n    /**\\n     * @notice Performs an addition on two bytes16 numbers\\n     * @param x The number to be added with `y`\\n     * @param y The number to be added with `x`\\n     */\\n    function addBytes(bytes16 x, bytes16 y) external pure returns (bytes16) {\\n        return ABDKMathQuad.add(x, y);\\n    }\\n\\n    /**\\n     * @notice Gets the short and long balances after the keeper rewards have been paid out\\n     *         Keeper rewards are paid proportionally to the short and long pool\\n     * @dev Assumes shortBalance + longBalance >= reward\\n     * @param reward Amount of keeper reward\\n     * @param shortBalance Short balance of the pool\\n     * @param longBalance Long balance of the pool\\n     * @return shortBalanceAfterFees Short balance of the pool after the keeper reward has been paid\\n     * @return longBalanceAfterFees Long balance of the pool after the keeper reward has been paid\\n     */\\n    function getBalancesAfterFees(\\n        uint256 reward,\\n        uint256 shortBalance,\\n        uint256 longBalance\\n    ) external pure returns (uint256, uint256) {\\n        bytes16 ratioShort = getRatio(shortBalance, shortBalance + longBalance);\\n\\n        uint256 shortFees = convertDecimalToUInt(multiplyDecimalByUInt(ratioShort, reward));\\n\\n        uint256 shortBalanceAfterFees = shortBalance - shortFees;\\n        uint256 longBalanceAfterFees = longBalance - (reward - shortFees);\\n\\n        // Return shortBalance and longBalance after rewards are paid out\\n        return (shortBalanceAfterFees, longBalanceAfterFees);\\n    }\\n\\n    /**\\n     * @notice Compares two decimal numbers\\n     * @param x The first number to compare\\n     * @param y The second number to compare\\n     * @return -1 if x < y, 0 if x = y, or 1 if x > y\\n     */\\n    function compareDecimals(bytes16 x, bytes16 y) public pure returns (int8) {\\n        return ABDKMathQuad.cmp(x, y);\\n    }\\n\\n    /**\\n     * @notice Converts an integer value to a compatible decimal value\\n     * @param amount The amount to convert\\n     * @return The amount as a IEEE754 quadruple precision number\\n     */\\n    function convertUIntToDecimal(uint256 amount) external pure returns (bytes16) {\\n        return ABDKMathQuad.fromUInt(amount);\\n    }\\n\\n    /**\\n     * @notice Converts a raw decimal value to a more readable uint256 value\\n     * @param ratio The value to convert\\n     * @return The converted value\\n     */\\n    function convertDecimalToUInt(bytes16 ratio) public pure returns (uint256) {\\n        return ABDKMathQuad.toUInt(ratio);\\n    }\\n\\n    /**\\n     * @notice Multiplies a decimal and an unsigned integer\\n     * @param a The first term\\n     * @param b The second term\\n     * @return The product of a*b as a decimal\\n     */\\n    function multiplyDecimalByUInt(bytes16 a, uint256 b) public pure returns (bytes16) {\\n        return ABDKMathQuad.mul(a, ABDKMathQuad.fromUInt(b));\\n    }\\n\\n    /**\\n     * @notice Divides two unsigned integers\\n     * @param a The dividend\\n     * @param b The divisor\\n     * @return The quotient\\n     */\\n    function divUInt(uint256 a, uint256 b) private pure returns (bytes16) {\\n        return ABDKMathQuad.div(ABDKMathQuad.fromUInt(a), ABDKMathQuad.fromUInt(b));\\n    }\\n\\n    /**\\n     * @notice Divides two integers\\n     * @param a The dividend\\n     * @param b The divisor\\n     * @return The quotient\\n     */\\n    function divInt(int256 a, int256 b) public pure returns (bytes16) {\\n        return ABDKMathQuad.div(ABDKMathQuad.fromInt(a), ABDKMathQuad.fromInt(b));\\n    }\\n\\n    /**\\n     * @notice Multiply an integer by a fraction\\n     * @return The result as an integer\\n     */\\n    function mulFraction(\\n        uint256 number,\\n        uint256 numerator,\\n        uint256 denominator\\n    ) public pure returns (uint256) {\\n        if (denominator == 0) {\\n            return 0;\\n        }\\n        bytes16 multiplyResult = ABDKMathQuad.mul(ABDKMathQuad.fromUInt(number), ABDKMathQuad.fromUInt(numerator));\\n        bytes16 result = ABDKMathQuad.div(multiplyResult, ABDKMathQuad.fromUInt(denominator));\\n        return convertDecimalToUInt(result);\\n    }\\n\\n    /**\\n     * @notice Calculates the loss multiplier to apply to the losing pool. Includes the power leverage\\n     * @param ratio The ratio of new price to old price\\n     * @param direction The direction of the change. -1 if it's decreased, 0 if it hasn't changed, and 1 if it's increased\\n     * @param leverage The amount of leverage to apply\\n     * @return The multiplier\\n     */\\n    function getLossMultiplier(\\n        bytes16 ratio,\\n        int8 direction,\\n        bytes16 leverage\\n    ) public pure returns (bytes16) {\\n        // If decreased:  2 ^ (leverage * log2[(1 * new/old) + [(0 * 1) / new/old]])\\n        //              = 2 ^ (leverage * log2[(new/old)])\\n        // If increased:  2 ^ (leverage * log2[(0 * new/old) + [(1 * 1) / new/old]])\\n        //              = 2 ^ (leverage * log2([1 / new/old]))\\n        //              = 2 ^ (leverage * log2([old/new]))\\n        return\\n            ABDKMathQuad.pow_2(\\n                ABDKMathQuad.mul(leverage, ABDKMathQuad.log_2(direction < 0 ? ratio : ABDKMathQuad.div(one, ratio)))\\n            );\\n    }\\n\\n    /**\\n     * @notice Calculates the amount to take from the losing pool\\n     * @param lossMultiplier The multiplier to use\\n     * @param balance The balance of the losing pool\\n     */\\n    function getLossAmount(bytes16 lossMultiplier, uint256 balance) public pure returns (uint256) {\\n        return\\n            ABDKMathQuad.toUInt(\\n                ABDKMathQuad.mul(ABDKMathQuad.sub(one, lossMultiplier), ABDKMathQuad.fromUInt(balance))\\n            );\\n    }\\n\\n    /**\\n     * @notice Calculates the effect of a price change. This involves calculating how many funds to transfer from the losing pool to the other.\\n     * @dev This function should be called by the LeveragedPool.\\n     * @param priceChange The struct containing necessary data to calculate price change\\n     * @return Resulting long balance\\n     * @return Resulting short balance\\n     * @return Resulting fees taken from long balance\\n     * @return Resulting fees taken from short balance\\n     */\\n    function calculatePriceChange(PriceChangeData calldata priceChange)\\n        external\\n        pure\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        uint256 shortBalance = priceChange.shortBalance;\\n        uint256 longBalance = priceChange.longBalance;\\n        bytes16 leverageAmount = priceChange.leverageAmount;\\n        int256 oldPrice = priceChange.oldPrice;\\n        int256 newPrice = priceChange.newPrice;\\n        bytes16 fee = priceChange.fee;\\n\\n        // Calculate fees from long and short sides\\n        uint256 longFeeAmount = convertDecimalToUInt(multiplyDecimalByUInt(fee, longBalance)) /\\n            PoolSwapLibrary.WAD_PRECISION;\\n        uint256 shortFeeAmount = convertDecimalToUInt(multiplyDecimalByUInt(fee, shortBalance)) /\\n            PoolSwapLibrary.WAD_PRECISION;\\n\\n        shortBalance = shortBalance - shortFeeAmount;\\n        longBalance = longBalance - longFeeAmount;\\n\\n        // Use the ratio to determine if the price increased or decreased and therefore which direction\\n        // the funds should be transferred towards.\\n\\n        bytes16 ratio = divInt(newPrice, oldPrice);\\n        int8 direction = compareDecimals(ratio, PoolSwapLibrary.one);\\n        // Take into account the leverage\\n        bytes16 lossMultiplier = getLossMultiplier(ratio, direction, leverageAmount);\\n\\n        if (direction >= 0 && shortBalance > 0) {\\n            // Move funds from short to long pair\\n            uint256 lossAmount = getLossAmount(lossMultiplier, shortBalance);\\n            shortBalance = shortBalance - lossAmount;\\n            longBalance = longBalance + lossAmount;\\n        } else if (direction < 0 && longBalance > 0) {\\n            // Move funds from long to short pair\\n            uint256 lossAmount = getLossAmount(lossMultiplier, longBalance);\\n            shortBalance = shortBalance + lossAmount;\\n            longBalance = longBalance - lossAmount;\\n        }\\n\\n        return (longBalance, shortBalance, longFeeAmount, shortFeeAmount);\\n    }\\n\\n    /**\\n     * @notice Returns true if the given timestamp is BEFORE the frontRunningInterval starts,\\n     *         which is allowed for uncommitment.\\n     * @dev If you try to uncommit AFTER the frontRunningInterval, it should revert.\\n     * @param subjectTime The timestamp for which you want to calculate if it was beforeFrontRunningInterval\\n     * @param lastPriceTimestamp The timestamp of the last price update\\n     * @param updateInterval The interval between price updates\\n     * @param frontRunningInterval The window of time before a price udpate users can not uncommit or have their commit executed from\\n     */\\n    function isBeforeFrontRunningInterval(\\n        uint256 subjectTime,\\n        uint256 lastPriceTimestamp,\\n        uint256 updateInterval,\\n        uint256 frontRunningInterval\\n    ) public pure returns (bool) {\\n        return lastPriceTimestamp + updateInterval - frontRunningInterval > subjectTime;\\n    }\\n\\n    /**\\n     * @notice Calculates the update interval ID that a commitment should be placed in.\\n     * @param timestamp Current block.timestamp\\n     * @param lastPriceTimestamp The timestamp of the last price update\\n     * @param frontRunningInterval The frontrunning interval of a pool - The amount of time before an update interval that you must commit to get included in that update\\n     * @param updateInterval The frequency of a pool's updates\\n     * @param currentUpdateIntervalId The current update interval's ID\\n     * @dev Note that the timestamp parameter is required to be >= lastPriceTimestamp\\n     * @return The update interval ID in which a commit being made at time timestamp should be included\\n     */\\n    function appropriateUpdateIntervalId(\\n        uint256 timestamp,\\n        uint256 lastPriceTimestamp,\\n        uint256 frontRunningInterval,\\n        uint256 updateInterval,\\n        uint256 currentUpdateIntervalId\\n    ) external pure returns (uint256) {\\n        // Since lastPriceTimestamp <= block.timestamp, the below also confirms that timestamp >= block.timestamp\\n        require(timestamp >= lastPriceTimestamp, \\\"timestamp in the past\\\");\\n        if (frontRunningInterval <= updateInterval) {\\n            // This is the \\\"simple\\\" case where we either want the current update interval or the next one\\n            if (isBeforeFrontRunningInterval(timestamp, lastPriceTimestamp, updateInterval, frontRunningInterval)) {\\n                // We are before the frontRunning interval\\n                return currentUpdateIntervalId;\\n            } else {\\n                return currentUpdateIntervalId + 1;\\n            }\\n        } else {\\n            // frontRunningInterval > updateInterval\\n            // This is the generalised case, where it could be any number of update intervals in the future\\n            uint256 factorDifference = ABDKMathQuad.toUInt(divUInt(frontRunningInterval, updateInterval));\\n            uint256 timeOfNextAvailableInterval = lastPriceTimestamp + (updateInterval * (factorDifference + 1));\\n            // frontRunningInterval is factorDifference times larger than updateInterval\\n            uint256 minimumUpdateIntervalId = currentUpdateIntervalId + factorDifference;\\n            // but, if timestamp is still within minimumUpdateInterval's frontRunningInterval we need to go to the next one\\n            return\\n                timestamp + frontRunningInterval > timeOfNextAvailableInterval\\n                    ? minimumUpdateIntervalId + 1\\n                    : minimumUpdateIntervalId;\\n        }\\n    }\\n\\n    /**\\n     * @notice Gets the number of settlement tokens to be withdrawn based on a pool token burn amount\\n     * @dev Calculates as `balance * amountIn / (tokenSupply + shadowBalance)\\n     * @param tokenSupply Total supply of pool tokens\\n     * @param amountIn Commitment amount of pool tokens going into the pool\\n     * @param balance Balance of the pool (no. of underlying collateral tokens in pool)\\n     * @param shadowBalance Balance the shadow pool at time of mint\\n     * @return Number of settlement tokens to be withdrawn on a burn\\n     */\\n    function getWithdrawAmountOnBurn(\\n        uint256 tokenSupply,\\n        uint256 amountIn,\\n        uint256 balance,\\n        uint256 shadowBalance\\n    ) external pure returns (uint256) {\\n        // Catch the divide by zero error, or return 0 if amountIn is 0\\n        if ((balance == 0) || (tokenSupply + shadowBalance == 0) || (amountIn == 0)) {\\n            return amountIn;\\n        }\\n        bytes16 numerator = ABDKMathQuad.mul(ABDKMathQuad.fromUInt(balance), ABDKMathQuad.fromUInt(amountIn));\\n        return ABDKMathQuad.toUInt(ABDKMathQuad.div(numerator, ABDKMathQuad.fromUInt(tokenSupply + shadowBalance)));\\n    }\\n\\n    /**\\n     * @notice Gets the number of pool tokens to be minted based on existing tokens\\n     * @dev Calculated as (tokenSupply + shadowBalance) * amountIn / balance\\n     * @param tokenSupply Total supply of pool tokens\\n     * @param amountIn Commitment amount of collateral tokens going into the pool\\n     * @param balance Balance of the pool (no. of underlying collateral tokens in pool)\\n     * @param shadowBalance Balance the shadow pool at time of mint\\n     * @return Number of pool tokens to be minted\\n     */\\n    function getMintAmount(\\n        uint256 tokenSupply,\\n        uint256 amountIn,\\n        uint256 balance,\\n        uint256 shadowBalance\\n    ) external pure returns (uint256) {\\n        // Catch the divide by zero error, or return 0 if amountIn is 0\\n        if (balance == 0 || tokenSupply + shadowBalance == 0 || amountIn == 0) {\\n            return amountIn;\\n        }\\n\\n        bytes16 numerator = ABDKMathQuad.mul(\\n            ABDKMathQuad.fromUInt(tokenSupply + shadowBalance),\\n            ABDKMathQuad.fromUInt(amountIn)\\n        );\\n        return ABDKMathQuad.toUInt(ABDKMathQuad.div(numerator, ABDKMathQuad.fromUInt(balance)));\\n    }\\n\\n    /**\\n     * @notice Get the Settlement/PoolToken price, in ABDK IEE754 precision\\n     * @dev Divide the side balance by the pool token's total supply\\n     * @param sideBalance no. of underlying collateral tokens on that side of the pool\\n     * @param tokenSupply Total supply of pool tokens\\n     */\\n    function getPrice(uint256 sideBalance, uint256 tokenSupply) external pure returns (bytes16) {\\n        if (tokenSupply == 0) {\\n            return one;\\n        }\\n        return ABDKMathQuad.div(ABDKMathQuad.fromUInt(sideBalance), ABDKMathQuad.fromUInt(tokenSupply));\\n    }\\n\\n    /**\\n     * @notice Calculates the number of pool tokens to mint, given some settlement token amount and a price\\n     * @param price Price of a pool token\\n     * @param amount Amount of settlement tokens being used to mint\\n     * @return Quantity of pool tokens to mint\\n     * @dev Throws if price is zero\\n     * @dev `getBurn()`\\n     */\\n    function getMint(bytes16 price, uint256 amount) public pure returns (uint256) {\\n        require(price != 0, \\\"price == 0\\\");\\n        return ABDKMathQuad.toUInt(ABDKMathQuad.div(ABDKMathQuad.fromUInt(amount), price));\\n    }\\n\\n    /**\\n     * @notice Calculate the number of settlement tokens to burn, based on a price and an amount of pool tokens\\n     * @param price Price of a pool token\\n     * @param amount Amount of settlement tokens being used to burn\\n     * @return Quantity of pool tokens to burn\\n     * @dev amount * price, where amount is in PoolToken and price is in USD/PoolToken\\n     * @dev Throws if price is zero\\n     * @dev `getMint()`\\n     */\\n    function getBurn(bytes16 price, uint256 amount) public pure returns (uint256) {\\n        require(price != 0, \\\"price == 0\\\");\\n        return ABDKMathQuad.toUInt(ABDKMathQuad.mul(ABDKMathQuad.fromUInt(amount), price));\\n    }\\n\\n    /**\\n     * @notice Calculate the number of pool tokens to mint, given some settlement token amount, a price, and a burn amount from other side for instant mint\\n     * @param price The price of a pool token\\n     * @param amount The amount of settlement tokens being used to mint\\n     * @param oppositePrice The price of the opposite side's pool token\\n     * @param amountBurnedInstantMint The amount of pool tokens that were burnt from the opposite side for an instant mint in this side\\n     * @return Quantity of pool tokens to mint\\n     * @dev Throws if price is zero\\n     */\\n    function getMintWithBurns(\\n        bytes16 price,\\n        bytes16 oppositePrice,\\n        uint256 amount,\\n        uint256 amountBurnedInstantMint\\n    ) public pure returns (uint256) {\\n        require(price != 0, \\\"price == 0\\\");\\n        if (amountBurnedInstantMint > 0) {\\n            // Calculate amount of settlement tokens generated from the burn.\\n            amount += getBurn(oppositePrice, amountBurnedInstantMint);\\n        }\\n        return getMint(price, amount);\\n    }\\n\\n    /**\\n     * @notice Converts from a WAD to normal value\\n     * @param _wadValue wad number\\n     * @param _decimals Quantity of decimal places to support\\n     * @return Converted (non-WAD) value\\n     */\\n    function fromWad(uint256 _wadValue, uint256 _decimals) external pure returns (uint256) {\\n        uint256 scaler = 10**(MAX_DECIMALS - _decimals);\\n        return _wadValue / scaler;\\n    }\\n\\n    /**\\n     * @notice Calculate the change in a user's balance based on recent commit(s)\\n     * @param data Information needed for updating the balance including prices and recent commit amounts\\n     * @return _newLongTokens Quantity of additional long tokens the user would receive\\n     * @return _newShortTokens Quantity of additional short tokens the user would receive\\n     * @return _longBurnFee Quantity of settlement tokens taken as a fee from long burns\\n     * @return _shortBurnFee Quantity of settlement tokens taken as a fee from short burns\\n     * @return _newSettlementTokens Quantity of additional settlement tokens the user would receive\\n     */\\n    function getUpdatedAggregateBalance(UpdateData calldata data)\\n        external\\n        pure\\n        returns (\\n            uint256 _newLongTokens,\\n            uint256 _newShortTokens,\\n            uint256 _longBurnFee,\\n            uint256 _shortBurnFee,\\n            uint256 _newSettlementTokens\\n        )\\n    {\\n        if (data.updateIntervalId == data.currentUpdateIntervalId) {\\n            // Update interval has not passed: No change\\n            return (0, 0, 0, 0, 0);\\n        }\\n        uint256 longBurnResult; // The amount of settlement tokens to withdraw based on long token burn\\n        uint256 shortBurnResult; // The amount of settlement tokens to withdraw based on short token burn\\n        if (data.longMintAmount > 0 || data.shortBurnLongMintAmount > 0) {\\n            _newLongTokens = getMintWithBurns(\\n                data.longPrice,\\n                data.shortPrice,\\n                data.longMintAmount,\\n                data.shortBurnLongMintAmount\\n            );\\n        }\\n\\n        if (data.longBurnAmount > 0) {\\n            // Calculate the amount of settlement tokens earned from burning long tokens\\n            longBurnResult = getBurn(data.longPrice, data.longBurnAmount);\\n            // Calculate the fee\\n            _longBurnFee = convertDecimalToUInt(multiplyDecimalByUInt(data.burnFee, longBurnResult)) / WAD_PRECISION;\\n            // Subtract the fee from settlement token amount\\n            longBurnResult -= _longBurnFee;\\n        }\\n\\n        if (data.shortMintAmount > 0 || data.longBurnShortMintAmount > 0) {\\n            _newShortTokens = getMintWithBurns(\\n                data.shortPrice,\\n                data.longPrice,\\n                data.shortMintAmount,\\n                data.longBurnShortMintAmount\\n            );\\n        }\\n\\n        if (data.shortBurnAmount > 0) {\\n            // Calculate the amount of settlement tokens earned from burning short tokens\\n            shortBurnResult = getBurn(data.shortPrice, data.shortBurnAmount);\\n            // Calculate the fee\\n            _shortBurnFee = convertDecimalToUInt(multiplyDecimalByUInt(data.burnFee, shortBurnResult)) / WAD_PRECISION;\\n            // Subtract the fee from settlement token amount\\n            shortBurnResult -= _shortBurnFee;\\n        }\\n\\n        _newSettlementTokens = shortBurnResult + longBurnResult;\\n    }\\n}\\n\",\"keccak256\":\"0xf804145c92e348fe1f92169040b01fbf5f97c9e2d60869d20811090dac402a70\",\"license\":\"CC-BY-NC-ND-4.0\"}},\"version\":1}",
  "bytecode": "0x61313261003a600b82828239805160001a60731461002d57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600436106101b35760003560e01c8063ab41556f11610103578063dc35bc13116100a1578063e45639451161007b578063e456394514610403578063fc31158114610416578063fea3de3314610429578063ff9afe871461043c57600080fd5b8063dc35bc13146103b5578063debb52df146103dd578063dfdbe4da146103f057600080fd5b8063bf36f0e9116100dd578063bf36f0e914610369578063c15172d21461037c578063c3ff80911461038f578063cff70001146103a257600080fd5b8063ab41556f14610330578063aeb64d7d14610343578063b6b2f9f61461035657600080fd5b80635cf4ee9111610170578063901717d11161014a578063901717d1146102a35780639eb17fa3146102af578063a481c1b4146102ea578063a818c0d21461031d57600080fd5b80635cf4ee911461025e578063664808a81461027157806381a799db1461028057600080fd5b80630417cf8e146101b85780630e8418dd146101d35780631842c9d8146101ff578063202f125714610225578063422051e71461023857806345e7ef9b1461024b575b600080fd5b6101c0601281565b6040519081526020015b60405180910390f35b6101e66101e1366004612d52565b61044f565b6040516001600160801b031990911681526020016101ca565b61021261020d366004612d52565b610464565b60405160009190910b81526020016101ca565b6101e6610233366004612e3c565b610470565b6101e6610246366004612e12565b61048c565b6101e6610259366004612d52565b6104a0565b6101e661026c366004612e3c565b6104ac565b6101c0670de0b6b3a764000081565b61029361028e366004612ece565b6104d4565b60405190151581526020016101ca565b6101e6613fff60f01b81565b6102c26102bd366004612e76565b6104f8565b604080519586526020860194909452928401919091526060830152608082015260a0016101ca565b6102fd6102f8366004612e5e565b6106ae565b6040805194855260208501939093529183015260608201526080016101ca565b6101c061032b366004612e12565b610817565b6101c061033e366004612ece565b61083c565b6101c0610351366004612d37565b6108a3565b6101e6610364366004612d52565b6108ae565b6101c0610377366004612e3c565b6108ba565b6101c061038a366004612d85565b6108df565b6101e661039d366004612dc7565b610941565b6101e66103b0366004612e3c565b610981565b6103c86103c3366004612ea2565b610990565b604080519283526020830191909152016101ca565b6101c06103eb366004612ece565b6109e9565b6101e66103fe366004612e89565b610a38565b6101c0610411366004612e12565b610a43565b6101c0610424366004612e12565b610a81565b6101c0610437366004612ea2565b610abf565b6101c061044a366004612f00565b610b01565b600061045b8383610bec565b90505b92915050565b600061045b8383610bfe565b600061045b61047e84610d25565b61048784610d25565b610db8565b600061045b8361049b8461106f565b6110d3565b600061045b83836110d3565b6000816104bf5750613fff60f01b61045e565b61045b6104cb8461106f565b6104878461106f565b600084826104e28587612f5f565b6104ec91906130a3565b1190505b949350505050565b6000806000806000856040013586606001351415610524575060009350839250829150819050806106a5565b60008060008860800135118061053f57506000886101200135115b156105775761057461055460208a018a612d37565b61056460408b0160208c01612d37565b8a608001358b61012001356108df565b96505b60a0880135156105dd5761059b61059160208a018a612d37565b8960a00135610a81565b9150670de0b6b3a76400006105c46103516105be6101608c016101408d01612d37565b8561048c565b6105ce9190612f77565b94506105da85836130a3565b91505b60008860c0013511806105f557506000886101000135115b1561062d5761062a61060d60408a0160208b01612d37565b61061a60208b018b612d37565b8a60c001358b61010001356108df565b95505b60e0880135156106965761065461064a60408a0160208b01612d37565b8960e00135610a81565b9050670de0b6b3a764000061067d6103516106776101608c016101408d01612d37565b8461048c565b6106879190612f77565b935061069384826130a3565b90505b6106a08282612f5f565b925050505b91939590929450565b600080808060608501356040860135826106ce60a0890160808a01612d37565b90508735602089013560006106e960c08c0160a08d01612d37565b90506000670de0b6b3a7640000610703610351848961048c565b61070d9190612f77565b90506000670de0b6b3a7640000610727610351858b61048c565b6107319190612f77565b905061073d81896130a3565b975061074982886130a3565b965060006107578587610470565b9050600061076a82613fff60f01b610464565b9050600061077983838b610941565b905060008260000b1215801561078f575060008b115b156107c05760006107a0828d610817565b90506107ac818d6130a3565b9b506107b8818c612f5f565b9a5050610800565b60008260000b1280156107d3575060008a115b156108005760006107e4828c610817565b90506107f0818d612f5f565b9b506107fc818c6130a3565b9a50505b50979e989d50919b50995095975050505050505050565b600061045b61083761082e613fff60f01b86610bec565b61049b8561106f565b61132e565b600082158061085257506108508286612f5f565b155b8061085b575083155b156108675750826104f0565b600061088761087e6108798589612f5f565b61106f565b61049b8761106f565b9050610899610837826104878761106f565b9695505050505050565b600061045e8261132e565b600061045b83836113b1565b6000806108c88360126130a3565b6108d390600a612fdc565b90506104f08185612f77565b60006001600160801b031985166109115760405162461bcd60e51b815260040161090890612f3b565b60405180910390fd5b811561092e576109218483610a81565b61092b9084612f5f565b92505b6109388584610a43565b95945050505050565b60006109776109728361049b60008760000b1261096c57610967613fff60f01b89610db8565b611771565b87611771565b611921565b90505b9392505050565b6000816104bf5750600061045e565b600080806109a2856103b08682612f5f565b905060006109b3610351838961048c565b905060006109c182886130a3565b905060006109cf838a6130a3565b6109d990886130a3565b9199919850909650505050505050565b60008215806109ff57506109fd8286612f5f565b155b80610a08575083155b15610a145750826104f0565b6000610a2261087e8561106f565b905061089961083782610487610879878b612f5f565b600061045e8261106f565b60006001600160801b03198316610a6c5760405162461bcd60e51b815260040161090890612f3b565b61045b610837610a7b8461106f565b85610db8565b60006001600160801b03198316610aaa5760405162461bcd60e51b815260040161090890612f3b565b61045b610837610ab98461106f565b856110d3565b600081610ace5750600061097a565b6000610ae5610adc8661106f565b61049b8661106f565b90506000610af6826104878661106f565b9050610899816108a3565b600084861015610b4b5760405162461bcd60e51b81526020600482015260156024820152741d1a5b595cdd185b5c081a5b881d1a19481c185cdd605a1b6044820152606401610908565b828411610b7c57610b5e868685876104d4565b15610b6a575080610938565b610b75826001612f5f565b9050610938565b6000610b8b6108378686612c73565b90506000610b9a826001612f5f565b610ba49086613084565b610bae9088612f5f565b90506000610bbc8386612f5f565b905081610bc9888b612f5f565b11610bd45780610bdf565b610bdf816001612f5f565b9998505050505050505050565b600061045b83600160ff1b84186113b1565b600060016001607f1b03608084901c16617fff60701b811115610c2057600080fd5b60016001607f1b03608084901c16617fff60701b811115610c4057600080fd5b6001600160801b0319858116908516141580610c695750617fff60701b826001600160801b0316105b610c7257600080fd5b6001600160801b03198581169085161415610c925760009250505061045e565b6001607f1b608086811c82118015929187901c919091101590610ce4578015610cd557826001600160801b0316846001600160801b031611610cd5576001610cd9565b6000195b94505050505061045e565b8015610cf757600194505050505061045e565b826001600160801b0316846001600160801b031611610d1857600019610cd9565b600194505050505061045e565b600081610d3457506000919050565b6000808313610d465782600003610d48565b825b90506000610d5582612c81565b90506070811015610d6e578060700382901b9150610d81565b6070811115610d81576070810382901c91505b6001600160701b03909116613fff820160701b17906000841215610da9576001607f1b821791505b5060801b92915050565b919050565b6000617fff60f084811c8216919084901c811690821415610dfe5780617fff1415610ded575061ffff60ef1b915061045e9050565b505050600160ff1b8116821861045e565b80617fff1415610e42576dffffffffffffffffffffffffffff60801b841615610e31575061ffff60ef1b915061045e9050565b505050808218600160ff1b1661045e565b600160801b600160ff1b038416610e8c57600160801b600160ff1b038516610e74575061ffff60ef1b915061045e9050565b505050808218600160ff1b16617fff60f01b1761045e565b6001600160701b03608085901c1681610ea85760019150610eaf565b600160701b175b6001600160701b03608087901c1683610eee578015610ee9576000610ed382612c81565b6001955060e20393840160711901939190911b90505b610ef8565b600160701b1760721b5b818181610f0757610f076130e6565b04905080610f3357600160ff1b87871816610f23576000610cd9565b600160ff1b94505050505061045e565b6001606c1b811015610f4757610f476130ba565b6000600160731b821015610f8657600160721b821015610f7b57600160711b821015610f74576070610f7e565b6071610f7e565b60725b60ff16610f8f565b610f8f82612c81565b905083614071018186011115610fad57617fff945060009150611040565b83818601613ffc011015610fc8576000945060009150611040565b83818601613f8c011015611015578385613ffc011115610ff3578385613ffc010382901b915061100c565b8385613ffc01101561100c57613ffc8585030382901c91505b60009450611040565b6070811115611028576070810382901c91505b6001600160701b038216915083818601613f8d010394505b81607086901b888a186001607f1b60801b1660801c6001600160801b0316171760801b9550505050505061045e565b60008161107e57506000919050565b81600061108a82612c81565b905060708110156110a3578060700382901b91506110b6565b60708111156110b6576070810382901c91505b613fff0160701b6001600160701b03919091161760801b92915050565b6000617fff60f084811c8216919084901c8116908214156111725780617fff1415611151576001600160801b0319858116908516141561111e57505050600160ff1b8116821861045e565b600160ff1b6001600160801b03198686181614156111415750505081811761045e565b5061ffff60ef1b915061045e9050565b600160801b600160ff1b038416610ded575061ffff60ef1b915061045e9050565b80617fff14156111ae57600160801b600160ff1b03851661119d575061ffff60ef1b915061045e9050565b505050600160ff1b8216811861045e565b6001600160701b03608086901c16826111ca57600192506111d1565b600160701b175b6001600160701b03608086901c16826111ed57600192506111f4565b600160701b175b908102908161121157600160ff1b87871816610f23576000610cd9565b928201926000600160e11b83101561124457600160e01b83101561123d5761123883612c81565b611247565b60e0611247565b60e15b905061407081860110156112625760009450600092506112ff565b6140e081860110156112a55761407085101561128757846140700383901c925061129c565b61407085111561129c57614070850383901b92505b600094506112ff565b61c0dd81860111156112bf57617fff9450600092506112ff565b60708111156112d6576070810383901c92506112e9565b60708110156112e9578060700383901b92505b6001600160701b03831692506140df8186010394505b82607086901b888a186001607f1b60801b1660801c6001600160801b0316171760801b9550505050505061045e565b6000617fff60f083901c16613fff81101561134c5750600092915050565b6001607f1b608084901c1061136057600080fd5b6140fe81111561136f57600080fd5b600160701b6001600160701b03608085901c161761406f8210156113995761406f8290031c61097a565b61406f82111561097a5761406e1982011b9392505050565b6000617fff60f084811c8216919084901c8116908214156113ff5780617fff14156113f5576001600160801b0319858116908516141561114157849250505061045e565b849250505061045e565b80617fff141561141357839250505061045e565b6001607f1b608086901c90811015906001600160701b0316836114395760019350611440565b600160701b175b6001607f1b608087901c90811015906001600160701b031684611466576001945061146d565b600160701b175b8261149d576001600160801b03198816600160ff1b1461148d5787611490565b60005b965050505050505061045e565b806114bd576001600160801b03198916600160ff1b1461148d5788611490565b84860384151583151514156115c85760708113156114e4578997505050505050505061045e565b60008113156114f65790811c90611525565b606f1981121561150f578897505050505050505061045e565b6000811215611525578060000384901c93508596505b92810192600160711b8410611540576001968701969390931c925b86617fff1415611572578461155a57617fff60f01b611564565b6001600160f01b03195b97505050505050505061045e565b600160701b8410156115875760009650611594565b6001600160701b03841693505b83607088901b866115a65760006115ac565b6001607f1b5b6001600160801b0316171760801b97505050505050505061045e565b60008113156115e357600184901b93506001870396506115fa565b60008112156115fa57600182901b91506001860396505b607081131561160c5760019150611659565b6001811315611629576001810360018303901c6001019150611659565b606f1981121561163c5760019350611659565b600019811215611659576001816000030360018503901c60010193505b81841061166a578184039350611673565b83820393508294505b8361168957506000965061045e95505050505050565b600061169485612c81565b905080607114156116ba57600185901c6001600160701b03169450600188019750611709565b60708110156116fc576070819003808911156116e9578086901b6001600160701b0316955080890398506116f6565b600098600019019590951b945b50611709565b6001600160701b03851694505b87617fff141561173c578561172357617fff60f01b61172d565b6001600160f01b03195b9850505050505050505061045e565b84607089901b8761174e576000611754565b6001607f1b5b6001600160801b0316171760801b9850505050505050505061045e565b60006001607f1b608083901c111561178f575061ffff60ef1b919050565b613fff60f01b6001600160801b0319831614156117ae57506000919050565b617fff60f083901c8116908114156117c7575090919050565b6001600160701b03608084901c16816117e357600191506117ea565b600160701b175b8061180057506001600160f01b03199392505050565b600061406f81613fff85106118265750600f9290921b9160009150613ffe198401611865565b60019250600160701b84106118485784613ffe039050600f84901b9350611865565b600061185385612c81565b607f8190039590951b9461406d039150505b836001607f1b141561189957821561187b576001015b600061188682612c81565b60700392839003929190911b90506118e7565b6000836118a75760006118aa565b60015b60ff1690505b600160701b8210156118e55793800260ff81901c607f81019190911c94600019939093019260019290921b90821801906118b0565b505b806001600160701b0316607083901b84611902576000611908565b6001607f1b5b6001600160801b0316171760801b979650505050505050565b60006001607f1b608083901c90811190617fff60f085901c8116916001600160701b0316908214801561195357508015155b15611967575061ffff60ef1b949350505050565b61400d82111561198c578261198157617fff60f01b610938565b600095945050505050565b613f7f8210156119a55750613fff60f01b949350505050565b816119b357600191506119ba565b600160701b175b613fef8211156119d057613fee1982011b6119e2565b613fef8210156119e257613fef8290031c5b8280156119f3575061203760811b81115b15611a0357506000949350505050565b82158015611a225750713fffffffffffffffffffffffffffffffffff81115b15611a365750617fff60f01b949350505050565b6001600160801b0381169060801c838015611a5057508115155b15611a5c579019906001015b6001607f1b82811615611a805770016a09e667f3bcc908b2fb1366ea957d3e0260801c5b6001607e1b831615611aa3577001306fe0a31b7152de8d5a46305c85edec0260801c5b6001607d1b831615611ac6577001172b83c7d517adcdf7c8c50eb14a791f0260801c5b6001607c1b831615611ae95770010b5586cf9890f6298b92b71842a983630260801c5b6001607b1b831615611b0c577001059b0d31585743ae7c548eb68ca417fd0260801c5b6001607a1b831615611b2f57700102c9a3e778060ee6f7caca4f7a29bde80260801c5b600160791b831615611b525770010163da9fb33356d84a66ae336dcdfa3f0260801c5b600160781b831615611b7557700100b1afa5abcbed6129ab13ec11dc95430260801c5b600160771b831615611b985770010058c86da1c09ea1ff19d294cf2f679b0260801c5b600160761b831615611bbb577001002c605e2e8cec506d21bfc89a23a00f0260801c5b600160751b831615611bde57700100162f3904051fa128bca9c55c31e5df0260801c5b600160741b831615611c01577001000b175effdc76ba38e31671ca9397250260801c5b600160731b831615611c2457700100058ba01fb9f96d6cacd4b180917c3d0260801c5b600160721b831615611c475770010002c5cc37da9491d0985c348c68e7b30260801c5b600160711b831615611c6a577001000162e525ee054754457d59952920260260801c5b600160701b831615611c8d5770010000b17255775c040618bf4a4ade83fc0260801c5b6001606f1b831615611cb0577001000058b91b5bc9ae2eed81e9b7d4cfab0260801c5b6001606e1b831615611cd357700100002c5c89d5ec6ca4d7c8acc017b7c90260801c5b6001606d1b831615611cf65770010000162e43f4f831060e02d839a9d16d0260801c5b6001606c1b831615611d1957700100000b1721bcfc99d9f890ea069117630260801c5b6001606b1b831615611d3c5770010000058b90cf1e6d97f9ca14dbcc16280260801c5b6001606a1b831615611d5f577001000002c5c863b73f016468f6bac5ca2b0260801c5b600160691b831615611d8257700100000162e430e5a18f6119e3c02282a50260801c5b600160681b831615611da5577001000000b1721835514b86e6d96efd1bfe0260801c5b600160671b831615611dc857700100000058b90c0b48c6be5df846c5b2ef0260801c5b600160661b831615611deb5770010000002c5c8601cc6b9e94213c72737a0260801c5b600160651b831615611e0e577001000000162e42fff037df38aa2b219f060260801c5b600160641b831615611e315770010000000b17217fba9c739aa5819f44f90260801c5b600160631b831615611e54577001000000058b90bfcdee5acd3c1cedc8230260801c5b600160621b831615611e7757700100000002c5c85fe31f35a6a30da1be500260801c5b600160611b831615611e9a5770010000000162e42ff0999ce3541b9fffcf0260801c5b600160601b831615611ebd57700100000000b17217f80f4ef5aadda455540260801c5b6001605f1b831615611ee05770010000000058b90bfbf8479bd5a81b51ad0260801c5b6001605e1b831615611f03577001000000002c5c85fdf84bd62ae30a74cc0260801c5b6001605d1b831615611f2657700100000000162e42fefb2fed257559bdaa0260801c5b6001605c1b831615611f49577001000000000b17217f7d5a7716bba4a9ae0260801c5b6001605b1b831615611f6c57700100000000058b90bfbe9ddbac5e109cce0260801c5b6001605a1b831615611f8f5770010000000002c5c85fdf4b15de6f17eb0d0260801c5b600160591b831615611fb2577001000000000162e42fefa494f1478fde050260801c5b600160581b831615611fd55770010000000000b17217f7d20cf927c8e94c0260801c5b600160571b831615611ff8577001000000000058b90bfbe8f71cb4e4b33d0260801c5b600160561b83161561201b57700100000000002c5c85fdf477b662b269450260801c5b600160551b83161561203e5770010000000000162e42fefa3ae53369388c0260801c5b600160541b83161561206157700100000000000b17217f7d1d351a389d400260801c5b600160531b8316156120845770010000000000058b90bfbe8e8b2d3d4ede0260801c5b600160521b8316156120a7577001000000000002c5c85fdf4741bea6e77e0260801c5b600160511b8316156120ca57700100000000000162e42fefa39fe95583c20260801c5b600160501b8316156120ed577001000000000000b17217f7d1cfb72b45e10260801c5b698000000000000000000083161561211657700100000000000058b90bfbe8e7cc35c3f00260801c5b694000000000000000000083161561213f5770010000000000002c5c85fdf473e242ea380260801c5b6920000000000000000000831615612168577001000000000000162e42fefa39f02b772c0260801c5b69100000000000000000008316156121915770010000000000000b17217f7d1cf7d83c1a0260801c5b69080000000000000000008316156121ba577001000000000000058b90bfbe8e7bdcbe2e0260801c5b69040000000000000000008316156121e357700100000000000002c5c85fdf473dea871f0260801c5b690200000000000000000083161561220c5770010000000000000162e42fefa39ef44d910260801c5b690100000000000000000083161561223557700100000000000000b17217f7d1cf79e9490260801c5b6880000000000000000083161561225d5770010000000000000058b90bfbe8e7bce5440260801c5b68400000000000000000831615612285577001000000000000002c5c85fdf473de6eca0260801c5b682000000000000000008316156122ad57700100000000000000162e42fefa39ef366f0260801c5b681000000000000000008316156122d5577001000000000000000b17217f7d1cf79afa0260801c5b680800000000000000008316156122fd57700100000000000000058b90bfbe8e7bcd6d0260801c5b680400000000000000008316156123255770010000000000000002c5c85fdf473de6b20260801c5b6802000000000000000083161561234d577001000000000000000162e42fefa39ef3580260801c5b600160401b8316156123705770010000000000000000b17217f7d1cf79ab0260801c5b678000000000000000831615612397577001000000000000000058b90bfbe8e7bcd50260801c5b6740000000000000008316156123be57700100000000000000002c5c85fdf473de6a0260801c5b6720000000000000008316156123e55770010000000000000000162e42fefa39ef340260801c5b67100000000000000083161561240c57700100000000000000000b17217f7d1cf7990260801c5b6708000000000000008316156124335770010000000000000000058b90bfbe8e7bcc0260801c5b67040000000000000083161561245a577001000000000000000002c5c85fdf473de50260801c5b67020000000000000083161561248157700100000000000000000162e42fefa39ef20260801c5b6701000000000000008316156124a8577001000000000000000000b17217f7d1cf780260801c5b66800000000000008316156124ce57700100000000000000000058b90bfbe8e7bb0260801c5b66400000000000008316156124f45770010000000000000000002c5c85fdf473dd0260801c5b662000000000000083161561251a577001000000000000000000162e42fefa39ee0260801c5b66100000000000008316156125405770010000000000000000000b17217f7d1cf60260801c5b6608000000000000831615612566577001000000000000000000058b90bfbe8e7a0260801c5b660400000000000083161561258c57700100000000000000000002c5c85fdf473c0260801c5b66020000000000008316156125b25770010000000000000000000162e42fefa39d0260801c5b66010000000000008316156125d857700100000000000000000000b17217f7d1ce0260801c5b658000000000008316156125fd5770010000000000000000000058b90bfbe8e60260801c5b65400000000000831615612622577001000000000000000000002c5c85fdf4720260801c5b6520000000000083161561264757700100000000000000000000162e42fefa380260801c5b6510000000000083161561266c577001000000000000000000000b17217f7d1b0260801c5b6508000000000083161561269157700100000000000000000000058b90bfbe8d0260801c5b650400000000008316156126b65770010000000000000000000002c5c85fdf460260801c5b650200000000008316156126db577001000000000000000000000162e42fefa20260801c5b650100000000008316156127005770010000000000000000000000b17217f7d00260801c5b648000000000831615612724577001000000000000000000000058b90bfbe70260801c5b64400000000083161561274857700100000000000000000000002c5c85fdf30260801c5b64200000000083161561276c5770010000000000000000000000162e42fef90260801c5b64100000000083161561279057700100000000000000000000000b17217f7c0260801c5b6408000000008316156127b45770010000000000000000000000058b90bfbd0260801c5b6404000000008316156127d8577001000000000000000000000002c5c85fde0260801c5b6402000000008316156127fc57700100000000000000000000000162e42fee0260801c5b640100000000831615612820577001000000000000000000000000b17217f60260801c5b638000000083161561284357700100000000000000000000000058b90bfa0260801c5b63400000008316156128665770010000000000000000000000002c5c85fc0260801c5b6320000000831615612889577001000000000000000000000000162e42fd0260801c5b63100000008316156128ac5770010000000000000000000000000b17217e0260801c5b63080000008316156128cf577001000000000000000000000000058b90be0260801c5b63040000008316156128f257700100000000000000000000000002c5c85e0260801c5b63020000008316156129155770010000000000000000000000000162e42e0260801c5b630100000083161561293857700100000000000000000000000000b172160260801c5b6280000083161561295a5770010000000000000000000000000058b90a0260801c5b6240000083161561297c577001000000000000000000000000002c5c840260801c5b6220000083161561299e57700100000000000000000000000000162e410260801c5b621000008316156129c0577001000000000000000000000000000b17200260801c5b620800008316156129e257700100000000000000000000000000058b8f0260801c5b62040000831615612a045770010000000000000000000000000002c5c70260801c5b62020000831615612a26577001000000000000000000000000000162e30260801c5b62010000831615612a485770010000000000000000000000000000b1710260801c5b618000831615612a69577001000000000000000000000000000058b80260801c5b614000831615612a8a57700100000000000000000000000000002c5b0260801c5b612000831615612aab5770010000000000000000000000000000162d0260801c5b611000831615612acc57700100000000000000000000000000000b160260801c5b610800831615612aed5770010000000000000000000000000000058a0260801c5b610400831615612b0e577001000000000000000000000000000002c40260801c5b610200831615612b2f577001000000000000000000000000000001610260801c5b610100831615612b50577001000000000000000000000000000000b00260801c5b6080831615612b70577001000000000000000000000000000000570260801c5b6040831615612b905770010000000000000000000000000000002b0260801c5b6020831615612bb0577001000000000000000000000000000000150260801c5b6010831615612bd05770010000000000000000000000000000000a0260801c5b6008831615612bf0577001000000000000000000000000000000040260801c5b6004831615612c10577001000000000000000000000000000000010260801c5b84612c3157600f81901c6001600160701b03169050613fff82019150612c60565b613ffe8211612c5657600f81901c6001600160701b0316905081613fff039150612c60565b600091613fee19011c5b60709190911b1760801b95945050505050565b600061045b6104cb8461106f565b6000808211612c8f57600080fd5b6000600160801b8310612ca457608092831c92015b600160401b8310612cb757604092831c92015b6401000000008310612ccb57602092831c92015b620100008310612cdd57601092831c92015b6101008310612cee57600892831c92015b60108310612cfe57600492831c92015b60048310612d0e57600292831c92015b6002831061045e5760010192915050565b80356001600160801b031981168114610db357600080fd5b600060208284031215612d4957600080fd5b61045b82612d1f565b60008060408385031215612d6557600080fd5b612d6e83612d1f565b9150612d7c60208401612d1f565b90509250929050565b60008060008060808587031215612d9b57600080fd5b612da485612d1f565b9350612db260208601612d1f565b93969395505050506040820135916060013590565b600080600060608486031215612ddc57600080fd5b612de584612d1f565b925060208401358060000b8114612dfb57600080fd5b9150612e0960408501612d1f565b90509250925092565b60008060408385031215612e2557600080fd5b612e2e83612d1f565b946020939093013593505050565b60008060408385031215612e4f57600080fd5b50508035926020909101359150565b600060c08284031215612e7057600080fd5b50919050565b60006101608284031215612e7057600080fd5b600060208284031215612e9b57600080fd5b5035919050565b600080600060608486031215612eb757600080fd5b505081359360208301359350604090920135919050565b60008060008060808587031215612ee457600080fd5b5050823594602084013594506040840135936060013592509050565b600080600080600060a08688031215612f1857600080fd5b505083359560208501359550604085013594606081013594506080013592509050565b6020808252600a908201526907072696365203d3d20360b41b604082015260600190565b60008219821115612f7257612f726130d0565b500190565b600082612f9457634e487b7160e01b600052601260045260246000fd5b500490565b600181815b80851115612fd4578160001904821115612fba57612fba6130d0565b80851615612fc757918102915b93841c9390800290612f9e565b509250929050565b600061045b8383600082612ff25750600161045e565b81612fff5750600061045e565b8160018114613015576002811461301f5761303b565b600191505061045e565b60ff841115613030576130306130d0565b50506001821b61045e565b5060208310610133831016604e8410600b841016171561305e575081810a61045e565b6130688383612f99565b806000190482111561307c5761307c6130d0565b029392505050565b600081600019048311821515161561309e5761309e6130d0565b500290565b6000828210156130b5576130b56130d0565b500390565b634e487b7160e01b600052600160045260246000fd5b634e487b7160e01b600052601160045260246000fd5b634e487b7160e01b600052601260045260246000fdfea264697066735822122079f7b3bf65e185ddca2de57448c2f40de42cf68d49c018aaeb14ee4e1432408b64736f6c63430008070033",
  "deployedBytecode": "0x73000000000000000000000000000000000000000030146080604052600436106101b35760003560e01c8063ab41556f11610103578063dc35bc13116100a1578063e45639451161007b578063e456394514610403578063fc31158114610416578063fea3de3314610429578063ff9afe871461043c57600080fd5b8063dc35bc13146103b5578063debb52df146103dd578063dfdbe4da146103f057600080fd5b8063bf36f0e9116100dd578063bf36f0e914610369578063c15172d21461037c578063c3ff80911461038f578063cff70001146103a257600080fd5b8063ab41556f14610330578063aeb64d7d14610343578063b6b2f9f61461035657600080fd5b80635cf4ee9111610170578063901717d11161014a578063901717d1146102a35780639eb17fa3146102af578063a481c1b4146102ea578063a818c0d21461031d57600080fd5b80635cf4ee911461025e578063664808a81461027157806381a799db1461028057600080fd5b80630417cf8e146101b85780630e8418dd146101d35780631842c9d8146101ff578063202f125714610225578063422051e71461023857806345e7ef9b1461024b575b600080fd5b6101c0601281565b6040519081526020015b60405180910390f35b6101e66101e1366004612d52565b61044f565b6040516001600160801b031990911681526020016101ca565b61021261020d366004612d52565b610464565b60405160009190910b81526020016101ca565b6101e6610233366004612e3c565b610470565b6101e6610246366004612e12565b61048c565b6101e6610259366004612d52565b6104a0565b6101e661026c366004612e3c565b6104ac565b6101c0670de0b6b3a764000081565b61029361028e366004612ece565b6104d4565b60405190151581526020016101ca565b6101e6613fff60f01b81565b6102c26102bd366004612e76565b6104f8565b604080519586526020860194909452928401919091526060830152608082015260a0016101ca565b6102fd6102f8366004612e5e565b6106ae565b6040805194855260208501939093529183015260608201526080016101ca565b6101c061032b366004612e12565b610817565b6101c061033e366004612ece565b61083c565b6101c0610351366004612d37565b6108a3565b6101e6610364366004612d52565b6108ae565b6101c0610377366004612e3c565b6108ba565b6101c061038a366004612d85565b6108df565b6101e661039d366004612dc7565b610941565b6101e66103b0366004612e3c565b610981565b6103c86103c3366004612ea2565b610990565b604080519283526020830191909152016101ca565b6101c06103eb366004612ece565b6109e9565b6101e66103fe366004612e89565b610a38565b6101c0610411366004612e12565b610a43565b6101c0610424366004612e12565b610a81565b6101c0610437366004612ea2565b610abf565b6101c061044a366004612f00565b610b01565b600061045b8383610bec565b90505b92915050565b600061045b8383610bfe565b600061045b61047e84610d25565b61048784610d25565b610db8565b600061045b8361049b8461106f565b6110d3565b600061045b83836110d3565b6000816104bf5750613fff60f01b61045e565b61045b6104cb8461106f565b6104878461106f565b600084826104e28587612f5f565b6104ec91906130a3565b1190505b949350505050565b6000806000806000856040013586606001351415610524575060009350839250829150819050806106a5565b60008060008860800135118061053f57506000886101200135115b156105775761057461055460208a018a612d37565b61056460408b0160208c01612d37565b8a608001358b61012001356108df565b96505b60a0880135156105dd5761059b61059160208a018a612d37565b8960a00135610a81565b9150670de0b6b3a76400006105c46103516105be6101608c016101408d01612d37565b8561048c565b6105ce9190612f77565b94506105da85836130a3565b91505b60008860c0013511806105f557506000886101000135115b1561062d5761062a61060d60408a0160208b01612d37565b61061a60208b018b612d37565b8a60c001358b61010001356108df565b95505b60e0880135156106965761065461064a60408a0160208b01612d37565b8960e00135610a81565b9050670de0b6b3a764000061067d6103516106776101608c016101408d01612d37565b8461048c565b6106879190612f77565b935061069384826130a3565b90505b6106a08282612f5f565b925050505b91939590929450565b600080808060608501356040860135826106ce60a0890160808a01612d37565b90508735602089013560006106e960c08c0160a08d01612d37565b90506000670de0b6b3a7640000610703610351848961048c565b61070d9190612f77565b90506000670de0b6b3a7640000610727610351858b61048c565b6107319190612f77565b905061073d81896130a3565b975061074982886130a3565b965060006107578587610470565b9050600061076a82613fff60f01b610464565b9050600061077983838b610941565b905060008260000b1215801561078f575060008b115b156107c05760006107a0828d610817565b90506107ac818d6130a3565b9b506107b8818c612f5f565b9a5050610800565b60008260000b1280156107d3575060008a115b156108005760006107e4828c610817565b90506107f0818d612f5f565b9b506107fc818c6130a3565b9a50505b50979e989d50919b50995095975050505050505050565b600061045b61083761082e613fff60f01b86610bec565b61049b8561106f565b61132e565b600082158061085257506108508286612f5f565b155b8061085b575083155b156108675750826104f0565b600061088761087e6108798589612f5f565b61106f565b61049b8761106f565b9050610899610837826104878761106f565b9695505050505050565b600061045e8261132e565b600061045b83836113b1565b6000806108c88360126130a3565b6108d390600a612fdc565b90506104f08185612f77565b60006001600160801b031985166109115760405162461bcd60e51b815260040161090890612f3b565b60405180910390fd5b811561092e576109218483610a81565b61092b9084612f5f565b92505b6109388584610a43565b95945050505050565b60006109776109728361049b60008760000b1261096c57610967613fff60f01b89610db8565b611771565b87611771565b611921565b90505b9392505050565b6000816104bf5750600061045e565b600080806109a2856103b08682612f5f565b905060006109b3610351838961048c565b905060006109c182886130a3565b905060006109cf838a6130a3565b6109d990886130a3565b9199919850909650505050505050565b60008215806109ff57506109fd8286612f5f565b155b80610a08575083155b15610a145750826104f0565b6000610a2261087e8561106f565b905061089961083782610487610879878b612f5f565b600061045e8261106f565b60006001600160801b03198316610a6c5760405162461bcd60e51b815260040161090890612f3b565b61045b610837610a7b8461106f565b85610db8565b60006001600160801b03198316610aaa5760405162461bcd60e51b815260040161090890612f3b565b61045b610837610ab98461106f565b856110d3565b600081610ace5750600061097a565b6000610ae5610adc8661106f565b61049b8661106f565b90506000610af6826104878661106f565b9050610899816108a3565b600084861015610b4b5760405162461bcd60e51b81526020600482015260156024820152741d1a5b595cdd185b5c081a5b881d1a19481c185cdd605a1b6044820152606401610908565b828411610b7c57610b5e868685876104d4565b15610b6a575080610938565b610b75826001612f5f565b9050610938565b6000610b8b6108378686612c73565b90506000610b9a826001612f5f565b610ba49086613084565b610bae9088612f5f565b90506000610bbc8386612f5f565b905081610bc9888b612f5f565b11610bd45780610bdf565b610bdf816001612f5f565b9998505050505050505050565b600061045b83600160ff1b84186113b1565b600060016001607f1b03608084901c16617fff60701b811115610c2057600080fd5b60016001607f1b03608084901c16617fff60701b811115610c4057600080fd5b6001600160801b0319858116908516141580610c695750617fff60701b826001600160801b0316105b610c7257600080fd5b6001600160801b03198581169085161415610c925760009250505061045e565b6001607f1b608086811c82118015929187901c919091101590610ce4578015610cd557826001600160801b0316846001600160801b031611610cd5576001610cd9565b6000195b94505050505061045e565b8015610cf757600194505050505061045e565b826001600160801b0316846001600160801b031611610d1857600019610cd9565b600194505050505061045e565b600081610d3457506000919050565b6000808313610d465782600003610d48565b825b90506000610d5582612c81565b90506070811015610d6e578060700382901b9150610d81565b6070811115610d81576070810382901c91505b6001600160701b03909116613fff820160701b17906000841215610da9576001607f1b821791505b5060801b92915050565b919050565b6000617fff60f084811c8216919084901c811690821415610dfe5780617fff1415610ded575061ffff60ef1b915061045e9050565b505050600160ff1b8116821861045e565b80617fff1415610e42576dffffffffffffffffffffffffffff60801b841615610e31575061ffff60ef1b915061045e9050565b505050808218600160ff1b1661045e565b600160801b600160ff1b038416610e8c57600160801b600160ff1b038516610e74575061ffff60ef1b915061045e9050565b505050808218600160ff1b16617fff60f01b1761045e565b6001600160701b03608085901c1681610ea85760019150610eaf565b600160701b175b6001600160701b03608087901c1683610eee578015610ee9576000610ed382612c81565b6001955060e20393840160711901939190911b90505b610ef8565b600160701b1760721b5b818181610f0757610f076130e6565b04905080610f3357600160ff1b87871816610f23576000610cd9565b600160ff1b94505050505061045e565b6001606c1b811015610f4757610f476130ba565b6000600160731b821015610f8657600160721b821015610f7b57600160711b821015610f74576070610f7e565b6071610f7e565b60725b60ff16610f8f565b610f8f82612c81565b905083614071018186011115610fad57617fff945060009150611040565b83818601613ffc011015610fc8576000945060009150611040565b83818601613f8c011015611015578385613ffc011115610ff3578385613ffc010382901b915061100c565b8385613ffc01101561100c57613ffc8585030382901c91505b60009450611040565b6070811115611028576070810382901c91505b6001600160701b038216915083818601613f8d010394505b81607086901b888a186001607f1b60801b1660801c6001600160801b0316171760801b9550505050505061045e565b60008161107e57506000919050565b81600061108a82612c81565b905060708110156110a3578060700382901b91506110b6565b60708111156110b6576070810382901c91505b613fff0160701b6001600160701b03919091161760801b92915050565b6000617fff60f084811c8216919084901c8116908214156111725780617fff1415611151576001600160801b0319858116908516141561111e57505050600160ff1b8116821861045e565b600160ff1b6001600160801b03198686181614156111415750505081811761045e565b5061ffff60ef1b915061045e9050565b600160801b600160ff1b038416610ded575061ffff60ef1b915061045e9050565b80617fff14156111ae57600160801b600160ff1b03851661119d575061ffff60ef1b915061045e9050565b505050600160ff1b8216811861045e565b6001600160701b03608086901c16826111ca57600192506111d1565b600160701b175b6001600160701b03608086901c16826111ed57600192506111f4565b600160701b175b908102908161121157600160ff1b87871816610f23576000610cd9565b928201926000600160e11b83101561124457600160e01b83101561123d5761123883612c81565b611247565b60e0611247565b60e15b905061407081860110156112625760009450600092506112ff565b6140e081860110156112a55761407085101561128757846140700383901c925061129c565b61407085111561129c57614070850383901b92505b600094506112ff565b61c0dd81860111156112bf57617fff9450600092506112ff565b60708111156112d6576070810383901c92506112e9565b60708110156112e9578060700383901b92505b6001600160701b03831692506140df8186010394505b82607086901b888a186001607f1b60801b1660801c6001600160801b0316171760801b9550505050505061045e565b6000617fff60f083901c16613fff81101561134c5750600092915050565b6001607f1b608084901c1061136057600080fd5b6140fe81111561136f57600080fd5b600160701b6001600160701b03608085901c161761406f8210156113995761406f8290031c61097a565b61406f82111561097a5761406e1982011b9392505050565b6000617fff60f084811c8216919084901c8116908214156113ff5780617fff14156113f5576001600160801b0319858116908516141561114157849250505061045e565b849250505061045e565b80617fff141561141357839250505061045e565b6001607f1b608086901c90811015906001600160701b0316836114395760019350611440565b600160701b175b6001607f1b608087901c90811015906001600160701b031684611466576001945061146d565b600160701b175b8261149d576001600160801b03198816600160ff1b1461148d5787611490565b60005b965050505050505061045e565b806114bd576001600160801b03198916600160ff1b1461148d5788611490565b84860384151583151514156115c85760708113156114e4578997505050505050505061045e565b60008113156114f65790811c90611525565b606f1981121561150f578897505050505050505061045e565b6000811215611525578060000384901c93508596505b92810192600160711b8410611540576001968701969390931c925b86617fff1415611572578461155a57617fff60f01b611564565b6001600160f01b03195b97505050505050505061045e565b600160701b8410156115875760009650611594565b6001600160701b03841693505b83607088901b866115a65760006115ac565b6001607f1b5b6001600160801b0316171760801b97505050505050505061045e565b60008113156115e357600184901b93506001870396506115fa565b60008112156115fa57600182901b91506001860396505b607081131561160c5760019150611659565b6001811315611629576001810360018303901c6001019150611659565b606f1981121561163c5760019350611659565b600019811215611659576001816000030360018503901c60010193505b81841061166a578184039350611673565b83820393508294505b8361168957506000965061045e95505050505050565b600061169485612c81565b905080607114156116ba57600185901c6001600160701b03169450600188019750611709565b60708110156116fc576070819003808911156116e9578086901b6001600160701b0316955080890398506116f6565b600098600019019590951b945b50611709565b6001600160701b03851694505b87617fff141561173c578561172357617fff60f01b61172d565b6001600160f01b03195b9850505050505050505061045e565b84607089901b8761174e576000611754565b6001607f1b5b6001600160801b0316171760801b9850505050505050505061045e565b60006001607f1b608083901c111561178f575061ffff60ef1b919050565b613fff60f01b6001600160801b0319831614156117ae57506000919050565b617fff60f083901c8116908114156117c7575090919050565b6001600160701b03608084901c16816117e357600191506117ea565b600160701b175b8061180057506001600160f01b03199392505050565b600061406f81613fff85106118265750600f9290921b9160009150613ffe198401611865565b60019250600160701b84106118485784613ffe039050600f84901b9350611865565b600061185385612c81565b607f8190039590951b9461406d039150505b836001607f1b141561189957821561187b576001015b600061188682612c81565b60700392839003929190911b90506118e7565b6000836118a75760006118aa565b60015b60ff1690505b600160701b8210156118e55793800260ff81901c607f81019190911c94600019939093019260019290921b90821801906118b0565b505b806001600160701b0316607083901b84611902576000611908565b6001607f1b5b6001600160801b0316171760801b979650505050505050565b60006001607f1b608083901c90811190617fff60f085901c8116916001600160701b0316908214801561195357508015155b15611967575061ffff60ef1b949350505050565b61400d82111561198c578261198157617fff60f01b610938565b600095945050505050565b613f7f8210156119a55750613fff60f01b949350505050565b816119b357600191506119ba565b600160701b175b613fef8211156119d057613fee1982011b6119e2565b613fef8210156119e257613fef8290031c5b8280156119f3575061203760811b81115b15611a0357506000949350505050565b82158015611a225750713fffffffffffffffffffffffffffffffffff81115b15611a365750617fff60f01b949350505050565b6001600160801b0381169060801c838015611a5057508115155b15611a5c579019906001015b6001607f1b82811615611a805770016a09e667f3bcc908b2fb1366ea957d3e0260801c5b6001607e1b831615611aa3577001306fe0a31b7152de8d5a46305c85edec0260801c5b6001607d1b831615611ac6577001172b83c7d517adcdf7c8c50eb14a791f0260801c5b6001607c1b831615611ae95770010b5586cf9890f6298b92b71842a983630260801c5b6001607b1b831615611b0c577001059b0d31585743ae7c548eb68ca417fd0260801c5b6001607a1b831615611b2f57700102c9a3e778060ee6f7caca4f7a29bde80260801c5b600160791b831615611b525770010163da9fb33356d84a66ae336dcdfa3f0260801c5b600160781b831615611b7557700100b1afa5abcbed6129ab13ec11dc95430260801c5b600160771b831615611b985770010058c86da1c09ea1ff19d294cf2f679b0260801c5b600160761b831615611bbb577001002c605e2e8cec506d21bfc89a23a00f0260801c5b600160751b831615611bde57700100162f3904051fa128bca9c55c31e5df0260801c5b600160741b831615611c01577001000b175effdc76ba38e31671ca9397250260801c5b600160731b831615611c2457700100058ba01fb9f96d6cacd4b180917c3d0260801c5b600160721b831615611c475770010002c5cc37da9491d0985c348c68e7b30260801c5b600160711b831615611c6a577001000162e525ee054754457d59952920260260801c5b600160701b831615611c8d5770010000b17255775c040618bf4a4ade83fc0260801c5b6001606f1b831615611cb0577001000058b91b5bc9ae2eed81e9b7d4cfab0260801c5b6001606e1b831615611cd357700100002c5c89d5ec6ca4d7c8acc017b7c90260801c5b6001606d1b831615611cf65770010000162e43f4f831060e02d839a9d16d0260801c5b6001606c1b831615611d1957700100000b1721bcfc99d9f890ea069117630260801c5b6001606b1b831615611d3c5770010000058b90cf1e6d97f9ca14dbcc16280260801c5b6001606a1b831615611d5f577001000002c5c863b73f016468f6bac5ca2b0260801c5b600160691b831615611d8257700100000162e430e5a18f6119e3c02282a50260801c5b600160681b831615611da5577001000000b1721835514b86e6d96efd1bfe0260801c5b600160671b831615611dc857700100000058b90c0b48c6be5df846c5b2ef0260801c5b600160661b831615611deb5770010000002c5c8601cc6b9e94213c72737a0260801c5b600160651b831615611e0e577001000000162e42fff037df38aa2b219f060260801c5b600160641b831615611e315770010000000b17217fba9c739aa5819f44f90260801c5b600160631b831615611e54577001000000058b90bfcdee5acd3c1cedc8230260801c5b600160621b831615611e7757700100000002c5c85fe31f35a6a30da1be500260801c5b600160611b831615611e9a5770010000000162e42ff0999ce3541b9fffcf0260801c5b600160601b831615611ebd57700100000000b17217f80f4ef5aadda455540260801c5b6001605f1b831615611ee05770010000000058b90bfbf8479bd5a81b51ad0260801c5b6001605e1b831615611f03577001000000002c5c85fdf84bd62ae30a74cc0260801c5b6001605d1b831615611f2657700100000000162e42fefb2fed257559bdaa0260801c5b6001605c1b831615611f49577001000000000b17217f7d5a7716bba4a9ae0260801c5b6001605b1b831615611f6c57700100000000058b90bfbe9ddbac5e109cce0260801c5b6001605a1b831615611f8f5770010000000002c5c85fdf4b15de6f17eb0d0260801c5b600160591b831615611fb2577001000000000162e42fefa494f1478fde050260801c5b600160581b831615611fd55770010000000000b17217f7d20cf927c8e94c0260801c5b600160571b831615611ff8577001000000000058b90bfbe8f71cb4e4b33d0260801c5b600160561b83161561201b57700100000000002c5c85fdf477b662b269450260801c5b600160551b83161561203e5770010000000000162e42fefa3ae53369388c0260801c5b600160541b83161561206157700100000000000b17217f7d1d351a389d400260801c5b600160531b8316156120845770010000000000058b90bfbe8e8b2d3d4ede0260801c5b600160521b8316156120a7577001000000000002c5c85fdf4741bea6e77e0260801c5b600160511b8316156120ca57700100000000000162e42fefa39fe95583c20260801c5b600160501b8316156120ed577001000000000000b17217f7d1cfb72b45e10260801c5b698000000000000000000083161561211657700100000000000058b90bfbe8e7cc35c3f00260801c5b694000000000000000000083161561213f5770010000000000002c5c85fdf473e242ea380260801c5b6920000000000000000000831615612168577001000000000000162e42fefa39f02b772c0260801c5b69100000000000000000008316156121915770010000000000000b17217f7d1cf7d83c1a0260801c5b69080000000000000000008316156121ba577001000000000000058b90bfbe8e7bdcbe2e0260801c5b69040000000000000000008316156121e357700100000000000002c5c85fdf473dea871f0260801c5b690200000000000000000083161561220c5770010000000000000162e42fefa39ef44d910260801c5b690100000000000000000083161561223557700100000000000000b17217f7d1cf79e9490260801c5b6880000000000000000083161561225d5770010000000000000058b90bfbe8e7bce5440260801c5b68400000000000000000831615612285577001000000000000002c5c85fdf473de6eca0260801c5b682000000000000000008316156122ad57700100000000000000162e42fefa39ef366f0260801c5b681000000000000000008316156122d5577001000000000000000b17217f7d1cf79afa0260801c5b680800000000000000008316156122fd57700100000000000000058b90bfbe8e7bcd6d0260801c5b680400000000000000008316156123255770010000000000000002c5c85fdf473de6b20260801c5b6802000000000000000083161561234d577001000000000000000162e42fefa39ef3580260801c5b600160401b8316156123705770010000000000000000b17217f7d1cf79ab0260801c5b678000000000000000831615612397577001000000000000000058b90bfbe8e7bcd50260801c5b6740000000000000008316156123be57700100000000000000002c5c85fdf473de6a0260801c5b6720000000000000008316156123e55770010000000000000000162e42fefa39ef340260801c5b67100000000000000083161561240c57700100000000000000000b17217f7d1cf7990260801c5b6708000000000000008316156124335770010000000000000000058b90bfbe8e7bcc0260801c5b67040000000000000083161561245a577001000000000000000002c5c85fdf473de50260801c5b67020000000000000083161561248157700100000000000000000162e42fefa39ef20260801c5b6701000000000000008316156124a8577001000000000000000000b17217f7d1cf780260801c5b66800000000000008316156124ce57700100000000000000000058b90bfbe8e7bb0260801c5b66400000000000008316156124f45770010000000000000000002c5c85fdf473dd0260801c5b662000000000000083161561251a577001000000000000000000162e42fefa39ee0260801c5b66100000000000008316156125405770010000000000000000000b17217f7d1cf60260801c5b6608000000000000831615612566577001000000000000000000058b90bfbe8e7a0260801c5b660400000000000083161561258c57700100000000000000000002c5c85fdf473c0260801c5b66020000000000008316156125b25770010000000000000000000162e42fefa39d0260801c5b66010000000000008316156125d857700100000000000000000000b17217f7d1ce0260801c5b658000000000008316156125fd5770010000000000000000000058b90bfbe8e60260801c5b65400000000000831615612622577001000000000000000000002c5c85fdf4720260801c5b6520000000000083161561264757700100000000000000000000162e42fefa380260801c5b6510000000000083161561266c577001000000000000000000000b17217f7d1b0260801c5b6508000000000083161561269157700100000000000000000000058b90bfbe8d0260801c5b650400000000008316156126b65770010000000000000000000002c5c85fdf460260801c5b650200000000008316156126db577001000000000000000000000162e42fefa20260801c5b650100000000008316156127005770010000000000000000000000b17217f7d00260801c5b648000000000831615612724577001000000000000000000000058b90bfbe70260801c5b64400000000083161561274857700100000000000000000000002c5c85fdf30260801c5b64200000000083161561276c5770010000000000000000000000162e42fef90260801c5b64100000000083161561279057700100000000000000000000000b17217f7c0260801c5b6408000000008316156127b45770010000000000000000000000058b90bfbd0260801c5b6404000000008316156127d8577001000000000000000000000002c5c85fde0260801c5b6402000000008316156127fc57700100000000000000000000000162e42fee0260801c5b640100000000831615612820577001000000000000000000000000b17217f60260801c5b638000000083161561284357700100000000000000000000000058b90bfa0260801c5b63400000008316156128665770010000000000000000000000002c5c85fc0260801c5b6320000000831615612889577001000000000000000000000000162e42fd0260801c5b63100000008316156128ac5770010000000000000000000000000b17217e0260801c5b63080000008316156128cf577001000000000000000000000000058b90be0260801c5b63040000008316156128f257700100000000000000000000000002c5c85e0260801c5b63020000008316156129155770010000000000000000000000000162e42e0260801c5b630100000083161561293857700100000000000000000000000000b172160260801c5b6280000083161561295a5770010000000000000000000000000058b90a0260801c5b6240000083161561297c577001000000000000000000000000002c5c840260801c5b6220000083161561299e57700100000000000000000000000000162e410260801c5b621000008316156129c0577001000000000000000000000000000b17200260801c5b620800008316156129e257700100000000000000000000000000058b8f0260801c5b62040000831615612a045770010000000000000000000000000002c5c70260801c5b62020000831615612a26577001000000000000000000000000000162e30260801c5b62010000831615612a485770010000000000000000000000000000b1710260801c5b618000831615612a69577001000000000000000000000000000058b80260801c5b614000831615612a8a57700100000000000000000000000000002c5b0260801c5b612000831615612aab5770010000000000000000000000000000162d0260801c5b611000831615612acc57700100000000000000000000000000000b160260801c5b610800831615612aed5770010000000000000000000000000000058a0260801c5b610400831615612b0e577001000000000000000000000000000002c40260801c5b610200831615612b2f577001000000000000000000000000000001610260801c5b610100831615612b50577001000000000000000000000000000000b00260801c5b6080831615612b70577001000000000000000000000000000000570260801c5b6040831615612b905770010000000000000000000000000000002b0260801c5b6020831615612bb0577001000000000000000000000000000000150260801c5b6010831615612bd05770010000000000000000000000000000000a0260801c5b6008831615612bf0577001000000000000000000000000000000040260801c5b6004831615612c10577001000000000000000000000000000000010260801c5b84612c3157600f81901c6001600160701b03169050613fff82019150612c60565b613ffe8211612c5657600f81901c6001600160701b0316905081613fff039150612c60565b600091613fee19011c5b60709190911b1760801b95945050505050565b600061045b6104cb8461106f565b6000808211612c8f57600080fd5b6000600160801b8310612ca457608092831c92015b600160401b8310612cb757604092831c92015b6401000000008310612ccb57602092831c92015b620100008310612cdd57601092831c92015b6101008310612cee57600892831c92015b60108310612cfe57600492831c92015b60048310612d0e57600292831c92015b6002831061045e5760010192915050565b80356001600160801b031981168114610db357600080fd5b600060208284031215612d4957600080fd5b61045b82612d1f565b60008060408385031215612d6557600080fd5b612d6e83612d1f565b9150612d7c60208401612d1f565b90509250929050565b60008060008060808587031215612d9b57600080fd5b612da485612d1f565b9350612db260208601612d1f565b93969395505050506040820135916060013590565b600080600060608486031215612ddc57600080fd5b612de584612d1f565b925060208401358060000b8114612dfb57600080fd5b9150612e0960408501612d1f565b90509250925092565b60008060408385031215612e2557600080fd5b612e2e83612d1f565b946020939093013593505050565b60008060408385031215612e4f57600080fd5b50508035926020909101359150565b600060c08284031215612e7057600080fd5b50919050565b60006101608284031215612e7057600080fd5b600060208284031215612e9b57600080fd5b5035919050565b600080600060608486031215612eb757600080fd5b505081359360208301359350604090920135919050565b60008060008060808587031215612ee457600080fd5b5050823594602084013594506040840135936060013592509050565b600080600080600060a08688031215612f1857600080fd5b505083359560208501359550604085013594606081013594506080013592509050565b6020808252600a908201526907072696365203d3d20360b41b604082015260600190565b60008219821115612f7257612f726130d0565b500190565b600082612f9457634e487b7160e01b600052601260045260246000fd5b500490565b600181815b80851115612fd4578160001904821115612fba57612fba6130d0565b80851615612fc757918102915b93841c9390800290612f9e565b509250929050565b600061045b8383600082612ff25750600161045e565b81612fff5750600061045e565b8160018114613015576002811461301f5761303b565b600191505061045e565b60ff841115613030576130306130d0565b50506001821b61045e565b5060208310610133831016604e8410600b841016171561305e575081810a61045e565b6130688383612f99565b806000190482111561307c5761307c6130d0565b029392505050565b600081600019048311821515161561309e5761309e6130d0565b500290565b6000828210156130b5576130b56130d0565b500390565b634e487b7160e01b600052600160045260246000fd5b634e487b7160e01b600052601160045260246000fd5b634e487b7160e01b600052601260045260246000fdfea264697066735822122079f7b3bf65e185ddca2de57448c2f40de42cf68d49c018aaeb14ee4e1432408b64736f6c63430008070033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "addBytes(bytes16,bytes16)": {
        "params": {
          "x": "The number to be added with `y`",
          "y": "The number to be added with `x`"
        }
      },
      "appropriateUpdateIntervalId(uint256,uint256,uint256,uint256,uint256)": {
        "details": "Note that the timestamp parameter is required to be >= lastPriceTimestamp",
        "params": {
          "currentUpdateIntervalId": "The current update interval's ID",
          "frontRunningInterval": "The frontrunning interval of a pool - The amount of time before an update interval that you must commit to get included in that update",
          "lastPriceTimestamp": "The timestamp of the last price update",
          "timestamp": "Current block.timestamp",
          "updateInterval": "The frequency of a pool's updates"
        },
        "returns": {
          "_0": "The update interval ID in which a commit being made at time timestamp should be included"
        }
      },
      "calculatePriceChange(PoolSwapLibrary.PriceChangeData)": {
        "details": "This function should be called by the LeveragedPool.",
        "params": {
          "priceChange": "The struct containing necessary data to calculate price change"
        },
        "returns": {
          "_0": "Resulting long balance",
          "_1": "Resulting short balance",
          "_2": "Resulting fees taken from long balance",
          "_3": "Resulting fees taken from short balance"
        }
      },
      "compareDecimals(bytes16,bytes16)": {
        "params": {
          "x": "The first number to compare",
          "y": "The second number to compare"
        },
        "returns": {
          "_0": "-1 if x < y, 0 if x = y, or 1 if x > y"
        }
      },
      "convertDecimalToUInt(bytes16)": {
        "params": {
          "ratio": "The value to convert"
        },
        "returns": {
          "_0": "The converted value"
        }
      },
      "convertUIntToDecimal(uint256)": {
        "params": {
          "amount": "The amount to convert"
        },
        "returns": {
          "_0": "The amount as a IEEE754 quadruple precision number"
        }
      },
      "divInt(int256,int256)": {
        "params": {
          "a": "The dividend",
          "b": "The divisor"
        },
        "returns": {
          "_0": "The quotient"
        }
      },
      "fromWad(uint256,uint256)": {
        "params": {
          "_decimals": "Quantity of decimal places to support",
          "_wadValue": "wad number"
        },
        "returns": {
          "_0": "Converted (non-WAD) value"
        }
      },
      "getBalancesAfterFees(uint256,uint256,uint256)": {
        "details": "Assumes shortBalance + longBalance >= reward",
        "params": {
          "longBalance": "Long balance of the pool",
          "reward": "Amount of keeper reward",
          "shortBalance": "Short balance of the pool"
        },
        "returns": {
          "_0": "shortBalanceAfterFees Short balance of the pool after the keeper reward has been paid",
          "_1": "longBalanceAfterFees Long balance of the pool after the keeper reward has been paid"
        }
      },
      "getBurn(bytes16,uint256)": {
        "details": "amount * price, where amount is in PoolToken and price is in USD/PoolTokenThrows if price is zero`getMint()`",
        "params": {
          "amount": "Amount of settlement tokens being used to burn",
          "price": "Price of a pool token"
        },
        "returns": {
          "_0": "Quantity of pool tokens to burn"
        }
      },
      "getLossAmount(bytes16,uint256)": {
        "params": {
          "balance": "The balance of the losing pool",
          "lossMultiplier": "The multiplier to use"
        }
      },
      "getLossMultiplier(bytes16,int8,bytes16)": {
        "params": {
          "direction": "The direction of the change. -1 if it's decreased, 0 if it hasn't changed, and 1 if it's increased",
          "leverage": "The amount of leverage to apply",
          "ratio": "The ratio of new price to old price"
        },
        "returns": {
          "_0": "The multiplier"
        }
      },
      "getMint(bytes16,uint256)": {
        "details": "Throws if price is zero`getBurn()`",
        "params": {
          "amount": "Amount of settlement tokens being used to mint",
          "price": "Price of a pool token"
        },
        "returns": {
          "_0": "Quantity of pool tokens to mint"
        }
      },
      "getMintAmount(uint256,uint256,uint256,uint256)": {
        "details": "Calculated as (tokenSupply + shadowBalance) * amountIn / balance",
        "params": {
          "amountIn": "Commitment amount of collateral tokens going into the pool",
          "balance": "Balance of the pool (no. of underlying collateral tokens in pool)",
          "shadowBalance": "Balance the shadow pool at time of mint",
          "tokenSupply": "Total supply of pool tokens"
        },
        "returns": {
          "_0": "Number of pool tokens to be minted"
        }
      },
      "getMintWithBurns(bytes16,bytes16,uint256,uint256)": {
        "details": "Throws if price is zero",
        "params": {
          "amount": "The amount of settlement tokens being used to mint",
          "amountBurnedInstantMint": "The amount of pool tokens that were burnt from the opposite side for an instant mint in this side",
          "oppositePrice": "The price of the opposite side's pool token",
          "price": "The price of a pool token"
        },
        "returns": {
          "_0": "Quantity of pool tokens to mint"
        }
      },
      "getPrice(uint256,uint256)": {
        "details": "Divide the side balance by the pool token's total supply",
        "params": {
          "sideBalance": "no. of underlying collateral tokens on that side of the pool",
          "tokenSupply": "Total supply of pool tokens"
        }
      },
      "getRatio(uint256,uint256)": {
        "details": "Rounds any overflow towards 0. If either parameter is zero, the ratio is 0",
        "params": {
          "_denominator": "The \"per part\" side of the equation. If this is zero, the ratio is zero",
          "_numerator": "The \"parts per\" side of the equation. If this is zero, the ratio is zero"
        },
        "returns": {
          "_0": "the ratio, as an ABDKMathQuad number (IEEE 754 quadruple precision floating point)"
        }
      },
      "getUpdatedAggregateBalance(PoolSwapLibrary.UpdateData)": {
        "params": {
          "data": "Information needed for updating the balance including prices and recent commit amounts"
        },
        "returns": {
          "_longBurnFee": "Quantity of settlement tokens taken as a fee from long burns",
          "_newLongTokens": "Quantity of additional long tokens the user would receive",
          "_newSettlementTokens": "Quantity of additional settlement tokens the user would receive",
          "_newShortTokens": "Quantity of additional short tokens the user would receive",
          "_shortBurnFee": "Quantity of settlement tokens taken as a fee from short burns"
        }
      },
      "getWithdrawAmountOnBurn(uint256,uint256,uint256,uint256)": {
        "details": "Calculates as `balance * amountIn / (tokenSupply + shadowBalance)",
        "params": {
          "amountIn": "Commitment amount of pool tokens going into the pool",
          "balance": "Balance of the pool (no. of underlying collateral tokens in pool)",
          "shadowBalance": "Balance the shadow pool at time of mint",
          "tokenSupply": "Total supply of pool tokens"
        },
        "returns": {
          "_0": "Number of settlement tokens to be withdrawn on a burn"
        }
      },
      "isBeforeFrontRunningInterval(uint256,uint256,uint256,uint256)": {
        "details": "If you try to uncommit AFTER the frontRunningInterval, it should revert.",
        "params": {
          "frontRunningInterval": "The window of time before a price udpate users can not uncommit or have their commit executed from",
          "lastPriceTimestamp": "The timestamp of the last price update",
          "subjectTime": "The timestamp for which you want to calculate if it was beforeFrontRunningInterval",
          "updateInterval": "The interval between price updates"
        }
      },
      "mulFraction(uint256,uint256,uint256)": {
        "returns": {
          "_0": "The result as an integer"
        }
      },
      "multiplyBytes(bytes16,bytes16)": {
        "params": {
          "x": "The number to be multiplied by `y`",
          "y": "The number to be multiplied by `x`"
        }
      },
      "multiplyDecimalByUInt(bytes16,uint256)": {
        "params": {
          "a": "The first term",
          "b": "The second term"
        },
        "returns": {
          "_0": "The product of a*b as a decimal"
        }
      },
      "subtractBytes(bytes16,bytes16)": {
        "params": {
          "x": "The number to be subtracted by `y`",
          "y": "The number to subtract from `x`"
        }
      }
    },
    "title": "Library for various useful (mostly) mathematical functions",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "MAX_DECIMALS()": {
        "notice": "Maximum number of decimal places supported by this contract (ABDKMathQuad defines this but it's private)"
      },
      "WAD_PRECISION()": {
        "notice": "Maximum precision supportable via wad arithmetic (for this contract)"
      },
      "addBytes(bytes16,bytes16)": {
        "notice": "Performs an addition on two bytes16 numbers"
      },
      "appropriateUpdateIntervalId(uint256,uint256,uint256,uint256,uint256)": {
        "notice": "Calculates the update interval ID that a commitment should be placed in."
      },
      "calculatePriceChange(PoolSwapLibrary.PriceChangeData)": {
        "notice": "Calculates the effect of a price change. This involves calculating how many funds to transfer from the losing pool to the other."
      },
      "compareDecimals(bytes16,bytes16)": {
        "notice": "Compares two decimal numbers"
      },
      "convertDecimalToUInt(bytes16)": {
        "notice": "Converts a raw decimal value to a more readable uint256 value"
      },
      "convertUIntToDecimal(uint256)": {
        "notice": "Converts an integer value to a compatible decimal value"
      },
      "divInt(int256,int256)": {
        "notice": "Divides two integers"
      },
      "fromWad(uint256,uint256)": {
        "notice": "Converts from a WAD to normal value"
      },
      "getBalancesAfterFees(uint256,uint256,uint256)": {
        "notice": "Gets the short and long balances after the keeper rewards have been paid out         Keeper rewards are paid proportionally to the short and long pool"
      },
      "getBurn(bytes16,uint256)": {
        "notice": "Calculate the number of settlement tokens to burn, based on a price and an amount of pool tokens"
      },
      "getLossAmount(bytes16,uint256)": {
        "notice": "Calculates the amount to take from the losing pool"
      },
      "getLossMultiplier(bytes16,int8,bytes16)": {
        "notice": "Calculates the loss multiplier to apply to the losing pool. Includes the power leverage"
      },
      "getMint(bytes16,uint256)": {
        "notice": "Calculates the number of pool tokens to mint, given some settlement token amount and a price"
      },
      "getMintAmount(uint256,uint256,uint256,uint256)": {
        "notice": "Gets the number of pool tokens to be minted based on existing tokens"
      },
      "getMintWithBurns(bytes16,bytes16,uint256,uint256)": {
        "notice": "Calculate the number of pool tokens to mint, given some settlement token amount, a price, and a burn amount from other side for instant mint"
      },
      "getPrice(uint256,uint256)": {
        "notice": "Get the Settlement/PoolToken price, in ABDK IEE754 precision"
      },
      "getRatio(uint256,uint256)": {
        "notice": "Calculates the ratio between two numbers"
      },
      "getUpdatedAggregateBalance(PoolSwapLibrary.UpdateData)": {
        "notice": "Calculate the change in a user's balance based on recent commit(s)"
      },
      "getWithdrawAmountOnBurn(uint256,uint256,uint256,uint256)": {
        "notice": "Gets the number of settlement tokens to be withdrawn based on a pool token burn amount"
      },
      "isBeforeFrontRunningInterval(uint256,uint256,uint256,uint256)": {
        "notice": "Returns true if the given timestamp is BEFORE the frontRunningInterval starts,         which is allowed for uncommitment."
      },
      "mulFraction(uint256,uint256,uint256)": {
        "notice": "Multiply an integer by a fraction"
      },
      "multiplyBytes(bytes16,bytes16)": {
        "notice": "Multiplies two numbers"
      },
      "multiplyDecimalByUInt(bytes16,uint256)": {
        "notice": "Multiplies a decimal and an unsigned integer"
      },
      "one()": {
        "notice": "ABDKMathQuad-formatted representation of the number one"
      },
      "subtractBytes(bytes16,bytes16)": {
        "notice": "Performs a subtraction on two bytes16 numbers"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}