{
    "address": "0x5470E49593bc68759A3035bF36B0501Ca3181866",
    "abi": [
        {
            "inputs": [],
            "name": "MAX_BURNING_FEE",
            "outputs": [
                {
                    "internalType": "bytes16",
                    "name": "",
                    "type": "bytes16"
                }
            ],
            "stateMutability": "view",
            "type": "function"
        },
        {
            "inputs": [],
            "name": "MAX_DECIMALS",
            "outputs": [
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                }
            ],
            "stateMutability": "view",
            "type": "function"
        },
        {
            "inputs": [],
            "name": "MAX_MINTING_FEE",
            "outputs": [
                {
                    "internalType": "bytes16",
                    "name": "",
                    "type": "bytes16"
                }
            ],
            "stateMutability": "view",
            "type": "function"
        },
        {
            "inputs": [],
            "name": "ONE",
            "outputs": [
                {
                    "internalType": "bytes16",
                    "name": "",
                    "type": "bytes16"
                }
            ],
            "stateMutability": "view",
            "type": "function"
        },
        {
            "inputs": [],
            "name": "WAD_PRECISION",
            "outputs": [
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                }
            ],
            "stateMutability": "view",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "bytes16",
                    "name": "x",
                    "type": "bytes16"
                },
                {
                    "internalType": "bytes16",
                    "name": "y",
                    "type": "bytes16"
                }
            ],
            "name": "addBytes",
            "outputs": [
                {
                    "internalType": "bytes16",
                    "name": "",
                    "type": "bytes16"
                }
            ],
            "stateMutability": "pure",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "uint256",
                    "name": "timestamp",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "lastPriceTimestamp",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "frontRunningInterval",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "updateInterval",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "currentUpdateIntervalId",
                    "type": "uint256"
                }
            ],
            "name": "appropriateUpdateIntervalId",
            "outputs": [
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                }
            ],
            "stateMutability": "pure",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "components": [
                        {
                            "internalType": "int256",
                            "name": "oldPrice",
                            "type": "int256"
                        },
                        {
                            "internalType": "int256",
                            "name": "newPrice",
                            "type": "int256"
                        },
                        {
                            "internalType": "uint256",
                            "name": "longBalance",
                            "type": "uint256"
                        },
                        {
                            "internalType": "uint256",
                            "name": "shortBalance",
                            "type": "uint256"
                        },
                        {
                            "internalType": "bytes16",
                            "name": "leverageAmount",
                            "type": "bytes16"
                        },
                        {
                            "internalType": "bytes16",
                            "name": "fee",
                            "type": "bytes16"
                        }
                    ],
                    "internalType": "struct PoolSwapLibrary.PriceChangeData",
                    "name": "priceChange",
                    "type": "tuple"
                }
            ],
            "name": "calculatePriceChange",
            "outputs": [
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                }
            ],
            "stateMutability": "pure",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "bytes16",
                    "name": "x",
                    "type": "bytes16"
                },
                {
                    "internalType": "bytes16",
                    "name": "y",
                    "type": "bytes16"
                }
            ],
            "name": "compareDecimals",
            "outputs": [
                {
                    "internalType": "int8",
                    "name": "",
                    "type": "int8"
                }
            ],
            "stateMutability": "pure",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "bytes16",
                    "name": "ratio",
                    "type": "bytes16"
                }
            ],
            "name": "convertDecimalToUInt",
            "outputs": [
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                }
            ],
            "stateMutability": "pure",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "uint256",
                    "name": "amount",
                    "type": "uint256"
                }
            ],
            "name": "convertUIntToDecimal",
            "outputs": [
                {
                    "internalType": "bytes16",
                    "name": "",
                    "type": "bytes16"
                }
            ],
            "stateMutability": "pure",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "int256",
                    "name": "a",
                    "type": "int256"
                },
                {
                    "internalType": "int256",
                    "name": "b",
                    "type": "int256"
                }
            ],
            "name": "divInt",
            "outputs": [
                {
                    "internalType": "bytes16",
                    "name": "",
                    "type": "bytes16"
                }
            ],
            "stateMutability": "pure",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "uint256",
                    "name": "_wadValue",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "_decimals",
                    "type": "uint256"
                }
            ],
            "name": "fromWad",
            "outputs": [
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                }
            ],
            "stateMutability": "pure",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "uint256",
                    "name": "reward",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "shortBalance",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "longBalance",
                    "type": "uint256"
                }
            ],
            "name": "getBalancesAfterFees",
            "outputs": [
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                }
            ],
            "stateMutability": "pure",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "bytes16",
                    "name": "price",
                    "type": "bytes16"
                },
                {
                    "internalType": "uint256",
                    "name": "amount",
                    "type": "uint256"
                }
            ],
            "name": "getBurn",
            "outputs": [
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                }
            ],
            "stateMutability": "pure",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "bytes16",
                    "name": "lossMultiplier",
                    "type": "bytes16"
                },
                {
                    "internalType": "uint256",
                    "name": "balance",
                    "type": "uint256"
                }
            ],
            "name": "getLossAmount",
            "outputs": [
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                }
            ],
            "stateMutability": "pure",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "bytes16",
                    "name": "ratio",
                    "type": "bytes16"
                },
                {
                    "internalType": "int8",
                    "name": "direction",
                    "type": "int8"
                },
                {
                    "internalType": "bytes16",
                    "name": "leverage",
                    "type": "bytes16"
                }
            ],
            "name": "getLossMultiplier",
            "outputs": [
                {
                    "internalType": "bytes16",
                    "name": "",
                    "type": "bytes16"
                }
            ],
            "stateMutability": "pure",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "bytes16",
                    "name": "price",
                    "type": "bytes16"
                },
                {
                    "internalType": "uint256",
                    "name": "amount",
                    "type": "uint256"
                }
            ],
            "name": "getMint",
            "outputs": [
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                }
            ],
            "stateMutability": "pure",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "uint256",
                    "name": "tokenSupply",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "amountIn",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "balance",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "pendingBurnPoolTokens",
                    "type": "uint256"
                }
            ],
            "name": "getMintAmount",
            "outputs": [
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                }
            ],
            "stateMutability": "pure",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "bytes16",
                    "name": "price",
                    "type": "bytes16"
                },
                {
                    "internalType": "bytes16",
                    "name": "oppositePrice",
                    "type": "bytes16"
                },
                {
                    "internalType": "uint256",
                    "name": "amount",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "amountBurnedInstantMint",
                    "type": "uint256"
                }
            ],
            "name": "getMintWithBurns",
            "outputs": [
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                }
            ],
            "stateMutability": "pure",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "uint256",
                    "name": "sideBalance",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "tokenSupply",
                    "type": "uint256"
                }
            ],
            "name": "getPrice",
            "outputs": [
                {
                    "internalType": "bytes16",
                    "name": "",
                    "type": "bytes16"
                }
            ],
            "stateMutability": "pure",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "uint256",
                    "name": "_numerator",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "_denominator",
                    "type": "uint256"
                }
            ],
            "name": "getRatio",
            "outputs": [
                {
                    "internalType": "bytes16",
                    "name": "",
                    "type": "bytes16"
                }
            ],
            "stateMutability": "pure",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "components": [
                        {
                            "internalType": "bytes16",
                            "name": "longPrice",
                            "type": "bytes16"
                        },
                        {
                            "internalType": "bytes16",
                            "name": "shortPrice",
                            "type": "bytes16"
                        },
                        {
                            "internalType": "uint256",
                            "name": "currentUpdateIntervalId",
                            "type": "uint256"
                        },
                        {
                            "internalType": "uint256",
                            "name": "updateIntervalId",
                            "type": "uint256"
                        },
                        {
                            "internalType": "uint256",
                            "name": "longMintSettlement",
                            "type": "uint256"
                        },
                        {
                            "internalType": "uint256",
                            "name": "longBurnPoolTokens",
                            "type": "uint256"
                        },
                        {
                            "internalType": "uint256",
                            "name": "shortMintSettlement",
                            "type": "uint256"
                        },
                        {
                            "internalType": "uint256",
                            "name": "shortBurnPoolTokens",
                            "type": "uint256"
                        },
                        {
                            "internalType": "uint256",
                            "name": "longBurnShortMintPoolTokens",
                            "type": "uint256"
                        },
                        {
                            "internalType": "uint256",
                            "name": "shortBurnLongMintPoolTokens",
                            "type": "uint256"
                        },
                        {
                            "internalType": "bytes16",
                            "name": "burnFee",
                            "type": "bytes16"
                        }
                    ],
                    "internalType": "struct PoolSwapLibrary.UpdateData",
                    "name": "data",
                    "type": "tuple"
                }
            ],
            "name": "getUpdatedAggregateBalance",
            "outputs": [
                {
                    "internalType": "uint256",
                    "name": "_newLongTokens",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "_newShortTokens",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "_longBurnFee",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "_shortBurnFee",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "_newSettlementTokens",
                    "type": "uint256"
                }
            ],
            "stateMutability": "pure",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "uint256",
                    "name": "tokenSupply",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "amountIn",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "balance",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "pendingBurnPoolTokens",
                    "type": "uint256"
                }
            ],
            "name": "getWithdrawAmountOnBurn",
            "outputs": [
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                }
            ],
            "stateMutability": "pure",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "uint256",
                    "name": "subjectTime",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "lastPriceTimestamp",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "updateInterval",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "frontRunningInterval",
                    "type": "uint256"
                }
            ],
            "name": "isBeforeFrontRunningInterval",
            "outputs": [
                {
                    "internalType": "bool",
                    "name": "",
                    "type": "bool"
                }
            ],
            "stateMutability": "pure",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "uint256",
                    "name": "number",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "numerator",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "denominator",
                    "type": "uint256"
                }
            ],
            "name": "mulFraction",
            "outputs": [
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                }
            ],
            "stateMutability": "pure",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "bytes16",
                    "name": "x",
                    "type": "bytes16"
                },
                {
                    "internalType": "bytes16",
                    "name": "y",
                    "type": "bytes16"
                }
            ],
            "name": "multiplyBytes",
            "outputs": [
                {
                    "internalType": "bytes16",
                    "name": "",
                    "type": "bytes16"
                }
            ],
            "stateMutability": "pure",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "bytes16",
                    "name": "a",
                    "type": "bytes16"
                },
                {
                    "internalType": "uint256",
                    "name": "b",
                    "type": "uint256"
                }
            ],
            "name": "multiplyDecimalByUInt",
            "outputs": [
                {
                    "internalType": "bytes16",
                    "name": "",
                    "type": "bytes16"
                }
            ],
            "stateMutability": "pure",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "bytes16",
                    "name": "x",
                    "type": "bytes16"
                },
                {
                    "internalType": "bytes16",
                    "name": "y",
                    "type": "bytes16"
                }
            ],
            "name": "subtractBytes",
            "outputs": [
                {
                    "internalType": "bytes16",
                    "name": "",
                    "type": "bytes16"
                }
            ],
            "stateMutability": "pure",
            "type": "function"
        }
    ],
    "transactionHash": "0xb2bf0c26d98bd6a47f72f3e88ee6deef5e84f2852feb83bf85b594b9adf6d115",
    "receipt": {
        "to": null,
        "from": "0x110af92Ba116fD7868216AA794a7E4dA3b9D7D11",
        "contractAddress": "0x5470E49593bc68759A3035bF36B0501Ca3181866",
        "transactionIndex": 0,
        "gasUsed": "41775708",
        "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
        "blockHash": "0x23208075ab71310ddd4467e1ae0d976100cef313d9c5b59b6d157f72535ef598",
        "transactionHash": "0xb2bf0c26d98bd6a47f72f3e88ee6deef5e84f2852feb83bf85b594b9adf6d115",
        "logs": [],
        "blockNumber": 10659393,
        "cumulativeGasUsed": "20131328",
        "status": 1,
        "byzantium": true
    },
    "args": [],
    "solcInputHash": "f23797a75a460924964c385a02c83432",
    "metadata": "{\"compiler\":{\"version\":\"0.8.7+commit.e28d00a7\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"MAX_BURNING_FEE\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_DECIMALS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_MINTING_FEE\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ONE\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WAD_PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"x\",\"type\":\"bytes16\"},{\"internalType\":\"bytes16\",\"name\":\"y\",\"type\":\"bytes16\"}],\"name\":\"addBytes\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastPriceTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"frontRunningInterval\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updateInterval\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentUpdateIntervalId\",\"type\":\"uint256\"}],\"name\":\"appropriateUpdateIntervalId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"int256\",\"name\":\"oldPrice\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"newPrice\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"longBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shortBalance\",\"type\":\"uint256\"},{\"internalType\":\"bytes16\",\"name\":\"leverageAmount\",\"type\":\"bytes16\"},{\"internalType\":\"bytes16\",\"name\":\"fee\",\"type\":\"bytes16\"}],\"internalType\":\"struct PoolSwapLibrary.PriceChangeData\",\"name\":\"priceChange\",\"type\":\"tuple\"}],\"name\":\"calculatePriceChange\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"x\",\"type\":\"bytes16\"},{\"internalType\":\"bytes16\",\"name\":\"y\",\"type\":\"bytes16\"}],\"name\":\"compareDecimals\",\"outputs\":[{\"internalType\":\"int8\",\"name\":\"\",\"type\":\"int8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"ratio\",\"type\":\"bytes16\"}],\"name\":\"convertDecimalToUInt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"convertUIntToDecimal\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"a\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"b\",\"type\":\"int256\"}],\"name\":\"divInt\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_wadValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_decimals\",\"type\":\"uint256\"}],\"name\":\"fromWad\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shortBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"longBalance\",\"type\":\"uint256\"}],\"name\":\"getBalancesAfterFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"price\",\"type\":\"bytes16\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getBurn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"lossMultiplier\",\"type\":\"bytes16\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"getLossAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"ratio\",\"type\":\"bytes16\"},{\"internalType\":\"int8\",\"name\":\"direction\",\"type\":\"int8\"},{\"internalType\":\"bytes16\",\"name\":\"leverage\",\"type\":\"bytes16\"}],\"name\":\"getLossMultiplier\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"price\",\"type\":\"bytes16\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getMint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pendingBurnPoolTokens\",\"type\":\"uint256\"}],\"name\":\"getMintAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"price\",\"type\":\"bytes16\"},{\"internalType\":\"bytes16\",\"name\":\"oppositePrice\",\"type\":\"bytes16\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountBurnedInstantMint\",\"type\":\"uint256\"}],\"name\":\"getMintWithBurns\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sideBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenSupply\",\"type\":\"uint256\"}],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_numerator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_denominator\",\"type\":\"uint256\"}],\"name\":\"getRatio\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes16\",\"name\":\"longPrice\",\"type\":\"bytes16\"},{\"internalType\":\"bytes16\",\"name\":\"shortPrice\",\"type\":\"bytes16\"},{\"internalType\":\"uint256\",\"name\":\"currentUpdateIntervalId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updateIntervalId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"longMintSettlement\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"longBurnPoolTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shortMintSettlement\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shortBurnPoolTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"longBurnShortMintPoolTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shortBurnLongMintPoolTokens\",\"type\":\"uint256\"},{\"internalType\":\"bytes16\",\"name\":\"burnFee\",\"type\":\"bytes16\"}],\"internalType\":\"struct PoolSwapLibrary.UpdateData\",\"name\":\"data\",\"type\":\"tuple\"}],\"name\":\"getUpdatedAggregateBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_newLongTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_newShortTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_longBurnFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_shortBurnFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_newSettlementTokens\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pendingBurnPoolTokens\",\"type\":\"uint256\"}],\"name\":\"getWithdrawAmountOnBurn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"subjectTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastPriceTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updateInterval\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"frontRunningInterval\",\"type\":\"uint256\"}],\"name\":\"isBeforeFrontRunningInterval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"number\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numerator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"denominator\",\"type\":\"uint256\"}],\"name\":\"mulFraction\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"x\",\"type\":\"bytes16\"},{\"internalType\":\"bytes16\",\"name\":\"y\",\"type\":\"bytes16\"}],\"name\":\"multiplyBytes\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"a\",\"type\":\"bytes16\"},{\"internalType\":\"uint256\",\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"multiplyDecimalByUInt\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"x\",\"type\":\"bytes16\"},{\"internalType\":\"bytes16\",\"name\":\"y\",\"type\":\"bytes16\"}],\"name\":\"subtractBytes\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"addBytes(bytes16,bytes16)\":{\"params\":{\"x\":\"The number to be added with `y`\",\"y\":\"The number to be added with `x`\"}},\"appropriateUpdateIntervalId(uint256,uint256,uint256,uint256,uint256)\":{\"details\":\"Note that the timestamp parameter is required to be >= lastPriceTimestamp\",\"params\":{\"currentUpdateIntervalId\":\"The current update interval's ID\",\"frontRunningInterval\":\"The frontrunning interval of a pool - The amount of time before an update interval that you must commit to get included in that update\",\"lastPriceTimestamp\":\"The timestamp of the last price update\",\"timestamp\":\"Current block.timestamp\",\"updateInterval\":\"The frequency of a pool's updates\"},\"returns\":{\"_0\":\"The update interval ID in which a commit being made at time timestamp should be included\"}},\"calculatePriceChange(PoolSwapLibrary.PriceChangeData)\":{\"details\":\"This function should be called by the LeveragedPool.\",\"params\":{\"priceChange\":\"The struct containing necessary data to calculate price change\"},\"returns\":{\"_0\":\"Resulting long balance\",\"_1\":\"Resulting short balance\",\"_2\":\"Resulting fees taken from long balance\",\"_3\":\"Resulting fees taken from short balance\"}},\"compareDecimals(bytes16,bytes16)\":{\"params\":{\"x\":\"The first number to compare\",\"y\":\"The second number to compare\"},\"returns\":{\"_0\":\"-1 if x < y, 0 if x = y, or 1 if x > y\"}},\"convertDecimalToUInt(bytes16)\":{\"params\":{\"ratio\":\"The value to convert\"},\"returns\":{\"_0\":\"The converted value\"}},\"convertUIntToDecimal(uint256)\":{\"params\":{\"amount\":\"The amount to convert\"},\"returns\":{\"_0\":\"The amount as a IEEE754 quadruple precision number\"}},\"divInt(int256,int256)\":{\"params\":{\"a\":\"The dividend\",\"b\":\"The divisor\"},\"returns\":{\"_0\":\"The quotient\"}},\"fromWad(uint256,uint256)\":{\"params\":{\"_decimals\":\"Quantity of decimal places to support\",\"_wadValue\":\"wad number\"},\"returns\":{\"_0\":\"Converted (non-WAD) value\"}},\"getBalancesAfterFees(uint256,uint256,uint256)\":{\"details\":\"Assumes shortBalance + longBalance >= reward\",\"params\":{\"longBalance\":\"Long balance of the pool\",\"reward\":\"Amount of keeper reward\",\"shortBalance\":\"Short balance of the pool\"},\"returns\":{\"_0\":\"shortBalanceAfterFees Short balance of the pool after the keeper reward has been paid\",\"_1\":\"longBalanceAfterFees Long balance of the pool after the keeper reward has been paid\"}},\"getBurn(bytes16,uint256)\":{\"details\":\"amount * price, where amount is in PoolToken and price is in USD/PoolTokenThrows if price is zero`getBurn()`\",\"params\":{\"amount\":\"Amount of pool tokens being used to burn\",\"price\":\"Price of a pool token\"},\"returns\":{\"_0\":\"Quantity of settlement tokens to return to the user after `amount` pool tokens are burnt.\"}},\"getLossAmount(bytes16,uint256)\":{\"params\":{\"balance\":\"The balance of the losing pool\",\"lossMultiplier\":\"The multiplier to use\"}},\"getLossMultiplier(bytes16,int8,bytes16)\":{\"params\":{\"direction\":\"The direction of the change. -1 if it's decreased, 0 if it hasn't changed, and 1 if it's increased\",\"leverage\":\"The amount of leverage to apply\",\"ratio\":\"The ratio of new price to old price\"},\"returns\":{\"_0\":\"The multiplier\"}},\"getMint(bytes16,uint256)\":{\"details\":\"Throws if price is zero`getMint()`\",\"params\":{\"amount\":\"Amount of settlement tokens being used to mint\",\"price\":\"Price of a pool token\"},\"returns\":{\"_0\":\"Quantity of pool tokens to mint\"}},\"getMintAmount(uint256,uint256,uint256,uint256)\":{\"details\":\"Calculated as (tokenSupply + shadowBalance) * amountIn / balance\",\"params\":{\"amountIn\":\"Commitment amount of settlement tokens going into the pool\",\"balance\":\"Balance of the pool (no. of underlying settlement tokens in pool)\",\"pendingBurnPoolTokens\":\"Amount of pool tokens being burnt during this update interval\",\"tokenSupply\":\"Total supply of pool tokens\"},\"returns\":{\"_0\":\"Number of pool tokens to be minted\"}},\"getMintWithBurns(bytes16,bytes16,uint256,uint256)\":{\"details\":\"Throws if price is zero\",\"params\":{\"amount\":\"The amount of settlement tokens being used to mint\",\"amountBurnedInstantMint\":\"The amount of pool tokens that were burnt from the opposite side for an instant mint in this side\",\"oppositePrice\":\"The price of the opposite side's pool token\",\"price\":\"The price of a pool token\"},\"returns\":{\"_0\":\"Quantity of pool tokens to mint\"}},\"getPrice(uint256,uint256)\":{\"details\":\"Divide the side balance by the pool token's total supply\",\"params\":{\"sideBalance\":\"no. of underlying settlement tokens on that side of the pool\",\"tokenSupply\":\"Total supply of pool tokens\"}},\"getRatio(uint256,uint256)\":{\"details\":\"Rounds any overflow towards 0. If either parameter is zero, the ratio is 0\",\"params\":{\"_denominator\":\"The \\\"per part\\\" side of the equation. If this is zero, the ratio is zero\",\"_numerator\":\"The \\\"parts per\\\" side of the equation. If this is zero, the ratio is zero\"},\"returns\":{\"_0\":\"the ratio, as an ABDKMathQuad number (IEEE 754 quadruple precision floating point)\"}},\"getUpdatedAggregateBalance(PoolSwapLibrary.UpdateData)\":{\"params\":{\"data\":\"Information needed for updating the balance including prices and recent commit amounts\"},\"returns\":{\"_longBurnFee\":\"Quantity of settlement tokens taken as a fee from long burns\",\"_newLongTokens\":\"Quantity of additional long tokens the user would receive\",\"_newSettlementTokens\":\"Quantity of additional settlement tokens the user would receive\",\"_newShortTokens\":\"Quantity of additional short tokens the user would receive\",\"_shortBurnFee\":\"Quantity of settlement tokens taken as a fee from short burns\"}},\"getWithdrawAmountOnBurn(uint256,uint256,uint256,uint256)\":{\"details\":\"Calculates as `balance * amountIn / (tokenSupply + shadowBalance)\",\"params\":{\"amountIn\":\"Commitment amount of pool tokens going into the pool\",\"balance\":\"Balance of the pool (no. of underlying settlement tokens in pool)\",\"pendingBurnPoolTokens\":\"Amount of pool tokens being burnt during this update interval\",\"tokenSupply\":\"Total supply of pool tokens\"},\"returns\":{\"_0\":\"Number of settlement tokens to be withdrawn on a burn\"}},\"isBeforeFrontRunningInterval(uint256,uint256,uint256,uint256)\":{\"params\":{\"frontRunningInterval\":\"The window of time before a price update in which users can have their commit executed from\",\"lastPriceTimestamp\":\"The timestamp of the last price update\",\"subjectTime\":\"The timestamp for which you want to calculate if it was beforeFrontRunningInterval\",\"updateInterval\":\"The interval between price updates\"}},\"mulFraction(uint256,uint256,uint256)\":{\"params\":{\"denominator\":\"The denominator of the fraction being multipled with `number`\",\"number\":\"The number with which the fraction calculated from `numerator` and `denominator` will be multiplied\",\"numerator\":\"The numerator of the fraction being multipled with `number`\"},\"returns\":{\"_0\":\"The result of multiplying number with numerator/denominator, as an integer\"}},\"multiplyBytes(bytes16,bytes16)\":{\"params\":{\"x\":\"The number to be multiplied by `y`\",\"y\":\"The number to be multiplied by `x`\"}},\"multiplyDecimalByUInt(bytes16,uint256)\":{\"params\":{\"a\":\"The first term\",\"b\":\"The second term\"},\"returns\":{\"_0\":\"The product of a*b as a decimal\"}},\"subtractBytes(bytes16,bytes16)\":{\"params\":{\"x\":\"The number to be subtracted by `y`\",\"y\":\"The number to subtract from `x`\"}}},\"title\":\"Library for various useful (mostly) mathematical functions\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"MAX_DECIMALS()\":{\"notice\":\"Maximum number of decimal places supported by this contract (ABDKMathQuad defines this but it's private)\"},\"ONE()\":{\"notice\":\"ABDKMathQuad-formatted representation of the number one\"},\"WAD_PRECISION()\":{\"notice\":\"Maximum precision supportable via wad arithmetic (for this contract)\"},\"addBytes(bytes16,bytes16)\":{\"notice\":\"Performs an addition on two bytes16 numbers\"},\"appropriateUpdateIntervalId(uint256,uint256,uint256,uint256,uint256)\":{\"notice\":\"Calculates the update interval ID that a commitment should be placed in.\"},\"calculatePriceChange(PoolSwapLibrary.PriceChangeData)\":{\"notice\":\"Calculates the effect of a price change. This involves calculating how many funds to transfer from the losing pool to the other.\"},\"compareDecimals(bytes16,bytes16)\":{\"notice\":\"Compares two decimal numbers\"},\"convertDecimalToUInt(bytes16)\":{\"notice\":\"Converts a raw decimal value to a more readable uint256 value\"},\"convertUIntToDecimal(uint256)\":{\"notice\":\"Converts an integer value to a compatible decimal value\"},\"divInt(int256,int256)\":{\"notice\":\"Divides two integers\"},\"fromWad(uint256,uint256)\":{\"notice\":\"Converts from a WAD to normal value\"},\"getBalancesAfterFees(uint256,uint256,uint256)\":{\"notice\":\"Gets the short and long balances after the keeper rewards have been paid out         Keeper rewards are paid proportionally to the short and long pool\"},\"getBurn(bytes16,uint256)\":{\"notice\":\"Calculate the number of settlement tokens to burn, based on a price and an amount of pool tokens\"},\"getLossAmount(bytes16,uint256)\":{\"notice\":\"Calculates the amount to take from the losing pool\"},\"getLossMultiplier(bytes16,int8,bytes16)\":{\"notice\":\"Calculates the loss multiplier to apply to the losing pool. Includes the power leverage\"},\"getMint(bytes16,uint256)\":{\"notice\":\"Calculates the number of pool tokens to mint, given some settlement token amount and a price\"},\"getMintAmount(uint256,uint256,uint256,uint256)\":{\"notice\":\"Gets the number of pool tokens to be minted based on existing tokens\"},\"getMintWithBurns(bytes16,bytes16,uint256,uint256)\":{\"notice\":\"Calculate the number of pool tokens to mint, given some settlement token amount, a price, and a burn amount from other side for instant mint\"},\"getPrice(uint256,uint256)\":{\"notice\":\"Get the Settlement/PoolToken price, in ABDK IEE754 precision\"},\"getRatio(uint256,uint256)\":{\"notice\":\"Calculates the ratio between two numbers\"},\"getUpdatedAggregateBalance(PoolSwapLibrary.UpdateData)\":{\"notice\":\"Calculate the change in a user's balance based on recent commit(s)\"},\"getWithdrawAmountOnBurn(uint256,uint256,uint256,uint256)\":{\"notice\":\"Gets the number of settlement tokens to be withdrawn based on a pool token burn amount\"},\"isBeforeFrontRunningInterval(uint256,uint256,uint256,uint256)\":{\"notice\":\"Returns true if the given timestamp is BEFORE the frontRunningInterval starts\"},\"mulFraction(uint256,uint256,uint256)\":{\"notice\":\"Multiply an integer by a fractionnumber * numerator / denominator\"},\"multiplyBytes(bytes16,bytes16)\":{\"notice\":\"Multiplies two numbers\"},\"multiplyDecimalByUInt(bytes16,uint256)\":{\"notice\":\"Multiplies a decimal and an unsigned integer\"},\"subtractBytes(bytes16,bytes16)\":{\"notice\":\"Performs a subtraction on two bytes16 numbers\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/libraries/PoolSwapLibrary.sol\":\"PoolSwapLibrary\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"abdk-libraries-solidity/ABDKMathQuad.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-4-Clause\\n/*\\n * ABDK Math Quad Smart Contract Library.  Copyright \\u00a9 2019 by ABDK Consulting.\\n * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\\n */\\npragma solidity ^0.8.0;\\n\\n/**\\n * Smart contract library of mathematical functions operating with IEEE 754\\n * quadruple-precision binary floating-point numbers (quadruple precision\\n * numbers).  As long as quadruple precision numbers are 16-bytes long, they are\\n * represented by bytes16 type.\\n */\\nlibrary ABDKMathQuad {\\n  /*\\n   * 0.\\n   */\\n  bytes16 private constant POSITIVE_ZERO = 0x00000000000000000000000000000000;\\n\\n  /*\\n   * -0.\\n   */\\n  bytes16 private constant NEGATIVE_ZERO = 0x80000000000000000000000000000000;\\n\\n  /*\\n   * +Infinity.\\n   */\\n  bytes16 private constant POSITIVE_INFINITY = 0x7FFF0000000000000000000000000000;\\n\\n  /*\\n   * -Infinity.\\n   */\\n  bytes16 private constant NEGATIVE_INFINITY = 0xFFFF0000000000000000000000000000;\\n\\n  /*\\n   * Canonical NaN value.\\n   */\\n  bytes16 private constant NaN = 0x7FFF8000000000000000000000000000;\\n\\n  /**\\n   * Convert signed 256-bit integer number into quadruple precision number.\\n   *\\n   * @param x signed 256-bit integer number\\n   * @return quadruple precision number\\n   */\\n  function fromInt (int256 x) internal pure returns (bytes16) {\\n    unchecked {\\n      if (x == 0) return bytes16 (0);\\n      else {\\n        // We rely on overflow behavior here\\n        uint256 result = uint256 (x > 0 ? x : -x);\\n\\n        uint256 msb = mostSignificantBit (result);\\n        if (msb < 112) result <<= 112 - msb;\\n        else if (msb > 112) result >>= msb - 112;\\n\\n        result = result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF | 16383 + msb << 112;\\n        if (x < 0) result |= 0x80000000000000000000000000000000;\\n\\n        return bytes16 (uint128 (result));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert quadruple precision number into signed 256-bit integer number\\n   * rounding towards zero.  Revert on overflow.\\n   *\\n   * @param x quadruple precision number\\n   * @return signed 256-bit integer number\\n   */\\n  function toInt (bytes16 x) internal pure returns (int256) {\\n    unchecked {\\n      uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\\n\\n      require (exponent <= 16638); // Overflow\\n      if (exponent < 16383) return 0; // Underflow\\n\\n      uint256 result = uint256 (uint128 (x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF |\\n        0x10000000000000000000000000000;\\n\\n      if (exponent < 16495) result >>= 16495 - exponent;\\n      else if (exponent > 16495) result <<= exponent - 16495;\\n\\n      if (uint128 (x) >= 0x80000000000000000000000000000000) { // Negative\\n        require (result <= 0x8000000000000000000000000000000000000000000000000000000000000000);\\n        return -int256 (result); // We rely on overflow behavior here\\n      } else {\\n        require (result <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n        return int256 (result);\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert unsigned 256-bit integer number into quadruple precision number.\\n   *\\n   * @param x unsigned 256-bit integer number\\n   * @return quadruple precision number\\n   */\\n  function fromUInt (uint256 x) internal pure returns (bytes16) {\\n    unchecked {\\n      if (x == 0) return bytes16 (0);\\n      else {\\n        uint256 result = x;\\n\\n        uint256 msb = mostSignificantBit (result);\\n        if (msb < 112) result <<= 112 - msb;\\n        else if (msb > 112) result >>= msb - 112;\\n\\n        result = result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF | 16383 + msb << 112;\\n\\n        return bytes16 (uint128 (result));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert quadruple precision number into unsigned 256-bit integer number\\n   * rounding towards zero.  Revert on underflow.  Note, that negative floating\\n   * point numbers in range (-1.0 .. 0.0) may be converted to unsigned integer\\n   * without error, because they are rounded to zero.\\n   *\\n   * @param x quadruple precision number\\n   * @return unsigned 256-bit integer number\\n   */\\n  function toUInt (bytes16 x) internal pure returns (uint256) {\\n    unchecked {\\n      uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\\n\\n      if (exponent < 16383) return 0; // Underflow\\n\\n      require (uint128 (x) < 0x80000000000000000000000000000000); // Negative\\n\\n      require (exponent <= 16638); // Overflow\\n      uint256 result = uint256 (uint128 (x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF |\\n        0x10000000000000000000000000000;\\n\\n      if (exponent < 16495) result >>= 16495 - exponent;\\n      else if (exponent > 16495) result <<= exponent - 16495;\\n\\n      return result;\\n    }\\n  }\\n\\n  /**\\n   * Convert signed 128.128 bit fixed point number into quadruple precision\\n   * number.\\n   *\\n   * @param x signed 128.128 bit fixed point number\\n   * @return quadruple precision number\\n   */\\n  function from128x128 (int256 x) internal pure returns (bytes16) {\\n    unchecked {\\n      if (x == 0) return bytes16 (0);\\n      else {\\n        // We rely on overflow behavior here\\n        uint256 result = uint256 (x > 0 ? x : -x);\\n\\n        uint256 msb = mostSignificantBit (result);\\n        if (msb < 112) result <<= 112 - msb;\\n        else if (msb > 112) result >>= msb - 112;\\n\\n        result = result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF | 16255 + msb << 112;\\n        if (x < 0) result |= 0x80000000000000000000000000000000;\\n\\n        return bytes16 (uint128 (result));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert quadruple precision number into signed 128.128 bit fixed point\\n   * number.  Revert on overflow.\\n   *\\n   * @param x quadruple precision number\\n   * @return signed 128.128 bit fixed point number\\n   */\\n  function to128x128 (bytes16 x) internal pure returns (int256) {\\n    unchecked {\\n      uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\\n\\n      require (exponent <= 16510); // Overflow\\n      if (exponent < 16255) return 0; // Underflow\\n\\n      uint256 result = uint256 (uint128 (x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF |\\n        0x10000000000000000000000000000;\\n\\n      if (exponent < 16367) result >>= 16367 - exponent;\\n      else if (exponent > 16367) result <<= exponent - 16367;\\n\\n      if (uint128 (x) >= 0x80000000000000000000000000000000) { // Negative\\n        require (result <= 0x8000000000000000000000000000000000000000000000000000000000000000);\\n        return -int256 (result); // We rely on overflow behavior here\\n      } else {\\n        require (result <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n        return int256 (result);\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert signed 64.64 bit fixed point number into quadruple precision\\n   * number.\\n   *\\n   * @param x signed 64.64 bit fixed point number\\n   * @return quadruple precision number\\n   */\\n  function from64x64 (int128 x) internal pure returns (bytes16) {\\n    unchecked {\\n      if (x == 0) return bytes16 (0);\\n      else {\\n        // We rely on overflow behavior here\\n        uint256 result = uint128 (x > 0 ? x : -x);\\n\\n        uint256 msb = mostSignificantBit (result);\\n        if (msb < 112) result <<= 112 - msb;\\n        else if (msb > 112) result >>= msb - 112;\\n\\n        result = result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF | 16319 + msb << 112;\\n        if (x < 0) result |= 0x80000000000000000000000000000000;\\n\\n        return bytes16 (uint128 (result));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert quadruple precision number into signed 64.64 bit fixed point\\n   * number.  Revert on overflow.\\n   *\\n   * @param x quadruple precision number\\n   * @return signed 64.64 bit fixed point number\\n   */\\n  function to64x64 (bytes16 x) internal pure returns (int128) {\\n    unchecked {\\n      uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\\n\\n      require (exponent <= 16446); // Overflow\\n      if (exponent < 16319) return 0; // Underflow\\n\\n      uint256 result = uint256 (uint128 (x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF |\\n        0x10000000000000000000000000000;\\n\\n      if (exponent < 16431) result >>= 16431 - exponent;\\n      else if (exponent > 16431) result <<= exponent - 16431;\\n\\n      if (uint128 (x) >= 0x80000000000000000000000000000000) { // Negative\\n        require (result <= 0x80000000000000000000000000000000);\\n        return -int128 (int256 (result)); // We rely on overflow behavior here\\n      } else {\\n        require (result <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n        return int128 (int256 (result));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert octuple precision number into quadruple precision number.\\n   *\\n   * @param x octuple precision number\\n   * @return quadruple precision number\\n   */\\n  function fromOctuple (bytes32 x) internal pure returns (bytes16) {\\n    unchecked {\\n      bool negative = x & 0x8000000000000000000000000000000000000000000000000000000000000000 > 0;\\n\\n      uint256 exponent = uint256 (x) >> 236 & 0x7FFFF;\\n      uint256 significand = uint256 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      if (exponent == 0x7FFFF) {\\n        if (significand > 0) return NaN;\\n        else return negative ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\\n      }\\n\\n      if (exponent > 278526)\\n        return negative ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\\n      else if (exponent < 245649)\\n        return negative ? NEGATIVE_ZERO : POSITIVE_ZERO;\\n      else if (exponent < 245761) {\\n        significand = (significand | 0x100000000000000000000000000000000000000000000000000000000000) >> 245885 - exponent;\\n        exponent = 0;\\n      } else {\\n        significand >>= 124;\\n        exponent -= 245760;\\n      }\\n\\n      uint128 result = uint128 (significand | exponent << 112);\\n      if (negative) result |= 0x80000000000000000000000000000000;\\n\\n      return bytes16 (result);\\n    }\\n  }\\n\\n  /**\\n   * Convert quadruple precision number into octuple precision number.\\n   *\\n   * @param x quadruple precision number\\n   * @return octuple precision number\\n   */\\n  function toOctuple (bytes16 x) internal pure returns (bytes32) {\\n    unchecked {\\n      uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\\n\\n      uint256 result = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      if (exponent == 0x7FFF) exponent = 0x7FFFF; // Infinity or NaN\\n      else if (exponent == 0) {\\n        if (result > 0) {\\n          uint256 msb = mostSignificantBit (result);\\n          result = result << 236 - msb & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n          exponent = 245649 + msb;\\n        }\\n      } else {\\n        result <<= 124;\\n        exponent += 245760;\\n      }\\n\\n      result |= exponent << 236;\\n      if (uint128 (x) >= 0x80000000000000000000000000000000)\\n        result |= 0x8000000000000000000000000000000000000000000000000000000000000000;\\n\\n      return bytes32 (result);\\n    }\\n  }\\n\\n  /**\\n   * Convert double precision number into quadruple precision number.\\n   *\\n   * @param x double precision number\\n   * @return quadruple precision number\\n   */\\n  function fromDouble (bytes8 x) internal pure returns (bytes16) {\\n    unchecked {\\n      uint256 exponent = uint64 (x) >> 52 & 0x7FF;\\n\\n      uint256 result = uint64 (x) & 0xFFFFFFFFFFFFF;\\n\\n      if (exponent == 0x7FF) exponent = 0x7FFF; // Infinity or NaN\\n      else if (exponent == 0) {\\n        if (result > 0) {\\n          uint256 msb = mostSignificantBit (result);\\n          result = result << 112 - msb & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n          exponent = 15309 + msb;\\n        }\\n      } else {\\n        result <<= 60;\\n        exponent += 15360;\\n      }\\n\\n      result |= exponent << 112;\\n      if (x & 0x8000000000000000 > 0)\\n        result |= 0x80000000000000000000000000000000;\\n\\n      return bytes16 (uint128 (result));\\n    }\\n  }\\n\\n  /**\\n   * Convert quadruple precision number into double precision number.\\n   *\\n   * @param x quadruple precision number\\n   * @return double precision number\\n   */\\n  function toDouble (bytes16 x) internal pure returns (bytes8) {\\n    unchecked {\\n      bool negative = uint128 (x) >= 0x80000000000000000000000000000000;\\n\\n      uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\\n      uint256 significand = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      if (exponent == 0x7FFF) {\\n        if (significand > 0) return 0x7FF8000000000000; // NaN\\n        else return negative ?\\n            bytes8 (0xFFF0000000000000) : // -Infinity\\n            bytes8 (0x7FF0000000000000); // Infinity\\n      }\\n\\n      if (exponent > 17406)\\n        return negative ?\\n            bytes8 (0xFFF0000000000000) : // -Infinity\\n            bytes8 (0x7FF0000000000000); // Infinity\\n      else if (exponent < 15309)\\n        return negative ?\\n            bytes8 (0x8000000000000000) : // -0\\n            bytes8 (0x0000000000000000); // 0\\n      else if (exponent < 15361) {\\n        significand = (significand | 0x10000000000000000000000000000) >> 15421 - exponent;\\n        exponent = 0;\\n      } else {\\n        significand >>= 60;\\n        exponent -= 15360;\\n      }\\n\\n      uint64 result = uint64 (significand | exponent << 52);\\n      if (negative) result |= 0x8000000000000000;\\n\\n      return bytes8 (result);\\n    }\\n  }\\n\\n  /**\\n   * Test whether given quadruple precision number is NaN.\\n   *\\n   * @param x quadruple precision number\\n   * @return true if x is NaN, false otherwise\\n   */\\n  function isNaN (bytes16 x) internal pure returns (bool) {\\n    unchecked {\\n      return uint128 (x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF >\\n        0x7FFF0000000000000000000000000000;\\n    }\\n  }\\n\\n  /**\\n   * Test whether given quadruple precision number is positive or negative\\n   * infinity.\\n   *\\n   * @param x quadruple precision number\\n   * @return true if x is positive or negative infinity, false otherwise\\n   */\\n  function isInfinity (bytes16 x) internal pure returns (bool) {\\n    unchecked {\\n      return uint128 (x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF ==\\n        0x7FFF0000000000000000000000000000;\\n    }\\n  }\\n\\n  /**\\n   * Calculate sign of x, i.e. -1 if x is negative, 0 if x if zero, and 1 if x\\n   * is positive.  Note that sign (-0) is zero.  Revert if x is NaN. \\n   *\\n   * @param x quadruple precision number\\n   * @return sign of x\\n   */\\n  function sign (bytes16 x) internal pure returns (int8) {\\n    unchecked {\\n      uint128 absoluteX = uint128 (x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      require (absoluteX <= 0x7FFF0000000000000000000000000000); // Not NaN\\n\\n      if (absoluteX == 0) return 0;\\n      else if (uint128 (x) >= 0x80000000000000000000000000000000) return -1;\\n      else return 1;\\n    }\\n  }\\n\\n  /**\\n   * Calculate sign (x - y).  Revert if either argument is NaN, or both\\n   * arguments are infinities of the same sign. \\n   *\\n   * @param x quadruple precision number\\n   * @param y quadruple precision number\\n   * @return sign (x - y)\\n   */\\n  function cmp (bytes16 x, bytes16 y) internal pure returns (int8) {\\n    unchecked {\\n      uint128 absoluteX = uint128 (x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      require (absoluteX <= 0x7FFF0000000000000000000000000000); // Not NaN\\n\\n      uint128 absoluteY = uint128 (y) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      require (absoluteY <= 0x7FFF0000000000000000000000000000); // Not NaN\\n\\n      // Not infinities of the same sign\\n      require (x != y || absoluteX < 0x7FFF0000000000000000000000000000);\\n\\n      if (x == y) return 0;\\n      else {\\n        bool negativeX = uint128 (x) >= 0x80000000000000000000000000000000;\\n        bool negativeY = uint128 (y) >= 0x80000000000000000000000000000000;\\n\\n        if (negativeX) {\\n          if (negativeY) return absoluteX > absoluteY ? -1 : int8 (1);\\n          else return -1; \\n        } else {\\n          if (negativeY) return 1;\\n          else return absoluteX > absoluteY ? int8 (1) : -1;\\n        }\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Test whether x equals y.  NaN, infinity, and -infinity are not equal to\\n   * anything. \\n   *\\n   * @param x quadruple precision number\\n   * @param y quadruple precision number\\n   * @return true if x equals to y, false otherwise\\n   */\\n  function eq (bytes16 x, bytes16 y) internal pure returns (bool) {\\n    unchecked {\\n      if (x == y) {\\n        return uint128 (x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF <\\n          0x7FFF0000000000000000000000000000;\\n      } else return false;\\n    }\\n  }\\n\\n  /**\\n   * Calculate x + y.  Special values behave in the following way:\\n   *\\n   * NaN + x = NaN for any x.\\n   * Infinity + x = Infinity for any finite x.\\n   * -Infinity + x = -Infinity for any finite x.\\n   * Infinity + Infinity = Infinity.\\n   * -Infinity + -Infinity = -Infinity.\\n   * Infinity + -Infinity = -Infinity + Infinity = NaN.\\n   *\\n   * @param x quadruple precision number\\n   * @param y quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function add (bytes16 x, bytes16 y) internal pure returns (bytes16) {\\n    unchecked {\\n      uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\\n      uint256 yExponent = uint128 (y) >> 112 & 0x7FFF;\\n\\n      if (xExponent == 0x7FFF) {\\n        if (yExponent == 0x7FFF) { \\n          if (x == y) return x;\\n          else return NaN;\\n        } else return x; \\n      } else if (yExponent == 0x7FFF) return y;\\n      else {\\n        bool xSign = uint128 (x) >= 0x80000000000000000000000000000000;\\n        uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (xExponent == 0) xExponent = 1;\\n        else xSignifier |= 0x10000000000000000000000000000;\\n\\n        bool ySign = uint128 (y) >= 0x80000000000000000000000000000000;\\n        uint256 ySignifier = uint128 (y) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (yExponent == 0) yExponent = 1;\\n        else ySignifier |= 0x10000000000000000000000000000;\\n\\n        if (xSignifier == 0) return y == NEGATIVE_ZERO ? POSITIVE_ZERO : y;\\n        else if (ySignifier == 0) return x == NEGATIVE_ZERO ? POSITIVE_ZERO : x;\\n        else {\\n          int256 delta = int256 (xExponent) - int256 (yExponent);\\n  \\n          if (xSign == ySign) {\\n            if (delta > 112) return x;\\n            else if (delta > 0) ySignifier >>= uint256 (delta);\\n            else if (delta < -112) return y;\\n            else if (delta < 0) {\\n              xSignifier >>= uint256 (-delta);\\n              xExponent = yExponent;\\n            }\\n  \\n            xSignifier += ySignifier;\\n  \\n            if (xSignifier >= 0x20000000000000000000000000000) {\\n              xSignifier >>= 1;\\n              xExponent += 1;\\n            }\\n  \\n            if (xExponent == 0x7FFF)\\n              return xSign ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\\n            else {\\n              if (xSignifier < 0x10000000000000000000000000000) xExponent = 0;\\n              else xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n  \\n              return bytes16 (uint128 (\\n                  (xSign ? 0x80000000000000000000000000000000 : 0) |\\n                  (xExponent << 112) |\\n                  xSignifier)); \\n            }\\n          } else {\\n            if (delta > 0) {\\n              xSignifier <<= 1;\\n              xExponent -= 1;\\n            } else if (delta < 0) {\\n              ySignifier <<= 1;\\n              xExponent = yExponent - 1;\\n            }\\n\\n            if (delta > 112) ySignifier = 1;\\n            else if (delta > 1) ySignifier = (ySignifier - 1 >> uint256 (delta - 1)) + 1;\\n            else if (delta < -112) xSignifier = 1;\\n            else if (delta < -1) xSignifier = (xSignifier - 1 >> uint256 (-delta - 1)) + 1;\\n\\n            if (xSignifier >= ySignifier) xSignifier -= ySignifier;\\n            else {\\n              xSignifier = ySignifier - xSignifier;\\n              xSign = ySign;\\n            }\\n\\n            if (xSignifier == 0)\\n              return POSITIVE_ZERO;\\n\\n            uint256 msb = mostSignificantBit (xSignifier);\\n\\n            if (msb == 113) {\\n              xSignifier = xSignifier >> 1 & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n              xExponent += 1;\\n            } else if (msb < 112) {\\n              uint256 shift = 112 - msb;\\n              if (xExponent > shift) {\\n                xSignifier = xSignifier << shift & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n                xExponent -= shift;\\n              } else {\\n                xSignifier <<= xExponent - 1;\\n                xExponent = 0;\\n              }\\n            } else xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n            if (xExponent == 0x7FFF)\\n              return xSign ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\\n            else return bytes16 (uint128 (\\n                (xSign ? 0x80000000000000000000000000000000 : 0) |\\n                (xExponent << 112) |\\n                xSignifier));\\n          }\\n        }\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate x - y.  Special values behave in the following way:\\n   *\\n   * NaN - x = NaN for any x.\\n   * Infinity - x = Infinity for any finite x.\\n   * -Infinity - x = -Infinity for any finite x.\\n   * Infinity - -Infinity = Infinity.\\n   * -Infinity - Infinity = -Infinity.\\n   * Infinity - Infinity = -Infinity - -Infinity = NaN.\\n   *\\n   * @param x quadruple precision number\\n   * @param y quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function sub (bytes16 x, bytes16 y) internal pure returns (bytes16) {\\n    unchecked {\\n      return add (x, y ^ 0x80000000000000000000000000000000);\\n    }\\n  }\\n\\n  /**\\n   * Calculate x * y.  Special values behave in the following way:\\n   *\\n   * NaN * x = NaN for any x.\\n   * Infinity * x = Infinity for any finite positive x.\\n   * Infinity * x = -Infinity for any finite negative x.\\n   * -Infinity * x = -Infinity for any finite positive x.\\n   * -Infinity * x = Infinity for any finite negative x.\\n   * Infinity * 0 = NaN.\\n   * -Infinity * 0 = NaN.\\n   * Infinity * Infinity = Infinity.\\n   * Infinity * -Infinity = -Infinity.\\n   * -Infinity * Infinity = -Infinity.\\n   * -Infinity * -Infinity = Infinity.\\n   *\\n   * @param x quadruple precision number\\n   * @param y quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function mul (bytes16 x, bytes16 y) internal pure returns (bytes16) {\\n    unchecked {\\n      uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\\n      uint256 yExponent = uint128 (y) >> 112 & 0x7FFF;\\n\\n      if (xExponent == 0x7FFF) {\\n        if (yExponent == 0x7FFF) {\\n          if (x == y) return x ^ y & 0x80000000000000000000000000000000;\\n          else if (x ^ y == 0x80000000000000000000000000000000) return x | y;\\n          else return NaN;\\n        } else {\\n          if (y & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) return NaN;\\n          else return x ^ y & 0x80000000000000000000000000000000;\\n        }\\n      } else if (yExponent == 0x7FFF) {\\n          if (x & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) return NaN;\\n          else return y ^ x & 0x80000000000000000000000000000000;\\n      } else {\\n        uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (xExponent == 0) xExponent = 1;\\n        else xSignifier |= 0x10000000000000000000000000000;\\n\\n        uint256 ySignifier = uint128 (y) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (yExponent == 0) yExponent = 1;\\n        else ySignifier |= 0x10000000000000000000000000000;\\n\\n        xSignifier *= ySignifier;\\n        if (xSignifier == 0)\\n          return (x ^ y) & 0x80000000000000000000000000000000 > 0 ?\\n              NEGATIVE_ZERO : POSITIVE_ZERO;\\n\\n        xExponent += yExponent;\\n\\n        uint256 msb =\\n          xSignifier >= 0x200000000000000000000000000000000000000000000000000000000 ? 225 :\\n          xSignifier >= 0x100000000000000000000000000000000000000000000000000000000 ? 224 :\\n          mostSignificantBit (xSignifier);\\n\\n        if (xExponent + msb < 16496) { // Underflow\\n          xExponent = 0;\\n          xSignifier = 0;\\n        } else if (xExponent + msb < 16608) { // Subnormal\\n          if (xExponent < 16496)\\n            xSignifier >>= 16496 - xExponent;\\n          else if (xExponent > 16496)\\n            xSignifier <<= xExponent - 16496;\\n          xExponent = 0;\\n        } else if (xExponent + msb > 49373) {\\n          xExponent = 0x7FFF;\\n          xSignifier = 0;\\n        } else {\\n          if (msb > 112)\\n            xSignifier >>= msb - 112;\\n          else if (msb < 112)\\n            xSignifier <<= 112 - msb;\\n\\n          xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n          xExponent = xExponent + msb - 16607;\\n        }\\n\\n        return bytes16 (uint128 (uint128 ((x ^ y) & 0x80000000000000000000000000000000) |\\n            xExponent << 112 | xSignifier));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate x / y.  Special values behave in the following way:\\n   *\\n   * NaN / x = NaN for any x.\\n   * x / NaN = NaN for any x.\\n   * Infinity / x = Infinity for any finite non-negative x.\\n   * Infinity / x = -Infinity for any finite negative x including -0.\\n   * -Infinity / x = -Infinity for any finite non-negative x.\\n   * -Infinity / x = Infinity for any finite negative x including -0.\\n   * x / Infinity = 0 for any finite non-negative x.\\n   * x / -Infinity = -0 for any finite non-negative x.\\n   * x / Infinity = -0 for any finite non-negative x including -0.\\n   * x / -Infinity = 0 for any finite non-negative x including -0.\\n   * \\n   * Infinity / Infinity = NaN.\\n   * Infinity / -Infinity = -NaN.\\n   * -Infinity / Infinity = -NaN.\\n   * -Infinity / -Infinity = NaN.\\n   *\\n   * Division by zero behaves in the following way:\\n   *\\n   * x / 0 = Infinity for any finite positive x.\\n   * x / -0 = -Infinity for any finite positive x.\\n   * x / 0 = -Infinity for any finite negative x.\\n   * x / -0 = Infinity for any finite negative x.\\n   * 0 / 0 = NaN.\\n   * 0 / -0 = NaN.\\n   * -0 / 0 = NaN.\\n   * -0 / -0 = NaN.\\n   *\\n   * @param x quadruple precision number\\n   * @param y quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function div (bytes16 x, bytes16 y) internal pure returns (bytes16) {\\n    unchecked {\\n      uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\\n      uint256 yExponent = uint128 (y) >> 112 & 0x7FFF;\\n\\n      if (xExponent == 0x7FFF) {\\n        if (yExponent == 0x7FFF) return NaN;\\n        else return x ^ y & 0x80000000000000000000000000000000;\\n      } else if (yExponent == 0x7FFF) {\\n        if (y & 0x0000FFFFFFFFFFFFFFFFFFFFFFFFFFFF != 0) return NaN;\\n        else return POSITIVE_ZERO | (x ^ y) & 0x80000000000000000000000000000000;\\n      } else if (y & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) {\\n        if (x & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) return NaN;\\n        else return POSITIVE_INFINITY | (x ^ y) & 0x80000000000000000000000000000000;\\n      } else {\\n        uint256 ySignifier = uint128 (y) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (yExponent == 0) yExponent = 1;\\n        else ySignifier |= 0x10000000000000000000000000000;\\n\\n        uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (xExponent == 0) {\\n          if (xSignifier != 0) {\\n            uint shift = 226 - mostSignificantBit (xSignifier);\\n\\n            xSignifier <<= shift;\\n\\n            xExponent = 1;\\n            yExponent += shift - 114;\\n          }\\n        }\\n        else {\\n          xSignifier = (xSignifier | 0x10000000000000000000000000000) << 114;\\n        }\\n\\n        xSignifier = xSignifier / ySignifier;\\n        if (xSignifier == 0)\\n          return (x ^ y) & 0x80000000000000000000000000000000 > 0 ?\\n              NEGATIVE_ZERO : POSITIVE_ZERO;\\n\\n        assert (xSignifier >= 0x1000000000000000000000000000);\\n\\n        uint256 msb =\\n          xSignifier >= 0x80000000000000000000000000000 ? mostSignificantBit (xSignifier) :\\n          xSignifier >= 0x40000000000000000000000000000 ? 114 :\\n          xSignifier >= 0x20000000000000000000000000000 ? 113 : 112;\\n\\n        if (xExponent + msb > yExponent + 16497) { // Overflow\\n          xExponent = 0x7FFF;\\n          xSignifier = 0;\\n        } else if (xExponent + msb + 16380  < yExponent) { // Underflow\\n          xExponent = 0;\\n          xSignifier = 0;\\n        } else if (xExponent + msb + 16268  < yExponent) { // Subnormal\\n          if (xExponent + 16380 > yExponent)\\n            xSignifier <<= xExponent + 16380 - yExponent;\\n          else if (xExponent + 16380 < yExponent)\\n            xSignifier >>= yExponent - xExponent - 16380;\\n\\n          xExponent = 0;\\n        } else { // Normal\\n          if (msb > 112)\\n            xSignifier >>= msb - 112;\\n\\n          xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n          xExponent = xExponent + msb + 16269 - yExponent;\\n        }\\n\\n        return bytes16 (uint128 (uint128 ((x ^ y) & 0x80000000000000000000000000000000) |\\n            xExponent << 112 | xSignifier));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate -x.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function neg (bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      return x ^ 0x80000000000000000000000000000000;\\n    }\\n  }\\n\\n  /**\\n   * Calculate |x|.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function abs (bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      return x & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n    }\\n  }\\n\\n  /**\\n   * Calculate square root of x.  Return NaN on negative x excluding -0.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function sqrt (bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      if (uint128 (x) >  0x80000000000000000000000000000000) return NaN;\\n      else {\\n        uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\\n        if (xExponent == 0x7FFF) return x;\\n        else {\\n          uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n          if (xExponent == 0) xExponent = 1;\\n          else xSignifier |= 0x10000000000000000000000000000;\\n\\n          if (xSignifier == 0) return POSITIVE_ZERO;\\n\\n          bool oddExponent = xExponent & 0x1 == 0;\\n          xExponent = xExponent + 16383 >> 1;\\n\\n          if (oddExponent) {\\n            if (xSignifier >= 0x10000000000000000000000000000)\\n              xSignifier <<= 113;\\n            else {\\n              uint256 msb = mostSignificantBit (xSignifier);\\n              uint256 shift = (226 - msb) & 0xFE;\\n              xSignifier <<= shift;\\n              xExponent -= shift - 112 >> 1;\\n            }\\n          } else {\\n            if (xSignifier >= 0x10000000000000000000000000000)\\n              xSignifier <<= 112;\\n            else {\\n              uint256 msb = mostSignificantBit (xSignifier);\\n              uint256 shift = (225 - msb) & 0xFE;\\n              xSignifier <<= shift;\\n              xExponent -= shift - 112 >> 1;\\n            }\\n          }\\n\\n          uint256 r = 0x10000000000000000000000000000;\\n          r = (r + xSignifier / r) >> 1;\\n          r = (r + xSignifier / r) >> 1;\\n          r = (r + xSignifier / r) >> 1;\\n          r = (r + xSignifier / r) >> 1;\\n          r = (r + xSignifier / r) >> 1;\\n          r = (r + xSignifier / r) >> 1;\\n          r = (r + xSignifier / r) >> 1; // Seven iterations should be enough\\n          uint256 r1 = xSignifier / r;\\n          if (r1 < r) r = r1;\\n\\n          return bytes16 (uint128 (xExponent << 112 | r & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF));\\n        }\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate binary logarithm of x.  Return NaN on negative x excluding -0.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function log_2 (bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      if (uint128 (x) > 0x80000000000000000000000000000000) return NaN;\\n      else if (x == 0x3FFF0000000000000000000000000000) return POSITIVE_ZERO; \\n      else {\\n        uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\\n        if (xExponent == 0x7FFF) return x;\\n        else {\\n          uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n          if (xExponent == 0) xExponent = 1;\\n          else xSignifier |= 0x10000000000000000000000000000;\\n\\n          if (xSignifier == 0) return NEGATIVE_INFINITY;\\n\\n          bool resultNegative;\\n          uint256 resultExponent = 16495;\\n          uint256 resultSignifier;\\n\\n          if (xExponent >= 0x3FFF) {\\n            resultNegative = false;\\n            resultSignifier = xExponent - 0x3FFF;\\n            xSignifier <<= 15;\\n          } else {\\n            resultNegative = true;\\n            if (xSignifier >= 0x10000000000000000000000000000) {\\n              resultSignifier = 0x3FFE - xExponent;\\n              xSignifier <<= 15;\\n            } else {\\n              uint256 msb = mostSignificantBit (xSignifier);\\n              resultSignifier = 16493 - msb;\\n              xSignifier <<= 127 - msb;\\n            }\\n          }\\n\\n          if (xSignifier == 0x80000000000000000000000000000000) {\\n            if (resultNegative) resultSignifier += 1;\\n            uint256 shift = 112 - mostSignificantBit (resultSignifier);\\n            resultSignifier <<= shift;\\n            resultExponent -= shift;\\n          } else {\\n            uint256 bb = resultNegative ? 1 : 0;\\n            while (resultSignifier < 0x10000000000000000000000000000) {\\n              resultSignifier <<= 1;\\n              resultExponent -= 1;\\n  \\n              xSignifier *= xSignifier;\\n              uint256 b = xSignifier >> 255;\\n              resultSignifier += b ^ bb;\\n              xSignifier >>= 127 + b;\\n            }\\n          }\\n\\n          return bytes16 (uint128 ((resultNegative ? 0x80000000000000000000000000000000 : 0) |\\n              resultExponent << 112 | resultSignifier & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF));\\n        }\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate natural logarithm of x.  Return NaN on negative x excluding -0.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function ln (bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      return mul (log_2 (x), 0x3FFE62E42FEFA39EF35793C7673007E5);\\n    }\\n  }\\n\\n  /**\\n   * Calculate 2^x.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function pow_2 (bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      bool xNegative = uint128 (x) > 0x80000000000000000000000000000000;\\n      uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\\n      uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      if (xExponent == 0x7FFF && xSignifier != 0) return NaN;\\n      else if (xExponent > 16397)\\n        return xNegative ? POSITIVE_ZERO : POSITIVE_INFINITY;\\n      else if (xExponent < 16255)\\n        return 0x3FFF0000000000000000000000000000;\\n      else {\\n        if (xExponent == 0) xExponent = 1;\\n        else xSignifier |= 0x10000000000000000000000000000;\\n\\n        if (xExponent > 16367)\\n          xSignifier <<= xExponent - 16367;\\n        else if (xExponent < 16367)\\n          xSignifier >>= 16367 - xExponent;\\n\\n        if (xNegative && xSignifier > 0x406E00000000000000000000000000000000)\\n          return POSITIVE_ZERO;\\n\\n        if (!xNegative && xSignifier > 0x3FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\\n          return POSITIVE_INFINITY;\\n\\n        uint256 resultExponent = xSignifier >> 128;\\n        xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (xNegative && xSignifier != 0) {\\n          xSignifier = ~xSignifier;\\n          resultExponent += 1;\\n        }\\n\\n        uint256 resultSignifier = 0x80000000000000000000000000000000;\\n        if (xSignifier & 0x80000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x16A09E667F3BCC908B2FB1366EA957D3E >> 128;\\n        if (xSignifier & 0x40000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1306FE0A31B7152DE8D5A46305C85EDEC >> 128;\\n        if (xSignifier & 0x20000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1172B83C7D517ADCDF7C8C50EB14A791F >> 128;\\n        if (xSignifier & 0x10000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10B5586CF9890F6298B92B71842A98363 >> 128;\\n        if (xSignifier & 0x8000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1059B0D31585743AE7C548EB68CA417FD >> 128;\\n        if (xSignifier & 0x4000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x102C9A3E778060EE6F7CACA4F7A29BDE8 >> 128;\\n        if (xSignifier & 0x2000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10163DA9FB33356D84A66AE336DCDFA3F >> 128;\\n        if (xSignifier & 0x1000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100B1AFA5ABCBED6129AB13EC11DC9543 >> 128;\\n        if (xSignifier & 0x800000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10058C86DA1C09EA1FF19D294CF2F679B >> 128;\\n        if (xSignifier & 0x400000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1002C605E2E8CEC506D21BFC89A23A00F >> 128;\\n        if (xSignifier & 0x200000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100162F3904051FA128BCA9C55C31E5DF >> 128;\\n        if (xSignifier & 0x100000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000B175EFFDC76BA38E31671CA939725 >> 128;\\n        if (xSignifier & 0x80000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100058BA01FB9F96D6CACD4B180917C3D >> 128;\\n        if (xSignifier & 0x40000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10002C5CC37DA9491D0985C348C68E7B3 >> 128;\\n        if (xSignifier & 0x20000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000162E525EE054754457D5995292026 >> 128;\\n        if (xSignifier & 0x10000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000B17255775C040618BF4A4ADE83FC >> 128;\\n        if (xSignifier & 0x8000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000058B91B5BC9AE2EED81E9B7D4CFAB >> 128;\\n        if (xSignifier & 0x4000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100002C5C89D5EC6CA4D7C8ACC017B7C9 >> 128;\\n        if (xSignifier & 0x2000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000162E43F4F831060E02D839A9D16D >> 128;\\n        if (xSignifier & 0x1000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000B1721BCFC99D9F890EA06911763 >> 128;\\n        if (xSignifier & 0x800000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000058B90CF1E6D97F9CA14DBCC1628 >> 128;\\n        if (xSignifier & 0x400000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000002C5C863B73F016468F6BAC5CA2B >> 128;\\n        if (xSignifier & 0x200000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000162E430E5A18F6119E3C02282A5 >> 128;\\n        if (xSignifier & 0x100000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000B1721835514B86E6D96EFD1BFE >> 128;\\n        if (xSignifier & 0x80000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000058B90C0B48C6BE5DF846C5B2EF >> 128;\\n        if (xSignifier & 0x40000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000002C5C8601CC6B9E94213C72737A >> 128;\\n        if (xSignifier & 0x20000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000162E42FFF037DF38AA2B219F06 >> 128;\\n        if (xSignifier & 0x10000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000B17217FBA9C739AA5819F44F9 >> 128;\\n        if (xSignifier & 0x8000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000058B90BFCDEE5ACD3C1CEDC823 >> 128;\\n        if (xSignifier & 0x4000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000002C5C85FE31F35A6A30DA1BE50 >> 128;\\n        if (xSignifier & 0x2000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000162E42FF0999CE3541B9FFFCF >> 128;\\n        if (xSignifier & 0x1000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000B17217F80F4EF5AADDA45554 >> 128;\\n        if (xSignifier & 0x800000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000058B90BFBF8479BD5A81B51AD >> 128;\\n        if (xSignifier & 0x400000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000002C5C85FDF84BD62AE30A74CC >> 128;\\n        if (xSignifier & 0x200000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000162E42FEFB2FED257559BDAA >> 128;\\n        if (xSignifier & 0x100000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000B17217F7D5A7716BBA4A9AE >> 128;\\n        if (xSignifier & 0x80000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000058B90BFBE9DDBAC5E109CCE >> 128;\\n        if (xSignifier & 0x40000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000002C5C85FDF4B15DE6F17EB0D >> 128;\\n        if (xSignifier & 0x20000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000162E42FEFA494F1478FDE05 >> 128;\\n        if (xSignifier & 0x10000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000B17217F7D20CF927C8E94C >> 128;\\n        if (xSignifier & 0x8000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000058B90BFBE8F71CB4E4B33D >> 128;\\n        if (xSignifier & 0x4000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000002C5C85FDF477B662B26945 >> 128;\\n        if (xSignifier & 0x2000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000162E42FEFA3AE53369388C >> 128;\\n        if (xSignifier & 0x1000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000B17217F7D1D351A389D40 >> 128;\\n        if (xSignifier & 0x800000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000058B90BFBE8E8B2D3D4EDE >> 128;\\n        if (xSignifier & 0x400000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000002C5C85FDF4741BEA6E77E >> 128;\\n        if (xSignifier & 0x200000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000162E42FEFA39FE95583C2 >> 128;\\n        if (xSignifier & 0x100000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000B17217F7D1CFB72B45E1 >> 128;\\n        if (xSignifier & 0x80000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000058B90BFBE8E7CC35C3F0 >> 128;\\n        if (xSignifier & 0x40000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000002C5C85FDF473E242EA38 >> 128;\\n        if (xSignifier & 0x20000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000162E42FEFA39F02B772C >> 128;\\n        if (xSignifier & 0x10000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000B17217F7D1CF7D83C1A >> 128;\\n        if (xSignifier & 0x8000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000058B90BFBE8E7BDCBE2E >> 128;\\n        if (xSignifier & 0x4000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000002C5C85FDF473DEA871F >> 128;\\n        if (xSignifier & 0x2000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000162E42FEFA39EF44D91 >> 128;\\n        if (xSignifier & 0x1000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000B17217F7D1CF79E949 >> 128;\\n        if (xSignifier & 0x800000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000058B90BFBE8E7BCE544 >> 128;\\n        if (xSignifier & 0x400000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000002C5C85FDF473DE6ECA >> 128;\\n        if (xSignifier & 0x200000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000162E42FEFA39EF366F >> 128;\\n        if (xSignifier & 0x100000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000B17217F7D1CF79AFA >> 128;\\n        if (xSignifier & 0x80000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000058B90BFBE8E7BCD6D >> 128;\\n        if (xSignifier & 0x40000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000002C5C85FDF473DE6B2 >> 128;\\n        if (xSignifier & 0x20000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000162E42FEFA39EF358 >> 128;\\n        if (xSignifier & 0x10000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000B17217F7D1CF79AB >> 128;\\n        if (xSignifier & 0x8000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000058B90BFBE8E7BCD5 >> 128;\\n        if (xSignifier & 0x4000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000002C5C85FDF473DE6A >> 128;\\n        if (xSignifier & 0x2000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000162E42FEFA39EF34 >> 128;\\n        if (xSignifier & 0x1000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000B17217F7D1CF799 >> 128;\\n        if (xSignifier & 0x800000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000058B90BFBE8E7BCC >> 128;\\n        if (xSignifier & 0x400000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000002C5C85FDF473DE5 >> 128;\\n        if (xSignifier & 0x200000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000162E42FEFA39EF2 >> 128;\\n        if (xSignifier & 0x100000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000B17217F7D1CF78 >> 128;\\n        if (xSignifier & 0x80000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000058B90BFBE8E7BB >> 128;\\n        if (xSignifier & 0x40000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000002C5C85FDF473DD >> 128;\\n        if (xSignifier & 0x20000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000162E42FEFA39EE >> 128;\\n        if (xSignifier & 0x10000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000B17217F7D1CF6 >> 128;\\n        if (xSignifier & 0x8000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000058B90BFBE8E7A >> 128;\\n        if (xSignifier & 0x4000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000002C5C85FDF473C >> 128;\\n        if (xSignifier & 0x2000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000162E42FEFA39D >> 128;\\n        if (xSignifier & 0x1000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000B17217F7D1CE >> 128;\\n        if (xSignifier & 0x800000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000058B90BFBE8E6 >> 128;\\n        if (xSignifier & 0x400000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000002C5C85FDF472 >> 128;\\n        if (xSignifier & 0x200000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000162E42FEFA38 >> 128;\\n        if (xSignifier & 0x100000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000B17217F7D1B >> 128;\\n        if (xSignifier & 0x80000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000058B90BFBE8D >> 128;\\n        if (xSignifier & 0x40000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000002C5C85FDF46 >> 128;\\n        if (xSignifier & 0x20000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000162E42FEFA2 >> 128;\\n        if (xSignifier & 0x10000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000B17217F7D0 >> 128;\\n        if (xSignifier & 0x8000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000058B90BFBE7 >> 128;\\n        if (xSignifier & 0x4000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000002C5C85FDF3 >> 128;\\n        if (xSignifier & 0x2000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000162E42FEF9 >> 128;\\n        if (xSignifier & 0x1000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000B17217F7C >> 128;\\n        if (xSignifier & 0x800000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000058B90BFBD >> 128;\\n        if (xSignifier & 0x400000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000002C5C85FDE >> 128;\\n        if (xSignifier & 0x200000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000162E42FEE >> 128;\\n        if (xSignifier & 0x100000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000B17217F6 >> 128;\\n        if (xSignifier & 0x80000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000058B90BFA >> 128;\\n        if (xSignifier & 0x40000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000002C5C85FC >> 128;\\n        if (xSignifier & 0x20000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000162E42FD >> 128;\\n        if (xSignifier & 0x10000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000B17217E >> 128;\\n        if (xSignifier & 0x8000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000058B90BE >> 128;\\n        if (xSignifier & 0x4000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000002C5C85E >> 128;\\n        if (xSignifier & 0x2000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000162E42E >> 128;\\n        if (xSignifier & 0x1000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000B17216 >> 128;\\n        if (xSignifier & 0x800000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000058B90A >> 128;\\n        if (xSignifier & 0x400000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000002C5C84 >> 128;\\n        if (xSignifier & 0x200000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000162E41 >> 128;\\n        if (xSignifier & 0x100000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000000B1720 >> 128;\\n        if (xSignifier & 0x80000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000058B8F >> 128;\\n        if (xSignifier & 0x40000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000002C5C7 >> 128;\\n        if (xSignifier & 0x20000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000000162E3 >> 128;\\n        if (xSignifier & 0x10000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000000B171 >> 128;\\n        if (xSignifier & 0x8000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000000058B8 >> 128;\\n        if (xSignifier & 0x4000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000002C5B >> 128;\\n        if (xSignifier & 0x2000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000000162D >> 128;\\n        if (xSignifier & 0x1000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000B16 >> 128;\\n        if (xSignifier & 0x800 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000000058A >> 128;\\n        if (xSignifier & 0x400 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000000002C4 >> 128;\\n        if (xSignifier & 0x200 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000161 >> 128;\\n        if (xSignifier & 0x100 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000000000B0 >> 128;\\n        if (xSignifier & 0x80 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000057 >> 128;\\n        if (xSignifier & 0x40 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000000002B >> 128;\\n        if (xSignifier & 0x20 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000015 >> 128;\\n        if (xSignifier & 0x10 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000000000A >> 128;\\n        if (xSignifier & 0x8 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000004 >> 128;\\n        if (xSignifier & 0x4 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000001 >> 128;\\n\\n        if (!xNegative) {\\n          resultSignifier = resultSignifier >> 15 & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n          resultExponent += 0x3FFF;\\n        } else if (resultExponent <= 0x3FFE) {\\n          resultSignifier = resultSignifier >> 15 & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n          resultExponent = 0x3FFF - resultExponent;\\n        } else {\\n          resultSignifier = resultSignifier >> resultExponent - 16367;\\n          resultExponent = 0;\\n        }\\n\\n        return bytes16 (uint128 (resultExponent << 112 | resultSignifier));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate e^x.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function exp (bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      return pow_2 (mul (x, 0x3FFF71547652B82FE1777D0FFDA0D23A));\\n    }\\n  }\\n\\n  /**\\n   * Get index of the most significant non-zero bit in binary representation of\\n   * x.  Reverts if x is zero.\\n   *\\n   * @return index of the most significant non-zero bit in binary representation\\n   *         of x\\n   */\\n  function mostSignificantBit (uint256 x) private pure returns (uint256) {\\n    unchecked {\\n      require (x > 0);\\n\\n      uint256 result = 0;\\n\\n      if (x >= 0x100000000000000000000000000000000) { x >>= 128; result += 128; }\\n      if (x >= 0x10000000000000000) { x >>= 64; result += 64; }\\n      if (x >= 0x100000000) { x >>= 32; result += 32; }\\n      if (x >= 0x10000) { x >>= 16; result += 16; }\\n      if (x >= 0x100) { x >>= 8; result += 8; }\\n      if (x >= 0x10) { x >>= 4; result += 4; }\\n      if (x >= 0x4) { x >>= 2; result += 2; }\\n      if (x >= 0x2) result += 1; // No need to shift x anymore\\n\\n      return result;\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0x9694a9f6fcadd4fa917efa674de42a74b8fbab8d68924f771ea5cc5e1a301434\",\"license\":\"BSD-4-Clause\"},\"contracts/libraries/PoolSwapLibrary.sol\":{\"content\":\"//SPDX-License-Identifier: CC-BY-NC-ND-4.0\\npragma solidity 0.8.7;\\n\\nimport \\\"abdk-libraries-solidity/ABDKMathQuad.sol\\\";\\n\\n/// @title Library for various useful (mostly) mathematical functions\\nlibrary PoolSwapLibrary {\\n    /// ABDKMathQuad-formatted representation of the number one\\n    bytes16 public constant ONE = 0x3fff0000000000000000000000000000;\\n\\n    /// Maximum number of decimal places supported by this contract\\n    /// (ABDKMathQuad defines this but it's private)\\n    uint256 public constant MAX_DECIMALS = 18;\\n\\n    /// Maximum precision supportable via wad arithmetic (for this contract)\\n    uint256 public constant WAD_PRECISION = 10**18;\\n\\n    // Set max minting fee to 100%. This is a ABDKQuad representation of 1 * 10 ** 18\\n    bytes16 public constant MAX_MINTING_FEE = 0x403abc16d674ec800000000000000000;\\n\\n    // Set max burning fee to 10%. This is a ABDKQuad representation of 0.1 * 10 ** 18\\n    bytes16 public constant MAX_BURNING_FEE = 0x40376345785d8a000000000000000000;\\n\\n    /// Information required to update a given user's aggregated balance\\n    struct UpdateData {\\n        bytes16 longPrice;\\n        bytes16 shortPrice;\\n        uint256 currentUpdateIntervalId;\\n        uint256 updateIntervalId;\\n        uint256 longMintSettlement;\\n        uint256 longBurnPoolTokens;\\n        uint256 shortMintSettlement;\\n        uint256 shortBurnPoolTokens;\\n        uint256 longBurnShortMintPoolTokens;\\n        uint256 shortBurnLongMintPoolTokens;\\n        bytes16 burnFee;\\n    }\\n\\n    /// Information required to perform a price change (of the underlying asset)\\n    struct PriceChangeData {\\n        int256 oldPrice;\\n        int256 newPrice;\\n        uint256 longBalance;\\n        uint256 shortBalance;\\n        bytes16 leverageAmount;\\n        bytes16 fee;\\n    }\\n\\n    /**\\n     * @notice Calculates the ratio between two numbers\\n     * @dev Rounds any overflow towards 0. If either parameter is zero, the ratio is 0\\n     * @param _numerator The \\\"parts per\\\" side of the equation. If this is zero, the ratio is zero\\n     * @param _denominator The \\\"per part\\\" side of the equation. If this is zero, the ratio is zero\\n     * @return the ratio, as an ABDKMathQuad number (IEEE 754 quadruple precision floating point)\\n     */\\n    function getRatio(uint256 _numerator, uint256 _denominator) public pure returns (bytes16) {\\n        // Catch the divide by zero error.\\n        if (_denominator == 0) {\\n            return 0;\\n        }\\n        return ABDKMathQuad.div(ABDKMathQuad.fromUInt(_numerator), ABDKMathQuad.fromUInt(_denominator));\\n    }\\n\\n    /**\\n     * @notice Multiplies two numbers\\n     * @param x The number to be multiplied by `y`\\n     * @param y The number to be multiplied by `x`\\n     */\\n    function multiplyBytes(bytes16 x, bytes16 y) external pure returns (bytes16) {\\n        return ABDKMathQuad.mul(x, y);\\n    }\\n\\n    /**\\n     * @notice Performs a subtraction on two bytes16 numbers\\n     * @param x The number to be subtracted by `y`\\n     * @param y The number to subtract from `x`\\n     */\\n    function subtractBytes(bytes16 x, bytes16 y) external pure returns (bytes16) {\\n        return ABDKMathQuad.sub(x, y);\\n    }\\n\\n    /**\\n     * @notice Performs an addition on two bytes16 numbers\\n     * @param x The number to be added with `y`\\n     * @param y The number to be added with `x`\\n     */\\n    function addBytes(bytes16 x, bytes16 y) external pure returns (bytes16) {\\n        return ABDKMathQuad.add(x, y);\\n    }\\n\\n    /**\\n     * @notice Gets the short and long balances after the keeper rewards have been paid out\\n     *         Keeper rewards are paid proportionally to the short and long pool\\n     * @dev Assumes shortBalance + longBalance >= reward\\n     * @param reward Amount of keeper reward\\n     * @param shortBalance Short balance of the pool\\n     * @param longBalance Long balance of the pool\\n     * @return shortBalanceAfterFees Short balance of the pool after the keeper reward has been paid\\n     * @return longBalanceAfterFees Long balance of the pool after the keeper reward has been paid\\n     */\\n    function getBalancesAfterFees(\\n        uint256 reward,\\n        uint256 shortBalance,\\n        uint256 longBalance\\n    ) external pure returns (uint256, uint256) {\\n        bytes16 ratioShort = getRatio(shortBalance, shortBalance + longBalance);\\n\\n        uint256 shortFees = convertDecimalToUInt(multiplyDecimalByUInt(ratioShort, reward));\\n\\n        uint256 shortBalanceAfterFees = shortBalance - shortFees;\\n        uint256 longBalanceAfterFees = longBalance - (reward - shortFees);\\n\\n        // Return shortBalance and longBalance after rewards are paid out\\n        return (shortBalanceAfterFees, longBalanceAfterFees);\\n    }\\n\\n    /**\\n     * @notice Compares two decimal numbers\\n     * @param x The first number to compare\\n     * @param y The second number to compare\\n     * @return -1 if x < y, 0 if x = y, or 1 if x > y\\n     */\\n    function compareDecimals(bytes16 x, bytes16 y) public pure returns (int8) {\\n        return ABDKMathQuad.cmp(x, y);\\n    }\\n\\n    /**\\n     * @notice Converts an integer value to a compatible decimal value\\n     * @param amount The amount to convert\\n     * @return The amount as a IEEE754 quadruple precision number\\n     */\\n    function convertUIntToDecimal(uint256 amount) external pure returns (bytes16) {\\n        return ABDKMathQuad.fromUInt(amount);\\n    }\\n\\n    /**\\n     * @notice Converts a raw decimal value to a more readable uint256 value\\n     * @param ratio The value to convert\\n     * @return The converted value\\n     */\\n    function convertDecimalToUInt(bytes16 ratio) public pure returns (uint256) {\\n        return ABDKMathQuad.toUInt(ratio);\\n    }\\n\\n    /**\\n     * @notice Multiplies a decimal and an unsigned integer\\n     * @param a The first term\\n     * @param b The second term\\n     * @return The product of a*b as a decimal\\n     */\\n    function multiplyDecimalByUInt(bytes16 a, uint256 b) public pure returns (bytes16) {\\n        return ABDKMathQuad.mul(a, ABDKMathQuad.fromUInt(b));\\n    }\\n\\n    /**\\n     * @notice Divides two unsigned integers\\n     * @param a The dividend\\n     * @param b The divisor\\n     * @return The quotient\\n     */\\n    function divUInt(uint256 a, uint256 b) private pure returns (bytes16) {\\n        return ABDKMathQuad.div(ABDKMathQuad.fromUInt(a), ABDKMathQuad.fromUInt(b));\\n    }\\n\\n    /**\\n     * @notice Divides two integers\\n     * @param a The dividend\\n     * @param b The divisor\\n     * @return The quotient\\n     */\\n    function divInt(int256 a, int256 b) public pure returns (bytes16) {\\n        return ABDKMathQuad.div(ABDKMathQuad.fromInt(a), ABDKMathQuad.fromInt(b));\\n    }\\n\\n    /**\\n     * @notice Multiply an integer by a fraction\\n     * @notice number * numerator / denominator\\n     * @param number The number with which the fraction calculated from `numerator` and `denominator` will be multiplied\\n     * @param numerator The numerator of the fraction being multipled with `number`\\n     * @param denominator The denominator of the fraction being multipled with `number`\\n     * @return The result of multiplying number with numerator/denominator, as an integer\\n     */\\n    function mulFraction(\\n        uint256 number,\\n        uint256 numerator,\\n        uint256 denominator\\n    ) public pure returns (uint256) {\\n        if (denominator == 0) {\\n            return 0;\\n        }\\n        bytes16 multiplyResult = ABDKMathQuad.mul(ABDKMathQuad.fromUInt(number), ABDKMathQuad.fromUInt(numerator));\\n        bytes16 result = ABDKMathQuad.div(multiplyResult, ABDKMathQuad.fromUInt(denominator));\\n        return convertDecimalToUInt(result);\\n    }\\n\\n    /**\\n     * @notice Calculates the loss multiplier to apply to the losing pool. Includes the power leverage\\n     * @param ratio The ratio of new price to old price\\n     * @param direction The direction of the change. -1 if it's decreased, 0 if it hasn't changed, and 1 if it's increased\\n     * @param leverage The amount of leverage to apply\\n     * @return The multiplier\\n     */\\n    function getLossMultiplier(\\n        bytes16 ratio,\\n        int8 direction,\\n        bytes16 leverage\\n    ) public pure returns (bytes16) {\\n        // If decreased:  2 ^ (leverage * log2[(1 * new/old) + [(0 * 1) / new/old]])\\n        //              = 2 ^ (leverage * log2[(new/old)])\\n        // If increased:  2 ^ (leverage * log2[(0 * new/old) + [(1 * 1) / new/old]])\\n        //              = 2 ^ (leverage * log2([1 / new/old]))\\n        //              = 2 ^ (leverage * log2([old/new]))\\n        return\\n            ABDKMathQuad.pow_2(\\n                ABDKMathQuad.mul(leverage, ABDKMathQuad.log_2(direction < 0 ? ratio : ABDKMathQuad.div(ONE, ratio)))\\n            );\\n    }\\n\\n    /**\\n     * @notice Calculates the amount to take from the losing pool\\n     * @param lossMultiplier The multiplier to use\\n     * @param balance The balance of the losing pool\\n     */\\n    function getLossAmount(bytes16 lossMultiplier, uint256 balance) public pure returns (uint256) {\\n        return\\n            ABDKMathQuad.toUInt(\\n                ABDKMathQuad.mul(ABDKMathQuad.sub(ONE, lossMultiplier), ABDKMathQuad.fromUInt(balance))\\n            );\\n    }\\n\\n    /**\\n     * @notice Calculates the effect of a price change. This involves calculating how many funds to transfer from the losing pool to the other.\\n     * @dev This function should be called by the LeveragedPool.\\n     * @param priceChange The struct containing necessary data to calculate price change\\n     * @return Resulting long balance\\n     * @return Resulting short balance\\n     * @return Resulting fees taken from long balance\\n     * @return Resulting fees taken from short balance\\n     */\\n    function calculatePriceChange(PriceChangeData calldata priceChange)\\n        external\\n        pure\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        uint256 shortBalance = priceChange.shortBalance;\\n        uint256 longBalance = priceChange.longBalance;\\n        bytes16 leverageAmount = priceChange.leverageAmount;\\n        int256 oldPrice = priceChange.oldPrice;\\n        int256 newPrice = priceChange.newPrice;\\n        bytes16 fee = priceChange.fee;\\n\\n        // Calculate fees from long and short sides\\n        uint256 longFeeAmount = convertDecimalToUInt(multiplyDecimalByUInt(fee, longBalance)) /\\n            PoolSwapLibrary.WAD_PRECISION;\\n        uint256 shortFeeAmount = convertDecimalToUInt(multiplyDecimalByUInt(fee, shortBalance)) /\\n            PoolSwapLibrary.WAD_PRECISION;\\n\\n        shortBalance = shortBalance - shortFeeAmount;\\n        longBalance = longBalance - longFeeAmount;\\n\\n        // Use the ratio to determine if the price increased or decreased and therefore which direction\\n        // the funds should be transferred towards.\\n\\n        bytes16 ratio = divInt(newPrice, oldPrice);\\n        int8 direction = compareDecimals(ratio, PoolSwapLibrary.ONE);\\n        // Take into account the leverage\\n        bytes16 lossMultiplier = getLossMultiplier(ratio, direction, leverageAmount);\\n\\n        if (direction >= 0 && shortBalance > 0) {\\n            // Move funds from short to long pair\\n            uint256 lossAmount = getLossAmount(lossMultiplier, shortBalance);\\n            shortBalance = shortBalance - lossAmount;\\n            longBalance = longBalance + lossAmount;\\n        } else if (direction < 0 && longBalance > 0) {\\n            // Move funds from long to short pair\\n            uint256 lossAmount = getLossAmount(lossMultiplier, longBalance);\\n            shortBalance = shortBalance + lossAmount;\\n            longBalance = longBalance - lossAmount;\\n        }\\n\\n        return (longBalance, shortBalance, longFeeAmount, shortFeeAmount);\\n    }\\n\\n    /**\\n     * @notice Returns true if the given timestamp is BEFORE the frontRunningInterval starts\\n     * @param subjectTime The timestamp for which you want to calculate if it was beforeFrontRunningInterval\\n     * @param lastPriceTimestamp The timestamp of the last price update\\n     * @param updateInterval The interval between price updates\\n     * @param frontRunningInterval The window of time before a price update in which users can have their commit executed from\\n     */\\n    function isBeforeFrontRunningInterval(\\n        uint256 subjectTime,\\n        uint256 lastPriceTimestamp,\\n        uint256 updateInterval,\\n        uint256 frontRunningInterval\\n    ) public pure returns (bool) {\\n        return lastPriceTimestamp + updateInterval - frontRunningInterval > subjectTime;\\n    }\\n\\n    /**\\n     * @notice Calculates the update interval ID that a commitment should be placed in.\\n     * @param timestamp Current block.timestamp\\n     * @param lastPriceTimestamp The timestamp of the last price update\\n     * @param frontRunningInterval The frontrunning interval of a pool - The amount of time before an update interval that you must commit to get included in that update\\n     * @param updateInterval The frequency of a pool's updates\\n     * @param currentUpdateIntervalId The current update interval's ID\\n     * @dev Note that the timestamp parameter is required to be >= lastPriceTimestamp\\n     * @return The update interval ID in which a commit being made at time timestamp should be included\\n     */\\n    function appropriateUpdateIntervalId(\\n        uint256 timestamp,\\n        uint256 lastPriceTimestamp,\\n        uint256 frontRunningInterval,\\n        uint256 updateInterval,\\n        uint256 currentUpdateIntervalId\\n    ) external pure returns (uint256) {\\n        require(lastPriceTimestamp <= timestamp, \\\"timestamp in the past\\\");\\n        if (frontRunningInterval <= updateInterval) {\\n            // This is the \\\"simple\\\" case where we either want the current update interval or the next one\\n            if (isBeforeFrontRunningInterval(timestamp, lastPriceTimestamp, updateInterval, frontRunningInterval)) {\\n                // We are before the frontRunning interval\\n                return currentUpdateIntervalId;\\n            } else {\\n                // Floor of `timePassed / updateInterval` to get the number of intervals passed\\n                uint256 updateIntervalsPassed = (timestamp - lastPriceTimestamp) / updateInterval;\\n                // If 1 update interval has passed, we want to check if we are within the frontrunning interval of currentUpdateIntervalId + 1\\n                uint256 frontRunningIntervalStart = lastPriceTimestamp +\\n                    ((updateIntervalsPassed + 1) * updateInterval) -\\n                    frontRunningInterval;\\n                if (timestamp >= frontRunningIntervalStart) {\\n                    // add an extra update interval because the frontrunning interval has passed\\n                    return currentUpdateIntervalId + updateIntervalsPassed + 1;\\n                } else {\\n                    return currentUpdateIntervalId + updateIntervalsPassed;\\n                }\\n            }\\n        } else {\\n            // frontRunningInterval > updateInterval\\n            // This is the generalised case, where it could be any number of update intervals in the future\\n            // Minimum time is the earliest we could possible execute this commitment (i.e. the current time plus frontrunning interval)\\n            uint256 minimumTime = timestamp + frontRunningInterval;\\n            // Number of update intervals that would have had to have passed.\\n            uint256 updateIntervals = (minimumTime - lastPriceTimestamp) / updateInterval;\\n\\n            return currentUpdateIntervalId + updateIntervals;\\n        }\\n    }\\n\\n    /**\\n     * @notice Gets the number of settlement tokens to be withdrawn based on a pool token burn amount\\n     * @dev Calculates as `balance * amountIn / (tokenSupply + shadowBalance)\\n     * @param tokenSupply Total supply of pool tokens\\n     * @param amountIn Commitment amount of pool tokens going into the pool\\n     * @param balance Balance of the pool (no. of underlying settlement tokens in pool)\\n     * @param pendingBurnPoolTokens Amount of pool tokens being burnt during this update interval\\n     * @return Number of settlement tokens to be withdrawn on a burn\\n     */\\n    function getWithdrawAmountOnBurn(\\n        uint256 tokenSupply,\\n        uint256 amountIn,\\n        uint256 balance,\\n        uint256 pendingBurnPoolTokens\\n    ) external pure returns (uint256) {\\n        // Catch the divide by zero error, or return 0 if amountIn is 0\\n        if ((balance == 0) || (tokenSupply + pendingBurnPoolTokens == 0) || (amountIn == 0)) {\\n            return amountIn;\\n        }\\n        return (balance * amountIn) / (tokenSupply + pendingBurnPoolTokens);\\n    }\\n\\n    /**\\n     * @notice Gets the number of pool tokens to be minted based on existing tokens\\n     * @dev Calculated as (tokenSupply + shadowBalance) * amountIn / balance\\n     * @param tokenSupply Total supply of pool tokens\\n     * @param amountIn Commitment amount of settlement tokens going into the pool\\n     * @param balance Balance of the pool (no. of underlying settlement tokens in pool)\\n     * @param pendingBurnPoolTokens Amount of pool tokens being burnt during this update interval\\n     * @return Number of pool tokens to be minted\\n     */\\n    function getMintAmount(\\n        uint256 tokenSupply,\\n        uint256 amountIn,\\n        uint256 balance,\\n        uint256 pendingBurnPoolTokens\\n    ) external pure returns (uint256) {\\n        // Catch the divide by zero error, or return 0 if amountIn is 0\\n        if (balance == 0 || tokenSupply + pendingBurnPoolTokens == 0 || amountIn == 0) {\\n            return amountIn;\\n        }\\n\\n        return ((tokenSupply + pendingBurnPoolTokens) * amountIn) / balance;\\n    }\\n\\n    /**\\n     * @notice Get the Settlement/PoolToken price, in ABDK IEE754 precision\\n     * @dev Divide the side balance by the pool token's total supply\\n     * @param sideBalance no. of underlying settlement tokens on that side of the pool\\n     * @param tokenSupply Total supply of pool tokens\\n     */\\n    function getPrice(uint256 sideBalance, uint256 tokenSupply) external pure returns (bytes16) {\\n        if (tokenSupply == 0) {\\n            return ONE;\\n        }\\n        return ABDKMathQuad.div(ABDKMathQuad.fromUInt(sideBalance), ABDKMathQuad.fromUInt(tokenSupply));\\n    }\\n\\n    /**\\n     * @notice Calculates the number of pool tokens to mint, given some settlement token amount and a price\\n     * @param price Price of a pool token\\n     * @param amount Amount of settlement tokens being used to mint\\n     * @return Quantity of pool tokens to mint\\n     * @dev Throws if price is zero\\n     * @dev `getMint()`\\n     */\\n    function getMint(bytes16 price, uint256 amount) public pure returns (uint256) {\\n        require(price != 0, \\\"price == 0\\\");\\n        return ABDKMathQuad.toUInt(ABDKMathQuad.div(ABDKMathQuad.fromUInt(amount), price));\\n    }\\n\\n    /**\\n     * @notice Calculate the number of settlement tokens to burn, based on a price and an amount of pool tokens\\n     * @param price Price of a pool token\\n     * @param amount Amount of pool tokens being used to burn\\n     * @return Quantity of settlement tokens to return to the user after `amount` pool tokens are burnt.\\n     * @dev amount * price, where amount is in PoolToken and price is in USD/PoolToken\\n     * @dev Throws if price is zero\\n     * @dev `getBurn()`\\n     */\\n    function getBurn(bytes16 price, uint256 amount) public pure returns (uint256) {\\n        require(price != 0, \\\"price == 0\\\");\\n        return ABDKMathQuad.toUInt(ABDKMathQuad.mul(ABDKMathQuad.fromUInt(amount), price));\\n    }\\n\\n    /**\\n     * @notice Calculate the number of pool tokens to mint, given some settlement token amount, a price, and a burn amount from other side for instant mint\\n     * @param price The price of a pool token\\n     * @param oppositePrice The price of the opposite side's pool token\\n     * @param amount The amount of settlement tokens being used to mint\\n     * @param amountBurnedInstantMint The amount of pool tokens that were burnt from the opposite side for an instant mint in this side\\n     * @return Quantity of pool tokens to mint\\n     * @dev Throws if price is zero\\n     */\\n    function getMintWithBurns(\\n        bytes16 price,\\n        bytes16 oppositePrice,\\n        uint256 amount,\\n        uint256 amountBurnedInstantMint\\n    ) public pure returns (uint256) {\\n        require(price != 0, \\\"price == 0\\\");\\n        if (amountBurnedInstantMint > 0) {\\n            // Calculate amount of settlement tokens generated from the burn.\\n            amount += getBurn(oppositePrice, amountBurnedInstantMint);\\n        }\\n        return getMint(price, amount);\\n    }\\n\\n    /**\\n     * @notice Converts from a WAD to normal value\\n     * @param _wadValue wad number\\n     * @param _decimals Quantity of decimal places to support\\n     * @return Converted (non-WAD) value\\n     */\\n    function fromWad(uint256 _wadValue, uint256 _decimals) external pure returns (uint256) {\\n        uint256 scaler = 10**(MAX_DECIMALS - _decimals);\\n        return _wadValue / scaler;\\n    }\\n\\n    /**\\n     * @notice Calculate the change in a user's balance based on recent commit(s)\\n     * @param data Information needed for updating the balance including prices and recent commit amounts\\n     * @return _newLongTokens Quantity of additional long tokens the user would receive\\n     * @return _newShortTokens Quantity of additional short tokens the user would receive\\n     * @return _longBurnFee Quantity of settlement tokens taken as a fee from long burns\\n     * @return _shortBurnFee Quantity of settlement tokens taken as a fee from short burns\\n     * @return _newSettlementTokens Quantity of additional settlement tokens the user would receive\\n     */\\n    function getUpdatedAggregateBalance(UpdateData calldata data)\\n        external\\n        pure\\n        returns (\\n            uint256 _newLongTokens,\\n            uint256 _newShortTokens,\\n            uint256 _longBurnFee,\\n            uint256 _shortBurnFee,\\n            uint256 _newSettlementTokens\\n        )\\n    {\\n        if (data.updateIntervalId >= data.currentUpdateIntervalId) {\\n            // Update interval has not passed: No change\\n            return (0, 0, 0, 0, 0);\\n        }\\n        uint256 longBurnResult; // The amount of settlement tokens to withdraw based on long token burn\\n        uint256 shortBurnResult; // The amount of settlement tokens to withdraw based on short token burn\\n        if (data.longMintSettlement > 0 || data.shortBurnLongMintPoolTokens > 0) {\\n            _newLongTokens = getMintWithBurns(\\n                data.longPrice,\\n                data.shortPrice,\\n                data.longMintSettlement,\\n                data.shortBurnLongMintPoolTokens\\n            );\\n        }\\n\\n        if (data.longBurnPoolTokens > 0) {\\n            // Calculate the amount of settlement tokens earned from burning long tokens\\n            longBurnResult = getBurn(data.longPrice, data.longBurnPoolTokens);\\n            // Calculate the fee\\n            _longBurnFee = convertDecimalToUInt(multiplyDecimalByUInt(data.burnFee, longBurnResult)) / WAD_PRECISION;\\n            // Subtract the fee from settlement token amount\\n            longBurnResult -= _longBurnFee;\\n        }\\n\\n        if (data.shortMintSettlement > 0 || data.longBurnShortMintPoolTokens > 0) {\\n            _newShortTokens = getMintWithBurns(\\n                data.shortPrice,\\n                data.longPrice,\\n                data.shortMintSettlement,\\n                data.longBurnShortMintPoolTokens\\n            );\\n        }\\n\\n        if (data.shortBurnPoolTokens > 0) {\\n            // Calculate the amount of settlement tokens earned from burning short tokens\\n            shortBurnResult = getBurn(data.shortPrice, data.shortBurnPoolTokens);\\n            // Calculate the fee\\n            _shortBurnFee = convertDecimalToUInt(multiplyDecimalByUInt(data.burnFee, shortBurnResult)) / WAD_PRECISION;\\n            // Subtract the fee from settlement token amount\\n            shortBurnResult -= _shortBurnFee;\\n        }\\n\\n        _newSettlementTokens = shortBurnResult + longBurnResult;\\n    }\\n}\\n\",\"keccak256\":\"0x4c7757caa8d1252d99704298ff86d873ddf401c42b2cfc633c75e4081c5b1408\",\"license\":\"CC-BY-NC-ND-4.0\"}},\"version\":1}",
    "bytecode": "0x61316f61003a600b82828239805160001a60731461002d57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600436106101d95760003560e01c8063ab41556f1161010e578063cff70001116100ac578063e45639451161007b578063e45639451461044b578063fc3115811461045e578063fea3de3314610471578063ff9afe871461048457600080fd5b8063cff70001146103ea578063dc35bc13146103fd578063debb52df14610425578063dfdbe4da1461043857600080fd5b8063bf36f0e9116100e8578063bf36f0e9146103a5578063c15172d2146103b8578063c2ee3a08146103cb578063c3ff8091146103d757600080fd5b8063ab41556f1461036c578063aeb64d7d1461037f578063b6b2f9f61461039257600080fd5b8063664808a81161017b57806388b78aaa1161015557806388b78aaa146102da5780639eb17fa3146102eb578063a481c1b414610326578063a818c0d21461035957600080fd5b8063664808a8146102975780636fa1268e146102a657806381a799db146102b757600080fd5b8063202f1257116101b7578063202f12571461024b578063422051e71461025e57806345e7ef9b146102715780635cf4ee911461028457600080fd5b80630417cf8e146101de5780630e8418dd146101f95780631842c9d814610225575b600080fd5b6101e6601281565b6040519081526020015b60405180910390f35b61020c610207366004612d8f565b610497565b6040516001600160801b031990911681526020016101f0565b610238610233366004612d8f565b6104ac565b60405160009190910b81526020016101f0565b61020c610259366004612e79565b6104b8565b61020c61026c366004612e4f565b6104d4565b61020c61027f366004612d8f565b6104e8565b61020c610292366004612e79565b6104f4565b6101e6670de0b6b3a764000081565b61020c66201bb1a2bc2ec560c91b81565b6102ca6102c5366004612f0b565b61051c565b60405190151581526020016101f0565b61020c668075782dace9d960c71b81565b6102fe6102f9366004612eb3565b610540565b604080519586526020860194909452928401919091526060830152608082015260a0016101f0565b610339610334366004612e9b565b6106f5565b6040805194855260208501939093529183015260608201526080016101f0565b6101e6610367366004612e4f565b61085e565b6101e661037a366004612f0b565b610883565b6101e661038d366004612d74565b6108d7565b61020c6103a0366004612d8f565b6108e2565b6101e66103b3366004612e79565b6108ee565b6101e66103c6366004612dc2565b610913565b61020c613fff60f01b81565b61020c6103e5366004612e04565b61096c565b61020c6103f8366004612e79565b6109ac565b61041061040b366004612edf565b6109bb565b604080519283526020830191909152016101f0565b6101e6610433366004612f0b565b610a14565b61020c610446366004612ec6565b610a53565b6101e6610459366004612e4f565b610a5e565b6101e661046c366004612e4f565b610a9c565b6101e661047f366004612edf565b610ada565b6101e6610492366004612f3d565b610b26565b60006104a38383610c37565b90505b92915050565b60006104a38383610c49565b60006104a36104c684610d70565b6104cf84610d70565b610e03565b60006104a3836104e3846110ba565b61111e565b60006104a3838361111e565b6000816105075750613fff60f01b6104a6565b6104a3610513846110ba565b6104cf846110ba565b6000848261052a8587612f9c565b61053491906130e0565b1190505b949350505050565b6000806000806000856040013586606001351061056b575060009350839250829150819050806106ec565b60008060008860800135118061058657506000886101200135115b156105be576105bb61059b60208a018a612d74565b6105ab60408b0160208c01612d74565b8a608001358b6101200135610913565b96505b60a088013515610624576105e26105d860208a018a612d74565b8960a00135610a9c565b9150670de0b6b3a764000061060b61038d6106056101608c016101408d01612d74565b856104d4565b6106159190612fb4565b945061062185836130e0565b91505b60008860c00135118061063c57506000886101000135115b156106745761067161065460408a0160208b01612d74565b61066160208b018b612d74565b8a60c001358b6101000135610913565b95505b60e0880135156106dd5761069b61069160408a0160208b01612d74565b8960e00135610a9c565b9050670de0b6b3a76400006106c461038d6106be6101608c016101408d01612d74565b846104d4565b6106ce9190612fb4565b93506106da84826130e0565b90505b6106e78282612f9c565b925050505b91939590929450565b6000808080606085013560408601358261071560a0890160808a01612d74565b905087356020890135600061073060c08c0160a08d01612d74565b90506000670de0b6b3a764000061074a61038d84896104d4565b6107549190612fb4565b90506000670de0b6b3a764000061076e61038d858b6104d4565b6107789190612fb4565b905061078481896130e0565b975061079082886130e0565b9650600061079e85876104b8565b905060006107b182613fff60f01b6104ac565b905060006107c083838b61096c565b905060008260000b121580156107d6575060008b115b156108075760006107e7828d61085e565b90506107f3818d6130e0565b9b506107ff818c612f9c565b9a5050610847565b60008260000b12801561081a575060008a115b1561084757600061082b828c61085e565b9050610837818d612f9c565b9b50610843818c6130e0565b9a50505b50979e989d50919b50995095975050505050505050565b60006104a361087e610875613fff60f01b86610c37565b6104e3856110ba565b611379565b600082158061089957506108978286612f9c565b155b806108a2575083155b156108ae575082610538565b82846108ba8488612f9c565b6108c491906130c1565b6108ce9190612fb4565b95945050505050565b60006104a682611379565b60006104a383836113fc565b6000806108fc8360126130e0565b61090790600a613019565b90506105388185612fb4565b60006001600160801b031985166109455760405162461bcd60e51b815260040161093c90612f78565b60405180910390fd5b8115610962576109558483610a9c565b61095f9084612f9c565b92505b6108ce8584610a5e565b60006109a261099d836104e360008760000b1261099757610992613fff60f01b89610e03565b6117bc565b876117bc565b61196c565b90505b9392505050565b600081610507575060006104a6565b600080806109cd856103f88682612f9c565b905060006109de61038d83896104d4565b905060006109ec82886130e0565b905060006109fa838a6130e0565b610a0490886130e0565b9199919850909650505050505050565b6000821580610a2a5750610a288286612f9c565b155b80610a33575083155b15610a3f575082610538565b610a498286612f9c565b6108c485856130c1565b60006104a6826110ba565b60006001600160801b03198316610a875760405162461bcd60e51b815260040161093c90612f78565b6104a361087e610a96846110ba565b85610e03565b60006001600160801b03198316610ac55760405162461bcd60e51b815260040161093c90612f78565b6104a361087e610ad4846110ba565b8561111e565b600081610ae9575060006109a5565b6000610b00610af7866110ba565b6104e3866110ba565b90506000610b11826104cf866110ba565b9050610b1c816108d7565b9695505050505050565b600085851115610b705760405162461bcd60e51b81526020600482015260156024820152741d1a5b595cdd185b5c081a5b881d1a19481c185cdd605a1b604482015260640161093c565b828411610c0657610b838686858761051c565b15610b8f5750806108ce565b600083610b9c87896130e0565b610ba69190612fb4565b905060008585610bb7846001612f9c565b610bc191906130c1565b610bcb9089612f9c565b610bd591906130e0565b9050808810610bfc57610be88285612f9c565b610bf3906001612f9c565b925050506108ce565b610bf38285612f9c565b6000610c128588612f9c565b9050600084610c2188846130e0565b610c2b9190612fb4565b9050610bf38185612f9c565b60006104a383600160ff1b84186113fc565b600060016001607f1b03608084901c16617fff60701b811115610c6b57600080fd5b60016001607f1b03608084901c16617fff60701b811115610c8b57600080fd5b6001600160801b0319858116908516141580610cb45750617fff60701b826001600160801b0316105b610cbd57600080fd5b6001600160801b03198581169085161415610cdd576000925050506104a6565b6001607f1b608086811c82118015929187901c919091101590610d2f578015610d2057826001600160801b0316846001600160801b031611610d20576001610d24565b6000195b9450505050506104a6565b8015610d425760019450505050506104a6565b826001600160801b0316846001600160801b031611610d6357600019610d24565b60019450505050506104a6565b600081610d7f57506000919050565b6000808313610d915782600003610d93565b825b90506000610da082612cbe565b90506070811015610db9578060700382901b9150610dcc565b6070811115610dcc576070810382901c91505b6001600160701b03909116613fff820160701b17906000841215610df4576001607f1b821791505b5060801b92915050565b919050565b6000617fff60f084811c8216919084901c811690821415610e495780617fff1415610e38575061ffff60ef1b91506104a69050565b505050600160ff1b811682186104a6565b80617fff1415610e8d576dffffffffffffffffffffffffffff60801b841615610e7c575061ffff60ef1b91506104a69050565b505050808218600160ff1b166104a6565b600160801b600160ff1b038416610ed757600160801b600160ff1b038516610ebf575061ffff60ef1b91506104a69050565b505050808218600160ff1b16617fff60f01b176104a6565b6001600160701b03608085901c1681610ef35760019150610efa565b600160701b175b6001600160701b03608087901c1683610f39578015610f34576000610f1e82612cbe565b6001955060e20393840160711901939190911b90505b610f43565b600160701b1760721b5b818181610f5257610f52613123565b04905080610f7e57600160ff1b87871816610f6e576000610d24565b600160ff1b9450505050506104a6565b6001606c1b811015610f9257610f926130f7565b6000600160731b821015610fd157600160721b821015610fc657600160711b821015610fbf576070610fc9565b6071610fc9565b60725b60ff16610fda565b610fda82612cbe565b905083614071018186011115610ff857617fff94506000915061108b565b83818601613ffc01101561101357600094506000915061108b565b83818601613f8c011015611060578385613ffc01111561103e578385613ffc010382901b9150611057565b8385613ffc01101561105757613ffc8585030382901c91505b6000945061108b565b6070811115611073576070810382901c91505b6001600160701b038216915083818601613f8d010394505b81607086901b888a186001607f1b60801b1660801c6001600160801b0316171760801b955050505050506104a6565b6000816110c957506000919050565b8160006110d582612cbe565b905060708110156110ee578060700382901b9150611101565b6070811115611101576070810382901c91505b613fff0160701b6001600160701b03919091161760801b92915050565b6000617fff60f084811c8216919084901c8116908214156111bd5780617fff141561119c576001600160801b0319858116908516141561116957505050600160ff1b811682186104a6565b600160ff1b6001600160801b031986861816141561118c575050508181176104a6565b5061ffff60ef1b91506104a69050565b600160801b600160ff1b038416610e38575061ffff60ef1b91506104a69050565b80617fff14156111f957600160801b600160ff1b0385166111e8575061ffff60ef1b91506104a69050565b505050600160ff1b821681186104a6565b6001600160701b03608086901c1682611215576001925061121c565b600160701b175b6001600160701b03608086901c1682611238576001925061123f565b600160701b175b908102908161125c57600160ff1b87871816610f6e576000610d24565b928201926000600160e11b83101561128f57600160e01b8310156112885761128383612cbe565b611292565b60e0611292565b60e15b905061407081860110156112ad57600094506000925061134a565b6140e081860110156112f0576140708510156112d257846140700383901c92506112e7565b6140708511156112e757614070850383901b92505b6000945061134a565b61c0dd818601111561130a57617fff94506000925061134a565b6070811115611321576070810383901c9250611334565b6070811015611334578060700383901b92505b6001600160701b03831692506140df8186010394505b82607086901b888a186001607f1b60801b1660801c6001600160801b0316171760801b955050505050506104a6565b6000617fff60f083901c16613fff8110156113975750600092915050565b6001607f1b608084901c106113ab57600080fd5b6140fe8111156113ba57600080fd5b600160701b6001600160701b03608085901c161761406f8210156113e45761406f8290031c6109a5565b61406f8211156109a55761406e1982011b9392505050565b6000617fff60f084811c8216919084901c81169082141561144a5780617fff1415611440576001600160801b0319858116908516141561118c5784925050506104a6565b84925050506104a6565b80617fff141561145e5783925050506104a6565b6001607f1b608086901c90811015906001600160701b031683611484576001935061148b565b600160701b175b6001607f1b608087901c90811015906001600160701b0316846114b157600194506114b8565b600160701b175b826114e8576001600160801b03198816600160ff1b146114d857876114db565b60005b96505050505050506104a6565b80611508576001600160801b03198916600160ff1b146114d857886114db565b848603841515831515141561161357607081131561152f57899750505050505050506104a6565b60008113156115415790811c90611570565b606f1981121561155a57889750505050505050506104a6565b6000811215611570578060000384901c93508596505b92810192600160711b841061158b576001968701969390931c925b86617fff14156115bd57846115a557617fff60f01b6115af565b6001600160f01b03195b9750505050505050506104a6565b600160701b8410156115d257600096506115df565b6001600160701b03841693505b83607088901b866115f15760006115f7565b6001607f1b5b6001600160801b0316171760801b9750505050505050506104a6565b600081131561162e57600184901b9350600187039650611645565b600081121561164557600182901b91506001860396505b607081131561165757600191506116a4565b6001811315611674576001810360018303901c60010191506116a4565b606f1981121561168757600193506116a4565b6000198112156116a4576001816000030360018503901c60010193505b8184106116b55781840393506116be565b83820393508294505b836116d45750600096506104a695505050505050565b60006116df85612cbe565b9050806071141561170557600185901c6001600160701b03169450600188019750611754565b607081101561174757607081900380891115611734578086901b6001600160701b031695508089039850611741565b600098600019019590951b945b50611754565b6001600160701b03851694505b87617fff1415611787578561176e57617fff60f01b611778565b6001600160f01b03195b985050505050505050506104a6565b84607089901b8761179957600061179f565b6001607f1b5b6001600160801b0316171760801b985050505050505050506104a6565b60006001607f1b608083901c11156117da575061ffff60ef1b919050565b613fff60f01b6001600160801b0319831614156117f957506000919050565b617fff60f083901c811690811415611812575090919050565b6001600160701b03608084901c168161182e5760019150611835565b600160701b175b8061184b57506001600160f01b03199392505050565b600061406f81613fff85106118715750600f9290921b9160009150613ffe1984016118b0565b60019250600160701b84106118935784613ffe039050600f84901b93506118b0565b600061189e85612cbe565b607f8190039590951b9461406d039150505b836001607f1b14156118e45782156118c6576001015b60006118d182612cbe565b60700392839003929190911b9050611932565b6000836118f25760006118f5565b60015b60ff1690505b600160701b8210156119305793800260ff81901c607f81019190911c94600019939093019260019290921b90821801906118fb565b505b806001600160701b0316607083901b8461194d576000611953565b6001607f1b5b6001600160801b0316171760801b979650505050505050565b60006001607f1b608083901c90811190617fff60f085901c8116916001600160701b0316908214801561199e57508015155b156119b2575061ffff60ef1b949350505050565b61400d8211156119d757826119cc57617fff60f01b6108ce565b600095945050505050565b613f7f8210156119f05750613fff60f01b949350505050565b816119fe5760019150611a05565b600160701b175b613fef821115611a1b57613fee1982011b611a2d565b613fef821015611a2d57613fef8290031c5b828015611a3e575061203760811b81115b15611a4e57506000949350505050565b82158015611a6d5750713fffffffffffffffffffffffffffffffffff81115b15611a815750617fff60f01b949350505050565b6001600160801b0381169060801c838015611a9b57508115155b15611aa7579019906001015b6001607f1b82811615611acb5770016a09e667f3bcc908b2fb1366ea957d3e0260801c5b6001607e1b831615611aee577001306fe0a31b7152de8d5a46305c85edec0260801c5b6001607d1b831615611b11577001172b83c7d517adcdf7c8c50eb14a791f0260801c5b6001607c1b831615611b345770010b5586cf9890f6298b92b71842a983630260801c5b6001607b1b831615611b57577001059b0d31585743ae7c548eb68ca417fd0260801c5b6001607a1b831615611b7a57700102c9a3e778060ee6f7caca4f7a29bde80260801c5b600160791b831615611b9d5770010163da9fb33356d84a66ae336dcdfa3f0260801c5b600160781b831615611bc057700100b1afa5abcbed6129ab13ec11dc95430260801c5b600160771b831615611be35770010058c86da1c09ea1ff19d294cf2f679b0260801c5b600160761b831615611c06577001002c605e2e8cec506d21bfc89a23a00f0260801c5b600160751b831615611c2957700100162f3904051fa128bca9c55c31e5df0260801c5b600160741b831615611c4c577001000b175effdc76ba38e31671ca9397250260801c5b600160731b831615611c6f57700100058ba01fb9f96d6cacd4b180917c3d0260801c5b600160721b831615611c925770010002c5cc37da9491d0985c348c68e7b30260801c5b600160711b831615611cb5577001000162e525ee054754457d59952920260260801c5b600160701b831615611cd85770010000b17255775c040618bf4a4ade83fc0260801c5b6001606f1b831615611cfb577001000058b91b5bc9ae2eed81e9b7d4cfab0260801c5b6001606e1b831615611d1e57700100002c5c89d5ec6ca4d7c8acc017b7c90260801c5b6001606d1b831615611d415770010000162e43f4f831060e02d839a9d16d0260801c5b6001606c1b831615611d6457700100000b1721bcfc99d9f890ea069117630260801c5b6001606b1b831615611d875770010000058b90cf1e6d97f9ca14dbcc16280260801c5b6001606a1b831615611daa577001000002c5c863b73f016468f6bac5ca2b0260801c5b600160691b831615611dcd57700100000162e430e5a18f6119e3c02282a50260801c5b600160681b831615611df0577001000000b1721835514b86e6d96efd1bfe0260801c5b600160671b831615611e1357700100000058b90c0b48c6be5df846c5b2ef0260801c5b600160661b831615611e365770010000002c5c8601cc6b9e94213c72737a0260801c5b600160651b831615611e59577001000000162e42fff037df38aa2b219f060260801c5b600160641b831615611e7c5770010000000b17217fba9c739aa5819f44f90260801c5b600160631b831615611e9f577001000000058b90bfcdee5acd3c1cedc8230260801c5b600160621b831615611ec257700100000002c5c85fe31f35a6a30da1be500260801c5b600160611b831615611ee55770010000000162e42ff0999ce3541b9fffcf0260801c5b600160601b831615611f0857700100000000b17217f80f4ef5aadda455540260801c5b6001605f1b831615611f2b5770010000000058b90bfbf8479bd5a81b51ad0260801c5b6001605e1b831615611f4e577001000000002c5c85fdf84bd62ae30a74cc0260801c5b6001605d1b831615611f7157700100000000162e42fefb2fed257559bdaa0260801c5b6001605c1b831615611f94577001000000000b17217f7d5a7716bba4a9ae0260801c5b6001605b1b831615611fb757700100000000058b90bfbe9ddbac5e109cce0260801c5b6001605a1b831615611fda5770010000000002c5c85fdf4b15de6f17eb0d0260801c5b600160591b831615611ffd577001000000000162e42fefa494f1478fde050260801c5b600160581b8316156120205770010000000000b17217f7d20cf927c8e94c0260801c5b600160571b831615612043577001000000000058b90bfbe8f71cb4e4b33d0260801c5b600160561b83161561206657700100000000002c5c85fdf477b662b269450260801c5b600160551b8316156120895770010000000000162e42fefa3ae53369388c0260801c5b600160541b8316156120ac57700100000000000b17217f7d1d351a389d400260801c5b600160531b8316156120cf5770010000000000058b90bfbe8e8b2d3d4ede0260801c5b600160521b8316156120f2577001000000000002c5c85fdf4741bea6e77e0260801c5b600160511b83161561211557700100000000000162e42fefa39fe95583c20260801c5b600160501b831615612138577001000000000000b17217f7d1cfb72b45e10260801c5b698000000000000000000083161561216157700100000000000058b90bfbe8e7cc35c3f00260801c5b694000000000000000000083161561218a5770010000000000002c5c85fdf473e242ea380260801c5b69200000000000000000008316156121b3577001000000000000162e42fefa39f02b772c0260801c5b69100000000000000000008316156121dc5770010000000000000b17217f7d1cf7d83c1a0260801c5b6908000000000000000000831615612205577001000000000000058b90bfbe8e7bdcbe2e0260801c5b690400000000000000000083161561222e57700100000000000002c5c85fdf473dea871f0260801c5b69020000000000000000008316156122575770010000000000000162e42fefa39ef44d910260801c5b690100000000000000000083161561228057700100000000000000b17217f7d1cf79e9490260801c5b688000000000000000008316156122a85770010000000000000058b90bfbe8e7bce5440260801c5b684000000000000000008316156122d0577001000000000000002c5c85fdf473de6eca0260801c5b682000000000000000008316156122f857700100000000000000162e42fefa39ef366f0260801c5b68100000000000000000831615612320577001000000000000000b17217f7d1cf79afa0260801c5b6808000000000000000083161561234857700100000000000000058b90bfbe8e7bcd6d0260801c5b680400000000000000008316156123705770010000000000000002c5c85fdf473de6b20260801c5b68020000000000000000831615612398577001000000000000000162e42fefa39ef3580260801c5b600160401b8316156123bb5770010000000000000000b17217f7d1cf79ab0260801c5b6780000000000000008316156123e2577001000000000000000058b90bfbe8e7bcd50260801c5b67400000000000000083161561240957700100000000000000002c5c85fdf473de6a0260801c5b6720000000000000008316156124305770010000000000000000162e42fefa39ef340260801c5b67100000000000000083161561245757700100000000000000000b17217f7d1cf7990260801c5b67080000000000000083161561247e5770010000000000000000058b90bfbe8e7bcc0260801c5b6704000000000000008316156124a5577001000000000000000002c5c85fdf473de50260801c5b6702000000000000008316156124cc57700100000000000000000162e42fefa39ef20260801c5b6701000000000000008316156124f3577001000000000000000000b17217f7d1cf780260801c5b668000000000000083161561251957700100000000000000000058b90bfbe8e7bb0260801c5b664000000000000083161561253f5770010000000000000000002c5c85fdf473dd0260801c5b6620000000000000831615612565577001000000000000000000162e42fefa39ee0260801c5b661000000000000083161561258b5770010000000000000000000b17217f7d1cf60260801c5b66080000000000008316156125b1577001000000000000000000058b90bfbe8e7a0260801c5b66040000000000008316156125d757700100000000000000000002c5c85fdf473c0260801c5b66020000000000008316156125fd5770010000000000000000000162e42fefa39d0260801c5b660100000000000083161561262357700100000000000000000000b17217f7d1ce0260801c5b658000000000008316156126485770010000000000000000000058b90bfbe8e60260801c5b6540000000000083161561266d577001000000000000000000002c5c85fdf4720260801c5b6520000000000083161561269257700100000000000000000000162e42fefa380260801c5b651000000000008316156126b7577001000000000000000000000b17217f7d1b0260801c5b650800000000008316156126dc57700100000000000000000000058b90bfbe8d0260801c5b650400000000008316156127015770010000000000000000000002c5c85fdf460260801c5b65020000000000831615612726577001000000000000000000000162e42fefa20260801c5b6501000000000083161561274b5770010000000000000000000000b17217f7d00260801c5b64800000000083161561276f577001000000000000000000000058b90bfbe70260801c5b64400000000083161561279357700100000000000000000000002c5c85fdf30260801c5b6420000000008316156127b75770010000000000000000000000162e42fef90260801c5b6410000000008316156127db57700100000000000000000000000b17217f7c0260801c5b6408000000008316156127ff5770010000000000000000000000058b90bfbd0260801c5b640400000000831615612823577001000000000000000000000002c5c85fde0260801c5b64020000000083161561284757700100000000000000000000000162e42fee0260801c5b64010000000083161561286b577001000000000000000000000000b17217f60260801c5b638000000083161561288e57700100000000000000000000000058b90bfa0260801c5b63400000008316156128b15770010000000000000000000000002c5c85fc0260801c5b63200000008316156128d4577001000000000000000000000000162e42fd0260801c5b63100000008316156128f75770010000000000000000000000000b17217e0260801c5b630800000083161561291a577001000000000000000000000000058b90be0260801c5b630400000083161561293d57700100000000000000000000000002c5c85e0260801c5b63020000008316156129605770010000000000000000000000000162e42e0260801c5b630100000083161561298357700100000000000000000000000000b172160260801c5b628000008316156129a55770010000000000000000000000000058b90a0260801c5b624000008316156129c7577001000000000000000000000000002c5c840260801c5b622000008316156129e957700100000000000000000000000000162e410260801c5b62100000831615612a0b577001000000000000000000000000000b17200260801c5b62080000831615612a2d57700100000000000000000000000000058b8f0260801c5b62040000831615612a4f5770010000000000000000000000000002c5c70260801c5b62020000831615612a71577001000000000000000000000000000162e30260801c5b62010000831615612a935770010000000000000000000000000000b1710260801c5b618000831615612ab4577001000000000000000000000000000058b80260801c5b614000831615612ad557700100000000000000000000000000002c5b0260801c5b612000831615612af65770010000000000000000000000000000162d0260801c5b611000831615612b1757700100000000000000000000000000000b160260801c5b610800831615612b385770010000000000000000000000000000058a0260801c5b610400831615612b59577001000000000000000000000000000002c40260801c5b610200831615612b7a577001000000000000000000000000000001610260801c5b610100831615612b9b577001000000000000000000000000000000b00260801c5b6080831615612bbb577001000000000000000000000000000000570260801c5b6040831615612bdb5770010000000000000000000000000000002b0260801c5b6020831615612bfb577001000000000000000000000000000000150260801c5b6010831615612c1b5770010000000000000000000000000000000a0260801c5b6008831615612c3b577001000000000000000000000000000000040260801c5b6004831615612c5b577001000000000000000000000000000000010260801c5b84612c7c57600f81901c6001600160701b03169050613fff82019150612cab565b613ffe8211612ca157600f81901c6001600160701b0316905081613fff039150612cab565b600091613fee19011c5b60709190911b1760801b95945050505050565b6000808211612ccc57600080fd5b6000600160801b8310612ce157608092831c92015b600160401b8310612cf457604092831c92015b6401000000008310612d0857602092831c92015b620100008310612d1a57601092831c92015b6101008310612d2b57600892831c92015b60108310612d3b57600492831c92015b60048310612d4b57600292831c92015b600283106104a65760010192915050565b80356001600160801b031981168114610dfe57600080fd5b600060208284031215612d8657600080fd5b6104a382612d5c565b60008060408385031215612da257600080fd5b612dab83612d5c565b9150612db960208401612d5c565b90509250929050565b60008060008060808587031215612dd857600080fd5b612de185612d5c565b9350612def60208601612d5c565b93969395505050506040820135916060013590565b600080600060608486031215612e1957600080fd5b612e2284612d5c565b925060208401358060000b8114612e3857600080fd5b9150612e4660408501612d5c565b90509250925092565b60008060408385031215612e6257600080fd5b612e6b83612d5c565b946020939093013593505050565b60008060408385031215612e8c57600080fd5b50508035926020909101359150565b600060c08284031215612ead57600080fd5b50919050565b60006101608284031215612ead57600080fd5b600060208284031215612ed857600080fd5b5035919050565b600080600060608486031215612ef457600080fd5b505081359360208301359350604090920135919050565b60008060008060808587031215612f2157600080fd5b5050823594602084013594506040840135936060013592509050565b600080600080600060a08688031215612f5557600080fd5b505083359560208501359550604085013594606081013594506080013592509050565b6020808252600a908201526907072696365203d3d20360b41b604082015260600190565b60008219821115612faf57612faf61310d565b500190565b600082612fd157634e487b7160e01b600052601260045260246000fd5b500490565b600181815b80851115613011578160001904821115612ff757612ff761310d565b8085161561300457918102915b93841c9390800290612fdb565b509250929050565b60006104a3838360008261302f575060016104a6565b8161303c575060006104a6565b8160018114613052576002811461305c57613078565b60019150506104a6565b60ff84111561306d5761306d61310d565b50506001821b6104a6565b5060208310610133831016604e8410600b841016171561309b575081810a6104a6565b6130a58383612fd6565b80600019048211156130b9576130b961310d565b029392505050565b60008160001904831182151516156130db576130db61310d565b500290565b6000828210156130f2576130f261310d565b500390565b634e487b7160e01b600052600160045260246000fd5b634e487b7160e01b600052601160045260246000fd5b634e487b7160e01b600052601260045260246000fdfea2646970667358221220ea5d348f64d5b920f23df3d012d449ffc00cb3b6caba215f675cf3058cea2ca864736f6c63430008070033",
    "deployedBytecode": "0x73000000000000000000000000000000000000000030146080604052600436106101d95760003560e01c8063ab41556f1161010e578063cff70001116100ac578063e45639451161007b578063e45639451461044b578063fc3115811461045e578063fea3de3314610471578063ff9afe871461048457600080fd5b8063cff70001146103ea578063dc35bc13146103fd578063debb52df14610425578063dfdbe4da1461043857600080fd5b8063bf36f0e9116100e8578063bf36f0e9146103a5578063c15172d2146103b8578063c2ee3a08146103cb578063c3ff8091146103d757600080fd5b8063ab41556f1461036c578063aeb64d7d1461037f578063b6b2f9f61461039257600080fd5b8063664808a81161017b57806388b78aaa1161015557806388b78aaa146102da5780639eb17fa3146102eb578063a481c1b414610326578063a818c0d21461035957600080fd5b8063664808a8146102975780636fa1268e146102a657806381a799db146102b757600080fd5b8063202f1257116101b7578063202f12571461024b578063422051e71461025e57806345e7ef9b146102715780635cf4ee911461028457600080fd5b80630417cf8e146101de5780630e8418dd146101f95780631842c9d814610225575b600080fd5b6101e6601281565b6040519081526020015b60405180910390f35b61020c610207366004612d8f565b610497565b6040516001600160801b031990911681526020016101f0565b610238610233366004612d8f565b6104ac565b60405160009190910b81526020016101f0565b61020c610259366004612e79565b6104b8565b61020c61026c366004612e4f565b6104d4565b61020c61027f366004612d8f565b6104e8565b61020c610292366004612e79565b6104f4565b6101e6670de0b6b3a764000081565b61020c66201bb1a2bc2ec560c91b81565b6102ca6102c5366004612f0b565b61051c565b60405190151581526020016101f0565b61020c668075782dace9d960c71b81565b6102fe6102f9366004612eb3565b610540565b604080519586526020860194909452928401919091526060830152608082015260a0016101f0565b610339610334366004612e9b565b6106f5565b6040805194855260208501939093529183015260608201526080016101f0565b6101e6610367366004612e4f565b61085e565b6101e661037a366004612f0b565b610883565b6101e661038d366004612d74565b6108d7565b61020c6103a0366004612d8f565b6108e2565b6101e66103b3366004612e79565b6108ee565b6101e66103c6366004612dc2565b610913565b61020c613fff60f01b81565b61020c6103e5366004612e04565b61096c565b61020c6103f8366004612e79565b6109ac565b61041061040b366004612edf565b6109bb565b604080519283526020830191909152016101f0565b6101e6610433366004612f0b565b610a14565b61020c610446366004612ec6565b610a53565b6101e6610459366004612e4f565b610a5e565b6101e661046c366004612e4f565b610a9c565b6101e661047f366004612edf565b610ada565b6101e6610492366004612f3d565b610b26565b60006104a38383610c37565b90505b92915050565b60006104a38383610c49565b60006104a36104c684610d70565b6104cf84610d70565b610e03565b60006104a3836104e3846110ba565b61111e565b60006104a3838361111e565b6000816105075750613fff60f01b6104a6565b6104a3610513846110ba565b6104cf846110ba565b6000848261052a8587612f9c565b61053491906130e0565b1190505b949350505050565b6000806000806000856040013586606001351061056b575060009350839250829150819050806106ec565b60008060008860800135118061058657506000886101200135115b156105be576105bb61059b60208a018a612d74565b6105ab60408b0160208c01612d74565b8a608001358b6101200135610913565b96505b60a088013515610624576105e26105d860208a018a612d74565b8960a00135610a9c565b9150670de0b6b3a764000061060b61038d6106056101608c016101408d01612d74565b856104d4565b6106159190612fb4565b945061062185836130e0565b91505b60008860c00135118061063c57506000886101000135115b156106745761067161065460408a0160208b01612d74565b61066160208b018b612d74565b8a60c001358b6101000135610913565b95505b60e0880135156106dd5761069b61069160408a0160208b01612d74565b8960e00135610a9c565b9050670de0b6b3a76400006106c461038d6106be6101608c016101408d01612d74565b846104d4565b6106ce9190612fb4565b93506106da84826130e0565b90505b6106e78282612f9c565b925050505b91939590929450565b6000808080606085013560408601358261071560a0890160808a01612d74565b905087356020890135600061073060c08c0160a08d01612d74565b90506000670de0b6b3a764000061074a61038d84896104d4565b6107549190612fb4565b90506000670de0b6b3a764000061076e61038d858b6104d4565b6107789190612fb4565b905061078481896130e0565b975061079082886130e0565b9650600061079e85876104b8565b905060006107b182613fff60f01b6104ac565b905060006107c083838b61096c565b905060008260000b121580156107d6575060008b115b156108075760006107e7828d61085e565b90506107f3818d6130e0565b9b506107ff818c612f9c565b9a5050610847565b60008260000b12801561081a575060008a115b1561084757600061082b828c61085e565b9050610837818d612f9c565b9b50610843818c6130e0565b9a50505b50979e989d50919b50995095975050505050505050565b60006104a361087e610875613fff60f01b86610c37565b6104e3856110ba565b611379565b600082158061089957506108978286612f9c565b155b806108a2575083155b156108ae575082610538565b82846108ba8488612f9c565b6108c491906130c1565b6108ce9190612fb4565b95945050505050565b60006104a682611379565b60006104a383836113fc565b6000806108fc8360126130e0565b61090790600a613019565b90506105388185612fb4565b60006001600160801b031985166109455760405162461bcd60e51b815260040161093c90612f78565b60405180910390fd5b8115610962576109558483610a9c565b61095f9084612f9c565b92505b6108ce8584610a5e565b60006109a261099d836104e360008760000b1261099757610992613fff60f01b89610e03565b6117bc565b876117bc565b61196c565b90505b9392505050565b600081610507575060006104a6565b600080806109cd856103f88682612f9c565b905060006109de61038d83896104d4565b905060006109ec82886130e0565b905060006109fa838a6130e0565b610a0490886130e0565b9199919850909650505050505050565b6000821580610a2a5750610a288286612f9c565b155b80610a33575083155b15610a3f575082610538565b610a498286612f9c565b6108c485856130c1565b60006104a6826110ba565b60006001600160801b03198316610a875760405162461bcd60e51b815260040161093c90612f78565b6104a361087e610a96846110ba565b85610e03565b60006001600160801b03198316610ac55760405162461bcd60e51b815260040161093c90612f78565b6104a361087e610ad4846110ba565b8561111e565b600081610ae9575060006109a5565b6000610b00610af7866110ba565b6104e3866110ba565b90506000610b11826104cf866110ba565b9050610b1c816108d7565b9695505050505050565b600085851115610b705760405162461bcd60e51b81526020600482015260156024820152741d1a5b595cdd185b5c081a5b881d1a19481c185cdd605a1b604482015260640161093c565b828411610c0657610b838686858761051c565b15610b8f5750806108ce565b600083610b9c87896130e0565b610ba69190612fb4565b905060008585610bb7846001612f9c565b610bc191906130c1565b610bcb9089612f9c565b610bd591906130e0565b9050808810610bfc57610be88285612f9c565b610bf3906001612f9c565b925050506108ce565b610bf38285612f9c565b6000610c128588612f9c565b9050600084610c2188846130e0565b610c2b9190612fb4565b9050610bf38185612f9c565b60006104a383600160ff1b84186113fc565b600060016001607f1b03608084901c16617fff60701b811115610c6b57600080fd5b60016001607f1b03608084901c16617fff60701b811115610c8b57600080fd5b6001600160801b0319858116908516141580610cb45750617fff60701b826001600160801b0316105b610cbd57600080fd5b6001600160801b03198581169085161415610cdd576000925050506104a6565b6001607f1b608086811c82118015929187901c919091101590610d2f578015610d2057826001600160801b0316846001600160801b031611610d20576001610d24565b6000195b9450505050506104a6565b8015610d425760019450505050506104a6565b826001600160801b0316846001600160801b031611610d6357600019610d24565b60019450505050506104a6565b600081610d7f57506000919050565b6000808313610d915782600003610d93565b825b90506000610da082612cbe565b90506070811015610db9578060700382901b9150610dcc565b6070811115610dcc576070810382901c91505b6001600160701b03909116613fff820160701b17906000841215610df4576001607f1b821791505b5060801b92915050565b919050565b6000617fff60f084811c8216919084901c811690821415610e495780617fff1415610e38575061ffff60ef1b91506104a69050565b505050600160ff1b811682186104a6565b80617fff1415610e8d576dffffffffffffffffffffffffffff60801b841615610e7c575061ffff60ef1b91506104a69050565b505050808218600160ff1b166104a6565b600160801b600160ff1b038416610ed757600160801b600160ff1b038516610ebf575061ffff60ef1b91506104a69050565b505050808218600160ff1b16617fff60f01b176104a6565b6001600160701b03608085901c1681610ef35760019150610efa565b600160701b175b6001600160701b03608087901c1683610f39578015610f34576000610f1e82612cbe565b6001955060e20393840160711901939190911b90505b610f43565b600160701b1760721b5b818181610f5257610f52613123565b04905080610f7e57600160ff1b87871816610f6e576000610d24565b600160ff1b9450505050506104a6565b6001606c1b811015610f9257610f926130f7565b6000600160731b821015610fd157600160721b821015610fc657600160711b821015610fbf576070610fc9565b6071610fc9565b60725b60ff16610fda565b610fda82612cbe565b905083614071018186011115610ff857617fff94506000915061108b565b83818601613ffc01101561101357600094506000915061108b565b83818601613f8c011015611060578385613ffc01111561103e578385613ffc010382901b9150611057565b8385613ffc01101561105757613ffc8585030382901c91505b6000945061108b565b6070811115611073576070810382901c91505b6001600160701b038216915083818601613f8d010394505b81607086901b888a186001607f1b60801b1660801c6001600160801b0316171760801b955050505050506104a6565b6000816110c957506000919050565b8160006110d582612cbe565b905060708110156110ee578060700382901b9150611101565b6070811115611101576070810382901c91505b613fff0160701b6001600160701b03919091161760801b92915050565b6000617fff60f084811c8216919084901c8116908214156111bd5780617fff141561119c576001600160801b0319858116908516141561116957505050600160ff1b811682186104a6565b600160ff1b6001600160801b031986861816141561118c575050508181176104a6565b5061ffff60ef1b91506104a69050565b600160801b600160ff1b038416610e38575061ffff60ef1b91506104a69050565b80617fff14156111f957600160801b600160ff1b0385166111e8575061ffff60ef1b91506104a69050565b505050600160ff1b821681186104a6565b6001600160701b03608086901c1682611215576001925061121c565b600160701b175b6001600160701b03608086901c1682611238576001925061123f565b600160701b175b908102908161125c57600160ff1b87871816610f6e576000610d24565b928201926000600160e11b83101561128f57600160e01b8310156112885761128383612cbe565b611292565b60e0611292565b60e15b905061407081860110156112ad57600094506000925061134a565b6140e081860110156112f0576140708510156112d257846140700383901c92506112e7565b6140708511156112e757614070850383901b92505b6000945061134a565b61c0dd818601111561130a57617fff94506000925061134a565b6070811115611321576070810383901c9250611334565b6070811015611334578060700383901b92505b6001600160701b03831692506140df8186010394505b82607086901b888a186001607f1b60801b1660801c6001600160801b0316171760801b955050505050506104a6565b6000617fff60f083901c16613fff8110156113975750600092915050565b6001607f1b608084901c106113ab57600080fd5b6140fe8111156113ba57600080fd5b600160701b6001600160701b03608085901c161761406f8210156113e45761406f8290031c6109a5565b61406f8211156109a55761406e1982011b9392505050565b6000617fff60f084811c8216919084901c81169082141561144a5780617fff1415611440576001600160801b0319858116908516141561118c5784925050506104a6565b84925050506104a6565b80617fff141561145e5783925050506104a6565b6001607f1b608086901c90811015906001600160701b031683611484576001935061148b565b600160701b175b6001607f1b608087901c90811015906001600160701b0316846114b157600194506114b8565b600160701b175b826114e8576001600160801b03198816600160ff1b146114d857876114db565b60005b96505050505050506104a6565b80611508576001600160801b03198916600160ff1b146114d857886114db565b848603841515831515141561161357607081131561152f57899750505050505050506104a6565b60008113156115415790811c90611570565b606f1981121561155a57889750505050505050506104a6565b6000811215611570578060000384901c93508596505b92810192600160711b841061158b576001968701969390931c925b86617fff14156115bd57846115a557617fff60f01b6115af565b6001600160f01b03195b9750505050505050506104a6565b600160701b8410156115d257600096506115df565b6001600160701b03841693505b83607088901b866115f15760006115f7565b6001607f1b5b6001600160801b0316171760801b9750505050505050506104a6565b600081131561162e57600184901b9350600187039650611645565b600081121561164557600182901b91506001860396505b607081131561165757600191506116a4565b6001811315611674576001810360018303901c60010191506116a4565b606f1981121561168757600193506116a4565b6000198112156116a4576001816000030360018503901c60010193505b8184106116b55781840393506116be565b83820393508294505b836116d45750600096506104a695505050505050565b60006116df85612cbe565b9050806071141561170557600185901c6001600160701b03169450600188019750611754565b607081101561174757607081900380891115611734578086901b6001600160701b031695508089039850611741565b600098600019019590951b945b50611754565b6001600160701b03851694505b87617fff1415611787578561176e57617fff60f01b611778565b6001600160f01b03195b985050505050505050506104a6565b84607089901b8761179957600061179f565b6001607f1b5b6001600160801b0316171760801b985050505050505050506104a6565b60006001607f1b608083901c11156117da575061ffff60ef1b919050565b613fff60f01b6001600160801b0319831614156117f957506000919050565b617fff60f083901c811690811415611812575090919050565b6001600160701b03608084901c168161182e5760019150611835565b600160701b175b8061184b57506001600160f01b03199392505050565b600061406f81613fff85106118715750600f9290921b9160009150613ffe1984016118b0565b60019250600160701b84106118935784613ffe039050600f84901b93506118b0565b600061189e85612cbe565b607f8190039590951b9461406d039150505b836001607f1b14156118e45782156118c6576001015b60006118d182612cbe565b60700392839003929190911b9050611932565b6000836118f25760006118f5565b60015b60ff1690505b600160701b8210156119305793800260ff81901c607f81019190911c94600019939093019260019290921b90821801906118fb565b505b806001600160701b0316607083901b8461194d576000611953565b6001607f1b5b6001600160801b0316171760801b979650505050505050565b60006001607f1b608083901c90811190617fff60f085901c8116916001600160701b0316908214801561199e57508015155b156119b2575061ffff60ef1b949350505050565b61400d8211156119d757826119cc57617fff60f01b6108ce565b600095945050505050565b613f7f8210156119f05750613fff60f01b949350505050565b816119fe5760019150611a05565b600160701b175b613fef821115611a1b57613fee1982011b611a2d565b613fef821015611a2d57613fef8290031c5b828015611a3e575061203760811b81115b15611a4e57506000949350505050565b82158015611a6d5750713fffffffffffffffffffffffffffffffffff81115b15611a815750617fff60f01b949350505050565b6001600160801b0381169060801c838015611a9b57508115155b15611aa7579019906001015b6001607f1b82811615611acb5770016a09e667f3bcc908b2fb1366ea957d3e0260801c5b6001607e1b831615611aee577001306fe0a31b7152de8d5a46305c85edec0260801c5b6001607d1b831615611b11577001172b83c7d517adcdf7c8c50eb14a791f0260801c5b6001607c1b831615611b345770010b5586cf9890f6298b92b71842a983630260801c5b6001607b1b831615611b57577001059b0d31585743ae7c548eb68ca417fd0260801c5b6001607a1b831615611b7a57700102c9a3e778060ee6f7caca4f7a29bde80260801c5b600160791b831615611b9d5770010163da9fb33356d84a66ae336dcdfa3f0260801c5b600160781b831615611bc057700100b1afa5abcbed6129ab13ec11dc95430260801c5b600160771b831615611be35770010058c86da1c09ea1ff19d294cf2f679b0260801c5b600160761b831615611c06577001002c605e2e8cec506d21bfc89a23a00f0260801c5b600160751b831615611c2957700100162f3904051fa128bca9c55c31e5df0260801c5b600160741b831615611c4c577001000b175effdc76ba38e31671ca9397250260801c5b600160731b831615611c6f57700100058ba01fb9f96d6cacd4b180917c3d0260801c5b600160721b831615611c925770010002c5cc37da9491d0985c348c68e7b30260801c5b600160711b831615611cb5577001000162e525ee054754457d59952920260260801c5b600160701b831615611cd85770010000b17255775c040618bf4a4ade83fc0260801c5b6001606f1b831615611cfb577001000058b91b5bc9ae2eed81e9b7d4cfab0260801c5b6001606e1b831615611d1e57700100002c5c89d5ec6ca4d7c8acc017b7c90260801c5b6001606d1b831615611d415770010000162e43f4f831060e02d839a9d16d0260801c5b6001606c1b831615611d6457700100000b1721bcfc99d9f890ea069117630260801c5b6001606b1b831615611d875770010000058b90cf1e6d97f9ca14dbcc16280260801c5b6001606a1b831615611daa577001000002c5c863b73f016468f6bac5ca2b0260801c5b600160691b831615611dcd57700100000162e430e5a18f6119e3c02282a50260801c5b600160681b831615611df0577001000000b1721835514b86e6d96efd1bfe0260801c5b600160671b831615611e1357700100000058b90c0b48c6be5df846c5b2ef0260801c5b600160661b831615611e365770010000002c5c8601cc6b9e94213c72737a0260801c5b600160651b831615611e59577001000000162e42fff037df38aa2b219f060260801c5b600160641b831615611e7c5770010000000b17217fba9c739aa5819f44f90260801c5b600160631b831615611e9f577001000000058b90bfcdee5acd3c1cedc8230260801c5b600160621b831615611ec257700100000002c5c85fe31f35a6a30da1be500260801c5b600160611b831615611ee55770010000000162e42ff0999ce3541b9fffcf0260801c5b600160601b831615611f0857700100000000b17217f80f4ef5aadda455540260801c5b6001605f1b831615611f2b5770010000000058b90bfbf8479bd5a81b51ad0260801c5b6001605e1b831615611f4e577001000000002c5c85fdf84bd62ae30a74cc0260801c5b6001605d1b831615611f7157700100000000162e42fefb2fed257559bdaa0260801c5b6001605c1b831615611f94577001000000000b17217f7d5a7716bba4a9ae0260801c5b6001605b1b831615611fb757700100000000058b90bfbe9ddbac5e109cce0260801c5b6001605a1b831615611fda5770010000000002c5c85fdf4b15de6f17eb0d0260801c5b600160591b831615611ffd577001000000000162e42fefa494f1478fde050260801c5b600160581b8316156120205770010000000000b17217f7d20cf927c8e94c0260801c5b600160571b831615612043577001000000000058b90bfbe8f71cb4e4b33d0260801c5b600160561b83161561206657700100000000002c5c85fdf477b662b269450260801c5b600160551b8316156120895770010000000000162e42fefa3ae53369388c0260801c5b600160541b8316156120ac57700100000000000b17217f7d1d351a389d400260801c5b600160531b8316156120cf5770010000000000058b90bfbe8e8b2d3d4ede0260801c5b600160521b8316156120f2577001000000000002c5c85fdf4741bea6e77e0260801c5b600160511b83161561211557700100000000000162e42fefa39fe95583c20260801c5b600160501b831615612138577001000000000000b17217f7d1cfb72b45e10260801c5b698000000000000000000083161561216157700100000000000058b90bfbe8e7cc35c3f00260801c5b694000000000000000000083161561218a5770010000000000002c5c85fdf473e242ea380260801c5b69200000000000000000008316156121b3577001000000000000162e42fefa39f02b772c0260801c5b69100000000000000000008316156121dc5770010000000000000b17217f7d1cf7d83c1a0260801c5b6908000000000000000000831615612205577001000000000000058b90bfbe8e7bdcbe2e0260801c5b690400000000000000000083161561222e57700100000000000002c5c85fdf473dea871f0260801c5b69020000000000000000008316156122575770010000000000000162e42fefa39ef44d910260801c5b690100000000000000000083161561228057700100000000000000b17217f7d1cf79e9490260801c5b688000000000000000008316156122a85770010000000000000058b90bfbe8e7bce5440260801c5b684000000000000000008316156122d0577001000000000000002c5c85fdf473de6eca0260801c5b682000000000000000008316156122f857700100000000000000162e42fefa39ef366f0260801c5b68100000000000000000831615612320577001000000000000000b17217f7d1cf79afa0260801c5b6808000000000000000083161561234857700100000000000000058b90bfbe8e7bcd6d0260801c5b680400000000000000008316156123705770010000000000000002c5c85fdf473de6b20260801c5b68020000000000000000831615612398577001000000000000000162e42fefa39ef3580260801c5b600160401b8316156123bb5770010000000000000000b17217f7d1cf79ab0260801c5b6780000000000000008316156123e2577001000000000000000058b90bfbe8e7bcd50260801c5b67400000000000000083161561240957700100000000000000002c5c85fdf473de6a0260801c5b6720000000000000008316156124305770010000000000000000162e42fefa39ef340260801c5b67100000000000000083161561245757700100000000000000000b17217f7d1cf7990260801c5b67080000000000000083161561247e5770010000000000000000058b90bfbe8e7bcc0260801c5b6704000000000000008316156124a5577001000000000000000002c5c85fdf473de50260801c5b6702000000000000008316156124cc57700100000000000000000162e42fefa39ef20260801c5b6701000000000000008316156124f3577001000000000000000000b17217f7d1cf780260801c5b668000000000000083161561251957700100000000000000000058b90bfbe8e7bb0260801c5b664000000000000083161561253f5770010000000000000000002c5c85fdf473dd0260801c5b6620000000000000831615612565577001000000000000000000162e42fefa39ee0260801c5b661000000000000083161561258b5770010000000000000000000b17217f7d1cf60260801c5b66080000000000008316156125b1577001000000000000000000058b90bfbe8e7a0260801c5b66040000000000008316156125d757700100000000000000000002c5c85fdf473c0260801c5b66020000000000008316156125fd5770010000000000000000000162e42fefa39d0260801c5b660100000000000083161561262357700100000000000000000000b17217f7d1ce0260801c5b658000000000008316156126485770010000000000000000000058b90bfbe8e60260801c5b6540000000000083161561266d577001000000000000000000002c5c85fdf4720260801c5b6520000000000083161561269257700100000000000000000000162e42fefa380260801c5b651000000000008316156126b7577001000000000000000000000b17217f7d1b0260801c5b650800000000008316156126dc57700100000000000000000000058b90bfbe8d0260801c5b650400000000008316156127015770010000000000000000000002c5c85fdf460260801c5b65020000000000831615612726577001000000000000000000000162e42fefa20260801c5b6501000000000083161561274b5770010000000000000000000000b17217f7d00260801c5b64800000000083161561276f577001000000000000000000000058b90bfbe70260801c5b64400000000083161561279357700100000000000000000000002c5c85fdf30260801c5b6420000000008316156127b75770010000000000000000000000162e42fef90260801c5b6410000000008316156127db57700100000000000000000000000b17217f7c0260801c5b6408000000008316156127ff5770010000000000000000000000058b90bfbd0260801c5b640400000000831615612823577001000000000000000000000002c5c85fde0260801c5b64020000000083161561284757700100000000000000000000000162e42fee0260801c5b64010000000083161561286b577001000000000000000000000000b17217f60260801c5b638000000083161561288e57700100000000000000000000000058b90bfa0260801c5b63400000008316156128b15770010000000000000000000000002c5c85fc0260801c5b63200000008316156128d4577001000000000000000000000000162e42fd0260801c5b63100000008316156128f75770010000000000000000000000000b17217e0260801c5b630800000083161561291a577001000000000000000000000000058b90be0260801c5b630400000083161561293d57700100000000000000000000000002c5c85e0260801c5b63020000008316156129605770010000000000000000000000000162e42e0260801c5b630100000083161561298357700100000000000000000000000000b172160260801c5b628000008316156129a55770010000000000000000000000000058b90a0260801c5b624000008316156129c7577001000000000000000000000000002c5c840260801c5b622000008316156129e957700100000000000000000000000000162e410260801c5b62100000831615612a0b577001000000000000000000000000000b17200260801c5b62080000831615612a2d57700100000000000000000000000000058b8f0260801c5b62040000831615612a4f5770010000000000000000000000000002c5c70260801c5b62020000831615612a71577001000000000000000000000000000162e30260801c5b62010000831615612a935770010000000000000000000000000000b1710260801c5b618000831615612ab4577001000000000000000000000000000058b80260801c5b614000831615612ad557700100000000000000000000000000002c5b0260801c5b612000831615612af65770010000000000000000000000000000162d0260801c5b611000831615612b1757700100000000000000000000000000000b160260801c5b610800831615612b385770010000000000000000000000000000058a0260801c5b610400831615612b59577001000000000000000000000000000002c40260801c5b610200831615612b7a577001000000000000000000000000000001610260801c5b610100831615612b9b577001000000000000000000000000000000b00260801c5b6080831615612bbb577001000000000000000000000000000000570260801c5b6040831615612bdb5770010000000000000000000000000000002b0260801c5b6020831615612bfb577001000000000000000000000000000000150260801c5b6010831615612c1b5770010000000000000000000000000000000a0260801c5b6008831615612c3b577001000000000000000000000000000000040260801c5b6004831615612c5b577001000000000000000000000000000000010260801c5b84612c7c57600f81901c6001600160701b03169050613fff82019150612cab565b613ffe8211612ca157600f81901c6001600160701b0316905081613fff039150612cab565b600091613fee19011c5b60709190911b1760801b95945050505050565b6000808211612ccc57600080fd5b6000600160801b8310612ce157608092831c92015b600160401b8310612cf457604092831c92015b6401000000008310612d0857602092831c92015b620100008310612d1a57601092831c92015b6101008310612d2b57600892831c92015b60108310612d3b57600492831c92015b60048310612d4b57600292831c92015b600283106104a65760010192915050565b80356001600160801b031981168114610dfe57600080fd5b600060208284031215612d8657600080fd5b6104a382612d5c565b60008060408385031215612da257600080fd5b612dab83612d5c565b9150612db960208401612d5c565b90509250929050565b60008060008060808587031215612dd857600080fd5b612de185612d5c565b9350612def60208601612d5c565b93969395505050506040820135916060013590565b600080600060608486031215612e1957600080fd5b612e2284612d5c565b925060208401358060000b8114612e3857600080fd5b9150612e4660408501612d5c565b90509250925092565b60008060408385031215612e6257600080fd5b612e6b83612d5c565b946020939093013593505050565b60008060408385031215612e8c57600080fd5b50508035926020909101359150565b600060c08284031215612ead57600080fd5b50919050565b60006101608284031215612ead57600080fd5b600060208284031215612ed857600080fd5b5035919050565b600080600060608486031215612ef457600080fd5b505081359360208301359350604090920135919050565b60008060008060808587031215612f2157600080fd5b5050823594602084013594506040840135936060013592509050565b600080600080600060a08688031215612f5557600080fd5b505083359560208501359550604085013594606081013594506080013592509050565b6020808252600a908201526907072696365203d3d20360b41b604082015260600190565b60008219821115612faf57612faf61310d565b500190565b600082612fd157634e487b7160e01b600052601260045260246000fd5b500490565b600181815b80851115613011578160001904821115612ff757612ff761310d565b8085161561300457918102915b93841c9390800290612fdb565b509250929050565b60006104a3838360008261302f575060016104a6565b8161303c575060006104a6565b8160018114613052576002811461305c57613078565b60019150506104a6565b60ff84111561306d5761306d61310d565b50506001821b6104a6565b5060208310610133831016604e8410600b841016171561309b575081810a6104a6565b6130a58383612fd6565b80600019048211156130b9576130b961310d565b029392505050565b60008160001904831182151516156130db576130db61310d565b500290565b6000828210156130f2576130f261310d565b500390565b634e487b7160e01b600052600160045260246000fd5b634e487b7160e01b600052601160045260246000fd5b634e487b7160e01b600052601260045260246000fdfea2646970667358221220ea5d348f64d5b920f23df3d012d449ffc00cb3b6caba215f675cf3058cea2ca864736f6c63430008070033",
    "devdoc": {
        "kind": "dev",
        "methods": {
            "addBytes(bytes16,bytes16)": {
                "params": {
                    "x": "The number to be added with `y`",
                    "y": "The number to be added with `x`"
                }
            },
            "appropriateUpdateIntervalId(uint256,uint256,uint256,uint256,uint256)": {
                "details": "Note that the timestamp parameter is required to be >= lastPriceTimestamp",
                "params": {
                    "currentUpdateIntervalId": "The current update interval's ID",
                    "frontRunningInterval": "The frontrunning interval of a pool - The amount of time before an update interval that you must commit to get included in that update",
                    "lastPriceTimestamp": "The timestamp of the last price update",
                    "timestamp": "Current block.timestamp",
                    "updateInterval": "The frequency of a pool's updates"
                },
                "returns": {
                    "_0": "The update interval ID in which a commit being made at time timestamp should be included"
                }
            },
            "calculatePriceChange(PoolSwapLibrary.PriceChangeData)": {
                "details": "This function should be called by the LeveragedPool.",
                "params": {
                    "priceChange": "The struct containing necessary data to calculate price change"
                },
                "returns": {
                    "_0": "Resulting long balance",
                    "_1": "Resulting short balance",
                    "_2": "Resulting fees taken from long balance",
                    "_3": "Resulting fees taken from short balance"
                }
            },
            "compareDecimals(bytes16,bytes16)": {
                "params": {
                    "x": "The first number to compare",
                    "y": "The second number to compare"
                },
                "returns": {
                    "_0": "-1 if x < y, 0 if x = y, or 1 if x > y"
                }
            },
            "convertDecimalToUInt(bytes16)": {
                "params": {
                    "ratio": "The value to convert"
                },
                "returns": {
                    "_0": "The converted value"
                }
            },
            "convertUIntToDecimal(uint256)": {
                "params": {
                    "amount": "The amount to convert"
                },
                "returns": {
                    "_0": "The amount as a IEEE754 quadruple precision number"
                }
            },
            "divInt(int256,int256)": {
                "params": {
                    "a": "The dividend",
                    "b": "The divisor"
                },
                "returns": {
                    "_0": "The quotient"
                }
            },
            "fromWad(uint256,uint256)": {
                "params": {
                    "_decimals": "Quantity of decimal places to support",
                    "_wadValue": "wad number"
                },
                "returns": {
                    "_0": "Converted (non-WAD) value"
                }
            },
            "getBalancesAfterFees(uint256,uint256,uint256)": {
                "details": "Assumes shortBalance + longBalance >= reward",
                "params": {
                    "longBalance": "Long balance of the pool",
                    "reward": "Amount of keeper reward",
                    "shortBalance": "Short balance of the pool"
                },
                "returns": {
                    "_0": "shortBalanceAfterFees Short balance of the pool after the keeper reward has been paid",
                    "_1": "longBalanceAfterFees Long balance of the pool after the keeper reward has been paid"
                }
            },
            "getBurn(bytes16,uint256)": {
                "details": "amount * price, where amount is in PoolToken and price is in USD/PoolTokenThrows if price is zero`getBurn()`",
                "params": {
                    "amount": "Amount of pool tokens being used to burn",
                    "price": "Price of a pool token"
                },
                "returns": {
                    "_0": "Quantity of settlement tokens to return to the user after `amount` pool tokens are burnt."
                }
            },
            "getLossAmount(bytes16,uint256)": {
                "params": {
                    "balance": "The balance of the losing pool",
                    "lossMultiplier": "The multiplier to use"
                }
            },
            "getLossMultiplier(bytes16,int8,bytes16)": {
                "params": {
                    "direction": "The direction of the change. -1 if it's decreased, 0 if it hasn't changed, and 1 if it's increased",
                    "leverage": "The amount of leverage to apply",
                    "ratio": "The ratio of new price to old price"
                },
                "returns": {
                    "_0": "The multiplier"
                }
            },
            "getMint(bytes16,uint256)": {
                "details": "Throws if price is zero`getMint()`",
                "params": {
                    "amount": "Amount of settlement tokens being used to mint",
                    "price": "Price of a pool token"
                },
                "returns": {
                    "_0": "Quantity of pool tokens to mint"
                }
            },
            "getMintAmount(uint256,uint256,uint256,uint256)": {
                "details": "Calculated as (tokenSupply + shadowBalance) * amountIn / balance",
                "params": {
                    "amountIn": "Commitment amount of settlement tokens going into the pool",
                    "balance": "Balance of the pool (no. of underlying settlement tokens in pool)",
                    "pendingBurnPoolTokens": "Amount of pool tokens being burnt during this update interval",
                    "tokenSupply": "Total supply of pool tokens"
                },
                "returns": {
                    "_0": "Number of pool tokens to be minted"
                }
            },
            "getMintWithBurns(bytes16,bytes16,uint256,uint256)": {
                "details": "Throws if price is zero",
                "params": {
                    "amount": "The amount of settlement tokens being used to mint",
                    "amountBurnedInstantMint": "The amount of pool tokens that were burnt from the opposite side for an instant mint in this side",
                    "oppositePrice": "The price of the opposite side's pool token",
                    "price": "The price of a pool token"
                },
                "returns": {
                    "_0": "Quantity of pool tokens to mint"
                }
            },
            "getPrice(uint256,uint256)": {
                "details": "Divide the side balance by the pool token's total supply",
                "params": {
                    "sideBalance": "no. of underlying settlement tokens on that side of the pool",
                    "tokenSupply": "Total supply of pool tokens"
                }
            },
            "getRatio(uint256,uint256)": {
                "details": "Rounds any overflow towards 0. If either parameter is zero, the ratio is 0",
                "params": {
                    "_denominator": "The \"per part\" side of the equation. If this is zero, the ratio is zero",
                    "_numerator": "The \"parts per\" side of the equation. If this is zero, the ratio is zero"
                },
                "returns": {
                    "_0": "the ratio, as an ABDKMathQuad number (IEEE 754 quadruple precision floating point)"
                }
            },
            "getUpdatedAggregateBalance(PoolSwapLibrary.UpdateData)": {
                "params": {
                    "data": "Information needed for updating the balance including prices and recent commit amounts"
                },
                "returns": {
                    "_longBurnFee": "Quantity of settlement tokens taken as a fee from long burns",
                    "_newLongTokens": "Quantity of additional long tokens the user would receive",
                    "_newSettlementTokens": "Quantity of additional settlement tokens the user would receive",
                    "_newShortTokens": "Quantity of additional short tokens the user would receive",
                    "_shortBurnFee": "Quantity of settlement tokens taken as a fee from short burns"
                }
            },
            "getWithdrawAmountOnBurn(uint256,uint256,uint256,uint256)": {
                "details": "Calculates as `balance * amountIn / (tokenSupply + shadowBalance)",
                "params": {
                    "amountIn": "Commitment amount of pool tokens going into the pool",
                    "balance": "Balance of the pool (no. of underlying settlement tokens in pool)",
                    "pendingBurnPoolTokens": "Amount of pool tokens being burnt during this update interval",
                    "tokenSupply": "Total supply of pool tokens"
                },
                "returns": {
                    "_0": "Number of settlement tokens to be withdrawn on a burn"
                }
            },
            "isBeforeFrontRunningInterval(uint256,uint256,uint256,uint256)": {
                "params": {
                    "frontRunningInterval": "The window of time before a price update in which users can have their commit executed from",
                    "lastPriceTimestamp": "The timestamp of the last price update",
                    "subjectTime": "The timestamp for which you want to calculate if it was beforeFrontRunningInterval",
                    "updateInterval": "The interval between price updates"
                }
            },
            "mulFraction(uint256,uint256,uint256)": {
                "params": {
                    "denominator": "The denominator of the fraction being multipled with `number`",
                    "number": "The number with which the fraction calculated from `numerator` and `denominator` will be multiplied",
                    "numerator": "The numerator of the fraction being multipled with `number`"
                },
                "returns": {
                    "_0": "The result of multiplying number with numerator/denominator, as an integer"
                }
            },
            "multiplyBytes(bytes16,bytes16)": {
                "params": {
                    "x": "The number to be multiplied by `y`",
                    "y": "The number to be multiplied by `x`"
                }
            },
            "multiplyDecimalByUInt(bytes16,uint256)": {
                "params": {
                    "a": "The first term",
                    "b": "The second term"
                },
                "returns": {
                    "_0": "The product of a*b as a decimal"
                }
            },
            "subtractBytes(bytes16,bytes16)": {
                "params": {
                    "x": "The number to be subtracted by `y`",
                    "y": "The number to subtract from `x`"
                }
            }
        },
        "title": "Library for various useful (mostly) mathematical functions",
        "version": 1
    },
    "userdoc": {
        "kind": "user",
        "methods": {
            "MAX_DECIMALS()": {
                "notice": "Maximum number of decimal places supported by this contract (ABDKMathQuad defines this but it's private)"
            },
            "ONE()": {
                "notice": "ABDKMathQuad-formatted representation of the number one"
            },
            "WAD_PRECISION()": {
                "notice": "Maximum precision supportable via wad arithmetic (for this contract)"
            },
            "addBytes(bytes16,bytes16)": {
                "notice": "Performs an addition on two bytes16 numbers"
            },
            "appropriateUpdateIntervalId(uint256,uint256,uint256,uint256,uint256)": {
                "notice": "Calculates the update interval ID that a commitment should be placed in."
            },
            "calculatePriceChange(PoolSwapLibrary.PriceChangeData)": {
                "notice": "Calculates the effect of a price change. This involves calculating how many funds to transfer from the losing pool to the other."
            },
            "compareDecimals(bytes16,bytes16)": {
                "notice": "Compares two decimal numbers"
            },
            "convertDecimalToUInt(bytes16)": {
                "notice": "Converts a raw decimal value to a more readable uint256 value"
            },
            "convertUIntToDecimal(uint256)": {
                "notice": "Converts an integer value to a compatible decimal value"
            },
            "divInt(int256,int256)": {
                "notice": "Divides two integers"
            },
            "fromWad(uint256,uint256)": {
                "notice": "Converts from a WAD to normal value"
            },
            "getBalancesAfterFees(uint256,uint256,uint256)": {
                "notice": "Gets the short and long balances after the keeper rewards have been paid out         Keeper rewards are paid proportionally to the short and long pool"
            },
            "getBurn(bytes16,uint256)": {
                "notice": "Calculate the number of settlement tokens to burn, based on a price and an amount of pool tokens"
            },
            "getLossAmount(bytes16,uint256)": {
                "notice": "Calculates the amount to take from the losing pool"
            },
            "getLossMultiplier(bytes16,int8,bytes16)": {
                "notice": "Calculates the loss multiplier to apply to the losing pool. Includes the power leverage"
            },
            "getMint(bytes16,uint256)": {
                "notice": "Calculates the number of pool tokens to mint, given some settlement token amount and a price"
            },
            "getMintAmount(uint256,uint256,uint256,uint256)": {
                "notice": "Gets the number of pool tokens to be minted based on existing tokens"
            },
            "getMintWithBurns(bytes16,bytes16,uint256,uint256)": {
                "notice": "Calculate the number of pool tokens to mint, given some settlement token amount, a price, and a burn amount from other side for instant mint"
            },
            "getPrice(uint256,uint256)": {
                "notice": "Get the Settlement/PoolToken price, in ABDK IEE754 precision"
            },
            "getRatio(uint256,uint256)": {
                "notice": "Calculates the ratio between two numbers"
            },
            "getUpdatedAggregateBalance(PoolSwapLibrary.UpdateData)": {
                "notice": "Calculate the change in a user's balance based on recent commit(s)"
            },
            "getWithdrawAmountOnBurn(uint256,uint256,uint256,uint256)": {
                "notice": "Gets the number of settlement tokens to be withdrawn based on a pool token burn amount"
            },
            "isBeforeFrontRunningInterval(uint256,uint256,uint256,uint256)": {
                "notice": "Returns true if the given timestamp is BEFORE the frontRunningInterval starts"
            },
            "mulFraction(uint256,uint256,uint256)": {
                "notice": "Multiply an integer by a fractionnumber * numerator / denominator"
            },
            "multiplyBytes(bytes16,bytes16)": {
                "notice": "Multiplies two numbers"
            },
            "multiplyDecimalByUInt(bytes16,uint256)": {
                "notice": "Multiplies a decimal and an unsigned integer"
            },
            "subtractBytes(bytes16,bytes16)": {
                "notice": "Performs a subtraction on two bytes16 numbers"
            }
        },
        "version": 1
    },
    "storageLayout": {
        "storage": [],
        "types": null
    }
}
