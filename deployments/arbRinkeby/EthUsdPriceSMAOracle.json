{
    "address": "0x5d497A485c4898060D5b81B50235b922EC8d78ac",
    "abi": [
        {
            "inputs": [
                {
                    "internalType": "address",
                    "name": "_spotOracle",
                    "type": "address"
                },
                {
                    "internalType": "uint256",
                    "name": "_spotDecimals",
                    "type": "uint256"
                },
                {
                    "internalType": "address",
                    "name": "_observer",
                    "type": "address"
                },
                {
                    "internalType": "uint256",
                    "name": "_periods",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "_updateInterval",
                    "type": "uint256"
                },
                {
                    "internalType": "address",
                    "name": "_deployer",
                    "type": "address"
                }
            ],
            "stateMutability": "nonpayable",
            "type": "constructor"
        },
        {
            "inputs": [],
            "name": "MAX_DECIMALS",
            "outputs": [
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                }
            ],
            "stateMutability": "view",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "int256[24]",
                    "name": "xs",
                    "type": "int256[24]"
                },
                {
                    "internalType": "uint256",
                    "name": "k",
                    "type": "uint256"
                }
            ],
            "name": "SMA",
            "outputs": [
                {
                    "internalType": "int256",
                    "name": "",
                    "type": "int256"
                }
            ],
            "stateMutability": "pure",
            "type": "function"
        },
        {
            "inputs": [],
            "name": "deployer",
            "outputs": [
                {
                    "internalType": "address",
                    "name": "",
                    "type": "address"
                }
            ],
            "stateMutability": "view",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "int256",
                    "name": "wad",
                    "type": "int256"
                }
            ],
            "name": "fromWad",
            "outputs": [
                {
                    "internalType": "int256",
                    "name": "",
                    "type": "int256"
                }
            ],
            "stateMutability": "view",
            "type": "function"
        },
        {
            "inputs": [],
            "name": "getPrice",
            "outputs": [
                {
                    "internalType": "int256",
                    "name": "",
                    "type": "int256"
                }
            ],
            "stateMutability": "view",
            "type": "function"
        },
        {
            "inputs": [],
            "name": "getPriceAndMetadata",
            "outputs": [
                {
                    "internalType": "int256",
                    "name": "_price",
                    "type": "int256"
                },
                {
                    "internalType": "bytes",
                    "name": "_data",
                    "type": "bytes"
                }
            ],
            "stateMutability": "view",
            "type": "function"
        },
        {
            "inputs": [],
            "name": "observer",
            "outputs": [
                {
                    "internalType": "address",
                    "name": "",
                    "type": "address"
                }
            ],
            "stateMutability": "view",
            "type": "function"
        },
        {
            "inputs": [],
            "name": "oracle",
            "outputs": [
                {
                    "internalType": "address",
                    "name": "",
                    "type": "address"
                }
            ],
            "stateMutability": "view",
            "type": "function"
        },
        {
            "inputs": [],
            "name": "periods",
            "outputs": [
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                }
            ],
            "stateMutability": "view",
            "type": "function"
        },
        {
            "inputs": [],
            "name": "poll",
            "outputs": [
                {
                    "internalType": "int256",
                    "name": "",
                    "type": "int256"
                }
            ],
            "stateMutability": "nonpayable",
            "type": "function"
        },
        {
            "inputs": [],
            "name": "price",
            "outputs": [
                {
                    "internalType": "int256",
                    "name": "",
                    "type": "int256"
                }
            ],
            "stateMutability": "view",
            "type": "function"
        },
        {
            "inputs": [],
            "name": "scaler",
            "outputs": [
                {
                    "internalType": "int256",
                    "name": "",
                    "type": "int256"
                }
            ],
            "stateMutability": "view",
            "type": "function"
        }
    ],
    "transactionHash": "0xcbec19381476487093085e537d0828ba50e4931b18da8ee278b7922a2c11a66f",
    "receipt": {
        "to": null,
        "from": "0xfb59B91646cd0890F3E5343384FEb746989B66C7",
        "contractAddress": "0x5d497A485c4898060D5b81B50235b922EC8d78ac",
        "transactionIndex": 0,
        "gasUsed": "7401907",
        "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
        "blockHash": "0x7d86fb17524627896edb68cf5c693aad4415155158415d8ba6a55bb04e88f453",
        "transactionHash": "0xcbec19381476487093085e537d0828ba50e4931b18da8ee278b7922a2c11a66f",
        "logs": [],
        "blockNumber": 7327026,
        "cumulativeGasUsed": "1064947",
        "status": 1,
        "byzantium": true
    },
    "args": [
        "0x0c87725599fd7E865975bEC32111d101b5D9A525",
        8,
        "0x7DDb05bf5144a4Be927d43126232549969D98C5B",
        24,
        3600,
        "0xfb59B91646cd0890F3E5343384FEb746989B66C7"
    ],
    "solcInputHash": "2618b71259c48e264b944568d24817df",
    "metadata": "{\"compiler\":{\"version\":\"0.8.7+commit.e28d00a7\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spotOracle\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_spotDecimals\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_observer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_periods\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_updateInterval\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_deployer\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"MAX_DECIMALS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256[24]\",\"name\":\"xs\",\"type\":\"int256[24]\"},{\"internalType\":\"uint256\",\"name\":\"k\",\"type\":\"uint256\"}],\"name\":\"SMA\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deployer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"wad\",\"type\":\"int256\"}],\"name\":\"fromWad\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPriceAndMetadata\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"_price\",\"type\":\"int256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"observer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oracle\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"periods\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poll\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"scaler\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"SMA(int256[24],uint256)\":{\"details\":\"Throws if `k` is zero (due to necessary division)Throws if `k` is greater than or equal to the length of `xs` (due to buffer overrun potential)Throws if `k` is the maximum *signed* 256-bit integer (due to necessary division)O(k) complexity due to linear traversal of the final `k` elements of `xs`Note that the signedness of the return type is due to the signedness of the elements of `xs`It's a true tragedy that we have to stipulate a fixed-length array for `xs`, but alas, Solidity's type system cannot          reason about this at all due to the value's runtime requirement\",\"params\":{\"k\":\"Number of periods to use for calculation of the SMA\",\"xs\":\"Dataset\"},\"returns\":{\"_0\":\"Simple moving average for `k` periods\"}},\"fromWad(int256)\":{\"params\":{\"wad\":\"wad maths value\"},\"returns\":{\"_0\":\"Raw (signed) integer\"}},\"getPrice()\":{\"details\":\"Recomputes SMA across sample size (`periods`)\"},\"getPriceAndMetadata()\":{\"details\":\"Required by the `IOracleWrapper` interface. The interface leaves          the metadata as implementation-defined. For the SMA oracle, there          is no clear use case for additional data, so it's left blank\"},\"poll()\":{\"details\":\"Throws if called within an update interval since last being calledEssentially wraps `update()`\",\"returns\":{\"_0\":\"Latest SMA price\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"SMA(int256[24],uint256)\":{\"notice\":\"Calculates the simple moving average of the provided dataset for the specified number of periods\"},\"fromWad(int256)\":{\"notice\":\"Converts `wad` to a raw integer\"},\"getPrice()\":{\"notice\":\"Retrieves the current SMA price\"},\"getPriceAndMetadata()\":{\"notice\":\"Returns the current SMA price and an empty bytes array\"},\"observer()\":{\"notice\":\"Price observer providing the SMA oracle with historical pricing data\"},\"oracle()\":{\"notice\":\"Price oracle supplying the spot price of the quote asset\"},\"periods()\":{\"notice\":\"Number of periods to use in calculating the SMA (`k` in the SMA equation)\"},\"poll()\":{\"notice\":\"Updates the SMA oracle by retrieving a new price from the          associated price observer contract (provided it's not too early)\"},\"price()\":{\"notice\":\"Current SMA price\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/implementation/SMAOracle.sol\":\"SMAOracle\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0x6bb804a310218875e89d12c053e94a13a4607cdf7cc2052f3e52bd32a0dc50a1\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0x95098bd1d9c8dec4d80d3dedb88a0d949fa0d740ee99f2aa466bc308216ca6d5\",\"license\":\"MIT\"},\"contracts/implementation/PriceObserver.sol\":{\"content\":\"//SPDX-License-Identifier: CC-BY-NC-ND-4.0\\npragma solidity 0.8.7;\\n\\nimport \\\"../interfaces/IPriceObserver.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\n/// Stores a finite sequence of price observations\\ncontract PriceObserver is Ownable, IPriceObserver {\\n    /// Maximum number of elements storable by the backing array\\n    uint256 public constant MAX_NUM_ELEMS = 24;\\n\\n    /// Current number of elements stored by the backing array\\n    uint256 public numElems = 0;\\n\\n    /// Backing array for storing price data\\n    int256[MAX_NUM_ELEMS] public observations;\\n\\n    /// Writer -- only address allowed to add data to the backing array\\n    address writer = address(0);\\n\\n    /**\\n     * @notice Returns the capacity of the backing array (i.e., the maximum\\n     *          number of price observations able to be stored by this contract)\\n     * @return Maximum number of price observations that can be stored\\n     * @dev `MAX_NUM_ELEMS`\\n     */\\n    function capacity() public pure override returns (uint256) {\\n        return MAX_NUM_ELEMS;\\n    }\\n\\n    /**\\n     * @notice Returns the current number of price observations stored\\n     * @return Current number of price observations stored\\n     * @dev Should always be less than or equal to `capacity`\\n     * @dev `numElems`\\n     */\\n    function length() public view override returns (uint256) {\\n        return numElems;\\n    }\\n\\n    /**\\n     * @notice Retrieves the `i`th price observation\\n     * @param i Period to retrieve the price observation of\\n     * @return `i`th price observation\\n     * @dev Throws if index is out of bounds (i.e., `i >= length()`)\\n     */\\n    function get(uint256 i) public view override returns (int256) {\\n        require(i < length(), \\\"PO: Out of bounds\\\");\\n        return observations[i];\\n    }\\n\\n    /**\\n     * @notice Retrieves all price observations\\n     * @return Backing array of all price observations\\n     * @dev Note that, due to this view simply returning a reference to the\\n     *      backing array, it's possible for there to be null prices (i.e., 0)\\n     */\\n    function getAll() public view override returns (int256[24] memory) {\\n        return observations;\\n    }\\n\\n    /**\\n     * @notice Adds a new price observation to the contract\\n     * @param x Price\\n     * @return Whether or not an existing price observation was rotated out\\n     * @dev If the backing array is full (i.e., `length() == capacity()`, then\\n     *      it is rotated such that the oldest price observation is deleted\\n     * @dev Only callable by the associated writer for this contract\\n     */\\n    function add(int256 x) public override onlyWriter returns (bool) {\\n        if (full()) {\\n            leftRotateWithPad(x);\\n            return true;\\n        } else {\\n            observations[length()] = x;\\n            numElems += 1;\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @notice Sets the associated writer address for this contract\\n     * @param _writer Address of the new writer\\n     * @dev Only callable by the owner of this contract\\n     * @dev Throws if `_writer` is the null address\\n     */\\n    function setWriter(address _writer) public onlyOwner {\\n        require(_writer != address(0), \\\"PO: Null address not allowed\\\");\\n        writer = _writer;\\n    }\\n\\n    /**\\n     * @notice Returns the current writer of this contract\\n     * @return Address of the writer for this contract\\n     * @dev `writer`\\n     */\\n    function getWriter() public view returns (address) {\\n        return writer;\\n    }\\n\\n    /**\\n     * @notice Determines whether or not the backing array is full\\n     * @return Flag indicating whether the backing array is full or not\\n     * @dev `length() == capacity()`\\n     */\\n    function full() private view returns (bool) {\\n        return length() == capacity();\\n    }\\n\\n    /**\\n     * @notice Resets the backing array and clears all of its stored prices\\n     * @dev Only callable by the owner of this contract\\n     */\\n    function clear() public onlyOwner {\\n        numElems = 0;\\n        delete observations;\\n    }\\n\\n    /**\\n     * @notice Rotates observations array to the **left** by one element and\\n     *          sets the last element of `xs` to `x`\\n     * @param x Element to \\\"rotate into\\\" observations array\\n     */\\n    function leftRotateWithPad(int256 x) private {\\n        uint256 n = length();\\n\\n        /* linear scan over the [1, n] subsequence */\\n        for (uint256 i = 1; i < n; i++) {\\n            observations[i - 1] = observations[i];\\n        }\\n\\n        /* rotate `x` into `observations` from the right (remember, we're\\n         * **left** rotating -- with padding!) */\\n        observations[n - 1] = x;\\n    }\\n\\n    /**\\n     * @notice Enforces that the caller is the associated writer of this\\n     *          contract\\n     */\\n    modifier onlyWriter() {\\n        require(msg.sender == writer, \\\"PO: Permission denied\\\");\\n        _;\\n    }\\n}\\n\",\"keccak256\":\"0x7ba9d2ccb090627c6186ea5f03feb830633fa69d037dc0970874348f4d93a08f\",\"license\":\"CC-BY-NC-ND-4.0\"},\"contracts/implementation/SMAOracle.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.7;\\nimport \\\"../interfaces/IOracleWrapper.sol\\\";\\nimport \\\"../interfaces/IPriceObserver.sol\\\";\\nimport \\\"../implementation/PriceObserver.sol\\\";\\nimport \\\"prb-math/contracts/PRBMathSD59x18.sol\\\";\\n\\ncontract SMAOracle is IOracleWrapper {\\n    using PRBMathSD59x18 for int256;\\n\\n    /// Price oracle supplying the spot price of the quote asset\\n    address public override oracle;\\n\\n    // Deployer of the oracle\\n    address public immutable override deployer;\\n\\n    /// Price observer providing the SMA oracle with historical pricing data\\n    address public observer;\\n\\n    /// Current SMA price\\n    int256 public price;\\n\\n    /// Number of periods to use in calculating the SMA (`k` in the SMA equation)\\n    uint256 public periods;\\n\\n    /// Time of last successful price update\\n    uint256 lastUpdate = 0;\\n\\n    /// Duration between price updates\\n    uint256 updateInterval = 0;\\n\\n    int256 public scaler;\\n    uint256 public constant MAX_DECIMALS = 18;\\n\\n    constructor(\\n        address _spotOracle,\\n        uint256 _spotDecimals,\\n        address _observer,\\n        uint256 _periods,\\n        uint256 _updateInterval,\\n        address _deployer\\n    ) {\\n        require(_spotOracle != address(0) && _observer != address(0), \\\"SMA: Null address forbidden\\\");\\n        require(_periods > 0 && _periods <= IPriceObserver(_observer).capacity(), \\\"SMA: Out of bounds\\\");\\n        require(_spotDecimals <= MAX_DECIMALS, \\\"SMA: Decimal precision too high\\\");\\n        periods = _periods;\\n        oracle = _spotOracle;\\n        observer = _observer;\\n        deployer = _deployer;\\n\\n        /* `scaler` is always <= 10^18 and >= 1 so this cast is safe */\\n        scaler = int256(10**(MAX_DECIMALS - _spotDecimals));\\n        updateInterval = _updateInterval;\\n    }\\n\\n    /**\\n     * @notice Converts `wad` to a raw integer\\n     * @param wad wad maths value\\n     * @return Raw (signed) integer\\n     */\\n    function fromWad(int256 wad) external view override returns (int256) {\\n        return wad / scaler;\\n    }\\n\\n    /**\\n     * @notice Retrieves the current SMA price\\n     * @dev Recomputes SMA across sample size (`periods`)\\n     */\\n    function getPrice() external view override returns (int256) {\\n        /* update current reported SMA price */\\n        return SMA(IPriceObserver(observer).getAll(), periods);\\n    }\\n\\n    /**\\n     * @notice Add a new spot price observation to the SMA oracle\\n     * @dev O(n) complexity (with n being `capacity`) due to rotation of\\n     *      underlying observations array and subsequent recalculation of SMA\\n     *      price\\n     */\\n    function update() internal returns (int256) {\\n        /* query the underlying spot price oracle */\\n        IOracleWrapper spotOracle = IOracleWrapper(oracle);\\n        int256 latestPrice = spotOracle.getPrice();\\n\\n        /* expire the oldest observation and load the fresh one in */\\n        PriceObserver priceObserver = PriceObserver(observer);\\n        priceObserver.add(latestPrice);\\n\\n        /* update current reported SMA price */\\n        return SMA(priceObserver.getAll(), periods);\\n    }\\n\\n    /**\\n     * @notice Updates the SMA oracle by retrieving a new price from the\\n     *          associated price observer contract (provided it's not too early)\\n     * @return Latest SMA price\\n     * @dev Throws if called within an update interval since last being called\\n     * @dev Essentially wraps `update()`\\n     */\\n    function poll() external override returns (int256) {\\n        require(block.timestamp >= lastUpdate + updateInterval, \\\"SMA: Too early to update\\\");\\n        return update();\\n    }\\n\\n    /**\\n     * @notice Calculates the simple moving average of the provided dataset for the specified number of periods\\n     * @param xs Dataset\\n     * @param k Number of periods to use for calculation of the SMA\\n     * @return Simple moving average for `k` periods\\n     * @dev Throws if `k` is zero (due to necessary division)\\n     * @dev Throws if `k` is greater than or equal to the length of `xs` (due to buffer overrun potential)\\n     * @dev Throws if `k` is the maximum *signed* 256-bit integer (due to necessary division)\\n     * @dev O(k) complexity due to linear traversal of the final `k` elements of `xs`\\n     * @dev Note that the signedness of the return type is due to the signedness of the elements of `xs`\\n     * @dev It's a true tragedy that we have to stipulate a fixed-length array for `xs`, but alas, Solidity's type system cannot\\n     *          reason about this at all due to the value's runtime requirement\\n     */\\n    function SMA(int256[24] memory xs, uint256 k) public pure returns (int256) {\\n        uint256 n = xs.length;\\n\\n        /* bounds check */\\n        require(k > 0 && k <= n && k <= uint256(type(int256).max), \\\"SMA: Out of bounds\\\");\\n\\n        /* running total */\\n        int256 S = 0;\\n\\n        /* linear scan over the [n - k, n] subsequence */\\n        for (uint256 i = n - k; i < n; i++) {\\n            S += xs[i];\\n        }\\n\\n        /* cast is safe due to above bounds check */\\n        return S / int256(k);\\n    }\\n\\n    /**\\n     * @notice Converts `x` to a wad value\\n     * @param x Number to convert to wad value\\n     * @return `x` but wad\\n     */\\n    function toWad(int256 x) private view returns (int256) {\\n        return x * scaler;\\n    }\\n\\n    /**\\n     * @notice Returns the current SMA price and an empty bytes array\\n     * @dev Required by the `IOracleWrapper` interface. The interface leaves\\n     *          the metadata as implementation-defined. For the SMA oracle, there\\n     *          is no clear use case for additional data, so it's left blank\\n     */\\n    function getPriceAndMetadata() external view override returns (int256 _price, bytes memory _data) {\\n        _price = SMA(IPriceObserver(observer).getAll(), periods);\\n        _data = \\\"\\\";\\n    }\\n}\\n\",\"keccak256\":\"0xa661a0a3181f9db2ff56c38b16012f8c66d125f25a830f95d154330c439ce1f1\",\"license\":\"MIT\"},\"contracts/interfaces/IOracleWrapper.sol\":{\"content\":\"//SPDX-License-Identifier: CC-BY-NC-ND-4.0\\npragma solidity 0.8.7;\\n\\n/// @title The oracle wrapper contract interface\\ninterface IOracleWrapper {\\n    function oracle() external view returns (address);\\n\\n    function deployer() external view returns (address);\\n\\n    // #### Functions\\n\\n    /**\\n     * @notice Returns the current price for the asset in question\\n     * @return The latest price\\n     */\\n    function getPrice() external view returns (int256);\\n\\n    /**\\n     * @return _price The latest round data price\\n     * @return _data The metadata. Implementations can choose what data to return here\\n     */\\n    function getPriceAndMetadata() external view returns (int256 _price, bytes memory _data);\\n\\n    /**\\n     * @notice Converts from a WAD to normal value\\n     * @return Converted non-WAD value\\n     */\\n    function fromWad(int256 wad) external view returns (int256);\\n\\n    /**\\n     * @notice Updates the underlying oracle state and returns the new price\\n     * @dev Spot oracles must implement but it will be a no-op\\n     */\\n    function poll() external returns (int256);\\n}\\n\",\"keccak256\":\"0x50b2e96b7b396f02b6a4c5fc6dee20a1134771c7a6ac0587ade614b50558b4de\",\"license\":\"CC-BY-NC-ND-4.0\"},\"contracts/interfaces/IPriceObserver.sol\":{\"content\":\"//SPDX-License-Identifier: CC-BY-NC-ND-4.0\\npragma solidity 0.8.7;\\n\\n/// @title The price observer interface\\ninterface IPriceObserver {\\n    function capacity() external view returns (uint256);\\n\\n    function length() external view returns (uint256);\\n\\n    function get(uint256 i) external view returns (int256);\\n\\n    function getAll() external view returns (int256[24] memory);\\n\\n    function add(int256 x) external returns (bool);\\n}\\n\",\"keccak256\":\"0xba914bb590abf02108160b7245580b4f43592021b26aaa8b9fa374774098aff6\",\"license\":\"CC-BY-NC-ND-4.0\"},\"prb-math/contracts/PRBMath.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity >=0.8.4;\\n\\n/// @notice Emitted when the result overflows uint256.\\nerror PRBMath__MulDivFixedPointOverflow(uint256 prod1);\\n\\n/// @notice Emitted when the result overflows uint256.\\nerror PRBMath__MulDivOverflow(uint256 prod1, uint256 denominator);\\n\\n/// @notice Emitted when one of the inputs is type(int256).min.\\nerror PRBMath__MulDivSignedInputTooSmall();\\n\\n/// @notice Emitted when the intermediary absolute result overflows int256.\\nerror PRBMath__MulDivSignedOverflow(uint256 rAbs);\\n\\n/// @notice Emitted when the input is MIN_SD59x18.\\nerror PRBMathSD59x18__AbsInputTooSmall();\\n\\n/// @notice Emitted when ceiling a number overflows SD59x18.\\nerror PRBMathSD59x18__CeilOverflow(int256 x);\\n\\n/// @notice Emitted when one of the inputs is MIN_SD59x18.\\nerror PRBMathSD59x18__DivInputTooSmall();\\n\\n/// @notice Emitted when one of the intermediary unsigned results overflows SD59x18.\\nerror PRBMathSD59x18__DivOverflow(uint256 rAbs);\\n\\n/// @notice Emitted when the input is greater than 133.084258667509499441.\\nerror PRBMathSD59x18__ExpInputTooBig(int256 x);\\n\\n/// @notice Emitted when the input is greater than 192.\\nerror PRBMathSD59x18__Exp2InputTooBig(int256 x);\\n\\n/// @notice Emitted when flooring a number underflows SD59x18.\\nerror PRBMathSD59x18__FloorUnderflow(int256 x);\\n\\n/// @notice Emitted when converting a basic integer to the fixed-point format overflows SD59x18.\\nerror PRBMathSD59x18__FromIntOverflow(int256 x);\\n\\n/// @notice Emitted when converting a basic integer to the fixed-point format underflows SD59x18.\\nerror PRBMathSD59x18__FromIntUnderflow(int256 x);\\n\\n/// @notice Emitted when the product of the inputs is negative.\\nerror PRBMathSD59x18__GmNegativeProduct(int256 x, int256 y);\\n\\n/// @notice Emitted when multiplying the inputs overflows SD59x18.\\nerror PRBMathSD59x18__GmOverflow(int256 x, int256 y);\\n\\n/// @notice Emitted when the input is less than or equal to zero.\\nerror PRBMathSD59x18__LogInputTooSmall(int256 x);\\n\\n/// @notice Emitted when one of the inputs is MIN_SD59x18.\\nerror PRBMathSD59x18__MulInputTooSmall();\\n\\n/// @notice Emitted when the intermediary absolute result overflows SD59x18.\\nerror PRBMathSD59x18__MulOverflow(uint256 rAbs);\\n\\n/// @notice Emitted when the intermediary absolute result overflows SD59x18.\\nerror PRBMathSD59x18__PowuOverflow(uint256 rAbs);\\n\\n/// @notice Emitted when the input is negative.\\nerror PRBMathSD59x18__SqrtNegativeInput(int256 x);\\n\\n/// @notice Emitted when the calculating the square root overflows SD59x18.\\nerror PRBMathSD59x18__SqrtOverflow(int256 x);\\n\\n/// @notice Emitted when addition overflows UD60x18.\\nerror PRBMathUD60x18__AddOverflow(uint256 x, uint256 y);\\n\\n/// @notice Emitted when ceiling a number overflows UD60x18.\\nerror PRBMathUD60x18__CeilOverflow(uint256 x);\\n\\n/// @notice Emitted when the input is greater than 133.084258667509499441.\\nerror PRBMathUD60x18__ExpInputTooBig(uint256 x);\\n\\n/// @notice Emitted when the input is greater than 192.\\nerror PRBMathUD60x18__Exp2InputTooBig(uint256 x);\\n\\n/// @notice Emitted when converting a basic integer to the fixed-point format format overflows UD60x18.\\nerror PRBMathUD60x18__FromUintOverflow(uint256 x);\\n\\n/// @notice Emitted when multiplying the inputs overflows UD60x18.\\nerror PRBMathUD60x18__GmOverflow(uint256 x, uint256 y);\\n\\n/// @notice Emitted when the input is less than 1.\\nerror PRBMathUD60x18__LogInputTooSmall(uint256 x);\\n\\n/// @notice Emitted when the calculating the square root overflows UD60x18.\\nerror PRBMathUD60x18__SqrtOverflow(uint256 x);\\n\\n/// @notice Emitted when subtraction underflows UD60x18.\\nerror PRBMathUD60x18__SubUnderflow(uint256 x, uint256 y);\\n\\n/// @dev Common mathematical functions used in both PRBMathSD59x18 and PRBMathUD60x18. Note that this shared library\\n/// does not always assume the signed 59.18-decimal fixed-point or the unsigned 60.18-decimal fixed-point\\n/// representation. When it does not, it is explicitly mentioned in the NatSpec documentation.\\nlibrary PRBMath {\\n    /// STRUCTS ///\\n\\n    struct SD59x18 {\\n        int256 value;\\n    }\\n\\n    struct UD60x18 {\\n        uint256 value;\\n    }\\n\\n    /// STORAGE ///\\n\\n    /// @dev How many trailing decimals can be represented.\\n    uint256 internal constant SCALE = 1e18;\\n\\n    /// @dev Largest power of two divisor of SCALE.\\n    uint256 internal constant SCALE_LPOTD = 262144;\\n\\n    /// @dev SCALE inverted mod 2^256.\\n    uint256 internal constant SCALE_INVERSE =\\n        78156646155174841979727994598816262306175212592076161876661_508869554232690281;\\n\\n    /// FUNCTIONS ///\\n\\n    /// @notice Calculates the binary exponent of x using the binary fraction method.\\n    /// @dev Has to use 192.64-bit fixed-point numbers.\\n    /// See https://ethereum.stackexchange.com/a/96594/24693.\\n    /// @param x The exponent as an unsigned 192.64-bit fixed-point number.\\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\\n    function exp2(uint256 x) internal pure returns (uint256 result) {\\n        unchecked {\\n            // Start from 0.5 in the 192.64-bit fixed-point format.\\n            result = 0x800000000000000000000000000000000000000000000000;\\n\\n            // Multiply the result by root(2, 2^-i) when the bit at position i is 1. None of the intermediary results overflows\\n            // because the initial result is 2^191 and all magic factors are less than 2^65.\\n            if (x & 0x8000000000000000 > 0) {\\n                result = (result * 0x16A09E667F3BCC909) >> 64;\\n            }\\n            if (x & 0x4000000000000000 > 0) {\\n                result = (result * 0x1306FE0A31B7152DF) >> 64;\\n            }\\n            if (x & 0x2000000000000000 > 0) {\\n                result = (result * 0x1172B83C7D517ADCE) >> 64;\\n            }\\n            if (x & 0x1000000000000000 > 0) {\\n                result = (result * 0x10B5586CF9890F62A) >> 64;\\n            }\\n            if (x & 0x800000000000000 > 0) {\\n                result = (result * 0x1059B0D31585743AE) >> 64;\\n            }\\n            if (x & 0x400000000000000 > 0) {\\n                result = (result * 0x102C9A3E778060EE7) >> 64;\\n            }\\n            if (x & 0x200000000000000 > 0) {\\n                result = (result * 0x10163DA9FB33356D8) >> 64;\\n            }\\n            if (x & 0x100000000000000 > 0) {\\n                result = (result * 0x100B1AFA5ABCBED61) >> 64;\\n            }\\n            if (x & 0x80000000000000 > 0) {\\n                result = (result * 0x10058C86DA1C09EA2) >> 64;\\n            }\\n            if (x & 0x40000000000000 > 0) {\\n                result = (result * 0x1002C605E2E8CEC50) >> 64;\\n            }\\n            if (x & 0x20000000000000 > 0) {\\n                result = (result * 0x100162F3904051FA1) >> 64;\\n            }\\n            if (x & 0x10000000000000 > 0) {\\n                result = (result * 0x1000B175EFFDC76BA) >> 64;\\n            }\\n            if (x & 0x8000000000000 > 0) {\\n                result = (result * 0x100058BA01FB9F96D) >> 64;\\n            }\\n            if (x & 0x4000000000000 > 0) {\\n                result = (result * 0x10002C5CC37DA9492) >> 64;\\n            }\\n            if (x & 0x2000000000000 > 0) {\\n                result = (result * 0x1000162E525EE0547) >> 64;\\n            }\\n            if (x & 0x1000000000000 > 0) {\\n                result = (result * 0x10000B17255775C04) >> 64;\\n            }\\n            if (x & 0x800000000000 > 0) {\\n                result = (result * 0x1000058B91B5BC9AE) >> 64;\\n            }\\n            if (x & 0x400000000000 > 0) {\\n                result = (result * 0x100002C5C89D5EC6D) >> 64;\\n            }\\n            if (x & 0x200000000000 > 0) {\\n                result = (result * 0x10000162E43F4F831) >> 64;\\n            }\\n            if (x & 0x100000000000 > 0) {\\n                result = (result * 0x100000B1721BCFC9A) >> 64;\\n            }\\n            if (x & 0x80000000000 > 0) {\\n                result = (result * 0x10000058B90CF1E6E) >> 64;\\n            }\\n            if (x & 0x40000000000 > 0) {\\n                result = (result * 0x1000002C5C863B73F) >> 64;\\n            }\\n            if (x & 0x20000000000 > 0) {\\n                result = (result * 0x100000162E430E5A2) >> 64;\\n            }\\n            if (x & 0x10000000000 > 0) {\\n                result = (result * 0x1000000B172183551) >> 64;\\n            }\\n            if (x & 0x8000000000 > 0) {\\n                result = (result * 0x100000058B90C0B49) >> 64;\\n            }\\n            if (x & 0x4000000000 > 0) {\\n                result = (result * 0x10000002C5C8601CC) >> 64;\\n            }\\n            if (x & 0x2000000000 > 0) {\\n                result = (result * 0x1000000162E42FFF0) >> 64;\\n            }\\n            if (x & 0x1000000000 > 0) {\\n                result = (result * 0x10000000B17217FBB) >> 64;\\n            }\\n            if (x & 0x800000000 > 0) {\\n                result = (result * 0x1000000058B90BFCE) >> 64;\\n            }\\n            if (x & 0x400000000 > 0) {\\n                result = (result * 0x100000002C5C85FE3) >> 64;\\n            }\\n            if (x & 0x200000000 > 0) {\\n                result = (result * 0x10000000162E42FF1) >> 64;\\n            }\\n            if (x & 0x100000000 > 0) {\\n                result = (result * 0x100000000B17217F8) >> 64;\\n            }\\n            if (x & 0x80000000 > 0) {\\n                result = (result * 0x10000000058B90BFC) >> 64;\\n            }\\n            if (x & 0x40000000 > 0) {\\n                result = (result * 0x1000000002C5C85FE) >> 64;\\n            }\\n            if (x & 0x20000000 > 0) {\\n                result = (result * 0x100000000162E42FF) >> 64;\\n            }\\n            if (x & 0x10000000 > 0) {\\n                result = (result * 0x1000000000B17217F) >> 64;\\n            }\\n            if (x & 0x8000000 > 0) {\\n                result = (result * 0x100000000058B90C0) >> 64;\\n            }\\n            if (x & 0x4000000 > 0) {\\n                result = (result * 0x10000000002C5C860) >> 64;\\n            }\\n            if (x & 0x2000000 > 0) {\\n                result = (result * 0x1000000000162E430) >> 64;\\n            }\\n            if (x & 0x1000000 > 0) {\\n                result = (result * 0x10000000000B17218) >> 64;\\n            }\\n            if (x & 0x800000 > 0) {\\n                result = (result * 0x1000000000058B90C) >> 64;\\n            }\\n            if (x & 0x400000 > 0) {\\n                result = (result * 0x100000000002C5C86) >> 64;\\n            }\\n            if (x & 0x200000 > 0) {\\n                result = (result * 0x10000000000162E43) >> 64;\\n            }\\n            if (x & 0x100000 > 0) {\\n                result = (result * 0x100000000000B1721) >> 64;\\n            }\\n            if (x & 0x80000 > 0) {\\n                result = (result * 0x10000000000058B91) >> 64;\\n            }\\n            if (x & 0x40000 > 0) {\\n                result = (result * 0x1000000000002C5C8) >> 64;\\n            }\\n            if (x & 0x20000 > 0) {\\n                result = (result * 0x100000000000162E4) >> 64;\\n            }\\n            if (x & 0x10000 > 0) {\\n                result = (result * 0x1000000000000B172) >> 64;\\n            }\\n            if (x & 0x8000 > 0) {\\n                result = (result * 0x100000000000058B9) >> 64;\\n            }\\n            if (x & 0x4000 > 0) {\\n                result = (result * 0x10000000000002C5D) >> 64;\\n            }\\n            if (x & 0x2000 > 0) {\\n                result = (result * 0x1000000000000162E) >> 64;\\n            }\\n            if (x & 0x1000 > 0) {\\n                result = (result * 0x10000000000000B17) >> 64;\\n            }\\n            if (x & 0x800 > 0) {\\n                result = (result * 0x1000000000000058C) >> 64;\\n            }\\n            if (x & 0x400 > 0) {\\n                result = (result * 0x100000000000002C6) >> 64;\\n            }\\n            if (x & 0x200 > 0) {\\n                result = (result * 0x10000000000000163) >> 64;\\n            }\\n            if (x & 0x100 > 0) {\\n                result = (result * 0x100000000000000B1) >> 64;\\n            }\\n            if (x & 0x80 > 0) {\\n                result = (result * 0x10000000000000059) >> 64;\\n            }\\n            if (x & 0x40 > 0) {\\n                result = (result * 0x1000000000000002C) >> 64;\\n            }\\n            if (x & 0x20 > 0) {\\n                result = (result * 0x10000000000000016) >> 64;\\n            }\\n            if (x & 0x10 > 0) {\\n                result = (result * 0x1000000000000000B) >> 64;\\n            }\\n            if (x & 0x8 > 0) {\\n                result = (result * 0x10000000000000006) >> 64;\\n            }\\n            if (x & 0x4 > 0) {\\n                result = (result * 0x10000000000000003) >> 64;\\n            }\\n            if (x & 0x2 > 0) {\\n                result = (result * 0x10000000000000001) >> 64;\\n            }\\n            if (x & 0x1 > 0) {\\n                result = (result * 0x10000000000000001) >> 64;\\n            }\\n\\n            // We're doing two things at the same time:\\n            //\\n            //   1. Multiply the result by 2^n + 1, where \\\"2^n\\\" is the integer part and the one is added to account for\\n            //      the fact that we initially set the result to 0.5. This is accomplished by subtracting from 191\\n            //      rather than 192.\\n            //   2. Convert the result to the unsigned 60.18-decimal fixed-point format.\\n            //\\n            // This works because 2^(191-ip) = 2^ip / 2^191, where \\\"ip\\\" is the integer part \\\"2^n\\\".\\n            result *= SCALE;\\n            result >>= (191 - (x >> 64));\\n        }\\n    }\\n\\n    /// @notice Finds the zero-based index of the first one in the binary representation of x.\\n    /// @dev See the note on msb in the \\\"Find First Set\\\" Wikipedia article https://en.wikipedia.org/wiki/Find_first_set\\n    /// @param x The uint256 number for which to find the index of the most significant bit.\\n    /// @return msb The index of the most significant bit as an uint256.\\n    function mostSignificantBit(uint256 x) internal pure returns (uint256 msb) {\\n        if (x >= 2**128) {\\n            x >>= 128;\\n            msb += 128;\\n        }\\n        if (x >= 2**64) {\\n            x >>= 64;\\n            msb += 64;\\n        }\\n        if (x >= 2**32) {\\n            x >>= 32;\\n            msb += 32;\\n        }\\n        if (x >= 2**16) {\\n            x >>= 16;\\n            msb += 16;\\n        }\\n        if (x >= 2**8) {\\n            x >>= 8;\\n            msb += 8;\\n        }\\n        if (x >= 2**4) {\\n            x >>= 4;\\n            msb += 4;\\n        }\\n        if (x >= 2**2) {\\n            x >>= 2;\\n            msb += 2;\\n        }\\n        if (x >= 2**1) {\\n            // No need to shift x any more.\\n            msb += 1;\\n        }\\n    }\\n\\n    /// @notice Calculates floor(x*y\\u00f7denominator) with full precision.\\n    ///\\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv.\\n    ///\\n    /// Requirements:\\n    /// - The denominator cannot be zero.\\n    /// - The result must fit within uint256.\\n    ///\\n    /// Caveats:\\n    /// - This function does not work with fixed-point numbers.\\n    ///\\n    /// @param x The multiplicand as an uint256.\\n    /// @param y The multiplier as an uint256.\\n    /// @param denominator The divisor as an uint256.\\n    /// @return result The result as an uint256.\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n        // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n        // variables such that product = prod1 * 2^256 + prod0.\\n        uint256 prod0; // Least significant 256 bits of the product\\n        uint256 prod1; // Most significant 256 bits of the product\\n        assembly {\\n            let mm := mulmod(x, y, not(0))\\n            prod0 := mul(x, y)\\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n        }\\n\\n        // Handle non-overflow cases, 256 by 256 division.\\n        if (prod1 == 0) {\\n            unchecked {\\n                result = prod0 / denominator;\\n            }\\n            return result;\\n        }\\n\\n        // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n        if (prod1 >= denominator) {\\n            revert PRBMath__MulDivOverflow(prod1, denominator);\\n        }\\n\\n        ///////////////////////////////////////////////\\n        // 512 by 256 division.\\n        ///////////////////////////////////////////////\\n\\n        // Make division exact by subtracting the remainder from [prod1 prod0].\\n        uint256 remainder;\\n        assembly {\\n            // Compute remainder using mulmod.\\n            remainder := mulmod(x, y, denominator)\\n\\n            // Subtract 256 bit number from 512 bit number.\\n            prod1 := sub(prod1, gt(remainder, prod0))\\n            prod0 := sub(prod0, remainder)\\n        }\\n\\n        // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n        // See https://cs.stackexchange.com/q/138556/92363.\\n        unchecked {\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 lpotdod = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by lpotdod.\\n                denominator := div(denominator, lpotdod)\\n\\n                // Divide [prod1 prod0] by lpotdod.\\n                prod0 := div(prod0, lpotdod)\\n\\n                // Flip lpotdod such that it is 2^256 / lpotdod. If lpotdod is zero, then it becomes one.\\n                lpotdod := add(div(sub(0, lpotdod), lpotdod), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * lpotdod;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /// @notice Calculates floor(x*y\\u00f71e18) with full precision.\\n    ///\\n    /// @dev Variant of \\\"mulDiv\\\" with constant folding, i.e. in which the denominator is always 1e18. Before returning the\\n    /// final result, we add 1 if (x * y) % SCALE >= HALF_SCALE. Without this, 6.6e-19 would be truncated to 0 instead of\\n    /// being rounded to 1e-18.  See \\\"Listing 6\\\" and text above it at https://accu.org/index.php/journals/1717.\\n    ///\\n    /// Requirements:\\n    /// - The result must fit within uint256.\\n    ///\\n    /// Caveats:\\n    /// - The body is purposely left uncommented; see the NatSpec comments in \\\"PRBMath.mulDiv\\\" to understand how this works.\\n    /// - It is assumed that the result can never be type(uint256).max when x and y solve the following two equations:\\n    ///     1. x * y = type(uint256).max * SCALE\\n    ///     2. (x * y) % SCALE >= SCALE / 2\\n    ///\\n    /// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.\\n    /// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.\\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\\n    function mulDivFixedPoint(uint256 x, uint256 y) internal pure returns (uint256 result) {\\n        uint256 prod0;\\n        uint256 prod1;\\n        assembly {\\n            let mm := mulmod(x, y, not(0))\\n            prod0 := mul(x, y)\\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n        }\\n\\n        if (prod1 >= SCALE) {\\n            revert PRBMath__MulDivFixedPointOverflow(prod1);\\n        }\\n\\n        uint256 remainder;\\n        uint256 roundUpUnit;\\n        assembly {\\n            remainder := mulmod(x, y, SCALE)\\n            roundUpUnit := gt(remainder, 499999999999999999)\\n        }\\n\\n        if (prod1 == 0) {\\n            unchecked {\\n                result = (prod0 / SCALE) + roundUpUnit;\\n                return result;\\n            }\\n        }\\n\\n        assembly {\\n            result := add(\\n                mul(\\n                    or(\\n                        div(sub(prod0, remainder), SCALE_LPOTD),\\n                        mul(sub(prod1, gt(remainder, prod0)), add(div(sub(0, SCALE_LPOTD), SCALE_LPOTD), 1))\\n                    ),\\n                    SCALE_INVERSE\\n                ),\\n                roundUpUnit\\n            )\\n        }\\n    }\\n\\n    /// @notice Calculates floor(x*y\\u00f7denominator) with full precision.\\n    ///\\n    /// @dev An extension of \\\"mulDiv\\\" for signed numbers. Works by computing the signs and the absolute values separately.\\n    ///\\n    /// Requirements:\\n    /// - None of the inputs can be type(int256).min.\\n    /// - The result must fit within int256.\\n    ///\\n    /// @param x The multiplicand as an int256.\\n    /// @param y The multiplier as an int256.\\n    /// @param denominator The divisor as an int256.\\n    /// @return result The result as an int256.\\n    function mulDivSigned(\\n        int256 x,\\n        int256 y,\\n        int256 denominator\\n    ) internal pure returns (int256 result) {\\n        if (x == type(int256).min || y == type(int256).min || denominator == type(int256).min) {\\n            revert PRBMath__MulDivSignedInputTooSmall();\\n        }\\n\\n        // Get hold of the absolute values of x, y and the denominator.\\n        uint256 ax;\\n        uint256 ay;\\n        uint256 ad;\\n        unchecked {\\n            ax = x < 0 ? uint256(-x) : uint256(x);\\n            ay = y < 0 ? uint256(-y) : uint256(y);\\n            ad = denominator < 0 ? uint256(-denominator) : uint256(denominator);\\n        }\\n\\n        // Compute the absolute value of (x*y)\\u00f7denominator. The result must fit within int256.\\n        uint256 rAbs = mulDiv(ax, ay, ad);\\n        if (rAbs > uint256(type(int256).max)) {\\n            revert PRBMath__MulDivSignedOverflow(rAbs);\\n        }\\n\\n        // Get the signs of x, y and the denominator.\\n        uint256 sx;\\n        uint256 sy;\\n        uint256 sd;\\n        assembly {\\n            sx := sgt(x, sub(0, 1))\\n            sy := sgt(y, sub(0, 1))\\n            sd := sgt(denominator, sub(0, 1))\\n        }\\n\\n        // XOR over sx, sy and sd. This is checking whether there are one or three negative signs in the inputs.\\n        // If yes, the result should be negative.\\n        result = sx ^ sy ^ sd == 0 ? -int256(rAbs) : int256(rAbs);\\n    }\\n\\n    /// @notice Calculates the square root of x, rounding down.\\n    /// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\\n    ///\\n    /// Caveats:\\n    /// - This function does not work with fixed-point numbers.\\n    ///\\n    /// @param x The uint256 number for which to calculate the square root.\\n    /// @return result The result as an uint256.\\n    function sqrt(uint256 x) internal pure returns (uint256 result) {\\n        if (x == 0) {\\n            return 0;\\n        }\\n\\n        // Set the initial guess to the closest power of two that is higher than x.\\n        uint256 xAux = uint256(x);\\n        result = 1;\\n        if (xAux >= 0x100000000000000000000000000000000) {\\n            xAux >>= 128;\\n            result <<= 64;\\n        }\\n        if (xAux >= 0x10000000000000000) {\\n            xAux >>= 64;\\n            result <<= 32;\\n        }\\n        if (xAux >= 0x100000000) {\\n            xAux >>= 32;\\n            result <<= 16;\\n        }\\n        if (xAux >= 0x10000) {\\n            xAux >>= 16;\\n            result <<= 8;\\n        }\\n        if (xAux >= 0x100) {\\n            xAux >>= 8;\\n            result <<= 4;\\n        }\\n        if (xAux >= 0x10) {\\n            xAux >>= 4;\\n            result <<= 2;\\n        }\\n        if (xAux >= 0x8) {\\n            result <<= 1;\\n        }\\n\\n        // The operations can never overflow because the result is max 2^127 when it enters this block.\\n        unchecked {\\n            result = (result + x / result) >> 1;\\n            result = (result + x / result) >> 1;\\n            result = (result + x / result) >> 1;\\n            result = (result + x / result) >> 1;\\n            result = (result + x / result) >> 1;\\n            result = (result + x / result) >> 1;\\n            result = (result + x / result) >> 1; // Seven iterations should be enough\\n            uint256 roundedDownResult = x / result;\\n            return result >= roundedDownResult ? roundedDownResult : result;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x62cbabae4910e168e99b9c2c3e3b5c9c7ad5e7abd961dcc63b7ea3d83d8ea87e\",\"license\":\"Unlicense\"},\"prb-math/contracts/PRBMathSD59x18.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity >=0.8.4;\\n\\nimport \\\"./PRBMath.sol\\\";\\n\\n/// @title PRBMathSD59x18\\n/// @author Paul Razvan Berg\\n/// @notice Smart contract library for advanced fixed-point math that works with int256 numbers considered to have 18\\n/// trailing decimals. We call this number representation signed 59.18-decimal fixed-point, since the numbers can have\\n/// a sign and there can be up to 59 digits in the integer part and up to 18 decimals in the fractional part. The numbers\\n/// are bound by the minimum and the maximum values permitted by the Solidity type int256.\\nlibrary PRBMathSD59x18 {\\n    /// @dev log2(e) as a signed 59.18-decimal fixed-point number.\\n    int256 internal constant LOG2_E = 1_442695040888963407;\\n\\n    /// @dev Half the SCALE number.\\n    int256 internal constant HALF_SCALE = 5e17;\\n\\n    /// @dev The maximum value a signed 59.18-decimal fixed-point number can have.\\n    int256 internal constant MAX_SD59x18 =\\n        57896044618658097711785492504343953926634992332820282019728_792003956564819967;\\n\\n    /// @dev The maximum whole value a signed 59.18-decimal fixed-point number can have.\\n    int256 internal constant MAX_WHOLE_SD59x18 =\\n        57896044618658097711785492504343953926634992332820282019728_000000000000000000;\\n\\n    /// @dev The minimum value a signed 59.18-decimal fixed-point number can have.\\n    int256 internal constant MIN_SD59x18 =\\n        -57896044618658097711785492504343953926634992332820282019728_792003956564819968;\\n\\n    /// @dev The minimum whole value a signed 59.18-decimal fixed-point number can have.\\n    int256 internal constant MIN_WHOLE_SD59x18 =\\n        -57896044618658097711785492504343953926634992332820282019728_000000000000000000;\\n\\n    /// @dev How many trailing decimals can be represented.\\n    int256 internal constant SCALE = 1e18;\\n\\n    /// INTERNAL FUNCTIONS ///\\n\\n    /// @notice Calculate the absolute value of x.\\n    ///\\n    /// @dev Requirements:\\n    /// - x must be greater than MIN_SD59x18.\\n    ///\\n    /// @param x The number to calculate the absolute value for.\\n    /// @param result The absolute value of x.\\n    function abs(int256 x) internal pure returns (int256 result) {\\n        unchecked {\\n            if (x == MIN_SD59x18) {\\n                revert PRBMathSD59x18__AbsInputTooSmall();\\n            }\\n            result = x < 0 ? -x : x;\\n        }\\n    }\\n\\n    /// @notice Calculates the arithmetic average of x and y, rounding down.\\n    /// @param x The first operand as a signed 59.18-decimal fixed-point number.\\n    /// @param y The second operand as a signed 59.18-decimal fixed-point number.\\n    /// @return result The arithmetic average as a signed 59.18-decimal fixed-point number.\\n    function avg(int256 x, int256 y) internal pure returns (int256 result) {\\n        // The operations can never overflow.\\n        unchecked {\\n            int256 sum = (x >> 1) + (y >> 1);\\n            if (sum < 0) {\\n                // If at least one of x and y is odd, we add 1 to the result. This is because shifting negative numbers to the\\n                // right rounds down to infinity.\\n                assembly {\\n                    result := add(sum, and(or(x, y), 1))\\n                }\\n            } else {\\n                // If both x and y are odd, we add 1 to the result. This is because if both numbers are odd, the 0.5\\n                // remainder gets truncated twice.\\n                result = sum + (x & y & 1);\\n            }\\n        }\\n    }\\n\\n    /// @notice Yields the least greatest signed 59.18 decimal fixed-point number greater than or equal to x.\\n    ///\\n    /// @dev Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.\\n    /// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\\n    ///\\n    /// Requirements:\\n    /// - x must be less than or equal to MAX_WHOLE_SD59x18.\\n    ///\\n    /// @param x The signed 59.18-decimal fixed-point number to ceil.\\n    /// @param result The least integer greater than or equal to x, as a signed 58.18-decimal fixed-point number.\\n    function ceil(int256 x) internal pure returns (int256 result) {\\n        if (x > MAX_WHOLE_SD59x18) {\\n            revert PRBMathSD59x18__CeilOverflow(x);\\n        }\\n        unchecked {\\n            int256 remainder = x % SCALE;\\n            if (remainder == 0) {\\n                result = x;\\n            } else {\\n                // Solidity uses C fmod style, which returns a modulus with the same sign as x.\\n                result = x - remainder;\\n                if (x > 0) {\\n                    result += SCALE;\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @notice Divides two signed 59.18-decimal fixed-point numbers, returning a new signed 59.18-decimal fixed-point number.\\n    ///\\n    /// @dev Variant of \\\"mulDiv\\\" that works with signed numbers. Works by computing the signs and the absolute values separately.\\n    ///\\n    /// Requirements:\\n    /// - All from \\\"PRBMath.mulDiv\\\".\\n    /// - None of the inputs can be MIN_SD59x18.\\n    /// - The denominator cannot be zero.\\n    /// - The result must fit within int256.\\n    ///\\n    /// Caveats:\\n    /// - All from \\\"PRBMath.mulDiv\\\".\\n    ///\\n    /// @param x The numerator as a signed 59.18-decimal fixed-point number.\\n    /// @param y The denominator as a signed 59.18-decimal fixed-point number.\\n    /// @param result The quotient as a signed 59.18-decimal fixed-point number.\\n    function div(int256 x, int256 y) internal pure returns (int256 result) {\\n        if (x == MIN_SD59x18 || y == MIN_SD59x18) {\\n            revert PRBMathSD59x18__DivInputTooSmall();\\n        }\\n\\n        // Get hold of the absolute values of x and y.\\n        uint256 ax;\\n        uint256 ay;\\n        unchecked {\\n            ax = x < 0 ? uint256(-x) : uint256(x);\\n            ay = y < 0 ? uint256(-y) : uint256(y);\\n        }\\n\\n        // Compute the absolute value of (x*SCALE)\\u00f7y. The result must fit within int256.\\n        uint256 rAbs = PRBMath.mulDiv(ax, uint256(SCALE), ay);\\n        if (rAbs > uint256(MAX_SD59x18)) {\\n            revert PRBMathSD59x18__DivOverflow(rAbs);\\n        }\\n\\n        // Get the signs of x and y.\\n        uint256 sx;\\n        uint256 sy;\\n        assembly {\\n            sx := sgt(x, sub(0, 1))\\n            sy := sgt(y, sub(0, 1))\\n        }\\n\\n        // XOR over sx and sy. This is basically checking whether the inputs have the same sign. If yes, the result\\n        // should be positive. Otherwise, it should be negative.\\n        result = sx ^ sy == 1 ? -int256(rAbs) : int256(rAbs);\\n    }\\n\\n    /// @notice Returns Euler's number as a signed 59.18-decimal fixed-point number.\\n    /// @dev See https://en.wikipedia.org/wiki/E_(mathematical_constant).\\n    function e() internal pure returns (int256 result) {\\n        result = 2_718281828459045235;\\n    }\\n\\n    /// @notice Calculates the natural exponent of x.\\n    ///\\n    /// @dev Based on the insight that e^x = 2^(x * log2(e)).\\n    ///\\n    /// Requirements:\\n    /// - All from \\\"log2\\\".\\n    /// - x must be less than 133.084258667509499441.\\n    ///\\n    /// Caveats:\\n    /// - All from \\\"exp2\\\".\\n    /// - For any x less than -41.446531673892822322, the result is zero.\\n    ///\\n    /// @param x The exponent as a signed 59.18-decimal fixed-point number.\\n    /// @return result The result as a signed 59.18-decimal fixed-point number.\\n    function exp(int256 x) internal pure returns (int256 result) {\\n        // Without this check, the value passed to \\\"exp2\\\" would be less than -59.794705707972522261.\\n        if (x < -41_446531673892822322) {\\n            return 0;\\n        }\\n\\n        // Without this check, the value passed to \\\"exp2\\\" would be greater than 192.\\n        if (x >= 133_084258667509499441) {\\n            revert PRBMathSD59x18__ExpInputTooBig(x);\\n        }\\n\\n        // Do the fixed-point multiplication inline to save gas.\\n        unchecked {\\n            int256 doubleScaleProduct = x * LOG2_E;\\n            result = exp2((doubleScaleProduct + HALF_SCALE) / SCALE);\\n        }\\n    }\\n\\n    /// @notice Calculates the binary exponent of x using the binary fraction method.\\n    ///\\n    /// @dev See https://ethereum.stackexchange.com/q/79903/24693.\\n    ///\\n    /// Requirements:\\n    /// - x must be 192 or less.\\n    /// - The result must fit within MAX_SD59x18.\\n    ///\\n    /// Caveats:\\n    /// - For any x less than -59.794705707972522261, the result is zero.\\n    ///\\n    /// @param x The exponent as a signed 59.18-decimal fixed-point number.\\n    /// @return result The result as a signed 59.18-decimal fixed-point number.\\n    function exp2(int256 x) internal pure returns (int256 result) {\\n        // This works because 2^(-x) = 1/2^x.\\n        if (x < 0) {\\n            // 2^59.794705707972522262 is the maximum number whose inverse does not truncate down to zero.\\n            if (x < -59_794705707972522261) {\\n                return 0;\\n            }\\n\\n            // Do the fixed-point inversion inline to save gas. The numerator is SCALE * SCALE.\\n            unchecked {\\n                result = 1e36 / exp2(-x);\\n            }\\n        } else {\\n            // 2^192 doesn't fit within the 192.64-bit format used internally in this function.\\n            if (x >= 192e18) {\\n                revert PRBMathSD59x18__Exp2InputTooBig(x);\\n            }\\n\\n            unchecked {\\n                // Convert x to the 192.64-bit fixed-point format.\\n                uint256 x192x64 = (uint256(x) << 64) / uint256(SCALE);\\n\\n                // Safe to convert the result to int256 directly because the maximum input allowed is 192.\\n                result = int256(PRBMath.exp2(x192x64));\\n            }\\n        }\\n    }\\n\\n    /// @notice Yields the greatest signed 59.18 decimal fixed-point number less than or equal to x.\\n    ///\\n    /// @dev Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.\\n    /// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\\n    ///\\n    /// Requirements:\\n    /// - x must be greater than or equal to MIN_WHOLE_SD59x18.\\n    ///\\n    /// @param x The signed 59.18-decimal fixed-point number to floor.\\n    /// @param result The greatest integer less than or equal to x, as a signed 58.18-decimal fixed-point number.\\n    function floor(int256 x) internal pure returns (int256 result) {\\n        if (x < MIN_WHOLE_SD59x18) {\\n            revert PRBMathSD59x18__FloorUnderflow(x);\\n        }\\n        unchecked {\\n            int256 remainder = x % SCALE;\\n            if (remainder == 0) {\\n                result = x;\\n            } else {\\n                // Solidity uses C fmod style, which returns a modulus with the same sign as x.\\n                result = x - remainder;\\n                if (x < 0) {\\n                    result -= SCALE;\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @notice Yields the excess beyond the floor of x for positive numbers and the part of the number to the right\\n    /// of the radix point for negative numbers.\\n    /// @dev Based on the odd function definition. https://en.wikipedia.org/wiki/Fractional_part\\n    /// @param x The signed 59.18-decimal fixed-point number to get the fractional part of.\\n    /// @param result The fractional part of x as a signed 59.18-decimal fixed-point number.\\n    function frac(int256 x) internal pure returns (int256 result) {\\n        unchecked {\\n            result = x % SCALE;\\n        }\\n    }\\n\\n    /// @notice Converts a number from basic integer form to signed 59.18-decimal fixed-point representation.\\n    ///\\n    /// @dev Requirements:\\n    /// - x must be greater than or equal to MIN_SD59x18 divided by SCALE.\\n    /// - x must be less than or equal to MAX_SD59x18 divided by SCALE.\\n    ///\\n    /// @param x The basic integer to convert.\\n    /// @param result The same number in signed 59.18-decimal fixed-point representation.\\n    function fromInt(int256 x) internal pure returns (int256 result) {\\n        unchecked {\\n            if (x < MIN_SD59x18 / SCALE) {\\n                revert PRBMathSD59x18__FromIntUnderflow(x);\\n            }\\n            if (x > MAX_SD59x18 / SCALE) {\\n                revert PRBMathSD59x18__FromIntOverflow(x);\\n            }\\n            result = x * SCALE;\\n        }\\n    }\\n\\n    /// @notice Calculates geometric mean of x and y, i.e. sqrt(x * y), rounding down.\\n    ///\\n    /// @dev Requirements:\\n    /// - x * y must fit within MAX_SD59x18, lest it overflows.\\n    /// - x * y cannot be negative.\\n    ///\\n    /// @param x The first operand as a signed 59.18-decimal fixed-point number.\\n    /// @param y The second operand as a signed 59.18-decimal fixed-point number.\\n    /// @return result The result as a signed 59.18-decimal fixed-point number.\\n    function gm(int256 x, int256 y) internal pure returns (int256 result) {\\n        if (x == 0) {\\n            return 0;\\n        }\\n\\n        unchecked {\\n            // Checking for overflow this way is faster than letting Solidity do it.\\n            int256 xy = x * y;\\n            if (xy / x != y) {\\n                revert PRBMathSD59x18__GmOverflow(x, y);\\n            }\\n\\n            // The product cannot be negative.\\n            if (xy < 0) {\\n                revert PRBMathSD59x18__GmNegativeProduct(x, y);\\n            }\\n\\n            // We don't need to multiply by the SCALE here because the x*y product had already picked up a factor of SCALE\\n            // during multiplication. See the comments within the \\\"sqrt\\\" function.\\n            result = int256(PRBMath.sqrt(uint256(xy)));\\n        }\\n    }\\n\\n    /// @notice Calculates 1 / x, rounding toward zero.\\n    ///\\n    /// @dev Requirements:\\n    /// - x cannot be zero.\\n    ///\\n    /// @param x The signed 59.18-decimal fixed-point number for which to calculate the inverse.\\n    /// @return result The inverse as a signed 59.18-decimal fixed-point number.\\n    function inv(int256 x) internal pure returns (int256 result) {\\n        unchecked {\\n            // 1e36 is SCALE * SCALE.\\n            result = 1e36 / x;\\n        }\\n    }\\n\\n    /// @notice Calculates the natural logarithm of x.\\n    ///\\n    /// @dev Based on the insight that ln(x) = log2(x) / log2(e).\\n    ///\\n    /// Requirements:\\n    /// - All from \\\"log2\\\".\\n    ///\\n    /// Caveats:\\n    /// - All from \\\"log2\\\".\\n    /// - This doesn't return exactly 1 for 2718281828459045235, for that we would need more fine-grained precision.\\n    ///\\n    /// @param x The signed 59.18-decimal fixed-point number for which to calculate the natural logarithm.\\n    /// @return result The natural logarithm as a signed 59.18-decimal fixed-point number.\\n    function ln(int256 x) internal pure returns (int256 result) {\\n        // Do the fixed-point multiplication inline to save gas. This is overflow-safe because the maximum value that log2(x)\\n        // can return is 195205294292027477728.\\n        unchecked {\\n            result = (log2(x) * SCALE) / LOG2_E;\\n        }\\n    }\\n\\n    /// @notice Calculates the common logarithm of x.\\n    ///\\n    /// @dev First checks if x is an exact power of ten and it stops if yes. If it's not, calculates the common\\n    /// logarithm based on the insight that log10(x) = log2(x) / log2(10).\\n    ///\\n    /// Requirements:\\n    /// - All from \\\"log2\\\".\\n    ///\\n    /// Caveats:\\n    /// - All from \\\"log2\\\".\\n    ///\\n    /// @param x The signed 59.18-decimal fixed-point number for which to calculate the common logarithm.\\n    /// @return result The common logarithm as a signed 59.18-decimal fixed-point number.\\n    function log10(int256 x) internal pure returns (int256 result) {\\n        if (x <= 0) {\\n            revert PRBMathSD59x18__LogInputTooSmall(x);\\n        }\\n\\n        // Note that the \\\"mul\\\" in this block is the assembly mul operation, not the \\\"mul\\\" function defined in this contract.\\n        // prettier-ignore\\n        assembly {\\n            switch x\\n            case 1 { result := mul(SCALE, sub(0, 18)) }\\n            case 10 { result := mul(SCALE, sub(1, 18)) }\\n            case 100 { result := mul(SCALE, sub(2, 18)) }\\n            case 1000 { result := mul(SCALE, sub(3, 18)) }\\n            case 10000 { result := mul(SCALE, sub(4, 18)) }\\n            case 100000 { result := mul(SCALE, sub(5, 18)) }\\n            case 1000000 { result := mul(SCALE, sub(6, 18)) }\\n            case 10000000 { result := mul(SCALE, sub(7, 18)) }\\n            case 100000000 { result := mul(SCALE, sub(8, 18)) }\\n            case 1000000000 { result := mul(SCALE, sub(9, 18)) }\\n            case 10000000000 { result := mul(SCALE, sub(10, 18)) }\\n            case 100000000000 { result := mul(SCALE, sub(11, 18)) }\\n            case 1000000000000 { result := mul(SCALE, sub(12, 18)) }\\n            case 10000000000000 { result := mul(SCALE, sub(13, 18)) }\\n            case 100000000000000 { result := mul(SCALE, sub(14, 18)) }\\n            case 1000000000000000 { result := mul(SCALE, sub(15, 18)) }\\n            case 10000000000000000 { result := mul(SCALE, sub(16, 18)) }\\n            case 100000000000000000 { result := mul(SCALE, sub(17, 18)) }\\n            case 1000000000000000000 { result := 0 }\\n            case 10000000000000000000 { result := SCALE }\\n            case 100000000000000000000 { result := mul(SCALE, 2) }\\n            case 1000000000000000000000 { result := mul(SCALE, 3) }\\n            case 10000000000000000000000 { result := mul(SCALE, 4) }\\n            case 100000000000000000000000 { result := mul(SCALE, 5) }\\n            case 1000000000000000000000000 { result := mul(SCALE, 6) }\\n            case 10000000000000000000000000 { result := mul(SCALE, 7) }\\n            case 100000000000000000000000000 { result := mul(SCALE, 8) }\\n            case 1000000000000000000000000000 { result := mul(SCALE, 9) }\\n            case 10000000000000000000000000000 { result := mul(SCALE, 10) }\\n            case 100000000000000000000000000000 { result := mul(SCALE, 11) }\\n            case 1000000000000000000000000000000 { result := mul(SCALE, 12) }\\n            case 10000000000000000000000000000000 { result := mul(SCALE, 13) }\\n            case 100000000000000000000000000000000 { result := mul(SCALE, 14) }\\n            case 1000000000000000000000000000000000 { result := mul(SCALE, 15) }\\n            case 10000000000000000000000000000000000 { result := mul(SCALE, 16) }\\n            case 100000000000000000000000000000000000 { result := mul(SCALE, 17) }\\n            case 1000000000000000000000000000000000000 { result := mul(SCALE, 18) }\\n            case 10000000000000000000000000000000000000 { result := mul(SCALE, 19) }\\n            case 100000000000000000000000000000000000000 { result := mul(SCALE, 20) }\\n            case 1000000000000000000000000000000000000000 { result := mul(SCALE, 21) }\\n            case 10000000000000000000000000000000000000000 { result := mul(SCALE, 22) }\\n            case 100000000000000000000000000000000000000000 { result := mul(SCALE, 23) }\\n            case 1000000000000000000000000000000000000000000 { result := mul(SCALE, 24) }\\n            case 10000000000000000000000000000000000000000000 { result := mul(SCALE, 25) }\\n            case 100000000000000000000000000000000000000000000 { result := mul(SCALE, 26) }\\n            case 1000000000000000000000000000000000000000000000 { result := mul(SCALE, 27) }\\n            case 10000000000000000000000000000000000000000000000 { result := mul(SCALE, 28) }\\n            case 100000000000000000000000000000000000000000000000 { result := mul(SCALE, 29) }\\n            case 1000000000000000000000000000000000000000000000000 { result := mul(SCALE, 30) }\\n            case 10000000000000000000000000000000000000000000000000 { result := mul(SCALE, 31) }\\n            case 100000000000000000000000000000000000000000000000000 { result := mul(SCALE, 32) }\\n            case 1000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 33) }\\n            case 10000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 34) }\\n            case 100000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 35) }\\n            case 1000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 36) }\\n            case 10000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 37) }\\n            case 100000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 38) }\\n            case 1000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 39) }\\n            case 10000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 40) }\\n            case 100000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 41) }\\n            case 1000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 42) }\\n            case 10000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 43) }\\n            case 100000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 44) }\\n            case 1000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 45) }\\n            case 10000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 46) }\\n            case 100000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 47) }\\n            case 1000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 48) }\\n            case 10000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 49) }\\n            case 100000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 50) }\\n            case 1000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 51) }\\n            case 10000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 52) }\\n            case 100000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 53) }\\n            case 1000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 54) }\\n            case 10000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 55) }\\n            case 100000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 56) }\\n            case 1000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 57) }\\n            case 10000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 58) }\\n            default {\\n                result := MAX_SD59x18\\n            }\\n        }\\n\\n        if (result == MAX_SD59x18) {\\n            // Do the fixed-point division inline to save gas. The denominator is log2(10).\\n            unchecked {\\n                result = (log2(x) * SCALE) / 3_321928094887362347;\\n            }\\n        }\\n    }\\n\\n    /// @notice Calculates the binary logarithm of x.\\n    ///\\n    /// @dev Based on the iterative approximation algorithm.\\n    /// https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation\\n    ///\\n    /// Requirements:\\n    /// - x must be greater than zero.\\n    ///\\n    /// Caveats:\\n    /// - The results are not perfectly accurate to the last decimal, due to the lossy precision of the iterative approximation.\\n    ///\\n    /// @param x The signed 59.18-decimal fixed-point number for which to calculate the binary logarithm.\\n    /// @return result The binary logarithm as a signed 59.18-decimal fixed-point number.\\n    function log2(int256 x) internal pure returns (int256 result) {\\n        if (x <= 0) {\\n            revert PRBMathSD59x18__LogInputTooSmall(x);\\n        }\\n        unchecked {\\n            // This works because log2(x) = -log2(1/x).\\n            int256 sign;\\n            if (x >= SCALE) {\\n                sign = 1;\\n            } else {\\n                sign = -1;\\n                // Do the fixed-point inversion inline to save gas. The numerator is SCALE * SCALE.\\n                assembly {\\n                    x := div(1000000000000000000000000000000000000, x)\\n                }\\n            }\\n\\n            // Calculate the integer part of the logarithm and add it to the result and finally calculate y = x * 2^(-n).\\n            uint256 n = PRBMath.mostSignificantBit(uint256(x / SCALE));\\n\\n            // The integer part of the logarithm as a signed 59.18-decimal fixed-point number. The operation can't overflow\\n            // because n is maximum 255, SCALE is 1e18 and sign is either 1 or -1.\\n            result = int256(n) * SCALE;\\n\\n            // This is y = x * 2^(-n).\\n            int256 y = x >> n;\\n\\n            // If y = 1, the fractional part is zero.\\n            if (y == SCALE) {\\n                return result * sign;\\n            }\\n\\n            // Calculate the fractional part via the iterative approximation.\\n            // The \\\"delta >>= 1\\\" part is equivalent to \\\"delta /= 2\\\", but shifting bits is faster.\\n            for (int256 delta = int256(HALF_SCALE); delta > 0; delta >>= 1) {\\n                y = (y * y) / SCALE;\\n\\n                // Is y^2 > 2 and so in the range [2,4)?\\n                if (y >= 2 * SCALE) {\\n                    // Add the 2^(-m) factor to the logarithm.\\n                    result += delta;\\n\\n                    // Corresponds to z/2 on Wikipedia.\\n                    y >>= 1;\\n                }\\n            }\\n            result *= sign;\\n        }\\n    }\\n\\n    /// @notice Multiplies two signed 59.18-decimal fixed-point numbers together, returning a new signed 59.18-decimal\\n    /// fixed-point number.\\n    ///\\n    /// @dev Variant of \\\"mulDiv\\\" that works with signed numbers and employs constant folding, i.e. the denominator is\\n    /// always 1e18.\\n    ///\\n    /// Requirements:\\n    /// - All from \\\"PRBMath.mulDivFixedPoint\\\".\\n    /// - None of the inputs can be MIN_SD59x18\\n    /// - The result must fit within MAX_SD59x18.\\n    ///\\n    /// Caveats:\\n    /// - The body is purposely left uncommented; see the NatSpec comments in \\\"PRBMath.mulDiv\\\" to understand how this works.\\n    ///\\n    /// @param x The multiplicand as a signed 59.18-decimal fixed-point number.\\n    /// @param y The multiplier as a signed 59.18-decimal fixed-point number.\\n    /// @return result The product as a signed 59.18-decimal fixed-point number.\\n    function mul(int256 x, int256 y) internal pure returns (int256 result) {\\n        if (x == MIN_SD59x18 || y == MIN_SD59x18) {\\n            revert PRBMathSD59x18__MulInputTooSmall();\\n        }\\n\\n        unchecked {\\n            uint256 ax;\\n            uint256 ay;\\n            ax = x < 0 ? uint256(-x) : uint256(x);\\n            ay = y < 0 ? uint256(-y) : uint256(y);\\n\\n            uint256 rAbs = PRBMath.mulDivFixedPoint(ax, ay);\\n            if (rAbs > uint256(MAX_SD59x18)) {\\n                revert PRBMathSD59x18__MulOverflow(rAbs);\\n            }\\n\\n            uint256 sx;\\n            uint256 sy;\\n            assembly {\\n                sx := sgt(x, sub(0, 1))\\n                sy := sgt(y, sub(0, 1))\\n            }\\n            result = sx ^ sy == 1 ? -int256(rAbs) : int256(rAbs);\\n        }\\n    }\\n\\n    /// @notice Returns PI as a signed 59.18-decimal fixed-point number.\\n    function pi() internal pure returns (int256 result) {\\n        result = 3_141592653589793238;\\n    }\\n\\n    /// @notice Raises x to the power of y.\\n    ///\\n    /// @dev Based on the insight that x^y = 2^(log2(x) * y).\\n    ///\\n    /// Requirements:\\n    /// - All from \\\"exp2\\\", \\\"log2\\\" and \\\"mul\\\".\\n    /// - z cannot be zero.\\n    ///\\n    /// Caveats:\\n    /// - All from \\\"exp2\\\", \\\"log2\\\" and \\\"mul\\\".\\n    /// - Assumes 0^0 is 1.\\n    ///\\n    /// @param x Number to raise to given power y, as a signed 59.18-decimal fixed-point number.\\n    /// @param y Exponent to raise x to, as a signed 59.18-decimal fixed-point number.\\n    /// @return result x raised to power y, as a signed 59.18-decimal fixed-point number.\\n    function pow(int256 x, int256 y) internal pure returns (int256 result) {\\n        if (x == 0) {\\n            result = y == 0 ? SCALE : int256(0);\\n        } else {\\n            result = exp2(mul(log2(x), y));\\n        }\\n    }\\n\\n    /// @notice Raises x (signed 59.18-decimal fixed-point number) to the power of y (basic unsigned integer) using the\\n    /// famous algorithm \\\"exponentiation by squaring\\\".\\n    ///\\n    /// @dev See https://en.wikipedia.org/wiki/Exponentiation_by_squaring\\n    ///\\n    /// Requirements:\\n    /// - All from \\\"abs\\\" and \\\"PRBMath.mulDivFixedPoint\\\".\\n    /// - The result must fit within MAX_SD59x18.\\n    ///\\n    /// Caveats:\\n    /// - All from \\\"PRBMath.mulDivFixedPoint\\\".\\n    /// - Assumes 0^0 is 1.\\n    ///\\n    /// @param x The base as a signed 59.18-decimal fixed-point number.\\n    /// @param y The exponent as an uint256.\\n    /// @return result The result as a signed 59.18-decimal fixed-point number.\\n    function powu(int256 x, uint256 y) internal pure returns (int256 result) {\\n        uint256 xAbs = uint256(abs(x));\\n\\n        // Calculate the first iteration of the loop in advance.\\n        uint256 rAbs = y & 1 > 0 ? xAbs : uint256(SCALE);\\n\\n        // Equivalent to \\\"for(y /= 2; y > 0; y /= 2)\\\" but faster.\\n        uint256 yAux = y;\\n        for (yAux >>= 1; yAux > 0; yAux >>= 1) {\\n            xAbs = PRBMath.mulDivFixedPoint(xAbs, xAbs);\\n\\n            // Equivalent to \\\"y % 2 == 1\\\" but faster.\\n            if (yAux & 1 > 0) {\\n                rAbs = PRBMath.mulDivFixedPoint(rAbs, xAbs);\\n            }\\n        }\\n\\n        // The result must fit within the 59.18-decimal fixed-point representation.\\n        if (rAbs > uint256(MAX_SD59x18)) {\\n            revert PRBMathSD59x18__PowuOverflow(rAbs);\\n        }\\n\\n        // Is the base negative and the exponent an odd number?\\n        bool isNegative = x < 0 && y & 1 == 1;\\n        result = isNegative ? -int256(rAbs) : int256(rAbs);\\n    }\\n\\n    /// @notice Returns 1 as a signed 59.18-decimal fixed-point number.\\n    function scale() internal pure returns (int256 result) {\\n        result = SCALE;\\n    }\\n\\n    /// @notice Calculates the square root of x, rounding down.\\n    /// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\\n    ///\\n    /// Requirements:\\n    /// - x cannot be negative.\\n    /// - x must be less than MAX_SD59x18 / SCALE.\\n    ///\\n    /// @param x The signed 59.18-decimal fixed-point number for which to calculate the square root.\\n    /// @return result The result as a signed 59.18-decimal fixed-point .\\n    function sqrt(int256 x) internal pure returns (int256 result) {\\n        unchecked {\\n            if (x < 0) {\\n                revert PRBMathSD59x18__SqrtNegativeInput(x);\\n            }\\n            if (x > MAX_SD59x18 / SCALE) {\\n                revert PRBMathSD59x18__SqrtOverflow(x);\\n            }\\n            // Multiply x by the SCALE to account for the factor of SCALE that is picked up when multiplying two signed\\n            // 59.18-decimal fixed-point numbers together (in this case, those two numbers are both the square root).\\n            result = int256(PRBMath.sqrt(uint256(x * SCALE)));\\n        }\\n    }\\n\\n    /// @notice Converts a signed 59.18-decimal fixed-point number to basic integer form, rounding down in the process.\\n    /// @param x The signed 59.18-decimal fixed-point number to convert.\\n    /// @return result The same number in basic integer form.\\n    function toInt(int256 x) internal pure returns (int256 result) {\\n        unchecked {\\n            result = x / SCALE;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x1886d687eace717c05b7dcc20e43a088df0e549df86b453c2222961b520308f0\",\"license\":\"Unlicense\"}},\"version\":1}",
    "bytecode": "0x60a0604052600060045560006005553480156200001b57600080fd5b5060405162000c7a38038062000c7a8339810160408190526200003e916200025c565b6001600160a01b038616158015906200005f57506001600160a01b03841615155b620000b15760405162461bcd60e51b815260206004820152601b60248201527f534d413a204e756c6c206164647265737320666f7262696464656e000000000060448201526064015b60405180910390fd5b600083118015620001365750836001600160a01b0316635cfc1a516040518163ffffffff1660e01b815260040160206040518083038186803b158015620000f757600080fd5b505afa1580156200010c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190620001329190620002c2565b8311155b620001795760405162461bcd60e51b8152602060048201526012602482015271534d413a204f7574206f6620626f756e647360701b6044820152606401620000a8565b6012851115620001cc5760405162461bcd60e51b815260206004820152601f60248201527f534d413a20446563696d616c20707265636973696f6e20746f6f2068696768006044820152606401620000a8565b6003839055600080546001600160a01b038089166001600160a01b03199283161790925560018054928716929091169190911790556001600160601b0319606082901b1660805262000220856012620003f0565b6200022d90600a62000325565b60065550600555506200042092505050565b80516001600160a01b03811681146200025757600080fd5b919050565b60008060008060008060c087890312156200027657600080fd5b62000281876200023f565b95506020870151945062000298604088016200023f565b93506060870151925060808701519150620002b660a088016200023f565b90509295509295509295565b600060208284031215620002d557600080fd5b5051919050565b600181815b808511156200031d5781600019048211156200030157620003016200040a565b808516156200030f57918102915b93841c9390800290620002e1565b509250929050565b60006200033383836200033a565b9392505050565b6000826200034b57506001620003ea565b816200035a57506000620003ea565b81600181146200037357600281146200037e576200039e565b6001915050620003ea565b60ff8411156200039257620003926200040a565b50506001821b620003ea565b5060208310610133831016604e8410600b8410161715620003c3575081810a620003ea565b620003cf8383620002dc565b8060001904821115620003e657620003e66200040a565b0290505b92915050565b6000828210156200040557620004056200040a565b500390565b634e487b7160e01b600052601160045260246000fd5b60805160601c61083b6200043f6000396000610155015261083b6000f3fe608060405234801561001057600080fd5b50600436106100b45760003560e01c8063a035b1fe11610071578063a035b1fe14610136578063a11752791461013f578063a4caeb4214610147578063d5f3948814610150578063db6d8fcf14610177578063eb70e4981461018d57600080fd5b80630417cf8e146100b95780633c1e6ff5146100d4578063412ad1cc146100dd57806341506e44146100f05780637dc0d1d01461010357806398d5fdca1461012e575b600080fd5b6100c1601281565b6040519081526020015b60405180910390f35b6100c160065481565b6100c16100eb36600461064b565b6101a0565b6100c16100fe3660046105b1565b6101b6565b600054610116906001600160a01b031681565b6040516001600160a01b0390911681526020016100cb565b6100c1610283565b6100c160025481565b6100c161031c565b6100c160035481565b6101167f000000000000000000000000000000000000000000000000000000000000000081565b61017f610385565b6040516100cb92919061067d565b600154610116906001600160a01b031681565b6000600654826101b0919061076b565b92915050565b6000601882158015906101c95750808311155b80156101dc57506001600160ff1b038311155b6102225760405162461bcd60e51b8152602060048201526012602482015271534d413a204f7574206f6620626f756e647360701b60448201526064015b60405180910390fd5b60008061022f85846107a7565b90505b8281101561026f5785816018811061024c5761024c6107ef565b602002015161025b9083610712565b915080610267816107be565b915050610232565b5061027a848261076b565b95945050505050565b6000610317600160009054906101000a90046001600160a01b03166001600160a01b03166353ed51436040518163ffffffff1660e01b81526004016103006040518083038186803b1580156102d757600080fd5b505afa1580156102eb573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061030f9190610546565b6003546101b6565b905090565b600060055460045461032e9190610753565b42101561037d5760405162461bcd60e51b815260206004820152601860248201527f534d413a20546f6f206561726c7920746f2075706461746500000000000000006044820152606401610219565b6103176103f3565b600060606103db600160009054906101000a90046001600160a01b03166001600160a01b03166353ed51436040518163ffffffff1660e01b81526004016103006040518083038186803b1580156102d757600080fd5b91506040518060200160405280600081525090509091565b60008060008054906101000a90046001600160a01b031690506000816001600160a01b03166398d5fdca6040518163ffffffff1660e01b815260040160206040518083038186803b15801561044757600080fd5b505afa15801561045b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061047f9190610664565b6001546040516387db03b760e01b8152600481018390529192506001600160a01b03169081906387db03b790602401602060405180830381600087803b1580156104c857600080fd5b505af11580156104dc573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105009190610622565b5061053e816001600160a01b03166353ed51436040518163ffffffff1660e01b81526004016103006040518083038186803b1580156102d757600080fd5b935050505090565b600061030080838503121561055a57600080fd5b83601f84011261056957600080fd5b6105716106da565b808486848701111561058257600080fd5b600093505b60188410156105a757805183526001939093019260209283019201610587565b5095945050505050565b60008061032083850312156105c557600080fd5b83601f8401126105d457600080fd5b6105dc6106da565b80846103008601878111156105f057600080fd5b60005b60188110156106125782358552602094850194909201916001016105f3565b5091979135965090945050505050565b60006020828403121561063457600080fd5b8151801515811461064457600080fd5b9392505050565b60006020828403121561065d57600080fd5b5035919050565b60006020828403121561067657600080fd5b5051919050565b82815260006020604081840152835180604085015260005b818110156106b157858101830151858201606001528201610695565b818111156106c3576000606083870101525b50601f01601f191692909201606001949350505050565b604051610300810167ffffffffffffffff8111828210171561070c57634e487b7160e01b600052604160045260246000fd5b60405290565b600080821280156001600160ff1b0384900385131615610734576107346107d9565b600160ff1b839003841281161561074d5761074d6107d9565b50500190565b60008219821115610766576107666107d9565b500190565b60008261078857634e487b7160e01b600052601260045260246000fd5b600160ff1b8214600019841416156107a2576107a26107d9565b500590565b6000828210156107b9576107b96107d9565b500390565b60006000198214156107d2576107d26107d9565b5060010190565b634e487b7160e01b600052601160045260246000fd5b634e487b7160e01b600052603260045260246000fdfea2646970667358221220e787aefdc8998e711988401a8d847606296769f65378b926db5b2c243312a4df64736f6c63430008070033",
    "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100b45760003560e01c8063a035b1fe11610071578063a035b1fe14610136578063a11752791461013f578063a4caeb4214610147578063d5f3948814610150578063db6d8fcf14610177578063eb70e4981461018d57600080fd5b80630417cf8e146100b95780633c1e6ff5146100d4578063412ad1cc146100dd57806341506e44146100f05780637dc0d1d01461010357806398d5fdca1461012e575b600080fd5b6100c1601281565b6040519081526020015b60405180910390f35b6100c160065481565b6100c16100eb36600461064b565b6101a0565b6100c16100fe3660046105b1565b6101b6565b600054610116906001600160a01b031681565b6040516001600160a01b0390911681526020016100cb565b6100c1610283565b6100c160025481565b6100c161031c565b6100c160035481565b6101167f000000000000000000000000000000000000000000000000000000000000000081565b61017f610385565b6040516100cb92919061067d565b600154610116906001600160a01b031681565b6000600654826101b0919061076b565b92915050565b6000601882158015906101c95750808311155b80156101dc57506001600160ff1b038311155b6102225760405162461bcd60e51b8152602060048201526012602482015271534d413a204f7574206f6620626f756e647360701b60448201526064015b60405180910390fd5b60008061022f85846107a7565b90505b8281101561026f5785816018811061024c5761024c6107ef565b602002015161025b9083610712565b915080610267816107be565b915050610232565b5061027a848261076b565b95945050505050565b6000610317600160009054906101000a90046001600160a01b03166001600160a01b03166353ed51436040518163ffffffff1660e01b81526004016103006040518083038186803b1580156102d757600080fd5b505afa1580156102eb573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061030f9190610546565b6003546101b6565b905090565b600060055460045461032e9190610753565b42101561037d5760405162461bcd60e51b815260206004820152601860248201527f534d413a20546f6f206561726c7920746f2075706461746500000000000000006044820152606401610219565b6103176103f3565b600060606103db600160009054906101000a90046001600160a01b03166001600160a01b03166353ed51436040518163ffffffff1660e01b81526004016103006040518083038186803b1580156102d757600080fd5b91506040518060200160405280600081525090509091565b60008060008054906101000a90046001600160a01b031690506000816001600160a01b03166398d5fdca6040518163ffffffff1660e01b815260040160206040518083038186803b15801561044757600080fd5b505afa15801561045b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061047f9190610664565b6001546040516387db03b760e01b8152600481018390529192506001600160a01b03169081906387db03b790602401602060405180830381600087803b1580156104c857600080fd5b505af11580156104dc573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105009190610622565b5061053e816001600160a01b03166353ed51436040518163ffffffff1660e01b81526004016103006040518083038186803b1580156102d757600080fd5b935050505090565b600061030080838503121561055a57600080fd5b83601f84011261056957600080fd5b6105716106da565b808486848701111561058257600080fd5b600093505b60188410156105a757805183526001939093019260209283019201610587565b5095945050505050565b60008061032083850312156105c557600080fd5b83601f8401126105d457600080fd5b6105dc6106da565b80846103008601878111156105f057600080fd5b60005b60188110156106125782358552602094850194909201916001016105f3565b5091979135965090945050505050565b60006020828403121561063457600080fd5b8151801515811461064457600080fd5b9392505050565b60006020828403121561065d57600080fd5b5035919050565b60006020828403121561067657600080fd5b5051919050565b82815260006020604081840152835180604085015260005b818110156106b157858101830151858201606001528201610695565b818111156106c3576000606083870101525b50601f01601f191692909201606001949350505050565b604051610300810167ffffffffffffffff8111828210171561070c57634e487b7160e01b600052604160045260246000fd5b60405290565b600080821280156001600160ff1b0384900385131615610734576107346107d9565b600160ff1b839003841281161561074d5761074d6107d9565b50500190565b60008219821115610766576107666107d9565b500190565b60008261078857634e487b7160e01b600052601260045260246000fd5b600160ff1b8214600019841416156107a2576107a26107d9565b500590565b6000828210156107b9576107b96107d9565b500390565b60006000198214156107d2576107d26107d9565b5060010190565b634e487b7160e01b600052601160045260246000fd5b634e487b7160e01b600052603260045260246000fdfea2646970667358221220e787aefdc8998e711988401a8d847606296769f65378b926db5b2c243312a4df64736f6c63430008070033",
    "devdoc": {
        "kind": "dev",
        "methods": {
            "SMA(int256[24],uint256)": {
                "details": "Throws if `k` is zero (due to necessary division)Throws if `k` is greater than or equal to the length of `xs` (due to buffer overrun potential)Throws if `k` is the maximum *signed* 256-bit integer (due to necessary division)O(k) complexity due to linear traversal of the final `k` elements of `xs`Note that the signedness of the return type is due to the signedness of the elements of `xs`It's a true tragedy that we have to stipulate a fixed-length array for `xs`, but alas, Solidity's type system cannot          reason about this at all due to the value's runtime requirement",
                "params": {
                    "k": "Number of periods to use for calculation of the SMA",
                    "xs": "Dataset"
                },
                "returns": {
                    "_0": "Simple moving average for `k` periods"
                }
            },
            "fromWad(int256)": {
                "params": {
                    "wad": "wad maths value"
                },
                "returns": {
                    "_0": "Raw (signed) integer"
                }
            },
            "getPrice()": {
                "details": "Recomputes SMA across sample size (`periods`)"
            },
            "getPriceAndMetadata()": {
                "details": "Required by the `IOracleWrapper` interface. The interface leaves          the metadata as implementation-defined. For the SMA oracle, there          is no clear use case for additional data, so it's left blank"
            },
            "poll()": {
                "details": "Throws if called within an update interval since last being calledEssentially wraps `update()`",
                "returns": {
                    "_0": "Latest SMA price"
                }
            }
        },
        "version": 1
    },
    "userdoc": {
        "kind": "user",
        "methods": {
            "SMA(int256[24],uint256)": {
                "notice": "Calculates the simple moving average of the provided dataset for the specified number of periods"
            },
            "fromWad(int256)": {
                "notice": "Converts `wad` to a raw integer"
            },
            "getPrice()": {
                "notice": "Retrieves the current SMA price"
            },
            "getPriceAndMetadata()": {
                "notice": "Returns the current SMA price and an empty bytes array"
            },
            "observer()": {
                "notice": "Price observer providing the SMA oracle with historical pricing data"
            },
            "oracle()": {
                "notice": "Price oracle supplying the spot price of the quote asset"
            },
            "periods()": {
                "notice": "Number of periods to use in calculating the SMA (`k` in the SMA equation)"
            },
            "poll()": {
                "notice": "Updates the SMA oracle by retrieving a new price from the          associated price observer contract (provided it's not too early)"
            },
            "price()": {
                "notice": "Current SMA price"
            }
        },
        "version": 1
    },
    "storageLayout": {
        "storage": [
            {
                "astId": 13835,
                "contract": "contracts/implementation/SMAOracle.sol:SMAOracle",
                "label": "oracle",
                "offset": 0,
                "slot": "0",
                "type": "t_address"
            },
            {
                "astId": 13841,
                "contract": "contracts/implementation/SMAOracle.sol:SMAOracle",
                "label": "observer",
                "offset": 0,
                "slot": "1",
                "type": "t_address"
            },
            {
                "astId": 13844,
                "contract": "contracts/implementation/SMAOracle.sol:SMAOracle",
                "label": "price",
                "offset": 0,
                "slot": "2",
                "type": "t_int256"
            },
            {
                "astId": 13847,
                "contract": "contracts/implementation/SMAOracle.sol:SMAOracle",
                "label": "periods",
                "offset": 0,
                "slot": "3",
                "type": "t_uint256"
            },
            {
                "astId": 13851,
                "contract": "contracts/implementation/SMAOracle.sol:SMAOracle",
                "label": "lastUpdate",
                "offset": 0,
                "slot": "4",
                "type": "t_uint256"
            },
            {
                "astId": 13855,
                "contract": "contracts/implementation/SMAOracle.sol:SMAOracle",
                "label": "updateInterval",
                "offset": 0,
                "slot": "5",
                "type": "t_uint256"
            },
            {
                "astId": 13857,
                "contract": "contracts/implementation/SMAOracle.sol:SMAOracle",
                "label": "scaler",
                "offset": 0,
                "slot": "6",
                "type": "t_int256"
            }
        ],
        "types": {
            "t_address": {
                "encoding": "inplace",
                "label": "address",
                "numberOfBytes": "20"
            },
            "t_int256": {
                "encoding": "inplace",
                "label": "int256",
                "numberOfBytes": "32"
            },
            "t_uint256": {
                "encoding": "inplace",
                "label": "uint256",
                "numberOfBytes": "32"
            }
        }
    }
}
