{
    "address": "0xc05BD952dEc77c22082a3D79f67598f58EC3d18F",
    "abi": [
        {
            "inputs": [
                {
                    "internalType": "address",
                    "name": "_factory",
                    "type": "address"
                }
            ],
            "stateMutability": "nonpayable",
            "type": "constructor"
        },
        {
            "anonymous": false,
            "inputs": [
                {
                    "indexed": true,
                    "internalType": "address",
                    "name": "_pool",
                    "type": "address"
                },
                {
                    "indexed": true,
                    "internalType": "address",
                    "name": "keeper",
                    "type": "address"
                },
                {
                    "indexed": false,
                    "internalType": "uint256",
                    "name": "reward",
                    "type": "uint256"
                }
            ],
            "name": "KeeperPaid",
            "type": "event"
        },
        {
            "anonymous": false,
            "inputs": [
                {
                    "indexed": true,
                    "internalType": "address",
                    "name": "_pool",
                    "type": "address"
                },
                {
                    "indexed": true,
                    "internalType": "address",
                    "name": "keeper",
                    "type": "address"
                },
                {
                    "indexed": false,
                    "internalType": "uint256",
                    "name": "expectedReward",
                    "type": "uint256"
                }
            ],
            "name": "KeeperPaymentError",
            "type": "event"
        },
        {
            "anonymous": false,
            "inputs": [
                {
                    "indexed": true,
                    "internalType": "address",
                    "name": "previousOwner",
                    "type": "address"
                },
                {
                    "indexed": true,
                    "internalType": "address",
                    "name": "newOwner",
                    "type": "address"
                }
            ],
            "name": "OwnershipTransferred",
            "type": "event"
        },
        {
            "anonymous": false,
            "inputs": [
                {
                    "indexed": true,
                    "internalType": "address",
                    "name": "poolAddress",
                    "type": "address"
                },
                {
                    "indexed": true,
                    "internalType": "int256",
                    "name": "firstPrice",
                    "type": "int256"
                }
            ],
            "name": "PoolAdded",
            "type": "event"
        },
        {
            "anonymous": false,
            "inputs": [
                {
                    "indexed": true,
                    "internalType": "address",
                    "name": "pool",
                    "type": "address"
                },
                {
                    "indexed": false,
                    "internalType": "string",
                    "name": "reason",
                    "type": "string"
                }
            ],
            "name": "PoolUpkeepError",
            "type": "event"
        },
        {
            "anonymous": false,
            "inputs": [
                {
                    "indexed": true,
                    "internalType": "address",
                    "name": "pool",
                    "type": "address"
                },
                {
                    "indexed": false,
                    "internalType": "bytes",
                    "name": "data",
                    "type": "bytes"
                },
                {
                    "indexed": true,
                    "internalType": "int256",
                    "name": "startPrice",
                    "type": "int256"
                },
                {
                    "indexed": true,
                    "internalType": "int256",
                    "name": "endPrice",
                    "type": "int256"
                }
            ],
            "name": "UpkeepSuccessful",
            "type": "event"
        },
        {
            "inputs": [],
            "name": "BASE_TIP",
            "outputs": [
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                }
            ],
            "stateMutability": "view",
            "type": "function"
        },
        {
            "inputs": [],
            "name": "BLOCK_TIME",
            "outputs": [
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                }
            ],
            "stateMutability": "view",
            "type": "function"
        },
        {
            "inputs": [],
            "name": "MAX_DECIMALS",
            "outputs": [
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                }
            ],
            "stateMutability": "view",
            "type": "function"
        },
        {
            "inputs": [],
            "name": "TIP_DELTA_PER_BLOCK",
            "outputs": [
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                }
            ],
            "stateMutability": "view",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "address[]",
                    "name": "_pools",
                    "type": "address[]"
                }
            ],
            "name": "checkUpkeepMultiplePools",
            "outputs": [
                {
                    "internalType": "bool",
                    "name": "",
                    "type": "bool"
                }
            ],
            "stateMutability": "view",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "address",
                    "name": "_pool",
                    "type": "address"
                }
            ],
            "name": "checkUpkeepSinglePool",
            "outputs": [
                {
                    "internalType": "bool",
                    "name": "",
                    "type": "bool"
                }
            ],
            "stateMutability": "view",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "address",
                    "name": "",
                    "type": "address"
                }
            ],
            "name": "executionPrice",
            "outputs": [
                {
                    "internalType": "int256",
                    "name": "",
                    "type": "int256"
                }
            ],
            "stateMutability": "view",
            "type": "function"
        },
        {
            "inputs": [],
            "name": "factory",
            "outputs": [
                {
                    "internalType": "contract IPoolFactory",
                    "name": "",
                    "type": "address"
                }
            ],
            "stateMutability": "view",
            "type": "function"
        },
        {
            "inputs": [],
            "name": "gasPrice",
            "outputs": [
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                }
            ],
            "stateMutability": "view",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "address",
                    "name": "_pool",
                    "type": "address"
                },
                {
                    "internalType": "uint256",
                    "name": "_gasPrice",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "_gasSpent",
                    "type": "uint256"
                }
            ],
            "name": "keeperGas",
            "outputs": [
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                }
            ],
            "stateMutability": "view",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "address",
                    "name": "_pool",
                    "type": "address"
                },
                {
                    "internalType": "uint256",
                    "name": "_gasPrice",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "_gasSpent",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "_savedPreviousUpdatedTimestamp",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "_poolInterval",
                    "type": "uint256"
                }
            ],
            "name": "keeperReward",
            "outputs": [
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                }
            ],
            "stateMutability": "view",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "uint256",
                    "name": "_savedPreviousUpdatedTimestamp",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "_poolInterval",
                    "type": "uint256"
                }
            ],
            "name": "keeperTip",
            "outputs": [
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                }
            ],
            "stateMutability": "view",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "address",
                    "name": "_poolAddress",
                    "type": "address"
                }
            ],
            "name": "newPool",
            "outputs": [],
            "stateMutability": "nonpayable",
            "type": "function"
        },
        {
            "inputs": [],
            "name": "owner",
            "outputs": [
                {
                    "internalType": "address",
                    "name": "",
                    "type": "address"
                }
            ],
            "stateMutability": "view",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "address[]",
                    "name": "pools",
                    "type": "address[]"
                }
            ],
            "name": "performUpkeepMultiplePools",
            "outputs": [],
            "stateMutability": "nonpayable",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "address",
                    "name": "_pool",
                    "type": "address"
                }
            ],
            "name": "performUpkeepSinglePool",
            "outputs": [],
            "stateMutability": "nonpayable",
            "type": "function"
        },
        {
            "inputs": [],
            "name": "renounceOwnership",
            "outputs": [],
            "stateMutability": "nonpayable",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "address",
                    "name": "_factory",
                    "type": "address"
                }
            ],
            "name": "setFactory",
            "outputs": [],
            "stateMutability": "nonpayable",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "uint256",
                    "name": "_price",
                    "type": "uint256"
                }
            ],
            "name": "setGasPrice",
            "outputs": [],
            "stateMutability": "nonpayable",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "address",
                    "name": "newOwner",
                    "type": "address"
                }
            ],
            "name": "transferOwnership",
            "outputs": [],
            "stateMutability": "nonpayable",
            "type": "function"
        }
    ],
    "transactionHash": "0xc8472613ca0dc277c9fd5c0b0cfd7ff8532847e42731e1454e5a3b9e4abdcecb",
    "receipt": {
        "to": null,
        "from": "0x73A7Eb4fedcA6561F124d55A95f474c6A4ea7157",
        "contractAddress": "0xc05BD952dEc77c22082a3D79f67598f58EC3d18F",
        "transactionIndex": 0,
        "gasUsed": "67093028",
        "logsBloom": "0x00000000000000000000000000000000000000000000000000800000000000040000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000020000000000000000000800000000000000000000000000000000400000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000040000000000000000000000000020000000000000000000000000000000000000000000000000000000000000020000",
        "blockHash": "0x7845267c04e410f2aa7bbeb84fd8910261f021d8785e70347fe8f99e7637b1cd",
        "transactionHash": "0xc8472613ca0dc277c9fd5c0b0cfd7ff8532847e42731e1454e5a3b9e4abdcecb",
        "logs": [
            {
                "transactionIndex": 0,
                "blockNumber": 7353593,
                "transactionHash": "0xc8472613ca0dc277c9fd5c0b0cfd7ff8532847e42731e1454e5a3b9e4abdcecb",
                "address": "0xc05BD952dEc77c22082a3D79f67598f58EC3d18F",
                "topics": [
                    "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0",
                    "0x0000000000000000000000000000000000000000000000000000000000000000",
                    "0x00000000000000000000000073a7eb4fedca6561f124d55a95f474c6a4ea7157"
                ],
                "data": "0x",
                "logIndex": 0,
                "blockHash": "0x7845267c04e410f2aa7bbeb84fd8910261f021d8785e70347fe8f99e7637b1cd"
            }
        ],
        "blockNumber": 7353593,
        "cumulativeGasUsed": "51339408",
        "status": 1,
        "byzantium": true
    },
    "args": ["0x5B1B8eEB1401aAC76bA3e02885FCb725109E3F9b"],
    "solcInputHash": "9fa5c19a38f0b8dd3ef7cd9e4cdd4bc0",
    "metadata": "{\"compiler\":{\"version\":\"0.8.7+commit.e28d00a7\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"keeper\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"KeeperPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"keeper\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"expectedReward\",\"type\":\"uint256\"}],\"name\":\"KeeperPaymentError\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"poolAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"int256\",\"name\":\"firstPrice\",\"type\":\"int256\"}],\"name\":\"PoolAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"reason\",\"type\":\"string\"}],\"name\":\"PoolUpkeepError\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":true,\"internalType\":\"int256\",\"name\":\"startPrice\",\"type\":\"int256\"},{\"indexed\":true,\"internalType\":\"int256\",\"name\":\"endPrice\",\"type\":\"int256\"}],\"name\":\"UpkeepSuccessful\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BASE_TIP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BLOCK_TIME\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_DECIMALS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TIP_DELTA_PER_BLOCK\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_pools\",\"type\":\"address[]\"}],\"name\":\"checkUpkeepMultiplePools\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"}],\"name\":\"checkUpkeepSinglePool\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"executionPrice\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"contract IPoolFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gasPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_gasPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_gasSpent\",\"type\":\"uint256\"}],\"name\":\"keeperGas\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_gasPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_gasSpent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_savedPreviousUpdatedTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_poolInterval\",\"type\":\"uint256\"}],\"name\":\"keeperReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_savedPreviousUpdatedTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_poolInterval\",\"type\":\"uint256\"}],\"name\":\"keeperTip\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_poolAddress\",\"type\":\"address\"}],\"name\":\"newPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"pools\",\"type\":\"address[]\"}],\"name\":\"performUpkeepMultiplePools\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"}],\"name\":\"performUpkeepSinglePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"}],\"name\":\"setFactory\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"setGasPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"checkUpkeepMultiplePools(address[])\":{\"params\":{\"_pools\":\"The array of pools to check\"},\"returns\":{\"_0\":\"upkeepNeeded Whether or not at least one pool needs upkeeping\"}},\"checkUpkeepSinglePool(address)\":{\"params\":{\"_pool\":\"The address of the pool to upkeep\"},\"returns\":{\"_0\":\"upkeepNeeded Whether or not upkeep is needed for this single pool\"}},\"keeperGas(address,uint256,uint256)\":{\"params\":{\"_gasPrice\":\"Price of a single gas unit (in ETH)\",\"_gasSpent\":\"Number of gas units spent\",\"_pool\":\"Address of the given pool\"},\"returns\":{\"_0\":\"Keeper's gas compensation\"}},\"keeperReward(address,uint256,uint256,uint256,uint256)\":{\"params\":{\"_gasPrice\":\"Price of a single gas unit (in ETH)\",\"_gasSpent\":\"Number of gas units spent\",\"_pool\":\"Address of the given pool\",\"_poolInterval\":\"Pool interval of the given pool\",\"_savedPreviousUpdatedTimestamp\":\"Last timestamp when the pool's price execution happened\"},\"returns\":{\"_0\":\"Number of settlement tokens to give to the keeper for work performed\"}},\"keeperTip(uint256,uint256)\":{\"params\":{\"_poolInterval\":\"Pool interval of the given pool\",\"_savedPreviousUpdatedTimestamp\":\"Last timestamp when the pool's price execution happened\"},\"returns\":{\"_0\":\"Percent of the `keeperGas` cost to add to payment, as a percent\"}},\"newPool(address)\":{\"params\":{\"_poolAddress\":\"The address of the newly-created pools\"}},\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"performUpkeepMultiplePools(address[])\":{\"params\":{\"pools\":\"pool codes to perform the update for\"}},\"performUpkeepSinglePool(address)\":{\"params\":{\"_pool\":\"The pool code to perform the update for\"}},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.\"},\"setGasPrice(uint256)\":{\"details\":\"Only owner\",\"params\":{\"_price\":\"Price (in ETH) per unit gas\"}},\"transferOwnership(address)\":{\"details\":\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\"}},\"title\":\"The manager contract for multiple markets and the pools in them\",\"version\":1},\"userdoc\":{\"events\":{\"KeeperPaid(address,address,uint256)\":{\"notice\":\"Creates a notification when a keeper is paid for doing upkeep for a pool\"},\"KeeperPaymentError(address,address,uint256)\":{\"notice\":\"Creates a notification when a keeper's payment for upkeeping a pool failed\"},\"PoolAdded(address,int256)\":{\"notice\":\"Creates a notification when a pool is created\"},\"PoolUpkeepError(address,string)\":{\"notice\":\"Creates a notification of a failed pool update\"},\"UpkeepSuccessful(address,bytes,int256,int256)\":{\"notice\":\"Creates a notification when a call to LeveragedPool:poolUpkeep is successful\"}},\"kind\":\"user\",\"methods\":{\"checkUpkeepMultiplePools(address[])\":{\"notice\":\"Checks multiple pools if any of them need updating\"},\"checkUpkeepSinglePool(address)\":{\"notice\":\"Check if upkeep is required\"},\"executionPrice(address)\":{\"notice\":\"Format: Pool address => last executionPrice\"},\"keeperGas(address,uint256,uint256)\":{\"notice\":\"Compensation a keeper will receive for their gas expenditure\"},\"keeperReward(address,uint256,uint256,uint256,uint256)\":{\"notice\":\"Payment keeper receives for performing upkeep on a given pool\"},\"keeperTip(uint256,uint256)\":{\"notice\":\"Tip a keeper will receive for successfully updating the specified pool\"},\"newPool(address)\":{\"notice\":\"When a pool is created, this function is called by the factory to initiate price trackings\"},\"performUpkeepMultiplePools(address[])\":{\"notice\":\"Called by keepers to perform an update on multiple pools\"},\"performUpkeepSinglePool(address)\":{\"notice\":\"Called by keepers to perform an update on a single pool\"},\"setGasPrice(uint256)\":{\"notice\":\"Sets the gas price to be used in compensating keepers for successful upkeep\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/implementation/PoolKeeper.sol\":\"PoolKeeper\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@chainlink/contracts/src/v0.8/interfaces/AggregatorInterface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorInterface {\\n  function latestAnswer()\\n    external\\n    view\\n    returns (\\n      int256\\n    );\\n  \\n  function latestTimestamp()\\n    external\\n    view\\n    returns (\\n      uint256\\n    );\\n\\n  function latestRound()\\n    external\\n    view\\n    returns (\\n      uint256\\n    );\\n\\n  function getAnswer(\\n    uint256 roundId\\n  )\\n    external\\n    view\\n    returns (\\n      int256\\n    );\\n\\n  function getTimestamp(\\n    uint256 roundId\\n  )\\n    external\\n    view\\n    returns (\\n      uint256\\n    );\\n\\n  event AnswerUpdated(\\n    int256 indexed current,\\n    uint256 indexed roundId,\\n    uint256 updatedAt\\n  );\\n\\n  event NewRound(\\n    uint256 indexed roundId,\\n    address indexed startedBy,\\n    uint256 startedAt\\n  );\\n}\\n\",\"keccak256\":\"0x1a5dc81544a6479f64437a8aca22c869769dd54ee3522c7ef5ebae0d329a28f0\",\"license\":\"MIT\"},\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./AggregatorInterface.sol\\\";\\nimport \\\"./AggregatorV3Interface.sol\\\";\\n\\ninterface AggregatorV2V3Interface is AggregatorInterface, AggregatorV3Interface\\n{\\n}\\n\",\"keccak256\":\"0xe8f8d98b515366730824d24269c7267eee7f0288cf737db8659acbb0c751eb53\",\"license\":\"MIT\"},\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorV3Interface {\\n\\n  function decimals()\\n    external\\n    view\\n    returns (\\n      uint8\\n    );\\n\\n  function description()\\n    external\\n    view\\n    returns (\\n      string memory\\n    );\\n\\n  function version()\\n    external\\n    view\\n    returns (\\n      uint256\\n    );\\n\\n  // getRoundData and latestRoundData should both raise \\\"No data present\\\"\\n  // if they do not have data to report, instead of returning unset values\\n  // which could be misinterpreted as actual reported values.\\n  function getRoundData(\\n    uint80 _roundId\\n  )\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n}\\n\",\"keccak256\":\"0xe6f5ac8c47f3b9b6135051efb9216f9ba5b312a6ecc20209b4f66a780443c328\",\"license\":\"MIT\"},\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0x6bb804a310218875e89d12c053e94a13a4607cdf7cc2052f3e52bd32a0dc50a1\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/Clones.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\\n * deploying minimal proxy contracts, also known as \\\"clones\\\".\\n *\\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\\n *\\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\\n * deterministic method.\\n *\\n * _Available since v3.4._\\n */\\nlibrary Clones {\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create opcode, which should never revert.\\n     */\\n    function clone(address implementation) internal returns (address instance) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n            instance := create(0, ptr, 0x37)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create failed\\\");\\n    }\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\\n     * the clones cannot be deployed twice at the same address.\\n     */\\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n            instance := create2(0, ptr, 0x37, salt)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create2 failed\\\");\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\\n            mstore(add(ptr, 0x4c), salt)\\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\\n            predicted := keccak256(add(ptr, 0x37), 0x55)\\n        }\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(address implementation, bytes32 salt)\\n        internal\\n        view\\n        returns (address predicted)\\n    {\\n        return predictDeterministicAddress(implementation, salt, address(this));\\n    }\\n}\\n\",\"keccak256\":\"0xa3bbab77849522b73d8c6cd3d2ac54bef7580e4354484f35f4cabf55d3d2b3f9\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\",\"keccak256\":\"0x027b891937d20ccf213fdb9c31531574256de774bda99d3a70ecef6e1913ed2a\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0x95098bd1d9c8dec4d80d3dedb88a0d949fa0d740ee99f2aa466bc308216ca6d5\",\"license\":\"MIT\"},\"abdk-libraries-solidity/ABDKMathQuad.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-4-Clause\\n/*\\n * ABDK Math Quad Smart Contract Library.  Copyright \\u00a9 2019 by ABDK Consulting.\\n * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\\n */\\npragma solidity ^0.8.0;\\n\\n/**\\n * Smart contract library of mathematical functions operating with IEEE 754\\n * quadruple-precision binary floating-point numbers (quadruple precision\\n * numbers).  As long as quadruple precision numbers are 16-bytes long, they are\\n * represented by bytes16 type.\\n */\\nlibrary ABDKMathQuad {\\n  /*\\n   * 0.\\n   */\\n  bytes16 private constant POSITIVE_ZERO = 0x00000000000000000000000000000000;\\n\\n  /*\\n   * -0.\\n   */\\n  bytes16 private constant NEGATIVE_ZERO = 0x80000000000000000000000000000000;\\n\\n  /*\\n   * +Infinity.\\n   */\\n  bytes16 private constant POSITIVE_INFINITY = 0x7FFF0000000000000000000000000000;\\n\\n  /*\\n   * -Infinity.\\n   */\\n  bytes16 private constant NEGATIVE_INFINITY = 0xFFFF0000000000000000000000000000;\\n\\n  /*\\n   * Canonical NaN value.\\n   */\\n  bytes16 private constant NaN = 0x7FFF8000000000000000000000000000;\\n\\n  /**\\n   * Convert signed 256-bit integer number into quadruple precision number.\\n   *\\n   * @param x signed 256-bit integer number\\n   * @return quadruple precision number\\n   */\\n  function fromInt (int256 x) internal pure returns (bytes16) {\\n    unchecked {\\n      if (x == 0) return bytes16 (0);\\n      else {\\n        // We rely on overflow behavior here\\n        uint256 result = uint256 (x > 0 ? x : -x);\\n\\n        uint256 msb = mostSignificantBit (result);\\n        if (msb < 112) result <<= 112 - msb;\\n        else if (msb > 112) result >>= msb - 112;\\n\\n        result = result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF | 16383 + msb << 112;\\n        if (x < 0) result |= 0x80000000000000000000000000000000;\\n\\n        return bytes16 (uint128 (result));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert quadruple precision number into signed 256-bit integer number\\n   * rounding towards zero.  Revert on overflow.\\n   *\\n   * @param x quadruple precision number\\n   * @return signed 256-bit integer number\\n   */\\n  function toInt (bytes16 x) internal pure returns (int256) {\\n    unchecked {\\n      uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\\n\\n      require (exponent <= 16638); // Overflow\\n      if (exponent < 16383) return 0; // Underflow\\n\\n      uint256 result = uint256 (uint128 (x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF |\\n        0x10000000000000000000000000000;\\n\\n      if (exponent < 16495) result >>= 16495 - exponent;\\n      else if (exponent > 16495) result <<= exponent - 16495;\\n\\n      if (uint128 (x) >= 0x80000000000000000000000000000000) { // Negative\\n        require (result <= 0x8000000000000000000000000000000000000000000000000000000000000000);\\n        return -int256 (result); // We rely on overflow behavior here\\n      } else {\\n        require (result <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n        return int256 (result);\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert unsigned 256-bit integer number into quadruple precision number.\\n   *\\n   * @param x unsigned 256-bit integer number\\n   * @return quadruple precision number\\n   */\\n  function fromUInt (uint256 x) internal pure returns (bytes16) {\\n    unchecked {\\n      if (x == 0) return bytes16 (0);\\n      else {\\n        uint256 result = x;\\n\\n        uint256 msb = mostSignificantBit (result);\\n        if (msb < 112) result <<= 112 - msb;\\n        else if (msb > 112) result >>= msb - 112;\\n\\n        result = result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF | 16383 + msb << 112;\\n\\n        return bytes16 (uint128 (result));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert quadruple precision number into unsigned 256-bit integer number\\n   * rounding towards zero.  Revert on underflow.  Note, that negative floating\\n   * point numbers in range (-1.0 .. 0.0) may be converted to unsigned integer\\n   * without error, because they are rounded to zero.\\n   *\\n   * @param x quadruple precision number\\n   * @return unsigned 256-bit integer number\\n   */\\n  function toUInt (bytes16 x) internal pure returns (uint256) {\\n    unchecked {\\n      uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\\n\\n      if (exponent < 16383) return 0; // Underflow\\n\\n      require (uint128 (x) < 0x80000000000000000000000000000000); // Negative\\n\\n      require (exponent <= 16638); // Overflow\\n      uint256 result = uint256 (uint128 (x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF |\\n        0x10000000000000000000000000000;\\n\\n      if (exponent < 16495) result >>= 16495 - exponent;\\n      else if (exponent > 16495) result <<= exponent - 16495;\\n\\n      return result;\\n    }\\n  }\\n\\n  /**\\n   * Convert signed 128.128 bit fixed point number into quadruple precision\\n   * number.\\n   *\\n   * @param x signed 128.128 bit fixed point number\\n   * @return quadruple precision number\\n   */\\n  function from128x128 (int256 x) internal pure returns (bytes16) {\\n    unchecked {\\n      if (x == 0) return bytes16 (0);\\n      else {\\n        // We rely on overflow behavior here\\n        uint256 result = uint256 (x > 0 ? x : -x);\\n\\n        uint256 msb = mostSignificantBit (result);\\n        if (msb < 112) result <<= 112 - msb;\\n        else if (msb > 112) result >>= msb - 112;\\n\\n        result = result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF | 16255 + msb << 112;\\n        if (x < 0) result |= 0x80000000000000000000000000000000;\\n\\n        return bytes16 (uint128 (result));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert quadruple precision number into signed 128.128 bit fixed point\\n   * number.  Revert on overflow.\\n   *\\n   * @param x quadruple precision number\\n   * @return signed 128.128 bit fixed point number\\n   */\\n  function to128x128 (bytes16 x) internal pure returns (int256) {\\n    unchecked {\\n      uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\\n\\n      require (exponent <= 16510); // Overflow\\n      if (exponent < 16255) return 0; // Underflow\\n\\n      uint256 result = uint256 (uint128 (x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF |\\n        0x10000000000000000000000000000;\\n\\n      if (exponent < 16367) result >>= 16367 - exponent;\\n      else if (exponent > 16367) result <<= exponent - 16367;\\n\\n      if (uint128 (x) >= 0x80000000000000000000000000000000) { // Negative\\n        require (result <= 0x8000000000000000000000000000000000000000000000000000000000000000);\\n        return -int256 (result); // We rely on overflow behavior here\\n      } else {\\n        require (result <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n        return int256 (result);\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert signed 64.64 bit fixed point number into quadruple precision\\n   * number.\\n   *\\n   * @param x signed 64.64 bit fixed point number\\n   * @return quadruple precision number\\n   */\\n  function from64x64 (int128 x) internal pure returns (bytes16) {\\n    unchecked {\\n      if (x == 0) return bytes16 (0);\\n      else {\\n        // We rely on overflow behavior here\\n        uint256 result = uint128 (x > 0 ? x : -x);\\n\\n        uint256 msb = mostSignificantBit (result);\\n        if (msb < 112) result <<= 112 - msb;\\n        else if (msb > 112) result >>= msb - 112;\\n\\n        result = result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF | 16319 + msb << 112;\\n        if (x < 0) result |= 0x80000000000000000000000000000000;\\n\\n        return bytes16 (uint128 (result));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert quadruple precision number into signed 64.64 bit fixed point\\n   * number.  Revert on overflow.\\n   *\\n   * @param x quadruple precision number\\n   * @return signed 64.64 bit fixed point number\\n   */\\n  function to64x64 (bytes16 x) internal pure returns (int128) {\\n    unchecked {\\n      uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\\n\\n      require (exponent <= 16446); // Overflow\\n      if (exponent < 16319) return 0; // Underflow\\n\\n      uint256 result = uint256 (uint128 (x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF |\\n        0x10000000000000000000000000000;\\n\\n      if (exponent < 16431) result >>= 16431 - exponent;\\n      else if (exponent > 16431) result <<= exponent - 16431;\\n\\n      if (uint128 (x) >= 0x80000000000000000000000000000000) { // Negative\\n        require (result <= 0x80000000000000000000000000000000);\\n        return -int128 (int256 (result)); // We rely on overflow behavior here\\n      } else {\\n        require (result <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n        return int128 (int256 (result));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert octuple precision number into quadruple precision number.\\n   *\\n   * @param x octuple precision number\\n   * @return quadruple precision number\\n   */\\n  function fromOctuple (bytes32 x) internal pure returns (bytes16) {\\n    unchecked {\\n      bool negative = x & 0x8000000000000000000000000000000000000000000000000000000000000000 > 0;\\n\\n      uint256 exponent = uint256 (x) >> 236 & 0x7FFFF;\\n      uint256 significand = uint256 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      if (exponent == 0x7FFFF) {\\n        if (significand > 0) return NaN;\\n        else return negative ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\\n      }\\n\\n      if (exponent > 278526)\\n        return negative ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\\n      else if (exponent < 245649)\\n        return negative ? NEGATIVE_ZERO : POSITIVE_ZERO;\\n      else if (exponent < 245761) {\\n        significand = (significand | 0x100000000000000000000000000000000000000000000000000000000000) >> 245885 - exponent;\\n        exponent = 0;\\n      } else {\\n        significand >>= 124;\\n        exponent -= 245760;\\n      }\\n\\n      uint128 result = uint128 (significand | exponent << 112);\\n      if (negative) result |= 0x80000000000000000000000000000000;\\n\\n      return bytes16 (result);\\n    }\\n  }\\n\\n  /**\\n   * Convert quadruple precision number into octuple precision number.\\n   *\\n   * @param x quadruple precision number\\n   * @return octuple precision number\\n   */\\n  function toOctuple (bytes16 x) internal pure returns (bytes32) {\\n    unchecked {\\n      uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\\n\\n      uint256 result = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      if (exponent == 0x7FFF) exponent = 0x7FFFF; // Infinity or NaN\\n      else if (exponent == 0) {\\n        if (result > 0) {\\n          uint256 msb = mostSignificantBit (result);\\n          result = result << 236 - msb & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n          exponent = 245649 + msb;\\n        }\\n      } else {\\n        result <<= 124;\\n        exponent += 245760;\\n      }\\n\\n      result |= exponent << 236;\\n      if (uint128 (x) >= 0x80000000000000000000000000000000)\\n        result |= 0x8000000000000000000000000000000000000000000000000000000000000000;\\n\\n      return bytes32 (result);\\n    }\\n  }\\n\\n  /**\\n   * Convert double precision number into quadruple precision number.\\n   *\\n   * @param x double precision number\\n   * @return quadruple precision number\\n   */\\n  function fromDouble (bytes8 x) internal pure returns (bytes16) {\\n    unchecked {\\n      uint256 exponent = uint64 (x) >> 52 & 0x7FF;\\n\\n      uint256 result = uint64 (x) & 0xFFFFFFFFFFFFF;\\n\\n      if (exponent == 0x7FF) exponent = 0x7FFF; // Infinity or NaN\\n      else if (exponent == 0) {\\n        if (result > 0) {\\n          uint256 msb = mostSignificantBit (result);\\n          result = result << 112 - msb & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n          exponent = 15309 + msb;\\n        }\\n      } else {\\n        result <<= 60;\\n        exponent += 15360;\\n      }\\n\\n      result |= exponent << 112;\\n      if (x & 0x8000000000000000 > 0)\\n        result |= 0x80000000000000000000000000000000;\\n\\n      return bytes16 (uint128 (result));\\n    }\\n  }\\n\\n  /**\\n   * Convert quadruple precision number into double precision number.\\n   *\\n   * @param x quadruple precision number\\n   * @return double precision number\\n   */\\n  function toDouble (bytes16 x) internal pure returns (bytes8) {\\n    unchecked {\\n      bool negative = uint128 (x) >= 0x80000000000000000000000000000000;\\n\\n      uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\\n      uint256 significand = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      if (exponent == 0x7FFF) {\\n        if (significand > 0) return 0x7FF8000000000000; // NaN\\n        else return negative ?\\n            bytes8 (0xFFF0000000000000) : // -Infinity\\n            bytes8 (0x7FF0000000000000); // Infinity\\n      }\\n\\n      if (exponent > 17406)\\n        return negative ?\\n            bytes8 (0xFFF0000000000000) : // -Infinity\\n            bytes8 (0x7FF0000000000000); // Infinity\\n      else if (exponent < 15309)\\n        return negative ?\\n            bytes8 (0x8000000000000000) : // -0\\n            bytes8 (0x0000000000000000); // 0\\n      else if (exponent < 15361) {\\n        significand = (significand | 0x10000000000000000000000000000) >> 15421 - exponent;\\n        exponent = 0;\\n      } else {\\n        significand >>= 60;\\n        exponent -= 15360;\\n      }\\n\\n      uint64 result = uint64 (significand | exponent << 52);\\n      if (negative) result |= 0x8000000000000000;\\n\\n      return bytes8 (result);\\n    }\\n  }\\n\\n  /**\\n   * Test whether given quadruple precision number is NaN.\\n   *\\n   * @param x quadruple precision number\\n   * @return true if x is NaN, false otherwise\\n   */\\n  function isNaN (bytes16 x) internal pure returns (bool) {\\n    unchecked {\\n      return uint128 (x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF >\\n        0x7FFF0000000000000000000000000000;\\n    }\\n  }\\n\\n  /**\\n   * Test whether given quadruple precision number is positive or negative\\n   * infinity.\\n   *\\n   * @param x quadruple precision number\\n   * @return true if x is positive or negative infinity, false otherwise\\n   */\\n  function isInfinity (bytes16 x) internal pure returns (bool) {\\n    unchecked {\\n      return uint128 (x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF ==\\n        0x7FFF0000000000000000000000000000;\\n    }\\n  }\\n\\n  /**\\n   * Calculate sign of x, i.e. -1 if x is negative, 0 if x if zero, and 1 if x\\n   * is positive.  Note that sign (-0) is zero.  Revert if x is NaN. \\n   *\\n   * @param x quadruple precision number\\n   * @return sign of x\\n   */\\n  function sign (bytes16 x) internal pure returns (int8) {\\n    unchecked {\\n      uint128 absoluteX = uint128 (x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      require (absoluteX <= 0x7FFF0000000000000000000000000000); // Not NaN\\n\\n      if (absoluteX == 0) return 0;\\n      else if (uint128 (x) >= 0x80000000000000000000000000000000) return -1;\\n      else return 1;\\n    }\\n  }\\n\\n  /**\\n   * Calculate sign (x - y).  Revert if either argument is NaN, or both\\n   * arguments are infinities of the same sign. \\n   *\\n   * @param x quadruple precision number\\n   * @param y quadruple precision number\\n   * @return sign (x - y)\\n   */\\n  function cmp (bytes16 x, bytes16 y) internal pure returns (int8) {\\n    unchecked {\\n      uint128 absoluteX = uint128 (x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      require (absoluteX <= 0x7FFF0000000000000000000000000000); // Not NaN\\n\\n      uint128 absoluteY = uint128 (y) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      require (absoluteY <= 0x7FFF0000000000000000000000000000); // Not NaN\\n\\n      // Not infinities of the same sign\\n      require (x != y || absoluteX < 0x7FFF0000000000000000000000000000);\\n\\n      if (x == y) return 0;\\n      else {\\n        bool negativeX = uint128 (x) >= 0x80000000000000000000000000000000;\\n        bool negativeY = uint128 (y) >= 0x80000000000000000000000000000000;\\n\\n        if (negativeX) {\\n          if (negativeY) return absoluteX > absoluteY ? -1 : int8 (1);\\n          else return -1; \\n        } else {\\n          if (negativeY) return 1;\\n          else return absoluteX > absoluteY ? int8 (1) : -1;\\n        }\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Test whether x equals y.  NaN, infinity, and -infinity are not equal to\\n   * anything. \\n   *\\n   * @param x quadruple precision number\\n   * @param y quadruple precision number\\n   * @return true if x equals to y, false otherwise\\n   */\\n  function eq (bytes16 x, bytes16 y) internal pure returns (bool) {\\n    unchecked {\\n      if (x == y) {\\n        return uint128 (x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF <\\n          0x7FFF0000000000000000000000000000;\\n      } else return false;\\n    }\\n  }\\n\\n  /**\\n   * Calculate x + y.  Special values behave in the following way:\\n   *\\n   * NaN + x = NaN for any x.\\n   * Infinity + x = Infinity for any finite x.\\n   * -Infinity + x = -Infinity for any finite x.\\n   * Infinity + Infinity = Infinity.\\n   * -Infinity + -Infinity = -Infinity.\\n   * Infinity + -Infinity = -Infinity + Infinity = NaN.\\n   *\\n   * @param x quadruple precision number\\n   * @param y quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function add (bytes16 x, bytes16 y) internal pure returns (bytes16) {\\n    unchecked {\\n      uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\\n      uint256 yExponent = uint128 (y) >> 112 & 0x7FFF;\\n\\n      if (xExponent == 0x7FFF) {\\n        if (yExponent == 0x7FFF) { \\n          if (x == y) return x;\\n          else return NaN;\\n        } else return x; \\n      } else if (yExponent == 0x7FFF) return y;\\n      else {\\n        bool xSign = uint128 (x) >= 0x80000000000000000000000000000000;\\n        uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (xExponent == 0) xExponent = 1;\\n        else xSignifier |= 0x10000000000000000000000000000;\\n\\n        bool ySign = uint128 (y) >= 0x80000000000000000000000000000000;\\n        uint256 ySignifier = uint128 (y) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (yExponent == 0) yExponent = 1;\\n        else ySignifier |= 0x10000000000000000000000000000;\\n\\n        if (xSignifier == 0) return y == NEGATIVE_ZERO ? POSITIVE_ZERO : y;\\n        else if (ySignifier == 0) return x == NEGATIVE_ZERO ? POSITIVE_ZERO : x;\\n        else {\\n          int256 delta = int256 (xExponent) - int256 (yExponent);\\n  \\n          if (xSign == ySign) {\\n            if (delta > 112) return x;\\n            else if (delta > 0) ySignifier >>= uint256 (delta);\\n            else if (delta < -112) return y;\\n            else if (delta < 0) {\\n              xSignifier >>= uint256 (-delta);\\n              xExponent = yExponent;\\n            }\\n  \\n            xSignifier += ySignifier;\\n  \\n            if (xSignifier >= 0x20000000000000000000000000000) {\\n              xSignifier >>= 1;\\n              xExponent += 1;\\n            }\\n  \\n            if (xExponent == 0x7FFF)\\n              return xSign ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\\n            else {\\n              if (xSignifier < 0x10000000000000000000000000000) xExponent = 0;\\n              else xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n  \\n              return bytes16 (uint128 (\\n                  (xSign ? 0x80000000000000000000000000000000 : 0) |\\n                  (xExponent << 112) |\\n                  xSignifier)); \\n            }\\n          } else {\\n            if (delta > 0) {\\n              xSignifier <<= 1;\\n              xExponent -= 1;\\n            } else if (delta < 0) {\\n              ySignifier <<= 1;\\n              xExponent = yExponent - 1;\\n            }\\n\\n            if (delta > 112) ySignifier = 1;\\n            else if (delta > 1) ySignifier = (ySignifier - 1 >> uint256 (delta - 1)) + 1;\\n            else if (delta < -112) xSignifier = 1;\\n            else if (delta < -1) xSignifier = (xSignifier - 1 >> uint256 (-delta - 1)) + 1;\\n\\n            if (xSignifier >= ySignifier) xSignifier -= ySignifier;\\n            else {\\n              xSignifier = ySignifier - xSignifier;\\n              xSign = ySign;\\n            }\\n\\n            if (xSignifier == 0)\\n              return POSITIVE_ZERO;\\n\\n            uint256 msb = mostSignificantBit (xSignifier);\\n\\n            if (msb == 113) {\\n              xSignifier = xSignifier >> 1 & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n              xExponent += 1;\\n            } else if (msb < 112) {\\n              uint256 shift = 112 - msb;\\n              if (xExponent > shift) {\\n                xSignifier = xSignifier << shift & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n                xExponent -= shift;\\n              } else {\\n                xSignifier <<= xExponent - 1;\\n                xExponent = 0;\\n              }\\n            } else xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n            if (xExponent == 0x7FFF)\\n              return xSign ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\\n            else return bytes16 (uint128 (\\n                (xSign ? 0x80000000000000000000000000000000 : 0) |\\n                (xExponent << 112) |\\n                xSignifier));\\n          }\\n        }\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate x - y.  Special values behave in the following way:\\n   *\\n   * NaN - x = NaN for any x.\\n   * Infinity - x = Infinity for any finite x.\\n   * -Infinity - x = -Infinity for any finite x.\\n   * Infinity - -Infinity = Infinity.\\n   * -Infinity - Infinity = -Infinity.\\n   * Infinity - Infinity = -Infinity - -Infinity = NaN.\\n   *\\n   * @param x quadruple precision number\\n   * @param y quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function sub (bytes16 x, bytes16 y) internal pure returns (bytes16) {\\n    unchecked {\\n      return add (x, y ^ 0x80000000000000000000000000000000);\\n    }\\n  }\\n\\n  /**\\n   * Calculate x * y.  Special values behave in the following way:\\n   *\\n   * NaN * x = NaN for any x.\\n   * Infinity * x = Infinity for any finite positive x.\\n   * Infinity * x = -Infinity for any finite negative x.\\n   * -Infinity * x = -Infinity for any finite positive x.\\n   * -Infinity * x = Infinity for any finite negative x.\\n   * Infinity * 0 = NaN.\\n   * -Infinity * 0 = NaN.\\n   * Infinity * Infinity = Infinity.\\n   * Infinity * -Infinity = -Infinity.\\n   * -Infinity * Infinity = -Infinity.\\n   * -Infinity * -Infinity = Infinity.\\n   *\\n   * @param x quadruple precision number\\n   * @param y quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function mul (bytes16 x, bytes16 y) internal pure returns (bytes16) {\\n    unchecked {\\n      uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\\n      uint256 yExponent = uint128 (y) >> 112 & 0x7FFF;\\n\\n      if (xExponent == 0x7FFF) {\\n        if (yExponent == 0x7FFF) {\\n          if (x == y) return x ^ y & 0x80000000000000000000000000000000;\\n          else if (x ^ y == 0x80000000000000000000000000000000) return x | y;\\n          else return NaN;\\n        } else {\\n          if (y & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) return NaN;\\n          else return x ^ y & 0x80000000000000000000000000000000;\\n        }\\n      } else if (yExponent == 0x7FFF) {\\n          if (x & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) return NaN;\\n          else return y ^ x & 0x80000000000000000000000000000000;\\n      } else {\\n        uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (xExponent == 0) xExponent = 1;\\n        else xSignifier |= 0x10000000000000000000000000000;\\n\\n        uint256 ySignifier = uint128 (y) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (yExponent == 0) yExponent = 1;\\n        else ySignifier |= 0x10000000000000000000000000000;\\n\\n        xSignifier *= ySignifier;\\n        if (xSignifier == 0)\\n          return (x ^ y) & 0x80000000000000000000000000000000 > 0 ?\\n              NEGATIVE_ZERO : POSITIVE_ZERO;\\n\\n        xExponent += yExponent;\\n\\n        uint256 msb =\\n          xSignifier >= 0x200000000000000000000000000000000000000000000000000000000 ? 225 :\\n          xSignifier >= 0x100000000000000000000000000000000000000000000000000000000 ? 224 :\\n          mostSignificantBit (xSignifier);\\n\\n        if (xExponent + msb < 16496) { // Underflow\\n          xExponent = 0;\\n          xSignifier = 0;\\n        } else if (xExponent + msb < 16608) { // Subnormal\\n          if (xExponent < 16496)\\n            xSignifier >>= 16496 - xExponent;\\n          else if (xExponent > 16496)\\n            xSignifier <<= xExponent - 16496;\\n          xExponent = 0;\\n        } else if (xExponent + msb > 49373) {\\n          xExponent = 0x7FFF;\\n          xSignifier = 0;\\n        } else {\\n          if (msb > 112)\\n            xSignifier >>= msb - 112;\\n          else if (msb < 112)\\n            xSignifier <<= 112 - msb;\\n\\n          xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n          xExponent = xExponent + msb - 16607;\\n        }\\n\\n        return bytes16 (uint128 (uint128 ((x ^ y) & 0x80000000000000000000000000000000) |\\n            xExponent << 112 | xSignifier));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate x / y.  Special values behave in the following way:\\n   *\\n   * NaN / x = NaN for any x.\\n   * x / NaN = NaN for any x.\\n   * Infinity / x = Infinity for any finite non-negative x.\\n   * Infinity / x = -Infinity for any finite negative x including -0.\\n   * -Infinity / x = -Infinity for any finite non-negative x.\\n   * -Infinity / x = Infinity for any finite negative x including -0.\\n   * x / Infinity = 0 for any finite non-negative x.\\n   * x / -Infinity = -0 for any finite non-negative x.\\n   * x / Infinity = -0 for any finite non-negative x including -0.\\n   * x / -Infinity = 0 for any finite non-negative x including -0.\\n   * \\n   * Infinity / Infinity = NaN.\\n   * Infinity / -Infinity = -NaN.\\n   * -Infinity / Infinity = -NaN.\\n   * -Infinity / -Infinity = NaN.\\n   *\\n   * Division by zero behaves in the following way:\\n   *\\n   * x / 0 = Infinity for any finite positive x.\\n   * x / -0 = -Infinity for any finite positive x.\\n   * x / 0 = -Infinity for any finite negative x.\\n   * x / -0 = Infinity for any finite negative x.\\n   * 0 / 0 = NaN.\\n   * 0 / -0 = NaN.\\n   * -0 / 0 = NaN.\\n   * -0 / -0 = NaN.\\n   *\\n   * @param x quadruple precision number\\n   * @param y quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function div (bytes16 x, bytes16 y) internal pure returns (bytes16) {\\n    unchecked {\\n      uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\\n      uint256 yExponent = uint128 (y) >> 112 & 0x7FFF;\\n\\n      if (xExponent == 0x7FFF) {\\n        if (yExponent == 0x7FFF) return NaN;\\n        else return x ^ y & 0x80000000000000000000000000000000;\\n      } else if (yExponent == 0x7FFF) {\\n        if (y & 0x0000FFFFFFFFFFFFFFFFFFFFFFFFFFFF != 0) return NaN;\\n        else return POSITIVE_ZERO | (x ^ y) & 0x80000000000000000000000000000000;\\n      } else if (y & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) {\\n        if (x & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) return NaN;\\n        else return POSITIVE_INFINITY | (x ^ y) & 0x80000000000000000000000000000000;\\n      } else {\\n        uint256 ySignifier = uint128 (y) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (yExponent == 0) yExponent = 1;\\n        else ySignifier |= 0x10000000000000000000000000000;\\n\\n        uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (xExponent == 0) {\\n          if (xSignifier != 0) {\\n            uint shift = 226 - mostSignificantBit (xSignifier);\\n\\n            xSignifier <<= shift;\\n\\n            xExponent = 1;\\n            yExponent += shift - 114;\\n          }\\n        }\\n        else {\\n          xSignifier = (xSignifier | 0x10000000000000000000000000000) << 114;\\n        }\\n\\n        xSignifier = xSignifier / ySignifier;\\n        if (xSignifier == 0)\\n          return (x ^ y) & 0x80000000000000000000000000000000 > 0 ?\\n              NEGATIVE_ZERO : POSITIVE_ZERO;\\n\\n        assert (xSignifier >= 0x1000000000000000000000000000);\\n\\n        uint256 msb =\\n          xSignifier >= 0x80000000000000000000000000000 ? mostSignificantBit (xSignifier) :\\n          xSignifier >= 0x40000000000000000000000000000 ? 114 :\\n          xSignifier >= 0x20000000000000000000000000000 ? 113 : 112;\\n\\n        if (xExponent + msb > yExponent + 16497) { // Overflow\\n          xExponent = 0x7FFF;\\n          xSignifier = 0;\\n        } else if (xExponent + msb + 16380  < yExponent) { // Underflow\\n          xExponent = 0;\\n          xSignifier = 0;\\n        } else if (xExponent + msb + 16268  < yExponent) { // Subnormal\\n          if (xExponent + 16380 > yExponent)\\n            xSignifier <<= xExponent + 16380 - yExponent;\\n          else if (xExponent + 16380 < yExponent)\\n            xSignifier >>= yExponent - xExponent - 16380;\\n\\n          xExponent = 0;\\n        } else { // Normal\\n          if (msb > 112)\\n            xSignifier >>= msb - 112;\\n\\n          xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n          xExponent = xExponent + msb + 16269 - yExponent;\\n        }\\n\\n        return bytes16 (uint128 (uint128 ((x ^ y) & 0x80000000000000000000000000000000) |\\n            xExponent << 112 | xSignifier));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate -x.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function neg (bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      return x ^ 0x80000000000000000000000000000000;\\n    }\\n  }\\n\\n  /**\\n   * Calculate |x|.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function abs (bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      return x & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n    }\\n  }\\n\\n  /**\\n   * Calculate square root of x.  Return NaN on negative x excluding -0.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function sqrt (bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      if (uint128 (x) >  0x80000000000000000000000000000000) return NaN;\\n      else {\\n        uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\\n        if (xExponent == 0x7FFF) return x;\\n        else {\\n          uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n          if (xExponent == 0) xExponent = 1;\\n          else xSignifier |= 0x10000000000000000000000000000;\\n\\n          if (xSignifier == 0) return POSITIVE_ZERO;\\n\\n          bool oddExponent = xExponent & 0x1 == 0;\\n          xExponent = xExponent + 16383 >> 1;\\n\\n          if (oddExponent) {\\n            if (xSignifier >= 0x10000000000000000000000000000)\\n              xSignifier <<= 113;\\n            else {\\n              uint256 msb = mostSignificantBit (xSignifier);\\n              uint256 shift = (226 - msb) & 0xFE;\\n              xSignifier <<= shift;\\n              xExponent -= shift - 112 >> 1;\\n            }\\n          } else {\\n            if (xSignifier >= 0x10000000000000000000000000000)\\n              xSignifier <<= 112;\\n            else {\\n              uint256 msb = mostSignificantBit (xSignifier);\\n              uint256 shift = (225 - msb) & 0xFE;\\n              xSignifier <<= shift;\\n              xExponent -= shift - 112 >> 1;\\n            }\\n          }\\n\\n          uint256 r = 0x10000000000000000000000000000;\\n          r = (r + xSignifier / r) >> 1;\\n          r = (r + xSignifier / r) >> 1;\\n          r = (r + xSignifier / r) >> 1;\\n          r = (r + xSignifier / r) >> 1;\\n          r = (r + xSignifier / r) >> 1;\\n          r = (r + xSignifier / r) >> 1;\\n          r = (r + xSignifier / r) >> 1; // Seven iterations should be enough\\n          uint256 r1 = xSignifier / r;\\n          if (r1 < r) r = r1;\\n\\n          return bytes16 (uint128 (xExponent << 112 | r & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF));\\n        }\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate binary logarithm of x.  Return NaN on negative x excluding -0.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function log_2 (bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      if (uint128 (x) > 0x80000000000000000000000000000000) return NaN;\\n      else if (x == 0x3FFF0000000000000000000000000000) return POSITIVE_ZERO; \\n      else {\\n        uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\\n        if (xExponent == 0x7FFF) return x;\\n        else {\\n          uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n          if (xExponent == 0) xExponent = 1;\\n          else xSignifier |= 0x10000000000000000000000000000;\\n\\n          if (xSignifier == 0) return NEGATIVE_INFINITY;\\n\\n          bool resultNegative;\\n          uint256 resultExponent = 16495;\\n          uint256 resultSignifier;\\n\\n          if (xExponent >= 0x3FFF) {\\n            resultNegative = false;\\n            resultSignifier = xExponent - 0x3FFF;\\n            xSignifier <<= 15;\\n          } else {\\n            resultNegative = true;\\n            if (xSignifier >= 0x10000000000000000000000000000) {\\n              resultSignifier = 0x3FFE - xExponent;\\n              xSignifier <<= 15;\\n            } else {\\n              uint256 msb = mostSignificantBit (xSignifier);\\n              resultSignifier = 16493 - msb;\\n              xSignifier <<= 127 - msb;\\n            }\\n          }\\n\\n          if (xSignifier == 0x80000000000000000000000000000000) {\\n            if (resultNegative) resultSignifier += 1;\\n            uint256 shift = 112 - mostSignificantBit (resultSignifier);\\n            resultSignifier <<= shift;\\n            resultExponent -= shift;\\n          } else {\\n            uint256 bb = resultNegative ? 1 : 0;\\n            while (resultSignifier < 0x10000000000000000000000000000) {\\n              resultSignifier <<= 1;\\n              resultExponent -= 1;\\n  \\n              xSignifier *= xSignifier;\\n              uint256 b = xSignifier >> 255;\\n              resultSignifier += b ^ bb;\\n              xSignifier >>= 127 + b;\\n            }\\n          }\\n\\n          return bytes16 (uint128 ((resultNegative ? 0x80000000000000000000000000000000 : 0) |\\n              resultExponent << 112 | resultSignifier & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF));\\n        }\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate natural logarithm of x.  Return NaN on negative x excluding -0.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function ln (bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      return mul (log_2 (x), 0x3FFE62E42FEFA39EF35793C7673007E5);\\n    }\\n  }\\n\\n  /**\\n   * Calculate 2^x.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function pow_2 (bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      bool xNegative = uint128 (x) > 0x80000000000000000000000000000000;\\n      uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\\n      uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      if (xExponent == 0x7FFF && xSignifier != 0) return NaN;\\n      else if (xExponent > 16397)\\n        return xNegative ? POSITIVE_ZERO : POSITIVE_INFINITY;\\n      else if (xExponent < 16255)\\n        return 0x3FFF0000000000000000000000000000;\\n      else {\\n        if (xExponent == 0) xExponent = 1;\\n        else xSignifier |= 0x10000000000000000000000000000;\\n\\n        if (xExponent > 16367)\\n          xSignifier <<= xExponent - 16367;\\n        else if (xExponent < 16367)\\n          xSignifier >>= 16367 - xExponent;\\n\\n        if (xNegative && xSignifier > 0x406E00000000000000000000000000000000)\\n          return POSITIVE_ZERO;\\n\\n        if (!xNegative && xSignifier > 0x3FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\\n          return POSITIVE_INFINITY;\\n\\n        uint256 resultExponent = xSignifier >> 128;\\n        xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (xNegative && xSignifier != 0) {\\n          xSignifier = ~xSignifier;\\n          resultExponent += 1;\\n        }\\n\\n        uint256 resultSignifier = 0x80000000000000000000000000000000;\\n        if (xSignifier & 0x80000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x16A09E667F3BCC908B2FB1366EA957D3E >> 128;\\n        if (xSignifier & 0x40000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1306FE0A31B7152DE8D5A46305C85EDEC >> 128;\\n        if (xSignifier & 0x20000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1172B83C7D517ADCDF7C8C50EB14A791F >> 128;\\n        if (xSignifier & 0x10000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10B5586CF9890F6298B92B71842A98363 >> 128;\\n        if (xSignifier & 0x8000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1059B0D31585743AE7C548EB68CA417FD >> 128;\\n        if (xSignifier & 0x4000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x102C9A3E778060EE6F7CACA4F7A29BDE8 >> 128;\\n        if (xSignifier & 0x2000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10163DA9FB33356D84A66AE336DCDFA3F >> 128;\\n        if (xSignifier & 0x1000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100B1AFA5ABCBED6129AB13EC11DC9543 >> 128;\\n        if (xSignifier & 0x800000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10058C86DA1C09EA1FF19D294CF2F679B >> 128;\\n        if (xSignifier & 0x400000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1002C605E2E8CEC506D21BFC89A23A00F >> 128;\\n        if (xSignifier & 0x200000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100162F3904051FA128BCA9C55C31E5DF >> 128;\\n        if (xSignifier & 0x100000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000B175EFFDC76BA38E31671CA939725 >> 128;\\n        if (xSignifier & 0x80000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100058BA01FB9F96D6CACD4B180917C3D >> 128;\\n        if (xSignifier & 0x40000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10002C5CC37DA9491D0985C348C68E7B3 >> 128;\\n        if (xSignifier & 0x20000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000162E525EE054754457D5995292026 >> 128;\\n        if (xSignifier & 0x10000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000B17255775C040618BF4A4ADE83FC >> 128;\\n        if (xSignifier & 0x8000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000058B91B5BC9AE2EED81E9B7D4CFAB >> 128;\\n        if (xSignifier & 0x4000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100002C5C89D5EC6CA4D7C8ACC017B7C9 >> 128;\\n        if (xSignifier & 0x2000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000162E43F4F831060E02D839A9D16D >> 128;\\n        if (xSignifier & 0x1000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000B1721BCFC99D9F890EA06911763 >> 128;\\n        if (xSignifier & 0x800000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000058B90CF1E6D97F9CA14DBCC1628 >> 128;\\n        if (xSignifier & 0x400000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000002C5C863B73F016468F6BAC5CA2B >> 128;\\n        if (xSignifier & 0x200000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000162E430E5A18F6119E3C02282A5 >> 128;\\n        if (xSignifier & 0x100000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000B1721835514B86E6D96EFD1BFE >> 128;\\n        if (xSignifier & 0x80000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000058B90C0B48C6BE5DF846C5B2EF >> 128;\\n        if (xSignifier & 0x40000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000002C5C8601CC6B9E94213C72737A >> 128;\\n        if (xSignifier & 0x20000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000162E42FFF037DF38AA2B219F06 >> 128;\\n        if (xSignifier & 0x10000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000B17217FBA9C739AA5819F44F9 >> 128;\\n        if (xSignifier & 0x8000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000058B90BFCDEE5ACD3C1CEDC823 >> 128;\\n        if (xSignifier & 0x4000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000002C5C85FE31F35A6A30DA1BE50 >> 128;\\n        if (xSignifier & 0x2000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000162E42FF0999CE3541B9FFFCF >> 128;\\n        if (xSignifier & 0x1000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000B17217F80F4EF5AADDA45554 >> 128;\\n        if (xSignifier & 0x800000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000058B90BFBF8479BD5A81B51AD >> 128;\\n        if (xSignifier & 0x400000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000002C5C85FDF84BD62AE30A74CC >> 128;\\n        if (xSignifier & 0x200000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000162E42FEFB2FED257559BDAA >> 128;\\n        if (xSignifier & 0x100000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000B17217F7D5A7716BBA4A9AE >> 128;\\n        if (xSignifier & 0x80000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000058B90BFBE9DDBAC5E109CCE >> 128;\\n        if (xSignifier & 0x40000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000002C5C85FDF4B15DE6F17EB0D >> 128;\\n        if (xSignifier & 0x20000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000162E42FEFA494F1478FDE05 >> 128;\\n        if (xSignifier & 0x10000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000B17217F7D20CF927C8E94C >> 128;\\n        if (xSignifier & 0x8000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000058B90BFBE8F71CB4E4B33D >> 128;\\n        if (xSignifier & 0x4000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000002C5C85FDF477B662B26945 >> 128;\\n        if (xSignifier & 0x2000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000162E42FEFA3AE53369388C >> 128;\\n        if (xSignifier & 0x1000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000B17217F7D1D351A389D40 >> 128;\\n        if (xSignifier & 0x800000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000058B90BFBE8E8B2D3D4EDE >> 128;\\n        if (xSignifier & 0x400000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000002C5C85FDF4741BEA6E77E >> 128;\\n        if (xSignifier & 0x200000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000162E42FEFA39FE95583C2 >> 128;\\n        if (xSignifier & 0x100000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000B17217F7D1CFB72B45E1 >> 128;\\n        if (xSignifier & 0x80000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000058B90BFBE8E7CC35C3F0 >> 128;\\n        if (xSignifier & 0x40000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000002C5C85FDF473E242EA38 >> 128;\\n        if (xSignifier & 0x20000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000162E42FEFA39F02B772C >> 128;\\n        if (xSignifier & 0x10000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000B17217F7D1CF7D83C1A >> 128;\\n        if (xSignifier & 0x8000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000058B90BFBE8E7BDCBE2E >> 128;\\n        if (xSignifier & 0x4000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000002C5C85FDF473DEA871F >> 128;\\n        if (xSignifier & 0x2000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000162E42FEFA39EF44D91 >> 128;\\n        if (xSignifier & 0x1000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000B17217F7D1CF79E949 >> 128;\\n        if (xSignifier & 0x800000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000058B90BFBE8E7BCE544 >> 128;\\n        if (xSignifier & 0x400000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000002C5C85FDF473DE6ECA >> 128;\\n        if (xSignifier & 0x200000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000162E42FEFA39EF366F >> 128;\\n        if (xSignifier & 0x100000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000B17217F7D1CF79AFA >> 128;\\n        if (xSignifier & 0x80000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000058B90BFBE8E7BCD6D >> 128;\\n        if (xSignifier & 0x40000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000002C5C85FDF473DE6B2 >> 128;\\n        if (xSignifier & 0x20000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000162E42FEFA39EF358 >> 128;\\n        if (xSignifier & 0x10000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000B17217F7D1CF79AB >> 128;\\n        if (xSignifier & 0x8000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000058B90BFBE8E7BCD5 >> 128;\\n        if (xSignifier & 0x4000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000002C5C85FDF473DE6A >> 128;\\n        if (xSignifier & 0x2000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000162E42FEFA39EF34 >> 128;\\n        if (xSignifier & 0x1000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000B17217F7D1CF799 >> 128;\\n        if (xSignifier & 0x800000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000058B90BFBE8E7BCC >> 128;\\n        if (xSignifier & 0x400000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000002C5C85FDF473DE5 >> 128;\\n        if (xSignifier & 0x200000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000162E42FEFA39EF2 >> 128;\\n        if (xSignifier & 0x100000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000B17217F7D1CF78 >> 128;\\n        if (xSignifier & 0x80000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000058B90BFBE8E7BB >> 128;\\n        if (xSignifier & 0x40000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000002C5C85FDF473DD >> 128;\\n        if (xSignifier & 0x20000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000162E42FEFA39EE >> 128;\\n        if (xSignifier & 0x10000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000B17217F7D1CF6 >> 128;\\n        if (xSignifier & 0x8000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000058B90BFBE8E7A >> 128;\\n        if (xSignifier & 0x4000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000002C5C85FDF473C >> 128;\\n        if (xSignifier & 0x2000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000162E42FEFA39D >> 128;\\n        if (xSignifier & 0x1000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000B17217F7D1CE >> 128;\\n        if (xSignifier & 0x800000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000058B90BFBE8E6 >> 128;\\n        if (xSignifier & 0x400000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000002C5C85FDF472 >> 128;\\n        if (xSignifier & 0x200000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000162E42FEFA38 >> 128;\\n        if (xSignifier & 0x100000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000B17217F7D1B >> 128;\\n        if (xSignifier & 0x80000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000058B90BFBE8D >> 128;\\n        if (xSignifier & 0x40000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000002C5C85FDF46 >> 128;\\n        if (xSignifier & 0x20000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000162E42FEFA2 >> 128;\\n        if (xSignifier & 0x10000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000B17217F7D0 >> 128;\\n        if (xSignifier & 0x8000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000058B90BFBE7 >> 128;\\n        if (xSignifier & 0x4000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000002C5C85FDF3 >> 128;\\n        if (xSignifier & 0x2000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000162E42FEF9 >> 128;\\n        if (xSignifier & 0x1000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000B17217F7C >> 128;\\n        if (xSignifier & 0x800000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000058B90BFBD >> 128;\\n        if (xSignifier & 0x400000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000002C5C85FDE >> 128;\\n        if (xSignifier & 0x200000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000162E42FEE >> 128;\\n        if (xSignifier & 0x100000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000B17217F6 >> 128;\\n        if (xSignifier & 0x80000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000058B90BFA >> 128;\\n        if (xSignifier & 0x40000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000002C5C85FC >> 128;\\n        if (xSignifier & 0x20000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000162E42FD >> 128;\\n        if (xSignifier & 0x10000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000B17217E >> 128;\\n        if (xSignifier & 0x8000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000058B90BE >> 128;\\n        if (xSignifier & 0x4000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000002C5C85E >> 128;\\n        if (xSignifier & 0x2000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000162E42E >> 128;\\n        if (xSignifier & 0x1000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000B17216 >> 128;\\n        if (xSignifier & 0x800000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000058B90A >> 128;\\n        if (xSignifier & 0x400000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000002C5C84 >> 128;\\n        if (xSignifier & 0x200000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000162E41 >> 128;\\n        if (xSignifier & 0x100000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000000B1720 >> 128;\\n        if (xSignifier & 0x80000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000058B8F >> 128;\\n        if (xSignifier & 0x40000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000002C5C7 >> 128;\\n        if (xSignifier & 0x20000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000000162E3 >> 128;\\n        if (xSignifier & 0x10000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000000B171 >> 128;\\n        if (xSignifier & 0x8000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000000058B8 >> 128;\\n        if (xSignifier & 0x4000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000002C5B >> 128;\\n        if (xSignifier & 0x2000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000000162D >> 128;\\n        if (xSignifier & 0x1000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000B16 >> 128;\\n        if (xSignifier & 0x800 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000000058A >> 128;\\n        if (xSignifier & 0x400 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000000002C4 >> 128;\\n        if (xSignifier & 0x200 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000161 >> 128;\\n        if (xSignifier & 0x100 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000000000B0 >> 128;\\n        if (xSignifier & 0x80 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000057 >> 128;\\n        if (xSignifier & 0x40 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000000002B >> 128;\\n        if (xSignifier & 0x20 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000015 >> 128;\\n        if (xSignifier & 0x10 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000000000A >> 128;\\n        if (xSignifier & 0x8 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000004 >> 128;\\n        if (xSignifier & 0x4 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000001 >> 128;\\n\\n        if (!xNegative) {\\n          resultSignifier = resultSignifier >> 15 & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n          resultExponent += 0x3FFF;\\n        } else if (resultExponent <= 0x3FFE) {\\n          resultSignifier = resultSignifier >> 15 & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n          resultExponent = 0x3FFF - resultExponent;\\n        } else {\\n          resultSignifier = resultSignifier >> resultExponent - 16367;\\n          resultExponent = 0;\\n        }\\n\\n        return bytes16 (uint128 (resultExponent << 112 | resultSignifier));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate e^x.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function exp (bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      return pow_2 (mul (x, 0x3FFF71547652B82FE1777D0FFDA0D23A));\\n    }\\n  }\\n\\n  /**\\n   * Get index of the most significant non-zero bit in binary representation of\\n   * x.  Reverts if x is zero.\\n   *\\n   * @return index of the most significant non-zero bit in binary representation\\n   *         of x\\n   */\\n  function mostSignificantBit (uint256 x) private pure returns (uint256) {\\n    unchecked {\\n      require (x > 0);\\n\\n      uint256 result = 0;\\n\\n      if (x >= 0x100000000000000000000000000000000) { x >>= 128; result += 128; }\\n      if (x >= 0x10000000000000000) { x >>= 64; result += 64; }\\n      if (x >= 0x100000000) { x >>= 32; result += 32; }\\n      if (x >= 0x10000) { x >>= 16; result += 16; }\\n      if (x >= 0x100) { x >>= 8; result += 8; }\\n      if (x >= 0x10) { x >>= 4; result += 4; }\\n      if (x >= 0x4) { x >>= 2; result += 2; }\\n      if (x >= 0x2) result += 1; // No need to shift x anymore\\n\\n      return result;\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0x9694a9f6fcadd4fa917efa674de42a74b8fbab8d68924f771ea5cc5e1a301434\",\"license\":\"BSD-4-Clause\"},\"contracts/implementation/PoolKeeper.sol\":{\"content\":\"//SPDX-License-Identifier: CC-BY-NC-ND-4.0\\npragma solidity 0.8.7;\\n\\nimport \\\"../interfaces/IPoolKeeper.sol\\\";\\nimport \\\"../interfaces/IOracleWrapper.sol\\\";\\nimport \\\"../interfaces/IPoolFactory.sol\\\";\\nimport \\\"../interfaces/ILeveragedPool.sol\\\";\\nimport \\\"../interfaces/IERC20DecimalsWrapper.sol\\\";\\nimport \\\"../interfaces/IERC20DecimalsWrapper.sol\\\";\\nimport \\\"./PoolSwapLibrary.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/proxy/Clones.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"abdk-libraries-solidity/ABDKMathQuad.sol\\\";\\nimport \\\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol\\\";\\n\\n/// @title The manager contract for multiple markets and the pools in them\\ncontract PoolKeeper is IPoolKeeper, Ownable {\\n    /* Constants */\\n    uint256 public constant BASE_TIP = 5; // 5% base tip\\n    uint256 public constant TIP_DELTA_PER_BLOCK = 5; // 5% increase per block\\n    uint256 public constant BLOCK_TIME = 13; /* in seconds */\\n    uint256 public constant MAX_DECIMALS = 18;\\n\\n    // #### Global variables\\n    /**\\n     * @notice Format: Pool address => last executionPrice\\n     */\\n    mapping(address => int256) public executionPrice;\\n\\n    IPoolFactory public factory;\\n    bytes16 constant fixedPoint = 0x403abc16d674ec800000000000000000; // 1 ether\\n\\n    uint256 public gasPrice = 10 gwei;\\n\\n    // #### Functions\\n    constructor(address _factory) {\\n        require(_factory != address(0), \\\"Factory cannot be 0 address\\\");\\n        factory = IPoolFactory(_factory);\\n    }\\n\\n    /**\\n     * @notice When a pool is created, this function is called by the factory to initiate price trackings\\n     * @param _poolAddress The address of the newly-created pools\\n     */\\n    function newPool(address _poolAddress) external override onlyFactory {\\n        address oracleWrapper = ILeveragedPool(_poolAddress).oracleWrapper();\\n        int256 firstPrice = IOracleWrapper(oracleWrapper).getPrice();\\n        require(firstPrice > 0, \\\"First price is non-positive\\\");\\n        int256 startingPrice = ABDKMathQuad.toInt(ABDKMathQuad.mul(ABDKMathQuad.fromInt(firstPrice), fixedPoint));\\n        emit PoolAdded(_poolAddress, firstPrice);\\n        executionPrice[_poolAddress] = startingPrice;\\n    }\\n\\n    // Keeper network\\n    /**\\n     * @notice Check if upkeep is required\\n     * @param _pool The address of the pool to upkeep\\n     * @return upkeepNeeded Whether or not upkeep is needed for this single pool\\n     */\\n    function checkUpkeepSinglePool(address _pool) public view override returns (bool) {\\n        if (!factory.isValidPool(_pool)) {\\n            return false;\\n        }\\n\\n        // The update interval has passed\\n        return ILeveragedPool(_pool).intervalPassed();\\n    }\\n\\n    /**\\n     * @notice Checks multiple pools if any of them need updating\\n     * @param _pools The array of pools to check\\n     * @return upkeepNeeded Whether or not at least one pool needs upkeeping\\n     */\\n    function checkUpkeepMultiplePools(address[] calldata _pools) external view override returns (bool) {\\n        for (uint256 i = 0; i < _pools.length; i++) {\\n            if (checkUpkeepSinglePool(_pools[i])) {\\n                // One has been found that requires upkeeping\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    /**\\n     * @notice Called by keepers to perform an update on a single pool\\n     * @param _pool The pool code to perform the update for\\n     */\\n    function performUpkeepSinglePool(address _pool) public override {\\n        uint256 startGas = gasleft();\\n\\n        // validate the pool, check that the interval time has passed\\n        if (!checkUpkeepSinglePool(_pool)) {\\n            return;\\n        }\\n        ILeveragedPool pool = ILeveragedPool(_pool);\\n        (int256 latestPrice, bytes memory data, uint256 savedPreviousUpdatedTimestamp, uint256 updateInterval) = pool\\n            .getUpkeepInformation();\\n\\n        // Start a new round\\n        // Get price in WAD format\\n        int256 lastExecutionPrice = executionPrice[_pool];\\n        executionPrice[_pool] = latestPrice;\\n\\n        // This allows us to still batch multiple calls to executePriceChange, even if some are invalid\\n        // Without reverting the entire transaction\\n        try pool.poolUpkeep(lastExecutionPrice, latestPrice) {\\n            // If poolUpkeep is successful, refund the keeper for their gas costs\\n            uint256 gasSpent = startGas - gasleft();\\n\\n            payKeeper(_pool, gasPrice, gasSpent, savedPreviousUpdatedTimestamp, updateInterval);\\n            emit UpkeepSuccessful(_pool, data, lastExecutionPrice, latestPrice);\\n        } catch Error(string memory reason) {\\n            // If poolUpkeep fails for any other reason, emit event\\n            emit PoolUpkeepError(_pool, reason);\\n        }\\n    }\\n\\n    /**\\n     * @notice Called by keepers to perform an update on multiple pools\\n     * @param pools pool codes to perform the update for\\n     */\\n    function performUpkeepMultiplePools(address[] calldata pools) external override {\\n        for (uint256 i = 0; i < pools.length; i++) {\\n            performUpkeepSinglePool(pools[i]);\\n        }\\n    }\\n\\n    /**\\n     * @notice Pay keeper for upkeep\\n     * @param _pool Address of the given pool\\n     * @param _gasPrice Price of a single gas unit (in ETH)\\n     * @param _gasSpent Number of gas units spent\\n     * @param _savedPreviousUpdatedTimestamp Last timestamp when the pool's price execution happened\\n     * @param _updateInterval Pool interval of the given pool\\n     */\\n    function payKeeper(\\n        address _pool,\\n        uint256 _gasPrice,\\n        uint256 _gasSpent,\\n        uint256 _savedPreviousUpdatedTimestamp,\\n        uint256 _updateInterval\\n    ) internal {\\n        uint256 reward = keeperReward(_pool, _gasPrice, _gasSpent, _savedPreviousUpdatedTimestamp, _updateInterval);\\n        if (ILeveragedPool(_pool).payKeeperFromBalances(msg.sender, reward)) {\\n            emit KeeperPaid(_pool, msg.sender, reward);\\n        } else {\\n            // Usually occurs if pool just started and does not have any funds\\n            emit KeeperPaymentError(_pool, msg.sender, reward);\\n        }\\n    }\\n\\n    /**\\n     * @notice Payment keeper receives for performing upkeep on a given pool\\n     * @param _pool Address of the given pool\\n     * @param _gasPrice Price of a single gas unit (in ETH)\\n     * @param _gasSpent Number of gas units spent\\n     * @param _savedPreviousUpdatedTimestamp Last timestamp when the pool's price execution happened\\n     * @param _poolInterval Pool interval of the given pool\\n     * @return Number of settlement tokens to give to the keeper for work performed\\n     */\\n    function keeperReward(\\n        address _pool,\\n        uint256 _gasPrice,\\n        uint256 _gasSpent,\\n        uint256 _savedPreviousUpdatedTimestamp,\\n        uint256 _poolInterval\\n    ) public view returns (uint256) {\\n        // keeper gas cost in wei. WAD formatted\\n        uint256 _keeperGas = keeperGas(_pool, _gasPrice, _gasSpent);\\n\\n        // tip percent in wad units\\n        bytes16 _tipPercent = ABDKMathQuad.fromUInt(keeperTip(_savedPreviousUpdatedTimestamp, _poolInterval));\\n\\n        // amount of settlement tokens to give to the keeper\\n        _tipPercent = ABDKMathQuad.div(_tipPercent, ABDKMathQuad.fromUInt(100));\\n        int256 wadRewardValue = ABDKMathQuad.toInt(\\n            ABDKMathQuad.add(\\n                ABDKMathQuad.fromUInt(_keeperGas),\\n                ABDKMathQuad.div((ABDKMathQuad.mul(ABDKMathQuad.fromUInt(_keeperGas), _tipPercent)), fixedPoint)\\n            )\\n        );\\n        uint256 decimals = IERC20DecimalsWrapper(ILeveragedPool(_pool).quoteToken()).decimals();\\n        uint256 deWadifiedReward = PoolSwapLibrary.fromWad(uint256(wadRewardValue), decimals);\\n        // _keeperGas + _keeperGas * percentTip\\n        return deWadifiedReward;\\n    }\\n\\n    /**\\n     * @notice Compensation a keeper will receive for their gas expenditure\\n     * @param _pool Address of the given pool\\n     * @param _gasPrice Price of a single gas unit (in ETH)\\n     * @param _gasSpent Number of gas units spent\\n     * @return Keeper's gas compensation\\n     */\\n    function keeperGas(\\n        address _pool,\\n        uint256 _gasPrice,\\n        uint256 _gasSpent\\n    ) public view returns (uint256) {\\n        int256 settlementTokenPrice = IOracleWrapper(ILeveragedPool(_pool).settlementEthOracle()).getPrice();\\n\\n        if (settlementTokenPrice <= 0) {\\n            return 0;\\n        } else {\\n            /* safe due to explicit bounds check above */\\n            /* (wei * Settlement / ETH) / fixed point (10^18) = amount in settlement */\\n            bytes16 _weiSpent = ABDKMathQuad.fromUInt(_gasPrice * _gasSpent);\\n            bytes16 _settlementTokenPrice = ABDKMathQuad.fromUInt(uint256(settlementTokenPrice));\\n            return\\n                ABDKMathQuad.toUInt(ABDKMathQuad.div(ABDKMathQuad.mul(_weiSpent, _settlementTokenPrice), fixedPoint));\\n        }\\n    }\\n\\n    /**\\n     * @notice Tip a keeper will receive for successfully updating the specified pool\\n     * @param _savedPreviousUpdatedTimestamp Last timestamp when the pool's price execution happened\\n     * @param _poolInterval Pool interval of the given pool\\n     * @return Percent of the `keeperGas` cost to add to payment, as a percent\\n     */\\n    function keeperTip(uint256 _savedPreviousUpdatedTimestamp, uint256 _poolInterval) public view returns (uint256) {\\n        /* the number of blocks that have elapsed since the given pool's updateInterval passed */\\n        uint256 elapsedBlocksNumerator = (block.timestamp - (_savedPreviousUpdatedTimestamp + _poolInterval));\\n\\n        uint256 keeperTip = BASE_TIP + (TIP_DELTA_PER_BLOCK * elapsedBlocksNumerator) / BLOCK_TIME;\\n\\n        // In case of network outages or otherwise, we want to cap the tip so that the keeper cost isn't unbounded\\n        if (keeperTip > 100) {\\n            return 100;\\n        } else {\\n            return keeperTip;\\n        }\\n    }\\n\\n    function setFactory(address _factory) external override onlyOwner {\\n        factory = IPoolFactory(_factory);\\n    }\\n\\n    /**\\n     * @notice Sets the gas price to be used in compensating keepers for successful upkeep\\n     * @param _price Price (in ETH) per unit gas\\n     * @dev Only owner\\n     */\\n    function setGasPrice(uint256 _price) external onlyOwner {\\n        gasPrice = _price;\\n    }\\n\\n    modifier onlyFactory() {\\n        require(msg.sender == address(factory), \\\"Caller not factory\\\");\\n        _;\\n    }\\n}\\n\",\"keccak256\":\"0x001eec712a08612e288ed286d26764e1bbb229aa57f20c48a8ec30a4fccab515\",\"license\":\"CC-BY-NC-ND-4.0\"},\"contracts/implementation/PoolSwapLibrary.sol\":{\"content\":\"//SPDX-License-Identifier: CC-BY-NC-ND-4.0\\npragma solidity 0.8.7;\\n\\nimport \\\"abdk-libraries-solidity/ABDKMathQuad.sol\\\";\\n\\n/// @title Library for various useful (mostly) mathematical functions\\nlibrary PoolSwapLibrary {\\n    bytes16 public constant one = 0x3fff0000000000000000000000000000;\\n    bytes16 public constant zero = 0x00000000000000000000000000000000;\\n\\n    /* ABDKMathQuad defines this but it's private */\\n    bytes16 private constant NEGATIVE_ZERO = 0x80000000000000000000000000000000;\\n    uint256 public constant MAX_DECIMALS = 18;\\n\\n    uint256 public constant WAD_PRECISION = 10**18;\\n\\n    struct PriceChangeData {\\n        int256 oldPrice;\\n        int256 newPrice;\\n        uint256 longBalance;\\n        uint256 shortBalance;\\n        bytes16 leverageAmount;\\n        bytes16 fee;\\n    }\\n\\n    /**\\n     * @notice Calculates the ratio between two numbers\\n     * @dev Rounds any overflow towards 0. If either parameter is zero, the ratio is 0\\n     * @param _numerator The \\\"parts per\\\" side of the equation. If this is zero, the ratio is zero\\n     * @param _denominator The \\\"per part\\\" side of the equation. If this is zero, the ratio is zero\\n     * @return the ratio, as an ABDKMathQuad number (IEEE 754 quadruple precision floating point)\\n     */\\n    function getRatio(uint256 _numerator, uint256 _denominator) public pure returns (bytes16) {\\n        // Catch the divide by zero error.\\n        if (_denominator == 0) {\\n            return 0;\\n        }\\n        return ABDKMathQuad.div(ABDKMathQuad.fromUInt(_numerator), ABDKMathQuad.fromUInt(_denominator));\\n    }\\n\\n    /**\\n     * @notice Gets the short and long balances after the keeper rewards have been paid out\\n     *         Keeper rewards are paid proportionally to the short and long pool\\n     * @dev Assumes shortBalance + longBalance >= reward\\n     * @param reward Amount of keeper reward\\n     * @param shortBalance Short balance of the pool\\n     * @param longBalance Long balance of the pool\\n     * @return shortBalanceAfterFees Short balance of the pool after the keeper reward has been paid\\n     * @return longBalanceAfterFees Long balance of the pool after the keeper reward has been paid\\n     */\\n    function getBalancesAfterFees(\\n        uint256 reward,\\n        uint256 shortBalance,\\n        uint256 longBalance\\n    ) external pure returns (uint256, uint256) {\\n        bytes16 ratioShort = getRatio(shortBalance, shortBalance + longBalance);\\n\\n        uint256 shortFees = convertDecimalToUInt(multiplyDecimalByUInt(ratioShort, reward));\\n\\n        uint256 shortBalanceAfterFees = shortBalance - shortFees;\\n        uint256 longBalanceAfterFees = longBalance - (reward - shortFees);\\n\\n        // Return shortBalance and longBalance after rewards are paid out\\n        return (shortBalanceAfterFees, longBalanceAfterFees);\\n    }\\n\\n    /**\\n     * @notice Compares two decimal numbers\\n     * @param x The first number to compare\\n     * @param y The second number to compare\\n     * @return -1 if x < y, 0 if x = y, or 1 if x > y\\n     */\\n    function compareDecimals(bytes16 x, bytes16 y) public pure returns (int8) {\\n        return ABDKMathQuad.cmp(x, y);\\n    }\\n\\n    /**\\n     * @notice Converts an integer value to a compatible decimal value\\n     * @param amount The amount to convert\\n     * @return The amount as a IEEE754 quadruple precision number\\n     */\\n    function convertUIntToDecimal(uint256 amount) external pure returns (bytes16) {\\n        return ABDKMathQuad.fromUInt(amount);\\n    }\\n\\n    /**\\n     * @notice Converts a raw decimal value to a more readable uint256 value\\n     * @param ratio The value to convert\\n     * @return The converted value\\n     */\\n    function convertDecimalToUInt(bytes16 ratio) public pure returns (uint256) {\\n        return ABDKMathQuad.toUInt(ratio);\\n    }\\n\\n    /**\\n     * @notice Multiplies a decimal and an unsigned integer\\n     * @param a The first term\\n     * @param b The second term\\n     * @return The product of a*b as a decimal\\n     */\\n    function multiplyDecimalByUInt(bytes16 a, uint256 b) public pure returns (bytes16) {\\n        return ABDKMathQuad.mul(a, ABDKMathQuad.fromUInt(b));\\n    }\\n\\n    /**\\n     * @notice Divides two integers\\n     * @param a The dividend\\n     * @param b The divisor\\n     * @return The quotient\\n     */\\n    function divInt(int256 a, int256 b) public pure returns (bytes16) {\\n        return ABDKMathQuad.div(ABDKMathQuad.fromInt(a), ABDKMathQuad.fromInt(b));\\n    }\\n\\n    /**\\n     * @notice Calculates the loss multiplier to apply to the losing pool. Includes the power leverage\\n     * @param ratio The ratio of new price to old price\\n     * @param direction The direction of the change. -1 if it's decreased, 0 if it hasn't changed, and 1 if it's increased\\n     * @param leverage The amount of leverage to apply\\n     * @return The multiplier\\n     */\\n    function getLossMultiplier(\\n        bytes16 ratio,\\n        int8 direction,\\n        bytes16 leverage\\n    ) public pure returns (bytes16) {\\n        // If decreased:  2 ^ (leverage * log2[(1 * new/old) + [(0 * 1) / new/old]])\\n        //              = 2 ^ (leverage * log2[(new/old)])\\n        // If increased:  2 ^ (leverage * log2[(0 * new/old) + [(1 * 1) / new/old]])\\n        //              = 2 ^ (leverage * log2([1 / new/old]))\\n        //              = 2 ^ (leverage * log2([old/new]))\\n        return\\n            ABDKMathQuad.pow_2(\\n                ABDKMathQuad.mul(leverage, ABDKMathQuad.log_2(direction < 0 ? ratio : ABDKMathQuad.div(one, ratio)))\\n            );\\n    }\\n\\n    /**\\n     * @notice Calculates the amount to take from the losing pool\\n     * @param lossMultiplier The multiplier to use\\n     * @param balance The balance of the losing pool\\n     */\\n    function getLossAmount(bytes16 lossMultiplier, uint256 balance) public pure returns (uint256) {\\n        return\\n            ABDKMathQuad.toUInt(\\n                ABDKMathQuad.mul(ABDKMathQuad.sub(one, lossMultiplier), ABDKMathQuad.fromUInt(balance))\\n            );\\n    }\\n\\n    /**\\n     * @notice Calculates the effect of a price change. This involves calculating how many funds to transfer from the losing pool to the other.\\n     * @dev This function should be called by the LeveragedPool.\\n     * @param priceChange The struct containing necessary data to calculate price change\\n     */\\n    function calculatePriceChange(PriceChangeData memory priceChange)\\n        external\\n        pure\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        uint256 shortBalance = priceChange.shortBalance;\\n        uint256 longBalance = priceChange.longBalance;\\n        bytes16 leverageAmount = priceChange.leverageAmount;\\n        int256 oldPrice = priceChange.oldPrice;\\n        int256 newPrice = priceChange.newPrice;\\n        bytes16 fee = priceChange.fee;\\n\\n        // Calculate fees from long and short sides\\n        uint256 longFeeAmount = convertDecimalToUInt(multiplyDecimalByUInt(fee, longBalance)) /\\n            PoolSwapLibrary.WAD_PRECISION;\\n        uint256 shortFeeAmount = convertDecimalToUInt(multiplyDecimalByUInt(fee, shortBalance)) /\\n            PoolSwapLibrary.WAD_PRECISION;\\n\\n        shortBalance = shortBalance - shortFeeAmount;\\n        longBalance = longBalance - longFeeAmount;\\n        uint256 totalFeeAmount = shortFeeAmount + longFeeAmount;\\n\\n        // Use the ratio to determine if the price increased or decreased and therefore which direction\\n        // the funds should be transferred towards.\\n\\n        bytes16 ratio = divInt(newPrice, oldPrice);\\n        int8 direction = compareDecimals(ratio, PoolSwapLibrary.one);\\n        // Take into account the leverage\\n        bytes16 lossMultiplier = getLossMultiplier(ratio, direction, leverageAmount);\\n\\n        if (direction >= 0 && shortBalance > 0) {\\n            // Move funds from short to long pair\\n            uint256 lossAmount = getLossAmount(lossMultiplier, shortBalance);\\n            shortBalance = shortBalance - lossAmount;\\n            longBalance = longBalance + lossAmount;\\n        } else if (direction < 0 && longBalance > 0) {\\n            // Move funds from long to short pair\\n            uint256 lossAmount = getLossAmount(lossMultiplier, longBalance);\\n            shortBalance = shortBalance + lossAmount;\\n            longBalance = longBalance - lossAmount;\\n        }\\n\\n        return (longBalance, shortBalance, totalFeeAmount);\\n    }\\n\\n    /**\\n     * @notice Returns true if the given timestamp is BEFORE the frontRunningInterval starts,\\n     *         which is allowed for uncommitment.\\n     * @dev If you try to uncommit AFTER the frontRunningInterval, it should revert.\\n     * @param subjectTime The timestamp for which you want to calculate if it was beforeFrontRunningInterval\\n     * @param lastPriceTimestamp The timestamp of the last price update\\n     * @param updateInterval The interval between price updates\\n     * @param frontRunningInterval The window of time before a price udpate users can not uncommit or have their commit executed from\\n     */\\n    function isBeforeFrontRunningInterval(\\n        uint256 subjectTime,\\n        uint256 lastPriceTimestamp,\\n        uint256 updateInterval,\\n        uint256 frontRunningInterval\\n    ) external pure returns (bool) {\\n        return lastPriceTimestamp + updateInterval - frontRunningInterval > subjectTime;\\n    }\\n\\n    /**\\n     * @notice Gets the number of settlement tokens to be withdrawn based on a pool token burn amount\\n     * @dev Calculates as `balance * amountIn / (tokenSupply + shadowBalance)\\n     * @param tokenSupply Total supply of pool tokens\\n     * @param amountIn Commitment amount of collateral tokens going into the pool\\n     * @param balance Balance of the pool (no. of underlying collateral tokens in pool)\\n     * @param shadowBalance Balance the shadow pool at time of mint\\n     * @return Number of settlement tokens to be withdrawn on a burn\\n     */\\n    function getWithdrawAmountOnBurn(\\n        uint256 tokenSupply,\\n        uint256 amountIn,\\n        uint256 balance,\\n        uint256 shadowBalance\\n    ) external pure returns (uint256) {\\n        require(amountIn > 0, \\\"Invalid amount\\\");\\n\\n        // Catch the divide by zero error.\\n        if (balance == 0 || tokenSupply + shadowBalance == 0) {\\n            return amountIn;\\n        }\\n        bytes16 numerator = ABDKMathQuad.mul(ABDKMathQuad.fromUInt(balance), ABDKMathQuad.fromUInt(amountIn));\\n        return ABDKMathQuad.toUInt(ABDKMathQuad.div(numerator, ABDKMathQuad.fromUInt(tokenSupply + shadowBalance)));\\n    }\\n\\n    /**\\n     * @notice Gets the number of pool tokens to be minted based on existing tokens\\n     * @dev Calculated as (tokenSupply + shadowBalance) * amountIn / balance\\n     * @param tokenSupply Total supply of pool tokens\\n     * @param amountIn Commitment amount of collateral tokens going into the pool\\n     * @param balance Balance of the pool (no. of underlying collateral tokens in pool)\\n     * @param shadowBalance Balance the shadow pool at time of mint\\n     * @return Number of pool tokens to be minted\\n     */\\n    function getMintAmount(\\n        uint256 tokenSupply,\\n        uint256 amountIn,\\n        uint256 balance,\\n        uint256 shadowBalance\\n    ) external pure returns (uint256) {\\n        require(amountIn > 0, \\\"Invalid amount\\\");\\n\\n        // Catch the divide by zero error.\\n        if (balance == 0 || tokenSupply + shadowBalance == 0) {\\n            return amountIn;\\n        }\\n\\n        bytes16 numerator = ABDKMathQuad.mul(\\n            ABDKMathQuad.fromUInt(tokenSupply + shadowBalance),\\n            ABDKMathQuad.fromUInt(amountIn)\\n        );\\n        return ABDKMathQuad.toUInt(ABDKMathQuad.div(numerator, ABDKMathQuad.fromUInt(balance)));\\n    }\\n\\n    /**\\n     * @notice Converts from a WAD to normal value\\n     * @return Converted non-WAD value\\n     */\\n    function fromWad(uint256 _wadValue, uint256 _decimals) external pure returns (uint256) {\\n        uint256 scaler = 10**(MAX_DECIMALS - _decimals);\\n        return _wadValue / scaler;\\n    }\\n}\\n\",\"keccak256\":\"0xdb371bc69356883d7f54cdf065df2c999d71ebeab16ecd5d19276a9a7be1de85\",\"license\":\"CC-BY-NC-ND-4.0\"},\"contracts/interfaces/IERC20DecimalsWrapper.sol\":{\"content\":\"//SPDX-License-Identifier: CC-BY-NC-ND-4.0\\npragma solidity 0.8.7;\\n\\n/// @title The decimals interface for extending the ERC20 interface\\ninterface IERC20DecimalsWrapper {\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x5b719acf06c256045637247185ac0a7f1ba2346ab14cec805a5b7ff2d0f1d83d\",\"license\":\"CC-BY-NC-ND-4.0\"},\"contracts/interfaces/ILeveragedPool.sol\":{\"content\":\"//SPDX-License-Identifier: CC-BY-NC-ND-4.0\\npragma solidity 0.8.7;\\n\\n/// @title The pool controller contract interface\\ninterface ILeveragedPool {\\n    // Initialisation parameters for new market\\n    struct Initialization {\\n        address _owner; // Owner of the contract\\n        address _keeper; // The address of the PoolKeeper contract\\n        address _oracleWrapper; // The oracle wrapper for the derivative price feed\\n        address _settlementEthOracle; // The oracle wrapper for the SettlementToken/ETH price feed\\n        address _longToken; // Address of the long pool token\\n        address _shortToken; // Address of the short pool token\\n        address _poolCommitter; // Address of the PoolCommitter contract\\n        string _poolName; // The pool identification name\\n        uint32 _frontRunningInterval; // The minimum number of seconds that must elapse before a commit is forced to wait until the next interval\\n        uint32 _updateInterval; // The minimum number of seconds that must elapse before a commit can be executed\\n        uint256 _fee; // The fund movement fee. This amount is extracted from the deposited asset with every update and sent to the fee address\\n        uint16 _leverageAmount; // The amount of exposure to price movements for the pool\\n        address _feeAddress; // The address that the fund movement fee is sent to\\n        address _quoteToken; //  The digital asset that the pool accepts. Must have a decimals() function\\n    }\\n\\n    // #### Events\\n    /**\\n     * @notice Creates a notification when the pool is setup and ready for use\\n     * @param longToken The address of the LONG pair token\\n     * @param shortToken The address of the SHORT pair token\\n     * @param quoteToken The address of the digital asset that the pool accepts\\n     * @param poolName The pool code for the pool\\n     */\\n    event PoolInitialized(address indexed longToken, address indexed shortToken, address quoteToken, string poolName);\\n\\n    /**\\n     * @notice Creates a notification when the pool is rebalanced\\n     * @param shortBalanceChange The change of funds in the short side\\n     * @param longBalanceChange The change of funds in the long side\\n     */\\n    event PoolRebalance(int256 shortBalanceChange, int256 longBalanceChange);\\n\\n    /**\\n     * @notice Creates a notification when the pool's price execution fails\\n     * @param startPrice Price prior to price change execution\\n     * @param endPrice Price during price change execution\\n     */\\n    event PriceChangeError(int256 indexed startPrice, int256 indexed endPrice);\\n\\n    /**\\n     * @notice Represents change in fee receiver's address\\n     * @param oldAddress Previous address\\n     * @param newAddress Address after change\\n     */\\n    event FeeAddressUpdated(address indexed oldAddress, address indexed newAddress);\\n\\n    /**\\n     * @notice Represents change in keeper's address\\n     * @param oldAddress Previous address\\n     * @param newAddress Address after change\\n     */\\n    event KeeperAddressChanged(address indexed oldAddress, address indexed newAddress);\\n\\n    /**\\n     * @notice Represents proposed change in governance address\\n     * @param newAddress Proposed address\\n     */\\n    event ProvisionalGovernanceChanged(address indexed newAddress);\\n\\n    /**\\n     * @notice Represents change in governance address\\n     * @param oldAddress Previous address\\n     * @param newAddress Address after change\\n     */\\n    event GovernanceAddressChanged(address indexed oldAddress, address indexed newAddress);\\n\\n    function leverageAmount() external view returns (bytes16);\\n\\n    function poolCommitter() external view returns (address);\\n\\n    function quoteToken() external view returns (address);\\n\\n    function oracleWrapper() external view returns (address);\\n\\n    function lastPriceTimestamp() external view returns (uint256);\\n\\n    function poolName() external view returns (string calldata);\\n\\n    function updateInterval() external view returns (uint32);\\n\\n    function shortBalance() external view returns (uint256);\\n\\n    function longBalance() external view returns (uint256);\\n\\n    function frontRunningInterval() external view returns (uint32);\\n\\n    function poolTokens() external view returns (address[2] memory);\\n\\n    function settlementEthOracle() external view returns (address);\\n\\n    // #### Functions\\n    /**\\n     * @notice Configures the pool on deployment. The pools are EIP 1167 clones.\\n     * @dev This should only be able to be run once to prevent abuse of the pool. Use of Openzeppelin Initializable or similar is recommended\\n     * @param initialization The struct Initialization containing initialization data\\n     */\\n    function initialize(Initialization calldata initialization) external;\\n\\n    function poolUpkeep(int256 _oldPrice, int256 _newPrice) external;\\n\\n    function quoteTokenTransferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external;\\n\\n    function payKeeperFromBalances(address to, uint256 amount) external returns (bool);\\n\\n    function quoteTokenTransfer(address to, uint256 amount) external;\\n\\n    function setNewPoolBalances(uint256 _longBalance, uint256 _shortBalance) external;\\n\\n    /**\\n     * @return _latestPrice The oracle price\\n     * @return _data The oracleWrapper's metadata. Implementations can choose what data to return here\\n     * @return _lastPriceTimestamp The timestamp of the last upkeep\\n     * @return _updateInterval The update frequency for this pool\\n     * @dev To save gas so PoolKeeper does not have to make three external calls\\n     */\\n    function getUpkeepInformation()\\n        external\\n        view\\n        returns (\\n            int256 _latestPrice,\\n            bytes memory _data,\\n            uint256 _lastPriceTimestamp,\\n            uint256 _updateInterval\\n        );\\n\\n    function getOraclePrice() external view returns (int256);\\n\\n    function intervalPassed() external view returns (bool);\\n\\n    function balances() external view returns (uint256 _shortBalance, uint256 _longBalance);\\n\\n    function setKeeper(address _keeper) external;\\n\\n    function transferGovernance(address _governance) external;\\n\\n    function claimGovernance() external;\\n\\n    function updateFeeAddress(address account) external;\\n\\n    function mintTokens(\\n        uint256 token,\\n        uint256 amount,\\n        address burner\\n    ) external;\\n\\n    function burnTokens(\\n        uint256 token,\\n        uint256 amount,\\n        address burner\\n    ) external;\\n}\\n\",\"keccak256\":\"0x8aa209784b4f3199fd603406dd75777d1df639dde6fdb6ec2d6930b363457f7c\",\"license\":\"CC-BY-NC-ND-4.0\"},\"contracts/interfaces/IOracleWrapper.sol\":{\"content\":\"//SPDX-License-Identifier: CC-BY-NC-ND-4.0\\npragma solidity 0.8.7;\\n\\n/// @title The oracle wrapper contract interface\\ninterface IOracleWrapper {\\n    function oracle() external view returns (address);\\n\\n    // #### Functions\\n    /**\\n     * @notice Sets the oracle for a given market\\n     * @dev Should be secured, ideally only allowing the PoolKeeper to access\\n     * @param _oracle The oracle to set for the market\\n     */\\n    function setOracle(address _oracle) external;\\n\\n    /**\\n     * @notice Returns the current price for the asset in question\\n     * @return The latest price\\n     */\\n    function getPrice() external view returns (int256);\\n\\n    /**\\n     * @return _price The latest round data price\\n     * @return _data The metadata. Implementations can choose what data to return here\\n     */\\n    function getPriceAndMetadata() external view returns (int256 _price, bytes memory _data);\\n\\n    /**\\n     * @notice Converts from a WAD to normal value\\n     * @return Converted non-WAD value\\n     */\\n    function fromWad(int256 wad) external view returns (int256);\\n}\\n\",\"keccak256\":\"0x884ce9d1b49a7372a50ac2350ea6c1529cd7a9da8e5b1c67ecee7d032a2166f9\",\"license\":\"CC-BY-NC-ND-4.0\"},\"contracts/interfaces/IPoolFactory.sol\":{\"content\":\"//SPDX-License-Identifier: CC-BY-NC-ND-4.0\\npragma solidity 0.8.7;\\n\\n/// @title The contract factory for the keeper and pool contracts. Utilizes minimal clones to keep gas costs low\\ninterface IPoolFactory {\\n    struct PoolDeployment {\\n        string poolName; // The name to identify a pool by\\n        uint32 frontRunningInterval; // The minimum number of seconds that must elapse before a commit can be executed. Must be smaller than or equal to the update interval to prevent deadlock\\n        uint32 updateInterval; // The minimum number of seconds that must elapse before a price change\\n        uint16 leverageAmount; // The amount of exposure to price movements for the pool\\n        address quoteToken; // The digital asset that the pool accepts\\n        address oracleWrapper; // The IOracleWrapper implementation for fetching price feed data\\n        address settlementEthOracle; // The oracle to fetch the price of Ether in terms of the settlement token\\n        uint128 minimumCommitSize; // The minimum amount (in settlement tokens) that a user can commit in a single commitment\\n        uint128 maximumCommitQueueLength; // The maximum number of commitments that can be made for a given updateInterval\\n    }\\n\\n    // #### Events\\n    /**\\n     * @notice Creates a notification when a pool is deployed\\n     * @param pool Address of the new pool\\n     * @param ticker Ticker of the neew pool\\n     */\\n    event DeployPool(address indexed pool, string ticker);\\n\\n    /**\\n     * @notice Creates a notification when the pool keeper changes\\n     * @param _poolKeeper Address of the new pool keeper\\n     */\\n    event PoolKeeperChanged(address _poolKeeper);\\n\\n    /**\\n     * @notice Creates a notification when the pool committer deployer for the factory changes\\n     * @param _poolCommitterDeployer Address of the new pool committer deployer\\n     */\\n    event PoolCommitterDeployerChanged(address _poolCommitterDeployer);\\n\\n    // #### Getters for Globals\\n    function pools(uint256 id) external view returns (address);\\n\\n    function numPools() external view returns (uint256);\\n\\n    function isValidPool(address _pool) external view returns (bool);\\n\\n    // #### Functions\\n    function deployPool(PoolDeployment calldata deploymentParameters) external returns (address);\\n\\n    function getOwner() external returns (address);\\n\\n    function setPoolKeeper(address _poolKeeper) external;\\n\\n    function setMaxLeverage(uint16 newMaxLeverage) external;\\n\\n    function setFeeReceiver(address _feeReceiver) external;\\n\\n    function setFee(uint256 _fee) external;\\n\\n    function setPoolCommitterDeployer(address _poolCommitterDeployer) external;\\n}\\n\",\"keccak256\":\"0xfa45389b359358b86d16613332e23f778b01e777937aa299071ddf4f7bf17038\",\"license\":\"CC-BY-NC-ND-4.0\"},\"contracts/interfaces/IPoolKeeper.sol\":{\"content\":\"//SPDX-License-Identifier: CC-BY-NC-ND-4.0\\npragma solidity 0.8.7;\\n\\n/// @title The manager contract interface for multiple markets and the pools in them\\ninterface IPoolKeeper {\\n    // #### Events\\n    /**\\n     * @notice Creates a notification when a pool is created\\n     * @param poolAddress The pool address of the newly created pool\\n     * @param firstPrice The price of the market oracle when the pool was created\\n     */\\n    event PoolAdded(address indexed poolAddress, int256 indexed firstPrice);\\n\\n    /**\\n     * @notice Creates a notification when a call to LeveragedPool:poolUpkeep is successful\\n     * @param pool The pool address being upkept\\n     * @param data Extra data about the price fetch. This could be roundID in the case of Chainlink Oracles\\n     * @param startPrice The previous price of the pool\\n     * @param endPrice The new price of the pool\\n     */\\n    event UpkeepSuccessful(address indexed pool, bytes data, int256 indexed startPrice, int256 indexed endPrice);\\n\\n    /**\\n     * @notice Creates a notification when a keeper is paid for doing upkeep for a pool\\n     * @param _pool Address of pool being upkept\\n     * @param keeper Keeper to be rewarded for upkeeping\\n     * @param reward Keeper's reward (in settlement tokens)\\n     */\\n    event KeeperPaid(address indexed _pool, address indexed keeper, uint256 reward);\\n\\n    /**\\n     * @notice Creates a notification when a keeper's payment for upkeeping a pool failed\\n     * @param _pool Address of pool being upkept\\n     * @param keeper Keeper to be rewarded for upkeeping\\n     * @param expectedReward Keeper's expected reward (in settlement tokens); not actually transferred\\n     */\\n    event KeeperPaymentError(address indexed _pool, address indexed keeper, uint256 expectedReward);\\n\\n    /**\\n     * @notice Creates a notification of a failed pool update\\n     * @param pool The pool that failed to update\\n     * @param reason The reason for the error\\n     */\\n    event PoolUpkeepError(address indexed pool, string reason);\\n\\n    // #### Functions\\n    function newPool(address _poolAddress) external;\\n\\n    function setFactory(address _factory) external;\\n\\n    function checkUpkeepSinglePool(address pool) external view returns (bool);\\n\\n    function checkUpkeepMultiplePools(address[] calldata pools) external view returns (bool);\\n\\n    function performUpkeepSinglePool(address pool) external;\\n\\n    function performUpkeepMultiplePools(address[] calldata pools) external;\\n}\\n\",\"keccak256\":\"0xfb5a863b843848563313bc782a188419089790f737cd677b7eb8ec43b44d09bc\",\"license\":\"CC-BY-NC-ND-4.0\"}},\"version\":1}",
    "bytecode": "0x60806040526402540be4006003553480156200001a57600080fd5b50604051620020d5380380620020d58339810160408190526200003d9162000119565b6200004833620000c9565b6001600160a01b038116620000a35760405162461bcd60e51b815260206004820152601b60248201527f466163746f72792063616e6e6f74206265203020616464726573730000000000604482015260640160405180910390fd5b600280546001600160a01b0319166001600160a01b03929092169190911790556200014b565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6000602082840312156200012c57600080fd5b81516001600160a01b03811681146200014457600080fd5b9392505050565b611f7a806200015b6000396000f3fe608060405234801561001057600080fd5b506004361061012c5760003560e01c8063b3fbb7c4116100ad578063ce1dcdfc11610071578063ce1dcdfc1461025e578063f2fde38b14610271578063f930191014610284578063fcab9e981461028c578063fe173b971461029f57600080fd5b8063b3fbb7c4146101f2578063b9c6536514610205578063bf1fe42014610218578063c45a01551461022b578063cdd9e1371461023e57600080fd5b80638da5cb5b116100f45780638da5cb5b1461019f57806391a60782146101c45780639f9a3d95146101d7578063a40d6b80146101df578063aea8acb1146101d757600080fd5b80630417cf8e14610131578063225739b11461014c5780633c5c7fb31461016f5780635bb4780814610184578063715018a614610197575b600080fd5b610139601281565b6040519081526020015b60405180910390f35b61015f61015a366004611a4c565b6102a8565b6040519015158152602001610143565b61018261017d366004611a4c565b6103a9565b005b610182610192366004611a4c565b6105b7565b610182610603565b6000546001600160a01b03165b6040516001600160a01b039091168152602001610143565b6101826101d2366004611a4c565b610639565b610139600581565b6101396101ed366004611a86565b61083b565b610139610200366004611abb565b610988565b610139610213366004611c7a565b610b72565b610182610226366004611c61565b610bce565b6002546101ac906001600160a01b031681565b61013961024c366004611a4c565b60016020526000908152604090205481565b61015f61026c366004611aff565b610bfd565b61018261027f366004611a4c565b610c5e565b610139600d81565b61018261029a366004611aff565b610cf9565b61013960035481565b600254604051635ab78ee160e01b81526001600160a01b0383811660048301526000921690635ab78ee19060240160206040518083038186803b1580156102ee57600080fd5b505afa158015610302573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103269190611b74565b61033257506000919050565b816001600160a01b0316637bbf10336040518163ffffffff1660e01b815260040160206040518083038186803b15801561036b57600080fd5b505afa15801561037f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103a39190611b74565b92915050565b6002546001600160a01b031633146103fd5760405162461bcd60e51b815260206004820152601260248201527143616c6c6572206e6f7420666163746f727960701b60448201526064015b60405180910390fd5b6000816001600160a01b031663b9ed8abf6040518163ffffffff1660e01b815260040160206040518083038186803b15801561043857600080fd5b505afa15801561044c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104709190611a69565b90506000816001600160a01b03166398d5fdca6040518163ffffffff1660e01b815260040160206040518083038186803b1580156104ad57600080fd5b505afa1580156104c1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104e59190611b96565b9050600081136105375760405162461bcd60e51b815260206004820152601b60248201527f4669727374207072696365206973206e6f6e2d706f736974697665000000000060448201526064016103f4565b600061055d61055861054884610d45565b668075782dace9d960c71b610dd3565b611050565b905081846001600160a01b03167fe950cb32f7a787627d713d7365623fef2d762ef8fcf813b865a04350852deb9b60405160405180910390a36001600160a01b039093166000908152600160205260409020929092555050565b6000546001600160a01b031633146105e15760405162461bcd60e51b81526004016103f490611cfe565b600280546001600160a01b0319166001600160a01b0392909216919091179055565b6000546001600160a01b0316331461062d5760405162461bcd60e51b81526004016103f490611cfe565b61063760006110f7565b565b60005a9050610647826102a8565b61064f575050565b6000829050600080600080846001600160a01b03166304883c276040518163ffffffff1660e01b815260040160006040518083038186803b15801561069357600080fd5b505afa1580156106a7573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526106cf9190810190611baf565b6001600160a01b038b81166000908152600160205260409081902080549087905590516303d8ce9d60e61b81526004810182905260248101879052959950939750919550935090919087169063f633a74090604401600060405180830381600087803b15801561073e57600080fd5b505af192505050801561074f575060015b6107ce5761075b611e89565b806308c379a014156107c25750610770611ea5565b8061077b57506107c4565b886001600160a01b03167f8a47468bf96478429d382ed6385d9c77fba8b89540cd88199b1b51d5723b11fa826040516107b49190611ceb565b60405180910390a250610831565b505b3d6000803e3d6000fd5b60005a6107db9089611d8c565b90506107ec89600354838787611147565b85828a6001600160a01b03167f0aa8d2838ad6d4e2a5d7ca0826dfdbc36d922adf8fe5c6d25aee2724b07de074886040516108279190611ceb565b60405180910390a4505b5050505050505050565b600080846001600160a01b0316638226f3966040518163ffffffff1660e01b815260040160206040518083038186803b15801561087757600080fd5b505afa15801561088b573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108af9190611a69565b6001600160a01b03166398d5fdca6040518163ffffffff1660e01b815260040160206040518083038186803b1580156108e757600080fd5b505afa1580156108fb573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061091f9190611b96565b905060008113610933576000915050610981565b60006109476109428587611d6d565b61126c565b905060006109548361126c565b905061097b6109766109668484610dd3565b668075782dace9d960c71b6112d0565b611566565b93505050505b9392505050565b60008061099687878761083b565b905060006109a76109428686610b72565b90506109bc816109b7606461126c565b6112d0565b905060006109e96105586109cf8561126c565b6109e46109666109de8861126c565b87610dd3565b6115e9565b90506000896001600160a01b031663217a4b706040518163ffffffff1660e01b815260040160206040518083038186803b158015610a2657600080fd5b505afa158015610a3a573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a5e9190611a69565b6001600160a01b031663313ce5676040518163ffffffff1660e01b815260040160206040518083038186803b158015610a9657600080fd5b505afa158015610aaa573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ace9190611c9c565b60405163bf36f0e960e01b81526004810184905260ff9190911660248201819052915060009073C793b1Bc41A5Ae49571d01e7A99731Ea3cb1Dd039063bf36f0e99060440160206040518083038186803b158015610b2b57600080fd5b505af4158015610b3f573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b639190611b96565b9b9a5050505050505050505050565b600080610b7f8385611d33565b610b899042611d8c565b90506000600d610b9a836005611d6d565b610ba49190611d4b565b610baf906005611d33565b90506064811115610bc5576064925050506103a3565b91506103a39050565b6000546001600160a01b03163314610bf85760405162461bcd60e51b81526004016103f490611cfe565b600355565b6000805b82811015610c5457610c33848483818110610c1e57610c1e611e5d565b905060200201602081019061015a9190611a4c565b15610c425760019150506103a3565b80610c4c81611e00565b915050610c01565b5060009392505050565b6000546001600160a01b03163314610c885760405162461bcd60e51b81526004016103f490611cfe565b6001600160a01b038116610ced5760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201526564647265737360d01b60648201526084016103f4565b610cf6816110f7565b50565b60005b81811015610d4057610d2e838383818110610d1957610d19611e5d565b90506020020160208101906101d29190611a4c565b80610d3881611e00565b915050610cfc565b505050565b600081610d5457506000919050565b6000808313610d665782600003610d68565b825b90506000610d75826119a9565b90506070811015610d8e578060700382901b9150610da1565b6070811115610da1576070810382901c91505b6001600160701b03909116613fff820160701b17906000841215610dc9576001607f1b821791505b5060801b92915050565b6000617fff60f084811c8216919084901c811690821415610e835780617fff1415610e51576001600160801b03198581169085161415610e1e57505050600160ff1b811682186103a3565b600160ff1b6001600160801b0319868618161415610e41575050508181176103a3565b5061ffff60ef1b91506103a39050565b600160801b600160ff1b038416610e72575061ffff60ef1b91506103a39050565b505050600160ff1b811682186103a3565b80617fff1415610ebf57600160801b600160ff1b038516610eae575061ffff60ef1b91506103a39050565b505050600160ff1b821681186103a3565b6001600160701b03608086901c1682610edb5760019250610ee2565b600160701b175b6001600160701b03608086901c1682610efe5760019250610f05565b600160701b175b9081029081610f3357600160ff1b87871816610f22576000610f28565b600160ff1b5b9450505050506103a3565b928201926000600160e11b831015610f6657600160e01b831015610f5f57610f5a836119a9565b610f69565b60e0610f69565b60e15b90506140708186011015610f84576000945060009250611021565b6140e08186011015610fc757614070851015610fa957846140700383901c9250610fbe565b614070851115610fbe57614070850383901b92505b60009450611021565b61c0dd8186011115610fe157617fff945060009250611021565b6070811115610ff8576070810383901c925061100b565b607081101561100b578060700383901b92505b6001600160701b03831692506140df8186010394505b82607086901b888a186001607f1b60801b1660801c6001600160801b0316171760801b955050505050506103a3565b6000617fff60f083901c166140fe81111561106a57600080fd5b613fff81101561107d5750600092915050565b600160701b6001600160701b03608085901c161761406f8210156110a75761406f8290031c6110b9565b61406f8211156110b95761406e1982011b5b6001607f1b608085901c106110e357600160ff1b8111156110d957600080fd5b6000039392505050565b6001600160ff1b0381111561098157600080fd5b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b60006111568686868686610988565b604051636dc2b27160e01b8152336004820152602481018290529091506001600160a01b03871690636dc2b27190604401602060405180830381600087803b1580156111a157600080fd5b505af11580156111b5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111d99190611b74565b156112235760405181815233906001600160a01b038816907ff03012dd4aab142682aa01439f94e975e2ec77ef558352323bc05f382f74b0829060200160405180910390a3611264565b60405181815233906001600160a01b038816907f08b35d4c86707ba44cdcc5efaa79b8a307e6c7f789f1eb86ca1ff1e9bde056979060200160405180910390a35b505050505050565b60008161127b57506000919050565b816000611287826119a9565b905060708110156112a0578060700382901b91506112b3565b60708111156112b3576070810382901c91505b613fff0160701b6001600160701b03919091161760801b92915050565b6000617fff60f084811c8216919084901c8116908214156113055780617fff1415610e72575061ffff60ef1b91506103a39050565b80617fff1415611349576dffffffffffffffffffffffffffff60801b841615611338575061ffff60ef1b91506103a39050565b505050808218600160ff1b166103a3565b600160801b600160ff1b03841661139357600160801b600160ff1b03851661137b575061ffff60ef1b91506103a39050565b505050808218600160ff1b16617fff60f01b176103a3565b6001600160701b03608085901c16816113af57600191506113b6565b600160701b175b6001600160701b03608087901c16836113f55780156113f05760006113da826119a9565b6001955060e20393840160711901939190911b90505b6113ff565b600160701b1760721b5b81818161140e5761140e611e47565b0490508061142a57600160ff1b87871816610f22576000610f28565b6001606c1b81101561143e5761143e611e1b565b6000600160731b82101561147d57600160721b82101561147257600160711b82101561146b576070611475565b6071611475565b60725b60ff16611486565b611486826119a9565b9050836140710181860111156114a457617fff945060009150611537565b83818601613ffc0110156114bf576000945060009150611537565b83818601613f8c01101561150c578385613ffc0111156114ea578385613ffc010382901b9150611503565b8385613ffc01101561150357613ffc8585030382901c91505b60009450611537565b607081111561151f576070810382901c91505b6001600160701b038216915083818601613f8d010394505b81607086901b888a186001607f1b60801b1660801c6001600160801b0316171760801b955050505050506103a3565b6000617fff60f083901c16613fff8110156115845750600092915050565b6001607f1b608084901c1061159857600080fd5b6140fe8111156115a757600080fd5b600160701b6001600160701b03608085901c161761406f8210156115d15761406f8290031c610981565b61406f8211156109815761406e1982011b9392505050565b6000617fff60f084811c8216919084901c8116908214156116375780617fff141561162d576001600160801b03198581169085161415610e415784925050506103a3565b84925050506103a3565b80617fff141561164b5783925050506103a3565b6001607f1b608086901c90811015906001600160701b0316836116715760019350611678565b600160701b175b6001607f1b608087901c90811015906001600160701b03168461169e57600194506116a5565b600160701b175b826116d5576001600160801b03198816600160ff1b146116c557876116c8565b60005b96505050505050506103a3565b806116f5576001600160801b03198916600160ff1b146116c557886116c8565b848603841515831515141561180057607081131561171c57899750505050505050506103a3565b600081131561172e5790811c9061175d565b606f1981121561174757889750505050505050506103a3565b600081121561175d578060000384901c93508596505b92810192600160711b8410611778576001968701969390931c925b86617fff14156117aa578461179257617fff60f01b61179c565b6001600160f01b03195b9750505050505050506103a3565b600160701b8410156117bf57600096506117cc565b6001600160701b03841693505b83607088901b866117de5760006117e4565b6001607f1b5b6001600160801b0316171760801b9750505050505050506103a3565b600081131561181b57600184901b9350600187039650611832565b600081121561183257600182901b91506001860396505b60708113156118445760019150611891565b6001811315611861576001810360018303901c6001019150611891565b606f198112156118745760019350611891565b600019811215611891576001816000030360018503901c60010193505b8184106118a25781840393506118ab565b83820393508294505b836118c15750600096506103a395505050505050565b60006118cc856119a9565b905080607114156118f257600185901c6001600160701b03169450600188019750611941565b607081101561193457607081900380891115611921578086901b6001600160701b03169550808903985061192e565b600098600019019590951b945b50611941565b6001600160701b03851694505b87617fff1415611974578561195b57617fff60f01b611965565b6001600160f01b03195b985050505050505050506103a3565b84607089901b8761198657600061198c565b6001607f1b5b6001600160801b0316171760801b985050505050505050506103a3565b60008082116119b757600080fd5b6000600160801b83106119cc57608092831c92015b6801000000000000000083106119e457604092831c92015b64010000000083106119f857602092831c92015b620100008310611a0a57601092831c92015b6101008310611a1b57600892831c92015b60108310611a2b57600492831c92015b60048310611a3b57600292831c92015b600283106103a35760010192915050565b600060208284031215611a5e57600080fd5b813561098181611f2f565b600060208284031215611a7b57600080fd5b815161098181611f2f565b600080600060608486031215611a9b57600080fd5b8335611aa681611f2f565b95602085013595506040909401359392505050565b600080600080600060a08688031215611ad357600080fd5b8535611ade81611f2f565b97602087013597506040870135966060810135965060800135945092505050565b60008060208385031215611b1257600080fd5b823567ffffffffffffffff80821115611b2a57600080fd5b818501915085601f830112611b3e57600080fd5b813581811115611b4d57600080fd5b8660208260051b8501011115611b6257600080fd5b60209290920196919550909350505050565b600060208284031215611b8657600080fd5b8151801515811461098157600080fd5b600060208284031215611ba857600080fd5b5051919050565b60008060008060808587031215611bc557600080fd5b84519350602085015167ffffffffffffffff80821115611be457600080fd5b818701915087601f830112611bf857600080fd5b815181811115611c0a57611c0a611e73565b6040519150611c23601f8201601f191660200183611dd3565b808252886020828501011115611c3857600080fd5b611c49816020840160208601611da3565b50604087015160609097015195989097509350505050565b600060208284031215611c7357600080fd5b5035919050565b60008060408385031215611c8d57600080fd5b50508035926020909101359150565b600060208284031215611cae57600080fd5b815160ff8116811461098157600080fd5b60008151808452611cd7816020860160208601611da3565b601f01601f19169290920160200192915050565b6020815260006109816020830184611cbf565b6020808252818101527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604082015260600190565b60008219821115611d4657611d46611e31565b500190565b600082611d6857634e487b7160e01b600052601260045260246000fd5b500490565b6000816000190483118215151615611d8757611d87611e31565b500290565b600082821015611d9e57611d9e611e31565b500390565b60005b83811015611dbe578181015183820152602001611da6565b83811115611dcd576000848401525b50505050565b601f8201601f1916810167ffffffffffffffff81118282101715611df957611df9611e73565b6040525050565b6000600019821415611e1457611e14611e31565b5060010190565b634e487b7160e01b600052600160045260246000fd5b634e487b7160e01b600052601160045260246000fd5b634e487b7160e01b600052601260045260246000fd5b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052604160045260246000fd5b600060033d1115611ea25760046000803e5060005160e01c5b90565b600060443d1015611eb35790565b6040516003193d81016004833e81513d67ffffffffffffffff8160248401118184111715611ee357505050505090565b8285019150815181811115611efb5750505050505090565b843d8701016020828501011115611f155750505050505090565b611f2460208286010187611dd3565b509095945050505050565b6001600160a01b0381168114610cf657600080fdfea26469706673582212204228dd043a362f2ea3f05e4a3e96ee425dab22e5950e1b776997974010e723e264736f6c63430008070033",
    "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061012c5760003560e01c8063b3fbb7c4116100ad578063ce1dcdfc11610071578063ce1dcdfc1461025e578063f2fde38b14610271578063f930191014610284578063fcab9e981461028c578063fe173b971461029f57600080fd5b8063b3fbb7c4146101f2578063b9c6536514610205578063bf1fe42014610218578063c45a01551461022b578063cdd9e1371461023e57600080fd5b80638da5cb5b116100f45780638da5cb5b1461019f57806391a60782146101c45780639f9a3d95146101d7578063a40d6b80146101df578063aea8acb1146101d757600080fd5b80630417cf8e14610131578063225739b11461014c5780633c5c7fb31461016f5780635bb4780814610184578063715018a614610197575b600080fd5b610139601281565b6040519081526020015b60405180910390f35b61015f61015a366004611a4c565b6102a8565b6040519015158152602001610143565b61018261017d366004611a4c565b6103a9565b005b610182610192366004611a4c565b6105b7565b610182610603565b6000546001600160a01b03165b6040516001600160a01b039091168152602001610143565b6101826101d2366004611a4c565b610639565b610139600581565b6101396101ed366004611a86565b61083b565b610139610200366004611abb565b610988565b610139610213366004611c7a565b610b72565b610182610226366004611c61565b610bce565b6002546101ac906001600160a01b031681565b61013961024c366004611a4c565b60016020526000908152604090205481565b61015f61026c366004611aff565b610bfd565b61018261027f366004611a4c565b610c5e565b610139600d81565b61018261029a366004611aff565b610cf9565b61013960035481565b600254604051635ab78ee160e01b81526001600160a01b0383811660048301526000921690635ab78ee19060240160206040518083038186803b1580156102ee57600080fd5b505afa158015610302573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103269190611b74565b61033257506000919050565b816001600160a01b0316637bbf10336040518163ffffffff1660e01b815260040160206040518083038186803b15801561036b57600080fd5b505afa15801561037f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103a39190611b74565b92915050565b6002546001600160a01b031633146103fd5760405162461bcd60e51b815260206004820152601260248201527143616c6c6572206e6f7420666163746f727960701b60448201526064015b60405180910390fd5b6000816001600160a01b031663b9ed8abf6040518163ffffffff1660e01b815260040160206040518083038186803b15801561043857600080fd5b505afa15801561044c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104709190611a69565b90506000816001600160a01b03166398d5fdca6040518163ffffffff1660e01b815260040160206040518083038186803b1580156104ad57600080fd5b505afa1580156104c1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104e59190611b96565b9050600081136105375760405162461bcd60e51b815260206004820152601b60248201527f4669727374207072696365206973206e6f6e2d706f736974697665000000000060448201526064016103f4565b600061055d61055861054884610d45565b668075782dace9d960c71b610dd3565b611050565b905081846001600160a01b03167fe950cb32f7a787627d713d7365623fef2d762ef8fcf813b865a04350852deb9b60405160405180910390a36001600160a01b039093166000908152600160205260409020929092555050565b6000546001600160a01b031633146105e15760405162461bcd60e51b81526004016103f490611cfe565b600280546001600160a01b0319166001600160a01b0392909216919091179055565b6000546001600160a01b0316331461062d5760405162461bcd60e51b81526004016103f490611cfe565b61063760006110f7565b565b60005a9050610647826102a8565b61064f575050565b6000829050600080600080846001600160a01b03166304883c276040518163ffffffff1660e01b815260040160006040518083038186803b15801561069357600080fd5b505afa1580156106a7573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526106cf9190810190611baf565b6001600160a01b038b81166000908152600160205260409081902080549087905590516303d8ce9d60e61b81526004810182905260248101879052959950939750919550935090919087169063f633a74090604401600060405180830381600087803b15801561073e57600080fd5b505af192505050801561074f575060015b6107ce5761075b611e89565b806308c379a014156107c25750610770611ea5565b8061077b57506107c4565b886001600160a01b03167f8a47468bf96478429d382ed6385d9c77fba8b89540cd88199b1b51d5723b11fa826040516107b49190611ceb565b60405180910390a250610831565b505b3d6000803e3d6000fd5b60005a6107db9089611d8c565b90506107ec89600354838787611147565b85828a6001600160a01b03167f0aa8d2838ad6d4e2a5d7ca0826dfdbc36d922adf8fe5c6d25aee2724b07de074886040516108279190611ceb565b60405180910390a4505b5050505050505050565b600080846001600160a01b0316638226f3966040518163ffffffff1660e01b815260040160206040518083038186803b15801561087757600080fd5b505afa15801561088b573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108af9190611a69565b6001600160a01b03166398d5fdca6040518163ffffffff1660e01b815260040160206040518083038186803b1580156108e757600080fd5b505afa1580156108fb573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061091f9190611b96565b905060008113610933576000915050610981565b60006109476109428587611d6d565b61126c565b905060006109548361126c565b905061097b6109766109668484610dd3565b668075782dace9d960c71b6112d0565b611566565b93505050505b9392505050565b60008061099687878761083b565b905060006109a76109428686610b72565b90506109bc816109b7606461126c565b6112d0565b905060006109e96105586109cf8561126c565b6109e46109666109de8861126c565b87610dd3565b6115e9565b90506000896001600160a01b031663217a4b706040518163ffffffff1660e01b815260040160206040518083038186803b158015610a2657600080fd5b505afa158015610a3a573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a5e9190611a69565b6001600160a01b031663313ce5676040518163ffffffff1660e01b815260040160206040518083038186803b158015610a9657600080fd5b505afa158015610aaa573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ace9190611c9c565b60405163bf36f0e960e01b81526004810184905260ff9190911660248201819052915060009073__$dc3b4b0a367edd91a2d74c73e2da54c142$__9063bf36f0e99060440160206040518083038186803b158015610b2b57600080fd5b505af4158015610b3f573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b639190611b96565b9b9a5050505050505050505050565b600080610b7f8385611d33565b610b899042611d8c565b90506000600d610b9a836005611d6d565b610ba49190611d4b565b610baf906005611d33565b90506064811115610bc5576064925050506103a3565b91506103a39050565b6000546001600160a01b03163314610bf85760405162461bcd60e51b81526004016103f490611cfe565b600355565b6000805b82811015610c5457610c33848483818110610c1e57610c1e611e5d565b905060200201602081019061015a9190611a4c565b15610c425760019150506103a3565b80610c4c81611e00565b915050610c01565b5060009392505050565b6000546001600160a01b03163314610c885760405162461bcd60e51b81526004016103f490611cfe565b6001600160a01b038116610ced5760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201526564647265737360d01b60648201526084016103f4565b610cf6816110f7565b50565b60005b81811015610d4057610d2e838383818110610d1957610d19611e5d565b90506020020160208101906101d29190611a4c565b80610d3881611e00565b915050610cfc565b505050565b600081610d5457506000919050565b6000808313610d665782600003610d68565b825b90506000610d75826119a9565b90506070811015610d8e578060700382901b9150610da1565b6070811115610da1576070810382901c91505b6001600160701b03909116613fff820160701b17906000841215610dc9576001607f1b821791505b5060801b92915050565b6000617fff60f084811c8216919084901c811690821415610e835780617fff1415610e51576001600160801b03198581169085161415610e1e57505050600160ff1b811682186103a3565b600160ff1b6001600160801b0319868618161415610e41575050508181176103a3565b5061ffff60ef1b91506103a39050565b600160801b600160ff1b038416610e72575061ffff60ef1b91506103a39050565b505050600160ff1b811682186103a3565b80617fff1415610ebf57600160801b600160ff1b038516610eae575061ffff60ef1b91506103a39050565b505050600160ff1b821681186103a3565b6001600160701b03608086901c1682610edb5760019250610ee2565b600160701b175b6001600160701b03608086901c1682610efe5760019250610f05565b600160701b175b9081029081610f3357600160ff1b87871816610f22576000610f28565b600160ff1b5b9450505050506103a3565b928201926000600160e11b831015610f6657600160e01b831015610f5f57610f5a836119a9565b610f69565b60e0610f69565b60e15b90506140708186011015610f84576000945060009250611021565b6140e08186011015610fc757614070851015610fa957846140700383901c9250610fbe565b614070851115610fbe57614070850383901b92505b60009450611021565b61c0dd8186011115610fe157617fff945060009250611021565b6070811115610ff8576070810383901c925061100b565b607081101561100b578060700383901b92505b6001600160701b03831692506140df8186010394505b82607086901b888a186001607f1b60801b1660801c6001600160801b0316171760801b955050505050506103a3565b6000617fff60f083901c166140fe81111561106a57600080fd5b613fff81101561107d5750600092915050565b600160701b6001600160701b03608085901c161761406f8210156110a75761406f8290031c6110b9565b61406f8211156110b95761406e1982011b5b6001607f1b608085901c106110e357600160ff1b8111156110d957600080fd5b6000039392505050565b6001600160ff1b0381111561098157600080fd5b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b60006111568686868686610988565b604051636dc2b27160e01b8152336004820152602481018290529091506001600160a01b03871690636dc2b27190604401602060405180830381600087803b1580156111a157600080fd5b505af11580156111b5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111d99190611b74565b156112235760405181815233906001600160a01b038816907ff03012dd4aab142682aa01439f94e975e2ec77ef558352323bc05f382f74b0829060200160405180910390a3611264565b60405181815233906001600160a01b038816907f08b35d4c86707ba44cdcc5efaa79b8a307e6c7f789f1eb86ca1ff1e9bde056979060200160405180910390a35b505050505050565b60008161127b57506000919050565b816000611287826119a9565b905060708110156112a0578060700382901b91506112b3565b60708111156112b3576070810382901c91505b613fff0160701b6001600160701b03919091161760801b92915050565b6000617fff60f084811c8216919084901c8116908214156113055780617fff1415610e72575061ffff60ef1b91506103a39050565b80617fff1415611349576dffffffffffffffffffffffffffff60801b841615611338575061ffff60ef1b91506103a39050565b505050808218600160ff1b166103a3565b600160801b600160ff1b03841661139357600160801b600160ff1b03851661137b575061ffff60ef1b91506103a39050565b505050808218600160ff1b16617fff60f01b176103a3565b6001600160701b03608085901c16816113af57600191506113b6565b600160701b175b6001600160701b03608087901c16836113f55780156113f05760006113da826119a9565b6001955060e20393840160711901939190911b90505b6113ff565b600160701b1760721b5b81818161140e5761140e611e47565b0490508061142a57600160ff1b87871816610f22576000610f28565b6001606c1b81101561143e5761143e611e1b565b6000600160731b82101561147d57600160721b82101561147257600160711b82101561146b576070611475565b6071611475565b60725b60ff16611486565b611486826119a9565b9050836140710181860111156114a457617fff945060009150611537565b83818601613ffc0110156114bf576000945060009150611537565b83818601613f8c01101561150c578385613ffc0111156114ea578385613ffc010382901b9150611503565b8385613ffc01101561150357613ffc8585030382901c91505b60009450611537565b607081111561151f576070810382901c91505b6001600160701b038216915083818601613f8d010394505b81607086901b888a186001607f1b60801b1660801c6001600160801b0316171760801b955050505050506103a3565b6000617fff60f083901c16613fff8110156115845750600092915050565b6001607f1b608084901c1061159857600080fd5b6140fe8111156115a757600080fd5b600160701b6001600160701b03608085901c161761406f8210156115d15761406f8290031c610981565b61406f8211156109815761406e1982011b9392505050565b6000617fff60f084811c8216919084901c8116908214156116375780617fff141561162d576001600160801b03198581169085161415610e415784925050506103a3565b84925050506103a3565b80617fff141561164b5783925050506103a3565b6001607f1b608086901c90811015906001600160701b0316836116715760019350611678565b600160701b175b6001607f1b608087901c90811015906001600160701b03168461169e57600194506116a5565b600160701b175b826116d5576001600160801b03198816600160ff1b146116c557876116c8565b60005b96505050505050506103a3565b806116f5576001600160801b03198916600160ff1b146116c557886116c8565b848603841515831515141561180057607081131561171c57899750505050505050506103a3565b600081131561172e5790811c9061175d565b606f1981121561174757889750505050505050506103a3565b600081121561175d578060000384901c93508596505b92810192600160711b8410611778576001968701969390931c925b86617fff14156117aa578461179257617fff60f01b61179c565b6001600160f01b03195b9750505050505050506103a3565b600160701b8410156117bf57600096506117cc565b6001600160701b03841693505b83607088901b866117de5760006117e4565b6001607f1b5b6001600160801b0316171760801b9750505050505050506103a3565b600081131561181b57600184901b9350600187039650611832565b600081121561183257600182901b91506001860396505b60708113156118445760019150611891565b6001811315611861576001810360018303901c6001019150611891565b606f198112156118745760019350611891565b600019811215611891576001816000030360018503901c60010193505b8184106118a25781840393506118ab565b83820393508294505b836118c15750600096506103a395505050505050565b60006118cc856119a9565b905080607114156118f257600185901c6001600160701b03169450600188019750611941565b607081101561193457607081900380891115611921578086901b6001600160701b03169550808903985061192e565b600098600019019590951b945b50611941565b6001600160701b03851694505b87617fff1415611974578561195b57617fff60f01b611965565b6001600160f01b03195b985050505050505050506103a3565b84607089901b8761198657600061198c565b6001607f1b5b6001600160801b0316171760801b985050505050505050506103a3565b60008082116119b757600080fd5b6000600160801b83106119cc57608092831c92015b6801000000000000000083106119e457604092831c92015b64010000000083106119f857602092831c92015b620100008310611a0a57601092831c92015b6101008310611a1b57600892831c92015b60108310611a2b57600492831c92015b60048310611a3b57600292831c92015b600283106103a35760010192915050565b600060208284031215611a5e57600080fd5b813561098181611f2f565b600060208284031215611a7b57600080fd5b815161098181611f2f565b600080600060608486031215611a9b57600080fd5b8335611aa681611f2f565b95602085013595506040909401359392505050565b600080600080600060a08688031215611ad357600080fd5b8535611ade81611f2f565b97602087013597506040870135966060810135965060800135945092505050565b60008060208385031215611b1257600080fd5b823567ffffffffffffffff80821115611b2a57600080fd5b818501915085601f830112611b3e57600080fd5b813581811115611b4d57600080fd5b8660208260051b8501011115611b6257600080fd5b60209290920196919550909350505050565b600060208284031215611b8657600080fd5b8151801515811461098157600080fd5b600060208284031215611ba857600080fd5b5051919050565b60008060008060808587031215611bc557600080fd5b84519350602085015167ffffffffffffffff80821115611be457600080fd5b818701915087601f830112611bf857600080fd5b815181811115611c0a57611c0a611e73565b6040519150611c23601f8201601f191660200183611dd3565b808252886020828501011115611c3857600080fd5b611c49816020840160208601611da3565b50604087015160609097015195989097509350505050565b600060208284031215611c7357600080fd5b5035919050565b60008060408385031215611c8d57600080fd5b50508035926020909101359150565b600060208284031215611cae57600080fd5b815160ff8116811461098157600080fd5b60008151808452611cd7816020860160208601611da3565b601f01601f19169290920160200192915050565b6020815260006109816020830184611cbf565b6020808252818101527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604082015260600190565b60008219821115611d4657611d46611e31565b500190565b600082611d6857634e487b7160e01b600052601260045260246000fd5b500490565b6000816000190483118215151615611d8757611d87611e31565b500290565b600082821015611d9e57611d9e611e31565b500390565b60005b83811015611dbe578181015183820152602001611da6565b83811115611dcd576000848401525b50505050565b601f8201601f1916810167ffffffffffffffff81118282101715611df957611df9611e73565b6040525050565b6000600019821415611e1457611e14611e31565b5060010190565b634e487b7160e01b600052600160045260246000fd5b634e487b7160e01b600052601160045260246000fd5b634e487b7160e01b600052601260045260246000fd5b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052604160045260246000fd5b600060033d1115611ea25760046000803e5060005160e01c5b90565b600060443d1015611eb35790565b6040516003193d81016004833e81513d67ffffffffffffffff8160248401118184111715611ee357505050505090565b8285019150815181811115611efb5750505050505090565b843d8701016020828501011115611f155750505050505090565b611f2460208286010187611dd3565b509095945050505050565b6001600160a01b0381168114610cf657600080fdfea26469706673582212204228dd043a362f2ea3f05e4a3e96ee425dab22e5950e1b776997974010e723e264736f6c63430008070033",
    "libraries": {
        "PoolSwapLibrary": "0xC793b1Bc41A5Ae49571d01e7A99731Ea3cb1Dd03"
    },
    "devdoc": {
        "kind": "dev",
        "methods": {
            "checkUpkeepMultiplePools(address[])": {
                "params": {
                    "_pools": "The array of pools to check"
                },
                "returns": {
                    "_0": "upkeepNeeded Whether or not at least one pool needs upkeeping"
                }
            },
            "checkUpkeepSinglePool(address)": {
                "params": {
                    "_pool": "The address of the pool to upkeep"
                },
                "returns": {
                    "_0": "upkeepNeeded Whether or not upkeep is needed for this single pool"
                }
            },
            "keeperGas(address,uint256,uint256)": {
                "params": {
                    "_gasPrice": "Price of a single gas unit (in ETH)",
                    "_gasSpent": "Number of gas units spent",
                    "_pool": "Address of the given pool"
                },
                "returns": {
                    "_0": "Keeper's gas compensation"
                }
            },
            "keeperReward(address,uint256,uint256,uint256,uint256)": {
                "params": {
                    "_gasPrice": "Price of a single gas unit (in ETH)",
                    "_gasSpent": "Number of gas units spent",
                    "_pool": "Address of the given pool",
                    "_poolInterval": "Pool interval of the given pool",
                    "_savedPreviousUpdatedTimestamp": "Last timestamp when the pool's price execution happened"
                },
                "returns": {
                    "_0": "Number of settlement tokens to give to the keeper for work performed"
                }
            },
            "keeperTip(uint256,uint256)": {
                "params": {
                    "_poolInterval": "Pool interval of the given pool",
                    "_savedPreviousUpdatedTimestamp": "Last timestamp when the pool's price execution happened"
                },
                "returns": {
                    "_0": "Percent of the `keeperGas` cost to add to payment, as a percent"
                }
            },
            "newPool(address)": {
                "params": {
                    "_poolAddress": "The address of the newly-created pools"
                }
            },
            "owner()": {
                "details": "Returns the address of the current owner."
            },
            "performUpkeepMultiplePools(address[])": {
                "params": {
                    "pools": "pool codes to perform the update for"
                }
            },
            "performUpkeepSinglePool(address)": {
                "params": {
                    "_pool": "The pool code to perform the update for"
                }
            },
            "renounceOwnership()": {
                "details": "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."
            },
            "setGasPrice(uint256)": {
                "details": "Only owner",
                "params": {
                    "_price": "Price (in ETH) per unit gas"
                }
            },
            "transferOwnership(address)": {
                "details": "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."
            }
        },
        "title": "The manager contract for multiple markets and the pools in them",
        "version": 1
    },
    "userdoc": {
        "events": {
            "KeeperPaid(address,address,uint256)": {
                "notice": "Creates a notification when a keeper is paid for doing upkeep for a pool"
            },
            "KeeperPaymentError(address,address,uint256)": {
                "notice": "Creates a notification when a keeper's payment for upkeeping a pool failed"
            },
            "PoolAdded(address,int256)": {
                "notice": "Creates a notification when a pool is created"
            },
            "PoolUpkeepError(address,string)": {
                "notice": "Creates a notification of a failed pool update"
            },
            "UpkeepSuccessful(address,bytes,int256,int256)": {
                "notice": "Creates a notification when a call to LeveragedPool:poolUpkeep is successful"
            }
        },
        "kind": "user",
        "methods": {
            "checkUpkeepMultiplePools(address[])": {
                "notice": "Checks multiple pools if any of them need updating"
            },
            "checkUpkeepSinglePool(address)": {
                "notice": "Check if upkeep is required"
            },
            "executionPrice(address)": {
                "notice": "Format: Pool address => last executionPrice"
            },
            "keeperGas(address,uint256,uint256)": {
                "notice": "Compensation a keeper will receive for their gas expenditure"
            },
            "keeperReward(address,uint256,uint256,uint256,uint256)": {
                "notice": "Payment keeper receives for performing upkeep on a given pool"
            },
            "keeperTip(uint256,uint256)": {
                "notice": "Tip a keeper will receive for successfully updating the specified pool"
            },
            "newPool(address)": {
                "notice": "When a pool is created, this function is called by the factory to initiate price trackings"
            },
            "performUpkeepMultiplePools(address[])": {
                "notice": "Called by keepers to perform an update on multiple pools"
            },
            "performUpkeepSinglePool(address)": {
                "notice": "Called by keepers to perform an update on a single pool"
            },
            "setGasPrice(uint256)": {
                "notice": "Sets the gas price to be used in compensating keepers for successful upkeep"
            }
        },
        "version": 1
    },
    "storageLayout": {
        "storage": [
            {
                "astId": 110,
                "contract": "contracts/implementation/PoolKeeper.sol:PoolKeeper",
                "label": "_owner",
                "offset": 0,
                "slot": "0",
                "type": "t_address"
            },
            {
                "astId": 9918,
                "contract": "contracts/implementation/PoolKeeper.sol:PoolKeeper",
                "label": "executionPrice",
                "offset": 0,
                "slot": "1",
                "type": "t_mapping(t_address,t_int256)"
            },
            {
                "astId": 9921,
                "contract": "contracts/implementation/PoolKeeper.sol:PoolKeeper",
                "label": "factory",
                "offset": 0,
                "slot": "2",
                "type": "t_contract(IPoolFactory)11671"
            },
            {
                "astId": 9927,
                "contract": "contracts/implementation/PoolKeeper.sol:PoolKeeper",
                "label": "gasPrice",
                "offset": 0,
                "slot": "3",
                "type": "t_uint256"
            }
        ],
        "types": {
            "t_address": {
                "encoding": "inplace",
                "label": "address",
                "numberOfBytes": "20"
            },
            "t_contract(IPoolFactory)11671": {
                "encoding": "inplace",
                "label": "contract IPoolFactory",
                "numberOfBytes": "20"
            },
            "t_int256": {
                "encoding": "inplace",
                "label": "int256",
                "numberOfBytes": "32"
            },
            "t_mapping(t_address,t_int256)": {
                "encoding": "mapping",
                "key": "t_address",
                "label": "mapping(address => int256)",
                "numberOfBytes": "32",
                "value": "t_int256"
            },
            "t_uint256": {
                "encoding": "inplace",
                "label": "uint256",
                "numberOfBytes": "32"
            }
        }
    }
}
