{
  "address": "0x9d1AE986A883B20F48bD02E8eBe8B1D0D1BA9Ffa",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_factory",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "_pool",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "keeper",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "reward",
          "type": "uint256"
        }
      ],
      "name": "KeeperPaid",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "_pool",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "keeper",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "expectedReward",
          "type": "uint256"
        }
      ],
      "name": "KeeperPaymentError",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferred",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "poolAddress",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "int256",
          "name": "firstPrice",
          "type": "int256"
        }
      ],
      "name": "PoolAdded",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "pool",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "string",
          "name": "reason",
          "type": "string"
        }
      ],
      "name": "PoolUpkeepError",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "pool",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        },
        {
          "indexed": true,
          "internalType": "int256",
          "name": "startPrice",
          "type": "int256"
        },
        {
          "indexed": true,
          "internalType": "int256",
          "name": "endPrice",
          "type": "int256"
        }
      ],
      "name": "UpkeepSuccessful",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "BASE_TIP",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "BLOCK_TIME",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "MAX_DECIMALS",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "MAX_TIP",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "TIP_DELTA_PER_BLOCK",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "_pools",
          "type": "address[]"
        }
      ],
      "name": "checkUpkeepMultiplePools",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_pool",
          "type": "address"
        }
      ],
      "name": "checkUpkeepSinglePool",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "executionPrice",
      "outputs": [
        {
          "internalType": "int256",
          "name": "",
          "type": "int256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "factory",
      "outputs": [
        {
          "internalType": "contract IPoolFactory",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "gasPrice",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_pool",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_gasPrice",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_gasSpent",
          "type": "uint256"
        }
      ],
      "name": "keeperGas",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_pool",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_gasPrice",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_gasSpent",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_savedPreviousUpdatedTimestamp",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_poolInterval",
          "type": "uint256"
        }
      ],
      "name": "keeperReward",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_savedPreviousUpdatedTimestamp",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_poolInterval",
          "type": "uint256"
        }
      ],
      "name": "keeperTip",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_poolAddress",
          "type": "address"
        }
      ],
      "name": "newPool",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "pools",
          "type": "address[]"
        }
      ],
      "name": "performUpkeepMultiplePools",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_pool",
          "type": "address"
        }
      ],
      "name": "performUpkeepSinglePool",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "renounceOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_factory",
          "type": "address"
        }
      ],
      "name": "setFactory",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_price",
          "type": "uint256"
        }
      ],
      "name": "setGasPrice",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "transferOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0xb8894ee3c9d1b74d823b70afcd7a8da74ca79684cd67f5f904ab9dd6f5d0bdc3",
  "receipt": {
    "to": null,
    "from": "0xc18fcFFD8c9173faB1684Ec1EEE32976f780B13E",
    "contractAddress": "0x9d1AE986A883B20F48bD02E8eBe8B1D0D1BA9Ffa",
    "transactionIndex": 0,
    "gasUsed": "29389073",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000800000000000000000000080000000020000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000020000000000000000000800000000000000000000000000000000400000000000000000000000080000000000000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000040000000000000000000000000",
    "blockHash": "0x81610dd9cc310b371ba436f916f2407e6d30ac9d06447396be2ac968591e8a78",
    "transactionHash": "0xb8894ee3c9d1b74d823b70afcd7a8da74ca79684cd67f5f904ab9dd6f5d0bdc3",
    "logs": [
      {
        "transactionIndex": 0,
        "blockNumber": 8969857,
        "transactionHash": "0xb8894ee3c9d1b74d823b70afcd7a8da74ca79684cd67f5f904ab9dd6f5d0bdc3",
        "address": "0x9d1AE986A883B20F48bD02E8eBe8B1D0D1BA9Ffa",
        "topics": [
          "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x000000000000000000000000c18fcffd8c9173fab1684ec1eee32976f780b13e"
        ],
        "data": "0x",
        "logIndex": 0,
        "blockHash": "0x81610dd9cc310b371ba436f916f2407e6d30ac9d06447396be2ac968591e8a78"
      }
    ],
    "blockNumber": 8969857,
    "cumulativeGasUsed": "13409133",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0xcbD0bA56d7b533eb96f13dB7f7D779432d485391"
  ],
  "solcInputHash": "4e236762a3d0441b39001e87e67104bc",
  "metadata": "{\"compiler\":{\"version\":\"0.8.7+commit.e28d00a7\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"keeper\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"KeeperPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"keeper\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"expectedReward\",\"type\":\"uint256\"}],\"name\":\"KeeperPaymentError\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"poolAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"int256\",\"name\":\"firstPrice\",\"type\":\"int256\"}],\"name\":\"PoolAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"reason\",\"type\":\"string\"}],\"name\":\"PoolUpkeepError\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":true,\"internalType\":\"int256\",\"name\":\"startPrice\",\"type\":\"int256\"},{\"indexed\":true,\"internalType\":\"int256\",\"name\":\"endPrice\",\"type\":\"int256\"}],\"name\":\"UpkeepSuccessful\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BASE_TIP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BLOCK_TIME\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_DECIMALS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_TIP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TIP_DELTA_PER_BLOCK\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_pools\",\"type\":\"address[]\"}],\"name\":\"checkUpkeepMultiplePools\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"}],\"name\":\"checkUpkeepSinglePool\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"executionPrice\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"contract IPoolFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gasPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_gasPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_gasSpent\",\"type\":\"uint256\"}],\"name\":\"keeperGas\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_gasPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_gasSpent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_savedPreviousUpdatedTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_poolInterval\",\"type\":\"uint256\"}],\"name\":\"keeperReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_savedPreviousUpdatedTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_poolInterval\",\"type\":\"uint256\"}],\"name\":\"keeperTip\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_poolAddress\",\"type\":\"address\"}],\"name\":\"newPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"pools\",\"type\":\"address[]\"}],\"name\":\"performUpkeepMultiplePools\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"}],\"name\":\"performUpkeepSinglePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"}],\"name\":\"setFactory\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"setGasPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"checkUpkeepMultiplePools(address[])\":{\"details\":\"Iterates over the provided array of pool addresses\",\"params\":{\"_pools\":\"Array of pools to check\"},\"returns\":{\"_0\":\"Whether or not at least one pool needs upkeeping\"}},\"checkUpkeepSinglePool(address)\":{\"params\":{\"_pool\":\"The address of the pool to upkeep\"},\"returns\":{\"_0\":\"Whether or not upkeep is needed for this single pool\"}},\"keeperGas(address,uint256,uint256)\":{\"params\":{\"_gasPrice\":\"Price of a single gas unit (in ETH (wei))\",\"_gasSpent\":\"Number of gas units spent\",\"_pool\":\"Address of the given pool\"},\"returns\":{\"_0\":\"Keeper's gas compensation\"}},\"keeperReward(address,uint256,uint256,uint256,uint256)\":{\"params\":{\"_gasPrice\":\"Price of a single gas unit (in ETH (wei))\",\"_gasSpent\":\"Number of gas units spent\",\"_pool\":\"Address of the given pool\",\"_poolInterval\":\"Pool interval of the given pool\",\"_savedPreviousUpdatedTimestamp\":\"Last timestamp when the pool's price execution happened\"},\"returns\":{\"_0\":\"Number of settlement tokens to give to the keeper for work performed\"}},\"keeperTip(uint256,uint256)\":{\"params\":{\"_poolInterval\":\"Pool interval of the given pool\",\"_savedPreviousUpdatedTimestamp\":\"Last timestamp when the pool's price execution happened\"},\"returns\":{\"_0\":\"Percent of the `keeperGas` cost to add to payment, as a percent\"}},\"newPool(address)\":{\"details\":\"Only callable by the associated `PoolFactory` contract\",\"params\":{\"_poolAddress\":\"The address of the newly-created pools\"}},\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"performUpkeepMultiplePools(address[])\":{\"details\":\"Iterates over the provided arrayEssentially wraps calls to `performUpkeepSinglePool`\",\"params\":{\"pools\":\"Addresses of each pool to upkeep\"}},\"performUpkeepSinglePool(address)\":{\"details\":\"Induces an update of the associated `PriceObserver` contractTracks gas usage via `gasleft` accounting and uses this to inform          keeper paymentCatches any failure of the underlying `pool.poolUpkeep` call\",\"params\":{\"_pool\":\"Address of the pool to be upkept\"}},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.\"},\"setFactory(address)\":{\"details\":\"Only callable by the owner\",\"params\":{\"_factory\":\"Address of the `PoolFactory` contract\"}},\"setGasPrice(uint256)\":{\"details\":\"Only callable by the ownerThis function is only necessary due to the L2 deployment of Pools -- in reality, it should be `BASEFEE`\",\"params\":{\"_price\":\"Price (in ETH) per unit gas\"}},\"transferOwnership(address)\":{\"details\":\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\"}},\"title\":\"The manager contract for multiple markets and the pools in them\",\"version\":1},\"userdoc\":{\"events\":{\"KeeperPaid(address,address,uint256)\":{\"notice\":\"Creates a notification when a keeper is paid for doing upkeep for a pool\"},\"KeeperPaymentError(address,address,uint256)\":{\"notice\":\"Creates a notification when a keeper's payment for upkeeping a pool failed\"},\"PoolAdded(address,int256)\":{\"notice\":\"Creates a notification when a pool is created\"},\"PoolUpkeepError(address,string)\":{\"notice\":\"Creates a notification of a failed pool update\"},\"UpkeepSuccessful(address,bytes,int256,int256)\":{\"notice\":\"Creates a notification when a call to LeveragedPool:poolUpkeep is successful\"}},\"kind\":\"user\",\"methods\":{\"checkUpkeepMultiplePools(address[])\":{\"notice\":\"Checks multiple pools if any of them need updating\"},\"checkUpkeepSinglePool(address)\":{\"notice\":\"Check if upkeep is required\"},\"executionPrice(address)\":{\"notice\":\"Format: Pool address => last executionPrice\"},\"keeperGas(address,uint256,uint256)\":{\"notice\":\"Compensation a keeper will receive for their gas expenditure\"},\"keeperReward(address,uint256,uint256,uint256,uint256)\":{\"notice\":\"Payment keeper receives for performing upkeep on a given pool\"},\"keeperTip(uint256,uint256)\":{\"notice\":\"Tip a keeper will receive for successfully updating the specified pool\"},\"newPool(address)\":{\"notice\":\"When a pool is created, this function is called by the factory to initiate price trackings\"},\"performUpkeepMultiplePools(address[])\":{\"notice\":\"Called by keepers to perform an update on multiple pools\"},\"performUpkeepSinglePool(address)\":{\"notice\":\"Called by keepers to perform an update on a single pool\"},\"setFactory(address)\":{\"notice\":\"Sets the address of the associated `PoolFactory` contract\"},\"setGasPrice(uint256)\":{\"notice\":\"Sets the gas price to be used in compensating keepers for successful upkeep\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/implementation/PoolKeeper.sol\":\"PoolKeeper\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0xa1b27b3f44ff825974e5268e8f63ad3b03add5b464880d860fbb8cae043e17f7\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0x7736c187e6f1358c1ea9350a2a21aa8528dec1c2f43b374a9067465a3a51f5d3\",\"license\":\"MIT\"},\"abdk-libraries-solidity/ABDKMathQuad.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-4-Clause\\n/*\\n * ABDK Math Quad Smart Contract Library.  Copyright \\u00a9 2019 by ABDK Consulting.\\n * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\\n */\\npragma solidity ^0.8.0;\\n\\n/**\\n * Smart contract library of mathematical functions operating with IEEE 754\\n * quadruple-precision binary floating-point numbers (quadruple precision\\n * numbers).  As long as quadruple precision numbers are 16-bytes long, they are\\n * represented by bytes16 type.\\n */\\nlibrary ABDKMathQuad {\\n  /*\\n   * 0.\\n   */\\n  bytes16 private constant POSITIVE_ZERO = 0x00000000000000000000000000000000;\\n\\n  /*\\n   * -0.\\n   */\\n  bytes16 private constant NEGATIVE_ZERO = 0x80000000000000000000000000000000;\\n\\n  /*\\n   * +Infinity.\\n   */\\n  bytes16 private constant POSITIVE_INFINITY = 0x7FFF0000000000000000000000000000;\\n\\n  /*\\n   * -Infinity.\\n   */\\n  bytes16 private constant NEGATIVE_INFINITY = 0xFFFF0000000000000000000000000000;\\n\\n  /*\\n   * Canonical NaN value.\\n   */\\n  bytes16 private constant NaN = 0x7FFF8000000000000000000000000000;\\n\\n  /**\\n   * Convert signed 256-bit integer number into quadruple precision number.\\n   *\\n   * @param x signed 256-bit integer number\\n   * @return quadruple precision number\\n   */\\n  function fromInt (int256 x) internal pure returns (bytes16) {\\n    unchecked {\\n      if (x == 0) return bytes16 (0);\\n      else {\\n        // We rely on overflow behavior here\\n        uint256 result = uint256 (x > 0 ? x : -x);\\n\\n        uint256 msb = mostSignificantBit (result);\\n        if (msb < 112) result <<= 112 - msb;\\n        else if (msb > 112) result >>= msb - 112;\\n\\n        result = result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF | 16383 + msb << 112;\\n        if (x < 0) result |= 0x80000000000000000000000000000000;\\n\\n        return bytes16 (uint128 (result));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert quadruple precision number into signed 256-bit integer number\\n   * rounding towards zero.  Revert on overflow.\\n   *\\n   * @param x quadruple precision number\\n   * @return signed 256-bit integer number\\n   */\\n  function toInt (bytes16 x) internal pure returns (int256) {\\n    unchecked {\\n      uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\\n\\n      require (exponent <= 16638); // Overflow\\n      if (exponent < 16383) return 0; // Underflow\\n\\n      uint256 result = uint256 (uint128 (x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF |\\n        0x10000000000000000000000000000;\\n\\n      if (exponent < 16495) result >>= 16495 - exponent;\\n      else if (exponent > 16495) result <<= exponent - 16495;\\n\\n      if (uint128 (x) >= 0x80000000000000000000000000000000) { // Negative\\n        require (result <= 0x8000000000000000000000000000000000000000000000000000000000000000);\\n        return -int256 (result); // We rely on overflow behavior here\\n      } else {\\n        require (result <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n        return int256 (result);\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert unsigned 256-bit integer number into quadruple precision number.\\n   *\\n   * @param x unsigned 256-bit integer number\\n   * @return quadruple precision number\\n   */\\n  function fromUInt (uint256 x) internal pure returns (bytes16) {\\n    unchecked {\\n      if (x == 0) return bytes16 (0);\\n      else {\\n        uint256 result = x;\\n\\n        uint256 msb = mostSignificantBit (result);\\n        if (msb < 112) result <<= 112 - msb;\\n        else if (msb > 112) result >>= msb - 112;\\n\\n        result = result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF | 16383 + msb << 112;\\n\\n        return bytes16 (uint128 (result));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert quadruple precision number into unsigned 256-bit integer number\\n   * rounding towards zero.  Revert on underflow.  Note, that negative floating\\n   * point numbers in range (-1.0 .. 0.0) may be converted to unsigned integer\\n   * without error, because they are rounded to zero.\\n   *\\n   * @param x quadruple precision number\\n   * @return unsigned 256-bit integer number\\n   */\\n  function toUInt (bytes16 x) internal pure returns (uint256) {\\n    unchecked {\\n      uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\\n\\n      if (exponent < 16383) return 0; // Underflow\\n\\n      require (uint128 (x) < 0x80000000000000000000000000000000); // Negative\\n\\n      require (exponent <= 16638); // Overflow\\n      uint256 result = uint256 (uint128 (x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF |\\n        0x10000000000000000000000000000;\\n\\n      if (exponent < 16495) result >>= 16495 - exponent;\\n      else if (exponent > 16495) result <<= exponent - 16495;\\n\\n      return result;\\n    }\\n  }\\n\\n  /**\\n   * Convert signed 128.128 bit fixed point number into quadruple precision\\n   * number.\\n   *\\n   * @param x signed 128.128 bit fixed point number\\n   * @return quadruple precision number\\n   */\\n  function from128x128 (int256 x) internal pure returns (bytes16) {\\n    unchecked {\\n      if (x == 0) return bytes16 (0);\\n      else {\\n        // We rely on overflow behavior here\\n        uint256 result = uint256 (x > 0 ? x : -x);\\n\\n        uint256 msb = mostSignificantBit (result);\\n        if (msb < 112) result <<= 112 - msb;\\n        else if (msb > 112) result >>= msb - 112;\\n\\n        result = result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF | 16255 + msb << 112;\\n        if (x < 0) result |= 0x80000000000000000000000000000000;\\n\\n        return bytes16 (uint128 (result));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert quadruple precision number into signed 128.128 bit fixed point\\n   * number.  Revert on overflow.\\n   *\\n   * @param x quadruple precision number\\n   * @return signed 128.128 bit fixed point number\\n   */\\n  function to128x128 (bytes16 x) internal pure returns (int256) {\\n    unchecked {\\n      uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\\n\\n      require (exponent <= 16510); // Overflow\\n      if (exponent < 16255) return 0; // Underflow\\n\\n      uint256 result = uint256 (uint128 (x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF |\\n        0x10000000000000000000000000000;\\n\\n      if (exponent < 16367) result >>= 16367 - exponent;\\n      else if (exponent > 16367) result <<= exponent - 16367;\\n\\n      if (uint128 (x) >= 0x80000000000000000000000000000000) { // Negative\\n        require (result <= 0x8000000000000000000000000000000000000000000000000000000000000000);\\n        return -int256 (result); // We rely on overflow behavior here\\n      } else {\\n        require (result <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n        return int256 (result);\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert signed 64.64 bit fixed point number into quadruple precision\\n   * number.\\n   *\\n   * @param x signed 64.64 bit fixed point number\\n   * @return quadruple precision number\\n   */\\n  function from64x64 (int128 x) internal pure returns (bytes16) {\\n    unchecked {\\n      if (x == 0) return bytes16 (0);\\n      else {\\n        // We rely on overflow behavior here\\n        uint256 result = uint128 (x > 0 ? x : -x);\\n\\n        uint256 msb = mostSignificantBit (result);\\n        if (msb < 112) result <<= 112 - msb;\\n        else if (msb > 112) result >>= msb - 112;\\n\\n        result = result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF | 16319 + msb << 112;\\n        if (x < 0) result |= 0x80000000000000000000000000000000;\\n\\n        return bytes16 (uint128 (result));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert quadruple precision number into signed 64.64 bit fixed point\\n   * number.  Revert on overflow.\\n   *\\n   * @param x quadruple precision number\\n   * @return signed 64.64 bit fixed point number\\n   */\\n  function to64x64 (bytes16 x) internal pure returns (int128) {\\n    unchecked {\\n      uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\\n\\n      require (exponent <= 16446); // Overflow\\n      if (exponent < 16319) return 0; // Underflow\\n\\n      uint256 result = uint256 (uint128 (x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF |\\n        0x10000000000000000000000000000;\\n\\n      if (exponent < 16431) result >>= 16431 - exponent;\\n      else if (exponent > 16431) result <<= exponent - 16431;\\n\\n      if (uint128 (x) >= 0x80000000000000000000000000000000) { // Negative\\n        require (result <= 0x80000000000000000000000000000000);\\n        return -int128 (int256 (result)); // We rely on overflow behavior here\\n      } else {\\n        require (result <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n        return int128 (int256 (result));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert octuple precision number into quadruple precision number.\\n   *\\n   * @param x octuple precision number\\n   * @return quadruple precision number\\n   */\\n  function fromOctuple (bytes32 x) internal pure returns (bytes16) {\\n    unchecked {\\n      bool negative = x & 0x8000000000000000000000000000000000000000000000000000000000000000 > 0;\\n\\n      uint256 exponent = uint256 (x) >> 236 & 0x7FFFF;\\n      uint256 significand = uint256 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      if (exponent == 0x7FFFF) {\\n        if (significand > 0) return NaN;\\n        else return negative ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\\n      }\\n\\n      if (exponent > 278526)\\n        return negative ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\\n      else if (exponent < 245649)\\n        return negative ? NEGATIVE_ZERO : POSITIVE_ZERO;\\n      else if (exponent < 245761) {\\n        significand = (significand | 0x100000000000000000000000000000000000000000000000000000000000) >> 245885 - exponent;\\n        exponent = 0;\\n      } else {\\n        significand >>= 124;\\n        exponent -= 245760;\\n      }\\n\\n      uint128 result = uint128 (significand | exponent << 112);\\n      if (negative) result |= 0x80000000000000000000000000000000;\\n\\n      return bytes16 (result);\\n    }\\n  }\\n\\n  /**\\n   * Convert quadruple precision number into octuple precision number.\\n   *\\n   * @param x quadruple precision number\\n   * @return octuple precision number\\n   */\\n  function toOctuple (bytes16 x) internal pure returns (bytes32) {\\n    unchecked {\\n      uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\\n\\n      uint256 result = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      if (exponent == 0x7FFF) exponent = 0x7FFFF; // Infinity or NaN\\n      else if (exponent == 0) {\\n        if (result > 0) {\\n          uint256 msb = mostSignificantBit (result);\\n          result = result << 236 - msb & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n          exponent = 245649 + msb;\\n        }\\n      } else {\\n        result <<= 124;\\n        exponent += 245760;\\n      }\\n\\n      result |= exponent << 236;\\n      if (uint128 (x) >= 0x80000000000000000000000000000000)\\n        result |= 0x8000000000000000000000000000000000000000000000000000000000000000;\\n\\n      return bytes32 (result);\\n    }\\n  }\\n\\n  /**\\n   * Convert double precision number into quadruple precision number.\\n   *\\n   * @param x double precision number\\n   * @return quadruple precision number\\n   */\\n  function fromDouble (bytes8 x) internal pure returns (bytes16) {\\n    unchecked {\\n      uint256 exponent = uint64 (x) >> 52 & 0x7FF;\\n\\n      uint256 result = uint64 (x) & 0xFFFFFFFFFFFFF;\\n\\n      if (exponent == 0x7FF) exponent = 0x7FFF; // Infinity or NaN\\n      else if (exponent == 0) {\\n        if (result > 0) {\\n          uint256 msb = mostSignificantBit (result);\\n          result = result << 112 - msb & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n          exponent = 15309 + msb;\\n        }\\n      } else {\\n        result <<= 60;\\n        exponent += 15360;\\n      }\\n\\n      result |= exponent << 112;\\n      if (x & 0x8000000000000000 > 0)\\n        result |= 0x80000000000000000000000000000000;\\n\\n      return bytes16 (uint128 (result));\\n    }\\n  }\\n\\n  /**\\n   * Convert quadruple precision number into double precision number.\\n   *\\n   * @param x quadruple precision number\\n   * @return double precision number\\n   */\\n  function toDouble (bytes16 x) internal pure returns (bytes8) {\\n    unchecked {\\n      bool negative = uint128 (x) >= 0x80000000000000000000000000000000;\\n\\n      uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\\n      uint256 significand = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      if (exponent == 0x7FFF) {\\n        if (significand > 0) return 0x7FF8000000000000; // NaN\\n        else return negative ?\\n            bytes8 (0xFFF0000000000000) : // -Infinity\\n            bytes8 (0x7FF0000000000000); // Infinity\\n      }\\n\\n      if (exponent > 17406)\\n        return negative ?\\n            bytes8 (0xFFF0000000000000) : // -Infinity\\n            bytes8 (0x7FF0000000000000); // Infinity\\n      else if (exponent < 15309)\\n        return negative ?\\n            bytes8 (0x8000000000000000) : // -0\\n            bytes8 (0x0000000000000000); // 0\\n      else if (exponent < 15361) {\\n        significand = (significand | 0x10000000000000000000000000000) >> 15421 - exponent;\\n        exponent = 0;\\n      } else {\\n        significand >>= 60;\\n        exponent -= 15360;\\n      }\\n\\n      uint64 result = uint64 (significand | exponent << 52);\\n      if (negative) result |= 0x8000000000000000;\\n\\n      return bytes8 (result);\\n    }\\n  }\\n\\n  /**\\n   * Test whether given quadruple precision number is NaN.\\n   *\\n   * @param x quadruple precision number\\n   * @return true if x is NaN, false otherwise\\n   */\\n  function isNaN (bytes16 x) internal pure returns (bool) {\\n    unchecked {\\n      return uint128 (x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF >\\n        0x7FFF0000000000000000000000000000;\\n    }\\n  }\\n\\n  /**\\n   * Test whether given quadruple precision number is positive or negative\\n   * infinity.\\n   *\\n   * @param x quadruple precision number\\n   * @return true if x is positive or negative infinity, false otherwise\\n   */\\n  function isInfinity (bytes16 x) internal pure returns (bool) {\\n    unchecked {\\n      return uint128 (x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF ==\\n        0x7FFF0000000000000000000000000000;\\n    }\\n  }\\n\\n  /**\\n   * Calculate sign of x, i.e. -1 if x is negative, 0 if x if zero, and 1 if x\\n   * is positive.  Note that sign (-0) is zero.  Revert if x is NaN. \\n   *\\n   * @param x quadruple precision number\\n   * @return sign of x\\n   */\\n  function sign (bytes16 x) internal pure returns (int8) {\\n    unchecked {\\n      uint128 absoluteX = uint128 (x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      require (absoluteX <= 0x7FFF0000000000000000000000000000); // Not NaN\\n\\n      if (absoluteX == 0) return 0;\\n      else if (uint128 (x) >= 0x80000000000000000000000000000000) return -1;\\n      else return 1;\\n    }\\n  }\\n\\n  /**\\n   * Calculate sign (x - y).  Revert if either argument is NaN, or both\\n   * arguments are infinities of the same sign. \\n   *\\n   * @param x quadruple precision number\\n   * @param y quadruple precision number\\n   * @return sign (x - y)\\n   */\\n  function cmp (bytes16 x, bytes16 y) internal pure returns (int8) {\\n    unchecked {\\n      uint128 absoluteX = uint128 (x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      require (absoluteX <= 0x7FFF0000000000000000000000000000); // Not NaN\\n\\n      uint128 absoluteY = uint128 (y) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      require (absoluteY <= 0x7FFF0000000000000000000000000000); // Not NaN\\n\\n      // Not infinities of the same sign\\n      require (x != y || absoluteX < 0x7FFF0000000000000000000000000000);\\n\\n      if (x == y) return 0;\\n      else {\\n        bool negativeX = uint128 (x) >= 0x80000000000000000000000000000000;\\n        bool negativeY = uint128 (y) >= 0x80000000000000000000000000000000;\\n\\n        if (negativeX) {\\n          if (negativeY) return absoluteX > absoluteY ? -1 : int8 (1);\\n          else return -1; \\n        } else {\\n          if (negativeY) return 1;\\n          else return absoluteX > absoluteY ? int8 (1) : -1;\\n        }\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Test whether x equals y.  NaN, infinity, and -infinity are not equal to\\n   * anything. \\n   *\\n   * @param x quadruple precision number\\n   * @param y quadruple precision number\\n   * @return true if x equals to y, false otherwise\\n   */\\n  function eq (bytes16 x, bytes16 y) internal pure returns (bool) {\\n    unchecked {\\n      if (x == y) {\\n        return uint128 (x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF <\\n          0x7FFF0000000000000000000000000000;\\n      } else return false;\\n    }\\n  }\\n\\n  /**\\n   * Calculate x + y.  Special values behave in the following way:\\n   *\\n   * NaN + x = NaN for any x.\\n   * Infinity + x = Infinity for any finite x.\\n   * -Infinity + x = -Infinity for any finite x.\\n   * Infinity + Infinity = Infinity.\\n   * -Infinity + -Infinity = -Infinity.\\n   * Infinity + -Infinity = -Infinity + Infinity = NaN.\\n   *\\n   * @param x quadruple precision number\\n   * @param y quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function add (bytes16 x, bytes16 y) internal pure returns (bytes16) {\\n    unchecked {\\n      uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\\n      uint256 yExponent = uint128 (y) >> 112 & 0x7FFF;\\n\\n      if (xExponent == 0x7FFF) {\\n        if (yExponent == 0x7FFF) { \\n          if (x == y) return x;\\n          else return NaN;\\n        } else return x; \\n      } else if (yExponent == 0x7FFF) return y;\\n      else {\\n        bool xSign = uint128 (x) >= 0x80000000000000000000000000000000;\\n        uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (xExponent == 0) xExponent = 1;\\n        else xSignifier |= 0x10000000000000000000000000000;\\n\\n        bool ySign = uint128 (y) >= 0x80000000000000000000000000000000;\\n        uint256 ySignifier = uint128 (y) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (yExponent == 0) yExponent = 1;\\n        else ySignifier |= 0x10000000000000000000000000000;\\n\\n        if (xSignifier == 0) return y == NEGATIVE_ZERO ? POSITIVE_ZERO : y;\\n        else if (ySignifier == 0) return x == NEGATIVE_ZERO ? POSITIVE_ZERO : x;\\n        else {\\n          int256 delta = int256 (xExponent) - int256 (yExponent);\\n  \\n          if (xSign == ySign) {\\n            if (delta > 112) return x;\\n            else if (delta > 0) ySignifier >>= uint256 (delta);\\n            else if (delta < -112) return y;\\n            else if (delta < 0) {\\n              xSignifier >>= uint256 (-delta);\\n              xExponent = yExponent;\\n            }\\n  \\n            xSignifier += ySignifier;\\n  \\n            if (xSignifier >= 0x20000000000000000000000000000) {\\n              xSignifier >>= 1;\\n              xExponent += 1;\\n            }\\n  \\n            if (xExponent == 0x7FFF)\\n              return xSign ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\\n            else {\\n              if (xSignifier < 0x10000000000000000000000000000) xExponent = 0;\\n              else xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n  \\n              return bytes16 (uint128 (\\n                  (xSign ? 0x80000000000000000000000000000000 : 0) |\\n                  (xExponent << 112) |\\n                  xSignifier)); \\n            }\\n          } else {\\n            if (delta > 0) {\\n              xSignifier <<= 1;\\n              xExponent -= 1;\\n            } else if (delta < 0) {\\n              ySignifier <<= 1;\\n              xExponent = yExponent - 1;\\n            }\\n\\n            if (delta > 112) ySignifier = 1;\\n            else if (delta > 1) ySignifier = (ySignifier - 1 >> uint256 (delta - 1)) + 1;\\n            else if (delta < -112) xSignifier = 1;\\n            else if (delta < -1) xSignifier = (xSignifier - 1 >> uint256 (-delta - 1)) + 1;\\n\\n            if (xSignifier >= ySignifier) xSignifier -= ySignifier;\\n            else {\\n              xSignifier = ySignifier - xSignifier;\\n              xSign = ySign;\\n            }\\n\\n            if (xSignifier == 0)\\n              return POSITIVE_ZERO;\\n\\n            uint256 msb = mostSignificantBit (xSignifier);\\n\\n            if (msb == 113) {\\n              xSignifier = xSignifier >> 1 & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n              xExponent += 1;\\n            } else if (msb < 112) {\\n              uint256 shift = 112 - msb;\\n              if (xExponent > shift) {\\n                xSignifier = xSignifier << shift & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n                xExponent -= shift;\\n              } else {\\n                xSignifier <<= xExponent - 1;\\n                xExponent = 0;\\n              }\\n            } else xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n            if (xExponent == 0x7FFF)\\n              return xSign ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\\n            else return bytes16 (uint128 (\\n                (xSign ? 0x80000000000000000000000000000000 : 0) |\\n                (xExponent << 112) |\\n                xSignifier));\\n          }\\n        }\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate x - y.  Special values behave in the following way:\\n   *\\n   * NaN - x = NaN for any x.\\n   * Infinity - x = Infinity for any finite x.\\n   * -Infinity - x = -Infinity for any finite x.\\n   * Infinity - -Infinity = Infinity.\\n   * -Infinity - Infinity = -Infinity.\\n   * Infinity - Infinity = -Infinity - -Infinity = NaN.\\n   *\\n   * @param x quadruple precision number\\n   * @param y quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function sub (bytes16 x, bytes16 y) internal pure returns (bytes16) {\\n    unchecked {\\n      return add (x, y ^ 0x80000000000000000000000000000000);\\n    }\\n  }\\n\\n  /**\\n   * Calculate x * y.  Special values behave in the following way:\\n   *\\n   * NaN * x = NaN for any x.\\n   * Infinity * x = Infinity for any finite positive x.\\n   * Infinity * x = -Infinity for any finite negative x.\\n   * -Infinity * x = -Infinity for any finite positive x.\\n   * -Infinity * x = Infinity for any finite negative x.\\n   * Infinity * 0 = NaN.\\n   * -Infinity * 0 = NaN.\\n   * Infinity * Infinity = Infinity.\\n   * Infinity * -Infinity = -Infinity.\\n   * -Infinity * Infinity = -Infinity.\\n   * -Infinity * -Infinity = Infinity.\\n   *\\n   * @param x quadruple precision number\\n   * @param y quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function mul (bytes16 x, bytes16 y) internal pure returns (bytes16) {\\n    unchecked {\\n      uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\\n      uint256 yExponent = uint128 (y) >> 112 & 0x7FFF;\\n\\n      if (xExponent == 0x7FFF) {\\n        if (yExponent == 0x7FFF) {\\n          if (x == y) return x ^ y & 0x80000000000000000000000000000000;\\n          else if (x ^ y == 0x80000000000000000000000000000000) return x | y;\\n          else return NaN;\\n        } else {\\n          if (y & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) return NaN;\\n          else return x ^ y & 0x80000000000000000000000000000000;\\n        }\\n      } else if (yExponent == 0x7FFF) {\\n          if (x & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) return NaN;\\n          else return y ^ x & 0x80000000000000000000000000000000;\\n      } else {\\n        uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (xExponent == 0) xExponent = 1;\\n        else xSignifier |= 0x10000000000000000000000000000;\\n\\n        uint256 ySignifier = uint128 (y) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (yExponent == 0) yExponent = 1;\\n        else ySignifier |= 0x10000000000000000000000000000;\\n\\n        xSignifier *= ySignifier;\\n        if (xSignifier == 0)\\n          return (x ^ y) & 0x80000000000000000000000000000000 > 0 ?\\n              NEGATIVE_ZERO : POSITIVE_ZERO;\\n\\n        xExponent += yExponent;\\n\\n        uint256 msb =\\n          xSignifier >= 0x200000000000000000000000000000000000000000000000000000000 ? 225 :\\n          xSignifier >= 0x100000000000000000000000000000000000000000000000000000000 ? 224 :\\n          mostSignificantBit (xSignifier);\\n\\n        if (xExponent + msb < 16496) { // Underflow\\n          xExponent = 0;\\n          xSignifier = 0;\\n        } else if (xExponent + msb < 16608) { // Subnormal\\n          if (xExponent < 16496)\\n            xSignifier >>= 16496 - xExponent;\\n          else if (xExponent > 16496)\\n            xSignifier <<= xExponent - 16496;\\n          xExponent = 0;\\n        } else if (xExponent + msb > 49373) {\\n          xExponent = 0x7FFF;\\n          xSignifier = 0;\\n        } else {\\n          if (msb > 112)\\n            xSignifier >>= msb - 112;\\n          else if (msb < 112)\\n            xSignifier <<= 112 - msb;\\n\\n          xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n          xExponent = xExponent + msb - 16607;\\n        }\\n\\n        return bytes16 (uint128 (uint128 ((x ^ y) & 0x80000000000000000000000000000000) |\\n            xExponent << 112 | xSignifier));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate x / y.  Special values behave in the following way:\\n   *\\n   * NaN / x = NaN for any x.\\n   * x / NaN = NaN for any x.\\n   * Infinity / x = Infinity for any finite non-negative x.\\n   * Infinity / x = -Infinity for any finite negative x including -0.\\n   * -Infinity / x = -Infinity for any finite non-negative x.\\n   * -Infinity / x = Infinity for any finite negative x including -0.\\n   * x / Infinity = 0 for any finite non-negative x.\\n   * x / -Infinity = -0 for any finite non-negative x.\\n   * x / Infinity = -0 for any finite non-negative x including -0.\\n   * x / -Infinity = 0 for any finite non-negative x including -0.\\n   * \\n   * Infinity / Infinity = NaN.\\n   * Infinity / -Infinity = -NaN.\\n   * -Infinity / Infinity = -NaN.\\n   * -Infinity / -Infinity = NaN.\\n   *\\n   * Division by zero behaves in the following way:\\n   *\\n   * x / 0 = Infinity for any finite positive x.\\n   * x / -0 = -Infinity for any finite positive x.\\n   * x / 0 = -Infinity for any finite negative x.\\n   * x / -0 = Infinity for any finite negative x.\\n   * 0 / 0 = NaN.\\n   * 0 / -0 = NaN.\\n   * -0 / 0 = NaN.\\n   * -0 / -0 = NaN.\\n   *\\n   * @param x quadruple precision number\\n   * @param y quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function div (bytes16 x, bytes16 y) internal pure returns (bytes16) {\\n    unchecked {\\n      uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\\n      uint256 yExponent = uint128 (y) >> 112 & 0x7FFF;\\n\\n      if (xExponent == 0x7FFF) {\\n        if (yExponent == 0x7FFF) return NaN;\\n        else return x ^ y & 0x80000000000000000000000000000000;\\n      } else if (yExponent == 0x7FFF) {\\n        if (y & 0x0000FFFFFFFFFFFFFFFFFFFFFFFFFFFF != 0) return NaN;\\n        else return POSITIVE_ZERO | (x ^ y) & 0x80000000000000000000000000000000;\\n      } else if (y & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) {\\n        if (x & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) return NaN;\\n        else return POSITIVE_INFINITY | (x ^ y) & 0x80000000000000000000000000000000;\\n      } else {\\n        uint256 ySignifier = uint128 (y) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (yExponent == 0) yExponent = 1;\\n        else ySignifier |= 0x10000000000000000000000000000;\\n\\n        uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (xExponent == 0) {\\n          if (xSignifier != 0) {\\n            uint shift = 226 - mostSignificantBit (xSignifier);\\n\\n            xSignifier <<= shift;\\n\\n            xExponent = 1;\\n            yExponent += shift - 114;\\n          }\\n        }\\n        else {\\n          xSignifier = (xSignifier | 0x10000000000000000000000000000) << 114;\\n        }\\n\\n        xSignifier = xSignifier / ySignifier;\\n        if (xSignifier == 0)\\n          return (x ^ y) & 0x80000000000000000000000000000000 > 0 ?\\n              NEGATIVE_ZERO : POSITIVE_ZERO;\\n\\n        assert (xSignifier >= 0x1000000000000000000000000000);\\n\\n        uint256 msb =\\n          xSignifier >= 0x80000000000000000000000000000 ? mostSignificantBit (xSignifier) :\\n          xSignifier >= 0x40000000000000000000000000000 ? 114 :\\n          xSignifier >= 0x20000000000000000000000000000 ? 113 : 112;\\n\\n        if (xExponent + msb > yExponent + 16497) { // Overflow\\n          xExponent = 0x7FFF;\\n          xSignifier = 0;\\n        } else if (xExponent + msb + 16380  < yExponent) { // Underflow\\n          xExponent = 0;\\n          xSignifier = 0;\\n        } else if (xExponent + msb + 16268  < yExponent) { // Subnormal\\n          if (xExponent + 16380 > yExponent)\\n            xSignifier <<= xExponent + 16380 - yExponent;\\n          else if (xExponent + 16380 < yExponent)\\n            xSignifier >>= yExponent - xExponent - 16380;\\n\\n          xExponent = 0;\\n        } else { // Normal\\n          if (msb > 112)\\n            xSignifier >>= msb - 112;\\n\\n          xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n          xExponent = xExponent + msb + 16269 - yExponent;\\n        }\\n\\n        return bytes16 (uint128 (uint128 ((x ^ y) & 0x80000000000000000000000000000000) |\\n            xExponent << 112 | xSignifier));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate -x.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function neg (bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      return x ^ 0x80000000000000000000000000000000;\\n    }\\n  }\\n\\n  /**\\n   * Calculate |x|.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function abs (bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      return x & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n    }\\n  }\\n\\n  /**\\n   * Calculate square root of x.  Return NaN on negative x excluding -0.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function sqrt (bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      if (uint128 (x) >  0x80000000000000000000000000000000) return NaN;\\n      else {\\n        uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\\n        if (xExponent == 0x7FFF) return x;\\n        else {\\n          uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n          if (xExponent == 0) xExponent = 1;\\n          else xSignifier |= 0x10000000000000000000000000000;\\n\\n          if (xSignifier == 0) return POSITIVE_ZERO;\\n\\n          bool oddExponent = xExponent & 0x1 == 0;\\n          xExponent = xExponent + 16383 >> 1;\\n\\n          if (oddExponent) {\\n            if (xSignifier >= 0x10000000000000000000000000000)\\n              xSignifier <<= 113;\\n            else {\\n              uint256 msb = mostSignificantBit (xSignifier);\\n              uint256 shift = (226 - msb) & 0xFE;\\n              xSignifier <<= shift;\\n              xExponent -= shift - 112 >> 1;\\n            }\\n          } else {\\n            if (xSignifier >= 0x10000000000000000000000000000)\\n              xSignifier <<= 112;\\n            else {\\n              uint256 msb = mostSignificantBit (xSignifier);\\n              uint256 shift = (225 - msb) & 0xFE;\\n              xSignifier <<= shift;\\n              xExponent -= shift - 112 >> 1;\\n            }\\n          }\\n\\n          uint256 r = 0x10000000000000000000000000000;\\n          r = (r + xSignifier / r) >> 1;\\n          r = (r + xSignifier / r) >> 1;\\n          r = (r + xSignifier / r) >> 1;\\n          r = (r + xSignifier / r) >> 1;\\n          r = (r + xSignifier / r) >> 1;\\n          r = (r + xSignifier / r) >> 1;\\n          r = (r + xSignifier / r) >> 1; // Seven iterations should be enough\\n          uint256 r1 = xSignifier / r;\\n          if (r1 < r) r = r1;\\n\\n          return bytes16 (uint128 (xExponent << 112 | r & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF));\\n        }\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate binary logarithm of x.  Return NaN on negative x excluding -0.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function log_2 (bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      if (uint128 (x) > 0x80000000000000000000000000000000) return NaN;\\n      else if (x == 0x3FFF0000000000000000000000000000) return POSITIVE_ZERO; \\n      else {\\n        uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\\n        if (xExponent == 0x7FFF) return x;\\n        else {\\n          uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n          if (xExponent == 0) xExponent = 1;\\n          else xSignifier |= 0x10000000000000000000000000000;\\n\\n          if (xSignifier == 0) return NEGATIVE_INFINITY;\\n\\n          bool resultNegative;\\n          uint256 resultExponent = 16495;\\n          uint256 resultSignifier;\\n\\n          if (xExponent >= 0x3FFF) {\\n            resultNegative = false;\\n            resultSignifier = xExponent - 0x3FFF;\\n            xSignifier <<= 15;\\n          } else {\\n            resultNegative = true;\\n            if (xSignifier >= 0x10000000000000000000000000000) {\\n              resultSignifier = 0x3FFE - xExponent;\\n              xSignifier <<= 15;\\n            } else {\\n              uint256 msb = mostSignificantBit (xSignifier);\\n              resultSignifier = 16493 - msb;\\n              xSignifier <<= 127 - msb;\\n            }\\n          }\\n\\n          if (xSignifier == 0x80000000000000000000000000000000) {\\n            if (resultNegative) resultSignifier += 1;\\n            uint256 shift = 112 - mostSignificantBit (resultSignifier);\\n            resultSignifier <<= shift;\\n            resultExponent -= shift;\\n          } else {\\n            uint256 bb = resultNegative ? 1 : 0;\\n            while (resultSignifier < 0x10000000000000000000000000000) {\\n              resultSignifier <<= 1;\\n              resultExponent -= 1;\\n  \\n              xSignifier *= xSignifier;\\n              uint256 b = xSignifier >> 255;\\n              resultSignifier += b ^ bb;\\n              xSignifier >>= 127 + b;\\n            }\\n          }\\n\\n          return bytes16 (uint128 ((resultNegative ? 0x80000000000000000000000000000000 : 0) |\\n              resultExponent << 112 | resultSignifier & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF));\\n        }\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate natural logarithm of x.  Return NaN on negative x excluding -0.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function ln (bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      return mul (log_2 (x), 0x3FFE62E42FEFA39EF35793C7673007E5);\\n    }\\n  }\\n\\n  /**\\n   * Calculate 2^x.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function pow_2 (bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      bool xNegative = uint128 (x) > 0x80000000000000000000000000000000;\\n      uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\\n      uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      if (xExponent == 0x7FFF && xSignifier != 0) return NaN;\\n      else if (xExponent > 16397)\\n        return xNegative ? POSITIVE_ZERO : POSITIVE_INFINITY;\\n      else if (xExponent < 16255)\\n        return 0x3FFF0000000000000000000000000000;\\n      else {\\n        if (xExponent == 0) xExponent = 1;\\n        else xSignifier |= 0x10000000000000000000000000000;\\n\\n        if (xExponent > 16367)\\n          xSignifier <<= xExponent - 16367;\\n        else if (xExponent < 16367)\\n          xSignifier >>= 16367 - xExponent;\\n\\n        if (xNegative && xSignifier > 0x406E00000000000000000000000000000000)\\n          return POSITIVE_ZERO;\\n\\n        if (!xNegative && xSignifier > 0x3FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\\n          return POSITIVE_INFINITY;\\n\\n        uint256 resultExponent = xSignifier >> 128;\\n        xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (xNegative && xSignifier != 0) {\\n          xSignifier = ~xSignifier;\\n          resultExponent += 1;\\n        }\\n\\n        uint256 resultSignifier = 0x80000000000000000000000000000000;\\n        if (xSignifier & 0x80000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x16A09E667F3BCC908B2FB1366EA957D3E >> 128;\\n        if (xSignifier & 0x40000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1306FE0A31B7152DE8D5A46305C85EDEC >> 128;\\n        if (xSignifier & 0x20000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1172B83C7D517ADCDF7C8C50EB14A791F >> 128;\\n        if (xSignifier & 0x10000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10B5586CF9890F6298B92B71842A98363 >> 128;\\n        if (xSignifier & 0x8000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1059B0D31585743AE7C548EB68CA417FD >> 128;\\n        if (xSignifier & 0x4000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x102C9A3E778060EE6F7CACA4F7A29BDE8 >> 128;\\n        if (xSignifier & 0x2000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10163DA9FB33356D84A66AE336DCDFA3F >> 128;\\n        if (xSignifier & 0x1000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100B1AFA5ABCBED6129AB13EC11DC9543 >> 128;\\n        if (xSignifier & 0x800000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10058C86DA1C09EA1FF19D294CF2F679B >> 128;\\n        if (xSignifier & 0x400000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1002C605E2E8CEC506D21BFC89A23A00F >> 128;\\n        if (xSignifier & 0x200000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100162F3904051FA128BCA9C55C31E5DF >> 128;\\n        if (xSignifier & 0x100000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000B175EFFDC76BA38E31671CA939725 >> 128;\\n        if (xSignifier & 0x80000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100058BA01FB9F96D6CACD4B180917C3D >> 128;\\n        if (xSignifier & 0x40000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10002C5CC37DA9491D0985C348C68E7B3 >> 128;\\n        if (xSignifier & 0x20000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000162E525EE054754457D5995292026 >> 128;\\n        if (xSignifier & 0x10000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000B17255775C040618BF4A4ADE83FC >> 128;\\n        if (xSignifier & 0x8000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000058B91B5BC9AE2EED81E9B7D4CFAB >> 128;\\n        if (xSignifier & 0x4000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100002C5C89D5EC6CA4D7C8ACC017B7C9 >> 128;\\n        if (xSignifier & 0x2000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000162E43F4F831060E02D839A9D16D >> 128;\\n        if (xSignifier & 0x1000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000B1721BCFC99D9F890EA06911763 >> 128;\\n        if (xSignifier & 0x800000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000058B90CF1E6D97F9CA14DBCC1628 >> 128;\\n        if (xSignifier & 0x400000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000002C5C863B73F016468F6BAC5CA2B >> 128;\\n        if (xSignifier & 0x200000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000162E430E5A18F6119E3C02282A5 >> 128;\\n        if (xSignifier & 0x100000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000B1721835514B86E6D96EFD1BFE >> 128;\\n        if (xSignifier & 0x80000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000058B90C0B48C6BE5DF846C5B2EF >> 128;\\n        if (xSignifier & 0x40000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000002C5C8601CC6B9E94213C72737A >> 128;\\n        if (xSignifier & 0x20000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000162E42FFF037DF38AA2B219F06 >> 128;\\n        if (xSignifier & 0x10000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000B17217FBA9C739AA5819F44F9 >> 128;\\n        if (xSignifier & 0x8000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000058B90BFCDEE5ACD3C1CEDC823 >> 128;\\n        if (xSignifier & 0x4000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000002C5C85FE31F35A6A30DA1BE50 >> 128;\\n        if (xSignifier & 0x2000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000162E42FF0999CE3541B9FFFCF >> 128;\\n        if (xSignifier & 0x1000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000B17217F80F4EF5AADDA45554 >> 128;\\n        if (xSignifier & 0x800000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000058B90BFBF8479BD5A81B51AD >> 128;\\n        if (xSignifier & 0x400000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000002C5C85FDF84BD62AE30A74CC >> 128;\\n        if (xSignifier & 0x200000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000162E42FEFB2FED257559BDAA >> 128;\\n        if (xSignifier & 0x100000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000B17217F7D5A7716BBA4A9AE >> 128;\\n        if (xSignifier & 0x80000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000058B90BFBE9DDBAC5E109CCE >> 128;\\n        if (xSignifier & 0x40000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000002C5C85FDF4B15DE6F17EB0D >> 128;\\n        if (xSignifier & 0x20000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000162E42FEFA494F1478FDE05 >> 128;\\n        if (xSignifier & 0x10000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000B17217F7D20CF927C8E94C >> 128;\\n        if (xSignifier & 0x8000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000058B90BFBE8F71CB4E4B33D >> 128;\\n        if (xSignifier & 0x4000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000002C5C85FDF477B662B26945 >> 128;\\n        if (xSignifier & 0x2000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000162E42FEFA3AE53369388C >> 128;\\n        if (xSignifier & 0x1000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000B17217F7D1D351A389D40 >> 128;\\n        if (xSignifier & 0x800000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000058B90BFBE8E8B2D3D4EDE >> 128;\\n        if (xSignifier & 0x400000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000002C5C85FDF4741BEA6E77E >> 128;\\n        if (xSignifier & 0x200000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000162E42FEFA39FE95583C2 >> 128;\\n        if (xSignifier & 0x100000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000B17217F7D1CFB72B45E1 >> 128;\\n        if (xSignifier & 0x80000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000058B90BFBE8E7CC35C3F0 >> 128;\\n        if (xSignifier & 0x40000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000002C5C85FDF473E242EA38 >> 128;\\n        if (xSignifier & 0x20000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000162E42FEFA39F02B772C >> 128;\\n        if (xSignifier & 0x10000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000B17217F7D1CF7D83C1A >> 128;\\n        if (xSignifier & 0x8000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000058B90BFBE8E7BDCBE2E >> 128;\\n        if (xSignifier & 0x4000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000002C5C85FDF473DEA871F >> 128;\\n        if (xSignifier & 0x2000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000162E42FEFA39EF44D91 >> 128;\\n        if (xSignifier & 0x1000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000B17217F7D1CF79E949 >> 128;\\n        if (xSignifier & 0x800000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000058B90BFBE8E7BCE544 >> 128;\\n        if (xSignifier & 0x400000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000002C5C85FDF473DE6ECA >> 128;\\n        if (xSignifier & 0x200000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000162E42FEFA39EF366F >> 128;\\n        if (xSignifier & 0x100000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000B17217F7D1CF79AFA >> 128;\\n        if (xSignifier & 0x80000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000058B90BFBE8E7BCD6D >> 128;\\n        if (xSignifier & 0x40000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000002C5C85FDF473DE6B2 >> 128;\\n        if (xSignifier & 0x20000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000162E42FEFA39EF358 >> 128;\\n        if (xSignifier & 0x10000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000B17217F7D1CF79AB >> 128;\\n        if (xSignifier & 0x8000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000058B90BFBE8E7BCD5 >> 128;\\n        if (xSignifier & 0x4000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000002C5C85FDF473DE6A >> 128;\\n        if (xSignifier & 0x2000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000162E42FEFA39EF34 >> 128;\\n        if (xSignifier & 0x1000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000B17217F7D1CF799 >> 128;\\n        if (xSignifier & 0x800000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000058B90BFBE8E7BCC >> 128;\\n        if (xSignifier & 0x400000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000002C5C85FDF473DE5 >> 128;\\n        if (xSignifier & 0x200000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000162E42FEFA39EF2 >> 128;\\n        if (xSignifier & 0x100000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000B17217F7D1CF78 >> 128;\\n        if (xSignifier & 0x80000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000058B90BFBE8E7BB >> 128;\\n        if (xSignifier & 0x40000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000002C5C85FDF473DD >> 128;\\n        if (xSignifier & 0x20000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000162E42FEFA39EE >> 128;\\n        if (xSignifier & 0x10000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000B17217F7D1CF6 >> 128;\\n        if (xSignifier & 0x8000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000058B90BFBE8E7A >> 128;\\n        if (xSignifier & 0x4000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000002C5C85FDF473C >> 128;\\n        if (xSignifier & 0x2000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000162E42FEFA39D >> 128;\\n        if (xSignifier & 0x1000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000B17217F7D1CE >> 128;\\n        if (xSignifier & 0x800000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000058B90BFBE8E6 >> 128;\\n        if (xSignifier & 0x400000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000002C5C85FDF472 >> 128;\\n        if (xSignifier & 0x200000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000162E42FEFA38 >> 128;\\n        if (xSignifier & 0x100000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000B17217F7D1B >> 128;\\n        if (xSignifier & 0x80000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000058B90BFBE8D >> 128;\\n        if (xSignifier & 0x40000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000002C5C85FDF46 >> 128;\\n        if (xSignifier & 0x20000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000162E42FEFA2 >> 128;\\n        if (xSignifier & 0x10000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000B17217F7D0 >> 128;\\n        if (xSignifier & 0x8000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000058B90BFBE7 >> 128;\\n        if (xSignifier & 0x4000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000002C5C85FDF3 >> 128;\\n        if (xSignifier & 0x2000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000162E42FEF9 >> 128;\\n        if (xSignifier & 0x1000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000B17217F7C >> 128;\\n        if (xSignifier & 0x800000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000058B90BFBD >> 128;\\n        if (xSignifier & 0x400000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000002C5C85FDE >> 128;\\n        if (xSignifier & 0x200000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000162E42FEE >> 128;\\n        if (xSignifier & 0x100000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000B17217F6 >> 128;\\n        if (xSignifier & 0x80000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000058B90BFA >> 128;\\n        if (xSignifier & 0x40000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000002C5C85FC >> 128;\\n        if (xSignifier & 0x20000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000162E42FD >> 128;\\n        if (xSignifier & 0x10000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000B17217E >> 128;\\n        if (xSignifier & 0x8000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000058B90BE >> 128;\\n        if (xSignifier & 0x4000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000002C5C85E >> 128;\\n        if (xSignifier & 0x2000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000162E42E >> 128;\\n        if (xSignifier & 0x1000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000B17216 >> 128;\\n        if (xSignifier & 0x800000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000058B90A >> 128;\\n        if (xSignifier & 0x400000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000002C5C84 >> 128;\\n        if (xSignifier & 0x200000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000162E41 >> 128;\\n        if (xSignifier & 0x100000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000000B1720 >> 128;\\n        if (xSignifier & 0x80000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000058B8F >> 128;\\n        if (xSignifier & 0x40000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000002C5C7 >> 128;\\n        if (xSignifier & 0x20000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000000162E3 >> 128;\\n        if (xSignifier & 0x10000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000000B171 >> 128;\\n        if (xSignifier & 0x8000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000000058B8 >> 128;\\n        if (xSignifier & 0x4000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000002C5B >> 128;\\n        if (xSignifier & 0x2000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000000162D >> 128;\\n        if (xSignifier & 0x1000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000B16 >> 128;\\n        if (xSignifier & 0x800 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000000058A >> 128;\\n        if (xSignifier & 0x400 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000000002C4 >> 128;\\n        if (xSignifier & 0x200 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000161 >> 128;\\n        if (xSignifier & 0x100 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000000000B0 >> 128;\\n        if (xSignifier & 0x80 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000057 >> 128;\\n        if (xSignifier & 0x40 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000000002B >> 128;\\n        if (xSignifier & 0x20 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000015 >> 128;\\n        if (xSignifier & 0x10 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000000000A >> 128;\\n        if (xSignifier & 0x8 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000004 >> 128;\\n        if (xSignifier & 0x4 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000001 >> 128;\\n\\n        if (!xNegative) {\\n          resultSignifier = resultSignifier >> 15 & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n          resultExponent += 0x3FFF;\\n        } else if (resultExponent <= 0x3FFE) {\\n          resultSignifier = resultSignifier >> 15 & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n          resultExponent = 0x3FFF - resultExponent;\\n        } else {\\n          resultSignifier = resultSignifier >> resultExponent - 16367;\\n          resultExponent = 0;\\n        }\\n\\n        return bytes16 (uint128 (resultExponent << 112 | resultSignifier));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate e^x.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function exp (bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      return pow_2 (mul (x, 0x3FFF71547652B82FE1777D0FFDA0D23A));\\n    }\\n  }\\n\\n  /**\\n   * Get index of the most significant non-zero bit in binary representation of\\n   * x.  Reverts if x is zero.\\n   *\\n   * @return index of the most significant non-zero bit in binary representation\\n   *         of x\\n   */\\n  function mostSignificantBit (uint256 x) private pure returns (uint256) {\\n    unchecked {\\n      require (x > 0);\\n\\n      uint256 result = 0;\\n\\n      if (x >= 0x100000000000000000000000000000000) { x >>= 128; result += 128; }\\n      if (x >= 0x10000000000000000) { x >>= 64; result += 64; }\\n      if (x >= 0x100000000) { x >>= 32; result += 32; }\\n      if (x >= 0x10000) { x >>= 16; result += 16; }\\n      if (x >= 0x100) { x >>= 8; result += 8; }\\n      if (x >= 0x10) { x >>= 4; result += 4; }\\n      if (x >= 0x4) { x >>= 2; result += 2; }\\n      if (x >= 0x2) result += 1; // No need to shift x anymore\\n\\n      return result;\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0x9694a9f6fcadd4fa917efa674de42a74b8fbab8d68924f771ea5cc5e1a301434\",\"license\":\"BSD-4-Clause\"},\"contracts/implementation/PoolKeeper.sol\":{\"content\":\"//SPDX-License-Identifier: CC-BY-NC-ND-4.0\\npragma solidity 0.8.7;\\n\\nimport \\\"../interfaces/IPoolKeeper.sol\\\";\\nimport \\\"../interfaces/IOracleWrapper.sol\\\";\\nimport \\\"../interfaces/IPoolFactory.sol\\\";\\nimport \\\"../implementation/PriceObserver.sol\\\";\\nimport \\\"../interfaces/ILeveragedPool.sol\\\";\\nimport \\\"../interfaces/IERC20DecimalsWrapper.sol\\\";\\nimport \\\"./PoolSwapLibrary.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"abdk-libraries-solidity/ABDKMathQuad.sol\\\";\\n\\n/// @title The manager contract for multiple markets and the pools in them\\ncontract PoolKeeper is IPoolKeeper, Ownable {\\n    /* Constants */\\n    uint256 public constant BASE_TIP = 5; // 5% base tip\\n    uint256 public constant TIP_DELTA_PER_BLOCK = 5; // 5% increase per block\\n    uint256 public constant BLOCK_TIME = 13; /* in seconds */\\n    uint256 public constant MAX_DECIMALS = 18;\\n    uint256 public constant MAX_TIP = 100; /* maximum keeper tip */\\n\\n    // #### Global variables\\n    /**\\n     * @notice Format: Pool address => last executionPrice\\n     */\\n    mapping(address => int256) public executionPrice;\\n\\n    IPoolFactory public factory;\\n    bytes16 constant fixedPoint = 0x403abc16d674ec800000000000000000; // 1 ether\\n\\n    uint256 public gasPrice = 10 gwei;\\n\\n    // #### Functions\\n    constructor(address _factory) {\\n        require(_factory != address(0), \\\"Factory cannot be 0 address\\\");\\n        factory = IPoolFactory(_factory);\\n    }\\n\\n    /**\\n     * @notice When a pool is created, this function is called by the factory to initiate price trackings\\n     * @param _poolAddress The address of the newly-created pools\\n     * @dev Only callable by the associated `PoolFactory` contract\\n     */\\n    function newPool(address _poolAddress) external override onlyFactory {\\n        address oracleWrapper = ILeveragedPool(_poolAddress).oracleWrapper();\\n        int256 firstPrice = IOracleWrapper(oracleWrapper).getPrice();\\n        require(firstPrice > 0, \\\"First price is non-positive\\\");\\n        int256 startingPrice = ABDKMathQuad.toInt(ABDKMathQuad.mul(ABDKMathQuad.fromInt(firstPrice), fixedPoint));\\n        emit PoolAdded(_poolAddress, firstPrice);\\n        executionPrice[_poolAddress] = startingPrice;\\n    }\\n\\n    /**\\n     * @notice Check if upkeep is required\\n     * @param _pool The address of the pool to upkeep\\n     * @return Whether or not upkeep is needed for this single pool\\n     */\\n    function checkUpkeepSinglePool(address _pool) public view override returns (bool) {\\n        if (!factory.isValidPool(_pool)) {\\n            return false;\\n        }\\n\\n        // The update interval has passed\\n        return ILeveragedPool(_pool).intervalPassed();\\n    }\\n\\n    /**\\n     * @notice Checks multiple pools if any of them need updating\\n     * @param _pools Array of pools to check\\n     * @return Whether or not at least one pool needs upkeeping\\n     * @dev Iterates over the provided array of pool addresses\\n     */\\n    function checkUpkeepMultiplePools(address[] calldata _pools) external view override returns (bool) {\\n        uint256 poolsLength = _pools.length;\\n        for (uint256 i = 0; i < poolsLength; i++) {\\n            if (checkUpkeepSinglePool(_pools[i])) {\\n                // One has been found that requires upkeeping\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    /**\\n     * @notice Called by keepers to perform an update on a single pool\\n     * @param _pool Address of the pool to be upkept\\n     * @dev Induces an update of the associated `PriceObserver` contract\\n     * @dev Tracks gas usage via `gasleft` accounting and uses this to inform\\n     *          keeper payment\\n     * @dev Catches any failure of the underlying `pool.poolUpkeep` call\\n     */\\n    function performUpkeepSinglePool(address _pool) public override {\\n        uint256 startGas = gasleft();\\n\\n        // validate the pool, check that the interval time has passed\\n        if (!checkUpkeepSinglePool(_pool)) {\\n            return;\\n        }\\n\\n        ILeveragedPool pool = ILeveragedPool(_pool);\\n\\n        /* update SMA oracle, does nothing for spot oracles */\\n        IOracleWrapper poolOracleWrapper = IOracleWrapper(pool.oracleWrapper());\\n        poolOracleWrapper.poll();\\n\\n        (int256 latestPrice, bytes memory data, uint256 savedPreviousUpdatedTimestamp, uint256 updateInterval) = pool\\n            .getUpkeepInformation();\\n\\n        // Start a new round\\n        // Get price in WAD format\\n        int256 lastExecutionPrice = executionPrice[_pool];\\n        executionPrice[_pool] = latestPrice;\\n\\n        // This allows us to still batch multiple calls to executePriceChange, even if some are invalid\\n        // Without reverting the entire transaction\\n        try pool.poolUpkeep(lastExecutionPrice, latestPrice) {\\n            // If poolUpkeep is successful, refund the keeper for their gas costs\\n            uint256 gasSpent = startGas - gasleft();\\n\\n            payKeeper(_pool, gasPrice, gasSpent, savedPreviousUpdatedTimestamp, updateInterval);\\n            emit UpkeepSuccessful(_pool, data, lastExecutionPrice, latestPrice);\\n        } catch Error(string memory reason) {\\n            // If poolUpkeep fails for any other reason, emit event\\n            emit PoolUpkeepError(_pool, reason);\\n        }\\n    }\\n\\n    /**\\n     * @notice Called by keepers to perform an update on multiple pools\\n     * @param pools Addresses of each pool to upkeep\\n     * @dev Iterates over the provided array\\n     * @dev Essentially wraps calls to `performUpkeepSinglePool`\\n     */\\n    function performUpkeepMultiplePools(address[] calldata pools) external override {\\n        uint256 poolsLength = pools.length;\\n        for (uint256 i = 0; i < poolsLength; i++) {\\n            performUpkeepSinglePool(pools[i]);\\n        }\\n    }\\n\\n    /**\\n     * @notice Pay keeper for upkeep\\n     * @param _pool Address of the given pool\\n     * @param _gasPrice Price of a single gas unit (in ETH (wei))\\n     * @param _gasSpent Number of gas units spent\\n     * @param _savedPreviousUpdatedTimestamp Last timestamp when the pool's price execution happened\\n     * @param _updateInterval Pool interval of the given pool\\n     * @dev Emits a `KeeperPaid` event if the underlying call to `pool.payKeeperFromBalances` succeeds\\n     * @dev Emits a `KeeperPaymentError` event otherwise\\n     */\\n    function payKeeper(\\n        address _pool,\\n        uint256 _gasPrice,\\n        uint256 _gasSpent,\\n        uint256 _savedPreviousUpdatedTimestamp,\\n        uint256 _updateInterval\\n    ) internal {\\n        uint256 reward = keeperReward(_pool, _gasPrice, _gasSpent, _savedPreviousUpdatedTimestamp, _updateInterval);\\n        if (ILeveragedPool(_pool).payKeeperFromBalances(msg.sender, reward)) {\\n            emit KeeperPaid(_pool, msg.sender, reward);\\n        } else {\\n            // Usually occurs if pool just started and does not have any funds\\n            emit KeeperPaymentError(_pool, msg.sender, reward);\\n        }\\n    }\\n\\n    /**\\n     * @notice Payment keeper receives for performing upkeep on a given pool\\n     * @param _pool Address of the given pool\\n     * @param _gasPrice Price of a single gas unit (in ETH (wei))\\n     * @param _gasSpent Number of gas units spent\\n     * @param _savedPreviousUpdatedTimestamp Last timestamp when the pool's price execution happened\\n     * @param _poolInterval Pool interval of the given pool\\n     * @return Number of settlement tokens to give to the keeper for work performed\\n     */\\n    function keeperReward(\\n        address _pool,\\n        uint256 _gasPrice,\\n        uint256 _gasSpent,\\n        uint256 _savedPreviousUpdatedTimestamp,\\n        uint256 _poolInterval\\n    ) public view returns (uint256) {\\n        /**\\n         * Conceptually, we have\\n         *\\n         * Reward = Gas + Tip = Gas + (Base + Premium * Blocks)\\n         *\\n         * Very roughly to scale:\\n         *\\n         * +---------------------------+------+---+---+~~~~~\\n         * | GGGGGGGGGGGGGGGGGGGGGGGGG | BBBB | P | P | ...\\n         * +---------------------------+------+---+---+~~~~~\\n         *\\n         * Under normal circumstances, we don't expect there to be any time\\n         * premium at all. The time premium exists in order to *further*\\n         * incentivise upkeep in the event of lateness.\\n         *\\n         * The base tip exists to act as pure profit for a keeper.\\n         *\\n         * Of course, the gas component acts as compensation for performing\\n         * on-chain computation.\\n         *\\n         */\\n\\n        // keeper gas cost in wei. WAD formatted\\n        uint256 _keeperGas = keeperGas(_pool, _gasPrice, _gasSpent);\\n\\n        // tip percent in wad units\\n        bytes16 _tipPercent = ABDKMathQuad.fromUInt(keeperTip(_savedPreviousUpdatedTimestamp, _poolInterval));\\n\\n        // amount of settlement tokens to give to the keeper\\n        _tipPercent = ABDKMathQuad.div(_tipPercent, ABDKMathQuad.fromUInt(100));\\n        int256 wadRewardValue = ABDKMathQuad.toInt(\\n            ABDKMathQuad.add(\\n                ABDKMathQuad.fromUInt(_keeperGas),\\n                ABDKMathQuad.div((ABDKMathQuad.mul(ABDKMathQuad.fromUInt(_keeperGas), _tipPercent)), fixedPoint)\\n            )\\n        );\\n        uint256 decimals = IERC20DecimalsWrapper(ILeveragedPool(_pool).quoteToken()).decimals();\\n        uint256 deWadifiedReward = PoolSwapLibrary.fromWad(uint256(wadRewardValue), decimals);\\n        // _keeperGas + _keeperGas * percentTip\\n        return deWadifiedReward;\\n    }\\n\\n    /**\\n     * @notice Compensation a keeper will receive for their gas expenditure\\n     * @param _pool Address of the given pool\\n     * @param _gasPrice Price of a single gas unit (in ETH (wei))\\n     * @param _gasSpent Number of gas units spent\\n     * @return Keeper's gas compensation\\n     */\\n    function keeperGas(\\n        address _pool,\\n        uint256 _gasPrice,\\n        uint256 _gasSpent\\n    ) public view returns (uint256) {\\n        int256 settlementTokenPrice = IOracleWrapper(ILeveragedPool(_pool).settlementEthOracle()).getPrice();\\n\\n        if (settlementTokenPrice <= 0) {\\n            return 0;\\n        } else {\\n            /* safe due to explicit bounds check above */\\n            /* (wei * Settlement / ETH) / fixed point (10^18) = amount in settlement */\\n            bytes16 _weiSpent = ABDKMathQuad.fromUInt(_gasPrice * _gasSpent);\\n            bytes16 _settlementTokenPrice = ABDKMathQuad.fromUInt(uint256(settlementTokenPrice));\\n            return\\n                ABDKMathQuad.toUInt(ABDKMathQuad.div(ABDKMathQuad.mul(_weiSpent, _settlementTokenPrice), fixedPoint));\\n        }\\n    }\\n\\n    /**\\n     * @notice Tip a keeper will receive for successfully updating the specified pool\\n     * @param _savedPreviousUpdatedTimestamp Last timestamp when the pool's price execution happened\\n     * @param _poolInterval Pool interval of the given pool\\n     * @return Percent of the `keeperGas` cost to add to payment, as a percent\\n     */\\n    function keeperTip(uint256 _savedPreviousUpdatedTimestamp, uint256 _poolInterval) public view returns (uint256) {\\n        /* the number of blocks that have elapsed since the given pool's updateInterval passed */\\n        uint256 elapsedBlocksNumerator = (block.timestamp - (_savedPreviousUpdatedTimestamp + _poolInterval));\\n\\n        uint256 keeperTip = BASE_TIP + (TIP_DELTA_PER_BLOCK * elapsedBlocksNumerator) / BLOCK_TIME;\\n\\n        // In case of network outages or otherwise, we want to cap the tip so that the keeper cost isn't unbounded\\n        if (keeperTip > MAX_TIP) {\\n            return MAX_TIP;\\n        } else {\\n            return keeperTip;\\n        }\\n    }\\n\\n    /**\\n     * @notice Sets the address of the associated `PoolFactory` contract\\n     * @param _factory Address of the `PoolFactory` contract\\n     * @dev Only callable by the owner\\n     */\\n    function setFactory(address _factory) external override onlyOwner {\\n        factory = IPoolFactory(_factory);\\n    }\\n\\n    /**\\n     * @notice Sets the gas price to be used in compensating keepers for successful upkeep\\n     * @param _price Price (in ETH) per unit gas\\n     * @dev Only callable by the owner\\n     * @dev This function is only necessary due to the L2 deployment of Pools -- in reality, it should be `BASEFEE`\\n     */\\n    function setGasPrice(uint256 _price) external onlyOwner {\\n        gasPrice = _price;\\n    }\\n\\n    /**\\n     * @notice Ensures that the caller is the associated `PoolFactory` contract\\n     */\\n    modifier onlyFactory() {\\n        require(msg.sender == address(factory), \\\"Caller not factory\\\");\\n        _;\\n    }\\n}\\n\",\"keccak256\":\"0x13a710f3d3d3a4d96fed1af9b7f5bb86c3273b7f2f0c3ad07361841c9b88ce32\",\"license\":\"CC-BY-NC-ND-4.0\"},\"contracts/implementation/PoolSwapLibrary.sol\":{\"content\":\"//SPDX-License-Identifier: CC-BY-NC-ND-4.0\\npragma solidity 0.8.7;\\n\\nimport \\\"abdk-libraries-solidity/ABDKMathQuad.sol\\\";\\n\\n/// @title Library for various useful (mostly) mathematical functions\\nlibrary PoolSwapLibrary {\\n    /// ABDKMathQuad-formatted representation of the number one\\n    bytes16 public constant one = 0x3fff0000000000000000000000000000;\\n\\n    /// Maximum number of decimal places supported by this contract\\n    /// (ABDKMathQuad defines this but it's private)\\n    uint256 public constant MAX_DECIMALS = 18;\\n\\n    /// Maximum precision supportable via wad arithmetic (for this contract)\\n    uint256 public constant WAD_PRECISION = 10**18;\\n\\n    /// Information required to update a given user's aggregated balance\\n    struct UpdateData {\\n        bytes16 longPrice;\\n        bytes16 shortPrice;\\n        uint256 currentUpdateIntervalId;\\n        uint256 updateIntervalId;\\n        uint256 longMintAmount;\\n        uint256 longBurnAmount;\\n        uint256 shortMintAmount;\\n        uint256 shortBurnAmount;\\n        uint256 longBurnShortMintAmount;\\n        uint256 shortBurnLongMintAmount;\\n        bytes16 burnFee;\\n    }\\n\\n    /// Information required to perform a price change (of the underlying asset)\\n    struct PriceChangeData {\\n        int256 oldPrice;\\n        int256 newPrice;\\n        uint256 longBalance;\\n        uint256 shortBalance;\\n        bytes16 leverageAmount;\\n        bytes16 fee;\\n    }\\n\\n    /**\\n     * @notice Calculates the ratio between two numbers\\n     * @dev Rounds any overflow towards 0. If either parameter is zero, the ratio is 0\\n     * @param _numerator The \\\"parts per\\\" side of the equation. If this is zero, the ratio is zero\\n     * @param _denominator The \\\"per part\\\" side of the equation. If this is zero, the ratio is zero\\n     * @return the ratio, as an ABDKMathQuad number (IEEE 754 quadruple precision floating point)\\n     */\\n    function getRatio(uint256 _numerator, uint256 _denominator) public pure returns (bytes16) {\\n        // Catch the divide by zero error.\\n        if (_denominator == 0) {\\n            return 0;\\n        }\\n        return ABDKMathQuad.div(ABDKMathQuad.fromUInt(_numerator), ABDKMathQuad.fromUInt(_denominator));\\n    }\\n\\n    /**\\n     * @notice Multiplies two numbers\\n     * @param x The number to be multiplied by `y`\\n     * @param y The number to be multiplied by `x`\\n     */\\n    function multiplyBytes(bytes16 x, bytes16 y) external pure returns (bytes16) {\\n        return ABDKMathQuad.mul(x, y);\\n    }\\n\\n    /**\\n     * @notice Performs a subtraction on two bytes16 numbers\\n     * @param x The number to be subtracted by `y`\\n     * @param y The number to subtract from `x`\\n     */\\n    function subtractBytes(bytes16 x, bytes16 y) external pure returns (bytes16) {\\n        return ABDKMathQuad.sub(x, y);\\n    }\\n\\n    /**\\n     * @notice Performs an addition on two bytes16 numbers\\n     * @param x The number to be added with `y`\\n     * @param y The number to be added with `x`\\n     */\\n    function addBytes(bytes16 x, bytes16 y) external pure returns (bytes16) {\\n        return ABDKMathQuad.add(x, y);\\n    }\\n\\n    /**\\n     * @notice Gets the short and long balances after the keeper rewards have been paid out\\n     *         Keeper rewards are paid proportionally to the short and long pool\\n     * @dev Assumes shortBalance + longBalance >= reward\\n     * @param reward Amount of keeper reward\\n     * @param shortBalance Short balance of the pool\\n     * @param longBalance Long balance of the pool\\n     * @return shortBalanceAfterFees Short balance of the pool after the keeper reward has been paid\\n     * @return longBalanceAfterFees Long balance of the pool after the keeper reward has been paid\\n     */\\n    function getBalancesAfterFees(\\n        uint256 reward,\\n        uint256 shortBalance,\\n        uint256 longBalance\\n    ) external pure returns (uint256, uint256) {\\n        bytes16 ratioShort = getRatio(shortBalance, shortBalance + longBalance);\\n\\n        uint256 shortFees = convertDecimalToUInt(multiplyDecimalByUInt(ratioShort, reward));\\n\\n        uint256 shortBalanceAfterFees = shortBalance - shortFees;\\n        uint256 longBalanceAfterFees = longBalance - (reward - shortFees);\\n\\n        // Return shortBalance and longBalance after rewards are paid out\\n        return (shortBalanceAfterFees, longBalanceAfterFees);\\n    }\\n\\n    /**\\n     * @notice Compares two decimal numbers\\n     * @param x The first number to compare\\n     * @param y The second number to compare\\n     * @return -1 if x < y, 0 if x = y, or 1 if x > y\\n     */\\n    function compareDecimals(bytes16 x, bytes16 y) public pure returns (int8) {\\n        return ABDKMathQuad.cmp(x, y);\\n    }\\n\\n    /**\\n     * @notice Converts an integer value to a compatible decimal value\\n     * @param amount The amount to convert\\n     * @return The amount as a IEEE754 quadruple precision number\\n     */\\n    function convertUIntToDecimal(uint256 amount) external pure returns (bytes16) {\\n        return ABDKMathQuad.fromUInt(amount);\\n    }\\n\\n    /**\\n     * @notice Converts a raw decimal value to a more readable uint256 value\\n     * @param ratio The value to convert\\n     * @return The converted value\\n     */\\n    function convertDecimalToUInt(bytes16 ratio) public pure returns (uint256) {\\n        return ABDKMathQuad.toUInt(ratio);\\n    }\\n\\n    /**\\n     * @notice Multiplies a decimal and an unsigned integer\\n     * @param a The first term\\n     * @param b The second term\\n     * @return The product of a*b as a decimal\\n     */\\n    function multiplyDecimalByUInt(bytes16 a, uint256 b) public pure returns (bytes16) {\\n        return ABDKMathQuad.mul(a, ABDKMathQuad.fromUInt(b));\\n    }\\n\\n    /**\\n     * @notice Divides two unsigned integers\\n     * @param a The dividend\\n     * @param b The divisor\\n     * @return The quotient\\n     */\\n    function divUInt(uint256 a, uint256 b) private pure returns (bytes16) {\\n        return ABDKMathQuad.div(ABDKMathQuad.fromUInt(a), ABDKMathQuad.fromUInt(b));\\n    }\\n\\n    /**\\n     * @notice Divides two integers\\n     * @param a The dividend\\n     * @param b The divisor\\n     * @return The quotient\\n     */\\n    function divInt(int256 a, int256 b) public pure returns (bytes16) {\\n        return ABDKMathQuad.div(ABDKMathQuad.fromInt(a), ABDKMathQuad.fromInt(b));\\n    }\\n\\n    /**\\n     * @notice Multiply an integer by a fraction\\n     * @return The result as an integer\\n     */\\n    function mulFraction(\\n        uint256 number,\\n        uint256 numerator,\\n        uint256 denominator\\n    ) public pure returns (uint256) {\\n        if (denominator == 0) {\\n            return 0;\\n        }\\n        bytes16 multiplyResult = ABDKMathQuad.mul(ABDKMathQuad.fromUInt(number), ABDKMathQuad.fromUInt(numerator));\\n        bytes16 result = ABDKMathQuad.div(multiplyResult, ABDKMathQuad.fromUInt(denominator));\\n        return convertDecimalToUInt(result);\\n    }\\n\\n    /**\\n     * @notice Calculates the loss multiplier to apply to the losing pool. Includes the power leverage\\n     * @param ratio The ratio of new price to old price\\n     * @param direction The direction of the change. -1 if it's decreased, 0 if it hasn't changed, and 1 if it's increased\\n     * @param leverage The amount of leverage to apply\\n     * @return The multiplier\\n     */\\n    function getLossMultiplier(\\n        bytes16 ratio,\\n        int8 direction,\\n        bytes16 leverage\\n    ) public pure returns (bytes16) {\\n        // If decreased:  2 ^ (leverage * log2[(1 * new/old) + [(0 * 1) / new/old]])\\n        //              = 2 ^ (leverage * log2[(new/old)])\\n        // If increased:  2 ^ (leverage * log2[(0 * new/old) + [(1 * 1) / new/old]])\\n        //              = 2 ^ (leverage * log2([1 / new/old]))\\n        //              = 2 ^ (leverage * log2([old/new]))\\n        return\\n            ABDKMathQuad.pow_2(\\n                ABDKMathQuad.mul(leverage, ABDKMathQuad.log_2(direction < 0 ? ratio : ABDKMathQuad.div(one, ratio)))\\n            );\\n    }\\n\\n    /**\\n     * @notice Calculates the amount to take from the losing pool\\n     * @param lossMultiplier The multiplier to use\\n     * @param balance The balance of the losing pool\\n     */\\n    function getLossAmount(bytes16 lossMultiplier, uint256 balance) public pure returns (uint256) {\\n        return\\n            ABDKMathQuad.toUInt(\\n                ABDKMathQuad.mul(ABDKMathQuad.sub(one, lossMultiplier), ABDKMathQuad.fromUInt(balance))\\n            );\\n    }\\n\\n    /**\\n     * @notice Calculates the effect of a price change. This involves calculating how many funds to transfer from the losing pool to the other.\\n     * @dev This function should be called by the LeveragedPool.\\n     * @param priceChange The struct containing necessary data to calculate price change\\n     * @return Resulting long balance\\n     * @return Resulting short balance\\n     * @return Resulting fees taken from long balance\\n     * @return Resulting fees taken from short balance\\n     */\\n    function calculatePriceChange(PriceChangeData calldata priceChange)\\n        external\\n        pure\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        uint256 shortBalance = priceChange.shortBalance;\\n        uint256 longBalance = priceChange.longBalance;\\n        bytes16 leverageAmount = priceChange.leverageAmount;\\n        int256 oldPrice = priceChange.oldPrice;\\n        int256 newPrice = priceChange.newPrice;\\n        bytes16 fee = priceChange.fee;\\n\\n        // Calculate fees from long and short sides\\n        uint256 longFeeAmount = convertDecimalToUInt(multiplyDecimalByUInt(fee, longBalance)) /\\n            PoolSwapLibrary.WAD_PRECISION;\\n        uint256 shortFeeAmount = convertDecimalToUInt(multiplyDecimalByUInt(fee, shortBalance)) /\\n            PoolSwapLibrary.WAD_PRECISION;\\n\\n        shortBalance = shortBalance - shortFeeAmount;\\n        longBalance = longBalance - longFeeAmount;\\n\\n        // Use the ratio to determine if the price increased or decreased and therefore which direction\\n        // the funds should be transferred towards.\\n\\n        bytes16 ratio = divInt(newPrice, oldPrice);\\n        int8 direction = compareDecimals(ratio, PoolSwapLibrary.one);\\n        // Take into account the leverage\\n        bytes16 lossMultiplier = getLossMultiplier(ratio, direction, leverageAmount);\\n\\n        if (direction >= 0 && shortBalance > 0) {\\n            // Move funds from short to long pair\\n            uint256 lossAmount = getLossAmount(lossMultiplier, shortBalance);\\n            shortBalance = shortBalance - lossAmount;\\n            longBalance = longBalance + lossAmount;\\n        } else if (direction < 0 && longBalance > 0) {\\n            // Move funds from long to short pair\\n            uint256 lossAmount = getLossAmount(lossMultiplier, longBalance);\\n            shortBalance = shortBalance + lossAmount;\\n            longBalance = longBalance - lossAmount;\\n        }\\n\\n        return (longBalance, shortBalance, longFeeAmount, shortFeeAmount);\\n    }\\n\\n    /**\\n     * @notice Returns true if the given timestamp is BEFORE the frontRunningInterval starts,\\n     *         which is allowed for uncommitment.\\n     * @dev If you try to uncommit AFTER the frontRunningInterval, it should revert.\\n     * @param subjectTime The timestamp for which you want to calculate if it was beforeFrontRunningInterval\\n     * @param lastPriceTimestamp The timestamp of the last price update\\n     * @param updateInterval The interval between price updates\\n     * @param frontRunningInterval The window of time before a price udpate users can not uncommit or have their commit executed from\\n     */\\n    function isBeforeFrontRunningInterval(\\n        uint256 subjectTime,\\n        uint256 lastPriceTimestamp,\\n        uint256 updateInterval,\\n        uint256 frontRunningInterval\\n    ) public pure returns (bool) {\\n        return lastPriceTimestamp + updateInterval - frontRunningInterval > subjectTime;\\n    }\\n\\n    /**\\n     * @notice Calculates the update interval ID that a commitment should be placed in.\\n     * @param timestamp Current block.timestamp\\n     * @param lastPriceTimestamp The timestamp of the last price update\\n     * @param frontRunningInterval The frontrunning interval of a pool - The amount of time before an update interval that you must commit to get included in that update\\n     * @param updateInterval The frequency of a pool's updates\\n     * @param currentUpdateIntervalId The current update interval's ID\\n     * @dev Note that the timestamp parameter is required to be >= lastPriceTimestamp\\n     * @return The update interval ID in which a commit being made at time timestamp should be included\\n     */\\n    function appropriateUpdateIntervalId(\\n        uint256 timestamp,\\n        uint256 lastPriceTimestamp,\\n        uint256 frontRunningInterval,\\n        uint256 updateInterval,\\n        uint256 currentUpdateIntervalId\\n    ) external pure returns (uint256) {\\n        // Since lastPriceTimestamp <= block.timestamp, the below also confirms that timestamp >= block.timestamp\\n        require(timestamp >= lastPriceTimestamp, \\\"timestamp in the past\\\");\\n        if (frontRunningInterval <= updateInterval) {\\n            // This is the \\\"simple\\\" case where we either want the current update interval or the next one\\n            if (isBeforeFrontRunningInterval(timestamp, lastPriceTimestamp, updateInterval, frontRunningInterval)) {\\n                // We are before the frontRunning interval\\n                return currentUpdateIntervalId;\\n            } else {\\n                return currentUpdateIntervalId + 1;\\n            }\\n        } else {\\n            // frontRunningInterval > updateInterval\\n            // This is the generalised case, where it could be any number of update intervals in the future\\n            uint256 factorDifference = ABDKMathQuad.toUInt(divUInt(frontRunningInterval, updateInterval));\\n            uint256 timeOfNextAvailableInterval = lastPriceTimestamp + (updateInterval * (factorDifference + 1));\\n            // frontRunningInterval is factorDifference times larger than updateInterval\\n            uint256 minimumUpdateIntervalId = currentUpdateIntervalId + factorDifference;\\n            // but, if timestamp is still within minimumUpdateInterval's frontRunningInterval we need to go to the next one\\n            return\\n                timestamp + frontRunningInterval > timeOfNextAvailableInterval\\n                    ? minimumUpdateIntervalId + 1\\n                    : minimumUpdateIntervalId;\\n        }\\n    }\\n\\n    /**\\n     * @notice Gets the number of settlement tokens to be withdrawn based on a pool token burn amount\\n     * @dev Calculates as `balance * amountIn / (tokenSupply + shadowBalance)\\n     * @param tokenSupply Total supply of pool tokens\\n     * @param amountIn Commitment amount of pool tokens going into the pool\\n     * @param balance Balance of the pool (no. of underlying collateral tokens in pool)\\n     * @param shadowBalance Balance the shadow pool at time of mint\\n     * @return Number of settlement tokens to be withdrawn on a burn\\n     */\\n    function getWithdrawAmountOnBurn(\\n        uint256 tokenSupply,\\n        uint256 amountIn,\\n        uint256 balance,\\n        uint256 shadowBalance\\n    ) external pure returns (uint256) {\\n        // Catch the divide by zero error, or return 0 if amountIn is 0\\n        if ((balance == 0) || (tokenSupply + shadowBalance == 0) || (amountIn == 0)) {\\n            return amountIn;\\n        }\\n        bytes16 numerator = ABDKMathQuad.mul(ABDKMathQuad.fromUInt(balance), ABDKMathQuad.fromUInt(amountIn));\\n        return ABDKMathQuad.toUInt(ABDKMathQuad.div(numerator, ABDKMathQuad.fromUInt(tokenSupply + shadowBalance)));\\n    }\\n\\n    /**\\n     * @notice Gets the number of pool tokens to be minted based on existing tokens\\n     * @dev Calculated as (tokenSupply + shadowBalance) * amountIn / balance\\n     * @param tokenSupply Total supply of pool tokens\\n     * @param amountIn Commitment amount of collateral tokens going into the pool\\n     * @param balance Balance of the pool (no. of underlying collateral tokens in pool)\\n     * @param shadowBalance Balance the shadow pool at time of mint\\n     * @return Number of pool tokens to be minted\\n     */\\n    function getMintAmount(\\n        uint256 tokenSupply,\\n        uint256 amountIn,\\n        uint256 balance,\\n        uint256 shadowBalance\\n    ) external pure returns (uint256) {\\n        // Catch the divide by zero error, or return 0 if amountIn is 0\\n        if (balance == 0 || tokenSupply + shadowBalance == 0 || amountIn == 0) {\\n            return amountIn;\\n        }\\n\\n        bytes16 numerator = ABDKMathQuad.mul(\\n            ABDKMathQuad.fromUInt(tokenSupply + shadowBalance),\\n            ABDKMathQuad.fromUInt(amountIn)\\n        );\\n        return ABDKMathQuad.toUInt(ABDKMathQuad.div(numerator, ABDKMathQuad.fromUInt(balance)));\\n    }\\n\\n    /**\\n     * @notice Get the Settlement/PoolToken price, in ABDK IEE754 precision\\n     * @dev Divide the side balance by the pool token's total supply\\n     * @param sideBalance no. of underlying collateral tokens on that side of the pool\\n     * @param tokenSupply Total supply of pool tokens\\n     */\\n    function getPrice(uint256 sideBalance, uint256 tokenSupply) external pure returns (bytes16) {\\n        if (tokenSupply == 0) {\\n            return one;\\n        }\\n        return ABDKMathQuad.div(ABDKMathQuad.fromUInt(sideBalance), ABDKMathQuad.fromUInt(tokenSupply));\\n    }\\n\\n    /**\\n     * @notice Calculates the number of pool tokens to mint, given some settlement token amount and a price\\n     * @param price Price of a pool token\\n     * @param amount Amount of settlement tokens being used to mint\\n     * @return Quantity of pool tokens to mint\\n     * @dev Throws if price is zero\\n     * @dev `getBurn()`\\n     */\\n    function getMint(bytes16 price, uint256 amount) public pure returns (uint256) {\\n        require(price != 0, \\\"price == 0\\\");\\n        return ABDKMathQuad.toUInt(ABDKMathQuad.div(ABDKMathQuad.fromUInt(amount), price));\\n    }\\n\\n    /**\\n     * @notice Calculate the number of settlement tokens to burn, based on a price and an amount of pool tokens\\n     * @param price Price of a pool token\\n     * @param amount Amount of settlement tokens being used to burn\\n     * @return Quantity of pool tokens to burn\\n     * @dev amount * price, where amount is in PoolToken and price is in USD/PoolToken\\n     * @dev Throws if price is zero\\n     * @dev `getMint()`\\n     */\\n    function getBurn(bytes16 price, uint256 amount) public pure returns (uint256) {\\n        require(price != 0, \\\"price == 0\\\");\\n        return ABDKMathQuad.toUInt(ABDKMathQuad.mul(ABDKMathQuad.fromUInt(amount), price));\\n    }\\n\\n    /**\\n     * @notice Calculate the number of pool tokens to mint, given some settlement token amount, a price, and a burn amount from other side for instant mint\\n     * @param price The price of a pool token\\n     * @param amount The amount of settlement tokens being used to mint\\n     * @param oppositePrice The price of the opposite side's pool token\\n     * @param amountBurnedInstantMint The amount of pool tokens that were burnt from the opposite side for an instant mint in this side\\n     * @return Quantity of pool tokens to mint\\n     * @dev Throws if price is zero\\n     */\\n    function getMintWithBurns(\\n        bytes16 price,\\n        bytes16 oppositePrice,\\n        uint256 amount,\\n        uint256 amountBurnedInstantMint\\n    ) public pure returns (uint256) {\\n        require(price != 0, \\\"price == 0\\\");\\n        if (amountBurnedInstantMint > 0) {\\n            // Calculate amount of settlement tokens generated from the burn.\\n            amount += getBurn(oppositePrice, amountBurnedInstantMint);\\n        }\\n        return getMint(price, amount);\\n    }\\n\\n    /**\\n     * @notice Converts from a WAD to normal value\\n     * @param _wadValue wad number\\n     * @param _decimals Quantity of decimal places to support\\n     * @return Converted (non-WAD) value\\n     */\\n    function fromWad(uint256 _wadValue, uint256 _decimals) external pure returns (uint256) {\\n        uint256 scaler = 10**(MAX_DECIMALS - _decimals);\\n        return _wadValue / scaler;\\n    }\\n\\n    /**\\n     * @notice Calculate the change in a user's balance based on recent commit(s)\\n     * @param data Information needed for updating the balance including prices and recent commit amounts\\n     * @return _newLongTokens Quantity of additional long tokens the user would receive\\n     * @return _newShortTokens Quantity of additional short tokens the user would receive\\n     * @return _longBurnFee Quantity of settlement tokens taken as a fee from long burns\\n     * @return _shortBurnFee Quantity of settlement tokens taken as a fee from short burns\\n     * @return _newSettlementTokens Quantity of additional settlement tokens the user would receive\\n     */\\n    function getUpdatedAggregateBalance(UpdateData calldata data)\\n        external\\n        pure\\n        returns (\\n            uint256 _newLongTokens,\\n            uint256 _newShortTokens,\\n            uint256 _longBurnFee,\\n            uint256 _shortBurnFee,\\n            uint256 _newSettlementTokens\\n        )\\n    {\\n        if (data.updateIntervalId == data.currentUpdateIntervalId) {\\n            // Update interval has not passed: No change\\n            return (0, 0, 0, 0, 0);\\n        }\\n        uint256 longBurnResult; // The amount of settlement tokens to withdraw based on long token burn\\n        uint256 shortBurnResult; // The amount of settlement tokens to withdraw based on short token burn\\n        if (data.longMintAmount > 0 || data.shortBurnLongMintAmount > 0) {\\n            _newLongTokens = getMintWithBurns(\\n                data.longPrice,\\n                data.shortPrice,\\n                data.longMintAmount,\\n                data.shortBurnLongMintAmount\\n            );\\n        }\\n\\n        if (data.longBurnAmount > 0) {\\n            // Calculate the amount of settlement tokens earned from burning long tokens\\n            longBurnResult = getBurn(data.longPrice, data.longBurnAmount);\\n            // Calculate the fee\\n            _longBurnFee = convertDecimalToUInt(multiplyDecimalByUInt(data.burnFee, longBurnResult)) / WAD_PRECISION;\\n            // Subtract the fee from settlement token amount\\n            longBurnResult -= _longBurnFee;\\n        }\\n\\n        if (data.shortMintAmount > 0 || data.longBurnShortMintAmount > 0) {\\n            _newShortTokens = getMintWithBurns(\\n                data.shortPrice,\\n                data.longPrice,\\n                data.shortMintAmount,\\n                data.longBurnShortMintAmount\\n            );\\n        }\\n\\n        if (data.shortBurnAmount > 0) {\\n            // Calculate the amount of settlement tokens earned from burning short tokens\\n            shortBurnResult = getBurn(data.shortPrice, data.shortBurnAmount);\\n            // Calculate the fee\\n            _shortBurnFee = convertDecimalToUInt(multiplyDecimalByUInt(data.burnFee, shortBurnResult)) / WAD_PRECISION;\\n            // Subtract the fee from settlement token amount\\n            shortBurnResult -= _shortBurnFee;\\n        }\\n\\n        _newSettlementTokens = shortBurnResult + longBurnResult;\\n    }\\n}\\n\",\"keccak256\":\"0xf804145c92e348fe1f92169040b01fbf5f97c9e2d60869d20811090dac402a70\",\"license\":\"CC-BY-NC-ND-4.0\"},\"contracts/implementation/PriceObserver.sol\":{\"content\":\"//SPDX-License-Identifier: CC-BY-NC-ND-4.0\\npragma solidity 0.8.7;\\n\\nimport \\\"../interfaces/IPriceObserver.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\n/// Stores a finite sequence of price observations\\ncontract PriceObserver is Ownable, IPriceObserver {\\n    /// Maximum number of elements storable by the backing array\\n    uint256 public constant MAX_NUM_ELEMS = 24;\\n\\n    /// Current number of elements stored by the backing array\\n    uint256 public numElems = 0;\\n\\n    /// Backing array for storing price data\\n    int256[MAX_NUM_ELEMS] public observations;\\n\\n    /// Writer -- only address allowed to add data to the backing array\\n    address writer = address(0);\\n\\n    /**\\n     * @notice Returns the capacity of the backing array (i.e., the maximum\\n     *          number of price observations able to be stored by this contract)\\n     * @return Maximum number of price observations that can be stored\\n     * @dev `MAX_NUM_ELEMS`\\n     */\\n    function capacity() public pure override returns (uint256) {\\n        return MAX_NUM_ELEMS;\\n    }\\n\\n    /**\\n     * @notice Returns the current number of price observations stored\\n     * @return Current number of price observations stored\\n     * @dev Should always be less than or equal to `capacity`\\n     * @dev `numElems`\\n     */\\n    function length() public view override returns (uint256) {\\n        return numElems;\\n    }\\n\\n    /**\\n     * @notice Retrieves the `i`th price observation\\n     * @param i Period to retrieve the price observation of\\n     * @return `i`th price observation\\n     * @dev Throws if index is out of bounds (i.e., `i >= length()`)\\n     */\\n    function get(uint256 i) public view override returns (int256) {\\n        require(i < length(), \\\"PO: Out of bounds\\\");\\n        return observations[i];\\n    }\\n\\n    /**\\n     * @notice Retrieves all price observations\\n     * @return Backing array of all price observations\\n     * @dev Note that, due to this view simply returning a reference to the\\n     *      backing array, it's possible for there to be null prices (i.e., 0)\\n     */\\n    function getAll() public view override returns (int256[24] memory) {\\n        return observations;\\n    }\\n\\n    /**\\n     * @notice Adds a new price observation to the contract\\n     * @param x Price\\n     * @return Whether or not an existing price observation was rotated out\\n     * @dev If the backing array is full (i.e., `length() == capacity()`, then\\n     *      it is rotated such that the oldest price observation is deleted\\n     * @dev Only callable by the associated writer for this contract\\n     */\\n    function add(int256 x) public override onlyWriter returns (bool) {\\n        if (full()) {\\n            leftRotateWithPad(x);\\n            return true;\\n        } else {\\n            observations[length()] = x;\\n            numElems += 1;\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @notice Sets the associated writer address for this contract\\n     * @param _writer Address of the new writer\\n     * @dev Only callable by the owner of this contract\\n     * @dev Throws if `_writer` is the null address\\n     */\\n    function setWriter(address _writer) public onlyOwner {\\n        require(_writer != address(0), \\\"PO: Null address not allowed\\\");\\n        writer = _writer;\\n    }\\n\\n    /**\\n     * @notice Returns the current writer of this contract\\n     * @return Address of the writer for this contract\\n     * @dev `writer`\\n     */\\n    function getWriter() public view returns (address) {\\n        return writer;\\n    }\\n\\n    /**\\n     * @notice Determines whether or not the backing array is full\\n     * @return Flag indicating whether the backing array is full or not\\n     * @dev `length() == capacity()`\\n     */\\n    function full() private view returns (bool) {\\n        return length() == capacity();\\n    }\\n\\n    /**\\n     * @notice Resets the backing array and clears all of its stored prices\\n     * @dev Only callable by the owner of this contract\\n     */\\n    function clear() public onlyOwner {\\n        numElems = 0;\\n        delete observations;\\n    }\\n\\n    /**\\n     * @notice Rotates observations array to the **left** by one element and\\n     *          sets the last element of `xs` to `x`\\n     * @param x Element to \\\"rotate into\\\" observations array\\n     */\\n    function leftRotateWithPad(int256 x) private {\\n        uint256 n = length();\\n\\n        /* linear scan over the [1, n] subsequence */\\n        for (uint256 i = 1; i < n; i++) {\\n            observations[i - 1] = observations[i];\\n        }\\n\\n        /* rotate `x` into `observations` from the right (remember, we're\\n         * **left** rotating -- with padding!) */\\n        observations[n - 1] = x;\\n    }\\n\\n    /**\\n     * @notice Enforces that the caller is the associated writer of this\\n     *          contract\\n     */\\n    modifier onlyWriter() {\\n        require(msg.sender == writer, \\\"PO: Permission denied\\\");\\n        _;\\n    }\\n}\\n\",\"keccak256\":\"0x7ba9d2ccb090627c6186ea5f03feb830633fa69d037dc0970874348f4d93a08f\",\"license\":\"CC-BY-NC-ND-4.0\"},\"contracts/interfaces/IERC20DecimalsWrapper.sol\":{\"content\":\"//SPDX-License-Identifier: CC-BY-NC-ND-4.0\\npragma solidity 0.8.7;\\n\\n/// @title The decimals interface for extending the ERC20 interface\\ninterface IERC20DecimalsWrapper {\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x5b719acf06c256045637247185ac0a7f1ba2346ab14cec805a5b7ff2d0f1d83d\",\"license\":\"CC-BY-NC-ND-4.0\"},\"contracts/interfaces/ILeveragedPool.sol\":{\"content\":\"//SPDX-License-Identifier: CC-BY-NC-ND-4.0\\npragma solidity 0.8.7;\\n\\n/// @title The pool controller contract interface\\ninterface ILeveragedPool {\\n    // Initialisation parameters for new market\\n    struct Initialization {\\n        address _owner; // Owner of the contract\\n        address _keeper; // The address of the PoolKeeper contract\\n        address _oracleWrapper; // The oracle wrapper for the derivative price feed\\n        address _settlementEthOracle; // The oracle wrapper for the SettlementToken/ETH price feed\\n        address _longToken; // Address of the long pool token\\n        address _shortToken; // Address of the short pool token\\n        address _poolCommitter; // Address of the PoolCommitter contract\\n        address _invariantCheckContract; // Address of the PoolCommitter contract\\n        string _poolName; // The pool identification name\\n        uint32 _frontRunningInterval; // The minimum number of seconds that must elapse before a commit is forced to wait until the next interval\\n        uint32 _updateInterval; // The minimum number of seconds that must elapse before a commit can be executed\\n        uint16 _leverageAmount; // The amount of exposure to price movements for the pool\\n        uint256 _fee; // The fund movement fee. This amount is extracted from the deposited asset with every update and sent to the fee address. Given as the decimal * 10 ^ 18. For example, 60% fee is 0.6 * 10 ^ 18\\n        address _feeAddress; // The address that the fund movement fee is sent to\\n        address _secondaryFeeAddress; // The address of fee recieved by third party deployers\\n        address _quoteToken; //  The digital asset that the pool accepts. Must have a decimals() function\\n        uint256 _secondaryFeeSplitPercent; // Percent of fees that go to secondary fee address if it exists\\n    }\\n\\n    // #### Events\\n    /**\\n     * @notice Creates a notification when the pool is setup and ready for use\\n     * @param longToken The address of the LONG pair token\\n     * @param shortToken The address of the SHORT pair token\\n     * @param quoteToken The address of the digital asset that the pool accepts\\n     * @param poolName The pool code for the pool\\n     */\\n    event PoolInitialized(address indexed longToken, address indexed shortToken, address quoteToken, string poolName);\\n\\n    /**\\n     * @notice Creates a notification when the pool is rebalanced\\n     * @param shortBalanceChange The change of funds in the short side\\n     * @param longBalanceChange The change of funds in the long side\\n     * @param shortFeeAmount Proportional fee taken from short side\\n     * @param longFeeAmount Proportional fee taken from long side\\n     */\\n    event PoolRebalance(\\n        int256 shortBalanceChange,\\n        int256 longBalanceChange,\\n        uint256 shortFeeAmount,\\n        uint256 longFeeAmount\\n    );\\n\\n    /**\\n     * @notice Creates a notification when the pool's price execution fails\\n     * @param startPrice Price prior to price change execution\\n     * @param endPrice Price during price change execution\\n     */\\n    event PriceChangeError(int256 indexed startPrice, int256 indexed endPrice);\\n\\n    /**\\n     * @notice Represents change in fee receiver's address\\n     * @param oldAddress Previous address\\n     * @param newAddress Address after change\\n     */\\n    event FeeAddressUpdated(address indexed oldAddress, address indexed newAddress);\\n\\n    /**\\n     * @notice Represents change in secondary fee receiver's address\\n     * @param oldAddress Previous address\\n     * @param newAddress Address after change\\n     */\\n    event SecondaryFeeAddressUpdated(address indexed oldAddress, address indexed newAddress);\\n\\n    /**\\n     * @notice Represents change in keeper's address\\n     * @param oldAddress Previous address\\n     * @param newAddress Address after change\\n     */\\n    event KeeperAddressChanged(address indexed oldAddress, address indexed newAddress);\\n\\n    /**\\n     * @notice Represents proposed change in governance address\\n     * @param newAddress Proposed address\\n     */\\n    event ProvisionalGovernanceChanged(address indexed newAddress);\\n\\n    /**\\n     * @notice Represents change in governance address\\n     * @param oldAddress Previous address\\n     * @param newAddress Address after change\\n     */\\n    event GovernanceAddressChanged(address indexed oldAddress, address indexed newAddress);\\n\\n    function leverageAmount() external view returns (bytes16);\\n\\n    function poolCommitter() external view returns (address);\\n\\n    function quoteToken() external view returns (address);\\n\\n    function oracleWrapper() external view returns (address);\\n\\n    function lastPriceTimestamp() external view returns (uint256);\\n\\n    function poolName() external view returns (string calldata);\\n\\n    function updateInterval() external view returns (uint32);\\n\\n    function shortBalance() external view returns (uint256);\\n\\n    function longBalance() external view returns (uint256);\\n\\n    function frontRunningInterval() external view returns (uint32);\\n\\n    function poolTokens() external view returns (address[2] memory);\\n\\n    function settlementEthOracle() external view returns (address);\\n\\n    // #### Functions\\n    /**\\n     * @notice Configures the pool on deployment. The pools are EIP 1167 clones.\\n     * @dev This should only be able to be run once to prevent abuse of the pool. Use of Openzeppelin Initializable or similar is recommended\\n     * @param initialization The struct Initialization containing initialization data\\n     */\\n    function initialize(Initialization calldata initialization) external;\\n\\n    function poolUpkeep(int256 _oldPrice, int256 _newPrice) external;\\n\\n    function quoteTokenTransferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external;\\n\\n    function payKeeperFromBalances(address to, uint256 amount) external returns (bool);\\n\\n    function quoteTokenTransfer(address to, uint256 amount) external;\\n\\n    function poolTokenTransfer(\\n        bool isLongToken,\\n        address to,\\n        uint256 amount\\n    ) external;\\n\\n    function setNewPoolBalances(uint256 _longBalance, uint256 _shortBalance) external;\\n\\n    /**\\n     * @return _latestPrice The oracle price\\n     * @return _data The oracleWrapper's metadata. Implementations can choose what data to return here\\n     * @return _lastPriceTimestamp The timestamp of the last upkeep\\n     * @return _updateInterval The update frequency for this pool\\n     * @dev To save gas so PoolKeeper does not have to make three external calls\\n     */\\n    function getUpkeepInformation()\\n        external\\n        view\\n        returns (\\n            int256 _latestPrice,\\n            bytes memory _data,\\n            uint256 _lastPriceTimestamp,\\n            uint256 _updateInterval\\n        );\\n\\n    function getOraclePrice() external view returns (int256);\\n\\n    function intervalPassed() external view returns (bool);\\n\\n    function balances() external view returns (uint256 _shortBalance, uint256 _longBalance);\\n\\n    function setKeeper(address _keeper) external;\\n\\n    function transferGovernance(address _governance) external;\\n\\n    function claimGovernance() external;\\n\\n    function updateFeeAddress(address account) external;\\n\\n    function updateSecondaryFeeAddress(address account) external;\\n\\n    function mintTokens(\\n        bool isLongToken,\\n        uint256 amount,\\n        address burner\\n    ) external;\\n\\n    function burnTokens(\\n        bool isLongToken,\\n        uint256 amount,\\n        address burner\\n    ) external;\\n}\\n\",\"keccak256\":\"0x94db9525799587472455f725b69475418c1fe64490f324d6e5e6cc3a28341fb9\",\"license\":\"CC-BY-NC-ND-4.0\"},\"contracts/interfaces/IOracleWrapper.sol\":{\"content\":\"//SPDX-License-Identifier: CC-BY-NC-ND-4.0\\npragma solidity 0.8.7;\\n\\n/// @title The oracle wrapper contract interface\\ninterface IOracleWrapper {\\n    function oracle() external view returns (address);\\n\\n    function deployer() external view returns (address);\\n\\n    // #### Functions\\n\\n    /**\\n     * @notice Returns the current price for the asset in question\\n     * @return The latest price\\n     */\\n    function getPrice() external view returns (int256);\\n\\n    /**\\n     * @return _price The latest round data price\\n     * @return _data The metadata. Implementations can choose what data to return here\\n     */\\n    function getPriceAndMetadata() external view returns (int256 _price, bytes memory _data);\\n\\n    /**\\n     * @notice Converts from a WAD to normal value\\n     * @return Converted non-WAD value\\n     */\\n    function fromWad(int256 wad) external view returns (int256);\\n\\n    /**\\n     * @notice Updates the underlying oracle state and returns the new price\\n     * @dev Spot oracles must implement but it will be a no-op\\n     */\\n    function poll() external returns (int256);\\n}\\n\",\"keccak256\":\"0x50b2e96b7b396f02b6a4c5fc6dee20a1134771c7a6ac0587ade614b50558b4de\",\"license\":\"CC-BY-NC-ND-4.0\"},\"contracts/interfaces/IPoolFactory.sol\":{\"content\":\"//SPDX-License-Identifier: CC-BY-NC-ND-4.0\\npragma solidity 0.8.7;\\n\\n/// @title The contract factory for the keeper and pool contracts. Utilizes minimal clones to keep gas costs low\\ninterface IPoolFactory {\\n    struct PoolDeployment {\\n        string poolName; // The name to identify a pool by\\n        uint32 frontRunningInterval; // The minimum number of seconds that must elapse before a commit can be executed. Must be smaller than or equal to the update interval to prevent deadlock\\n        uint32 updateInterval; // The minimum number of seconds that must elapse before a price change\\n        uint16 leverageAmount; // The amount of exposure to price movements for the pool\\n        address quoteToken; // The digital asset that the pool accepts\\n        address oracleWrapper; // The IOracleWrapper implementation for fetching price feed data\\n        address settlementEthOracle; // The oracle to fetch the price of Ether in terms of the settlement token\\n        address invariantCheckContract; // The IInvariantCheck contract that performs invariant checking\\n    }\\n\\n    // #### Events\\n    /**\\n     * @notice Creates a notification when a pool is deployed\\n     * @param pool Address of the new pool\\n     * @param ticker Ticker of the neew pool\\n     */\\n    event DeployPool(address indexed pool, address poolCommitter, string ticker);\\n\\n    /**\\n     * @notice Creates a notification when the pool keeper changes\\n     * @param _poolKeeper Address of the new pool keeper\\n     */\\n    event PoolKeeperChanged(address _poolKeeper);\\n\\n    // #### Getters for Globals\\n    function pools(uint256 id) external view returns (address);\\n\\n    function numPools() external view returns (uint256);\\n\\n    function isValidPool(address _pool) external view returns (bool);\\n\\n    function isValidPoolCommitter(address _poolCommitter) external view returns (bool);\\n\\n    // #### Functions\\n    function deployPool(PoolDeployment calldata deploymentParameters) external returns (address);\\n\\n    function getOwner() external returns (address);\\n\\n    function setPoolKeeper(address _poolKeeper) external;\\n\\n    function setAutoClaim(address _autoClaim) external;\\n\\n    function setMaxLeverage(uint16 newMaxLeverage) external;\\n\\n    function setFeeReceiver(address _feeReceiver) external;\\n\\n    function setFee(uint256 _fee) external;\\n\\n    function setSecondaryFeeSplitPercent(uint256 newFeePercent) external;\\n\\n    function setMintAndBurnFeeAndChangeInterval(\\n        uint256 _mintingFee,\\n        uint256 _burningFee,\\n        uint256 _changeInterval\\n    ) external;\\n}\\n\",\"keccak256\":\"0x3683e0f630a770132d0fec73abd39b9daf72ddf89d950255972ad979c09d1c2c\",\"license\":\"CC-BY-NC-ND-4.0\"},\"contracts/interfaces/IPoolKeeper.sol\":{\"content\":\"//SPDX-License-Identifier: CC-BY-NC-ND-4.0\\npragma solidity 0.8.7;\\n\\n/// @title The manager contract interface for multiple markets and the pools in them\\ninterface IPoolKeeper {\\n    // #### Events\\n    /**\\n     * @notice Creates a notification when a pool is created\\n     * @param poolAddress The pool address of the newly created pool\\n     * @param firstPrice The price of the market oracle when the pool was created\\n     */\\n    event PoolAdded(address indexed poolAddress, int256 indexed firstPrice);\\n\\n    /**\\n     * @notice Creates a notification when a call to LeveragedPool:poolUpkeep is successful\\n     * @param pool The pool address being upkept\\n     * @param data Extra data about the price fetch. This could be roundID in the case of Chainlink Oracles\\n     * @param startPrice The previous price of the pool\\n     * @param endPrice The new price of the pool\\n     */\\n    event UpkeepSuccessful(address indexed pool, bytes data, int256 indexed startPrice, int256 indexed endPrice);\\n\\n    /**\\n     * @notice Creates a notification when a keeper is paid for doing upkeep for a pool\\n     * @param _pool Address of pool being upkept\\n     * @param keeper Keeper to be rewarded for upkeeping\\n     * @param reward Keeper's reward (in settlement tokens)\\n     */\\n    event KeeperPaid(address indexed _pool, address indexed keeper, uint256 reward);\\n\\n    /**\\n     * @notice Creates a notification when a keeper's payment for upkeeping a pool failed\\n     * @param _pool Address of pool being upkept\\n     * @param keeper Keeper to be rewarded for upkeeping\\n     * @param expectedReward Keeper's expected reward (in settlement tokens); not actually transferred\\n     */\\n    event KeeperPaymentError(address indexed _pool, address indexed keeper, uint256 expectedReward);\\n\\n    /**\\n     * @notice Creates a notification of a failed pool update\\n     * @param pool The pool that failed to update\\n     * @param reason The reason for the error\\n     */\\n    event PoolUpkeepError(address indexed pool, string reason);\\n\\n    // #### Functions\\n    function newPool(address _poolAddress) external;\\n\\n    function setFactory(address _factory) external;\\n\\n    function checkUpkeepSinglePool(address pool) external view returns (bool);\\n\\n    function checkUpkeepMultiplePools(address[] calldata pools) external view returns (bool);\\n\\n    function performUpkeepSinglePool(address pool) external;\\n\\n    function performUpkeepMultiplePools(address[] calldata pools) external;\\n}\\n\",\"keccak256\":\"0xfb5a863b843848563313bc782a188419089790f737cd677b7eb8ec43b44d09bc\",\"license\":\"CC-BY-NC-ND-4.0\"},\"contracts/interfaces/IPriceObserver.sol\":{\"content\":\"//SPDX-License-Identifier: CC-BY-NC-ND-4.0\\npragma solidity 0.8.7;\\n\\n/// @title The price observer interface\\ninterface IPriceObserver {\\n    function capacity() external view returns (uint256);\\n\\n    function length() external view returns (uint256);\\n\\n    function get(uint256 i) external view returns (int256);\\n\\n    function getAll() external view returns (int256[24] memory);\\n\\n    function add(int256 x) external returns (bool);\\n}\\n\",\"keccak256\":\"0xba914bb590abf02108160b7245580b4f43592021b26aaa8b9fa374774098aff6\",\"license\":\"CC-BY-NC-ND-4.0\"}},\"version\":1}",
  "bytecode": "0x60806040526402540be4006003553480156200001a57600080fd5b50604051620021d3380380620021d38339810160408190526200003d9162000119565b6200004833620000c9565b6001600160a01b038116620000a35760405162461bcd60e51b815260206004820152601b60248201527f466163746f72792063616e6e6f74206265203020616464726573730000000000604482015260640160405180910390fd5b600280546001600160a01b0319166001600160a01b03929092169190911790556200014b565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6000602082840312156200012c57600080fd5b81516001600160a01b03811681146200014457600080fd5b9392505050565b612078806200015b6000396000f3fe608060405234801561001057600080fd5b50600436106101375760003560e01c8063b3fbb7c4116100b8578063ce1dcdfc1161007c578063ce1dcdfc14610269578063f2fde38b1461027c578063f6bd4a951461028f578063f930191014610297578063fcab9e981461029f578063fe173b97146102b257600080fd5b8063b3fbb7c4146101fd578063b9c6536514610210578063bf1fe42014610223578063c45a015514610236578063cdd9e1371461024957600080fd5b80638da5cb5b116100ff5780638da5cb5b146101aa57806391a60782146101cf5780639f9a3d95146101e2578063a40d6b80146101ea578063aea8acb1146101e257600080fd5b80630417cf8e1461013c578063225739b1146101575780633c5c7fb31461017a5780635bb478081461018f578063715018a6146101a2575b600080fd5b610144601281565b6040519081526020015b60405180910390f35b61016a610165366004611b4e565b6102bb565b604051901515815260200161014e565b61018d610188366004611b4e565b6103bc565b005b61018d61019d366004611b4e565b6105ca565b61018d610616565b6000546001600160a01b03165b6040516001600160a01b03909116815260200161014e565b61018d6101dd366004611b4e565b61064c565b610144600581565b6101446101f8366004611b88565b610938565b61014461020b366004611bbd565b610a85565b61014461021e366004611d7c565b610c6f565b61018d610231366004611d63565b610ccb565b6002546101b7906001600160a01b031681565b610144610257366004611b4e565b60016020526000908152604090205481565b61016a610277366004611c01565b610cfa565b61018d61028a366004611b4e565b610d5e565b610144606481565b610144600d81565b61018d6102ad366004611c01565b610df9565b61014460035481565b600254604051635ab78ee160e01b81526001600160a01b0383811660048301526000921690635ab78ee19060240160206040518083038186803b15801561030157600080fd5b505afa158015610315573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103399190611c76565b61034557506000919050565b816001600160a01b0316637bbf10336040518163ffffffff1660e01b815260040160206040518083038186803b15801561037e57600080fd5b505afa158015610392573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103b69190611c76565b92915050565b6002546001600160a01b031633146104105760405162461bcd60e51b815260206004820152601260248201527143616c6c6572206e6f7420666163746f727960701b60448201526064015b60405180910390fd5b6000816001600160a01b031663b9ed8abf6040518163ffffffff1660e01b815260040160206040518083038186803b15801561044b57600080fd5b505afa15801561045f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104839190611b6b565b90506000816001600160a01b03166398d5fdca6040518163ffffffff1660e01b815260040160206040518083038186803b1580156104c057600080fd5b505afa1580156104d4573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104f89190611c98565b90506000811361054a5760405162461bcd60e51b815260206004820152601b60248201527f4669727374207072696365206973206e6f6e2d706f73697469766500000000006044820152606401610407565b600061057061056b61055b84610e47565b668075782dace9d960c71b610ed5565b611152565b905081846001600160a01b03167fe950cb32f7a787627d713d7365623fef2d762ef8fcf813b865a04350852deb9b60405160405180910390a36001600160a01b039093166000908152600160205260409020929092555050565b6000546001600160a01b031633146105f45760405162461bcd60e51b815260040161040790611e00565b600280546001600160a01b0319166001600160a01b0392909216919091179055565b6000546001600160a01b031633146106405760405162461bcd60e51b815260040161040790611e00565b61064a60006111f9565b565b60005a905061065a826102bb565b610662575050565b60008290506000816001600160a01b031663b9ed8abf6040518163ffffffff1660e01b815260040160206040518083038186803b1580156106a257600080fd5b505afa1580156106b6573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106da9190611b6b565b9050806001600160a01b031663a11752796040518163ffffffff1660e01b8152600401602060405180830381600087803b15801561071757600080fd5b505af115801561072b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061074f9190611c98565b50600080600080856001600160a01b03166304883c276040518163ffffffff1660e01b815260040160006040518083038186803b15801561078f57600080fd5b505afa1580156107a3573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526107cb9190810190611cb1565b6001600160a01b038c81166000908152600160205260409081902080549087905590516303d8ce9d60e61b81526004810182905260248101879052959950939750919550935090919088169063f633a74090604401600060405180830381600087803b15801561083a57600080fd5b505af192505050801561084b575060015b6108ca57610857611f87565b806308c379a014156108be575061086c611fa3565b8061087757506108c0565b896001600160a01b03167f8a47468bf96478429d382ed6385d9c77fba8b89540cd88199b1b51d5723b11fa826040516108b09190611ded565b60405180910390a25061092d565b505b3d6000803e3d6000fd5b60005a6108d7908a611e8e565b90506108e88a600354838787611249565b85828b6001600160a01b03167f0aa8d2838ad6d4e2a5d7ca0826dfdbc36d922adf8fe5c6d25aee2724b07de074886040516109239190611ded565b60405180910390a4505b505050505050505050565b600080846001600160a01b0316638226f3966040518163ffffffff1660e01b815260040160206040518083038186803b15801561097457600080fd5b505afa158015610988573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109ac9190611b6b565b6001600160a01b03166398d5fdca6040518163ffffffff1660e01b815260040160206040518083038186803b1580156109e457600080fd5b505afa1580156109f8573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a1c9190611c98565b905060008113610a30576000915050610a7e565b6000610a44610a3f8587611e6f565b61136e565b90506000610a518361136e565b9050610a78610a73610a638484610ed5565b668075782dace9d960c71b6113d2565b611668565b93505050505b9392505050565b600080610a93878787610938565b90506000610aa4610a3f8686610c6f565b9050610ab981610ab4606461136e565b6113d2565b90506000610ae661056b610acc8561136e565b610ae1610a63610adb8861136e565b87610ed5565b6116eb565b90506000896001600160a01b031663217a4b706040518163ffffffff1660e01b815260040160206040518083038186803b158015610b2357600080fd5b505afa158015610b37573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b5b9190611b6b565b6001600160a01b031663313ce5676040518163ffffffff1660e01b815260040160206040518083038186803b158015610b9357600080fd5b505afa158015610ba7573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610bcb9190611d9e565b60405163bf36f0e960e01b81526004810184905260ff91909116602482018190529150600090732fB38A21cC1cE33a4a49c034893eaA5Fb3D0Dc769063bf36f0e99060440160206040518083038186803b158015610c2857600080fd5b505af4158015610c3c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c609190611c98565b9b9a5050505050505050505050565b600080610c7c8385611e35565b610c869042611e8e565b90506000600d610c97836005611e6f565b610ca19190611e4d565b610cac906005611e35565b90506064811115610cc2576064925050506103b6565b91506103b69050565b6000546001600160a01b03163314610cf55760405162461bcd60e51b815260040161040790611e00565b600355565b600081815b81811015610d5357610d31858583818110610d1c57610d1c611f5b565b90506020020160208101906101659190611b4e565b15610d41576001925050506103b6565b80610d4b81611efe565b915050610cff565b506000949350505050565b6000546001600160a01b03163314610d885760405162461bcd60e51b815260040161040790611e00565b6001600160a01b038116610ded5760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201526564647265737360d01b6064820152608401610407565b610df6816111f9565b50565b8060005b81811015610e4157610e2f848483818110610e1a57610e1a611f5b565b90506020020160208101906101dd9190611b4e565b80610e3981611efe565b915050610dfd565b50505050565b600081610e5657506000919050565b6000808313610e685782600003610e6a565b825b90506000610e7782611aab565b90506070811015610e90578060700382901b9150610ea3565b6070811115610ea3576070810382901c91505b6001600160701b03909116613fff820160701b17906000841215610ecb576001607f1b821791505b5060801b92915050565b6000617fff60f084811c8216919084901c811690821415610f855780617fff1415610f53576001600160801b03198581169085161415610f2057505050600160ff1b811682186103b6565b600160ff1b6001600160801b0319868618161415610f43575050508181176103b6565b5061ffff60ef1b91506103b69050565b600160801b600160ff1b038416610f74575061ffff60ef1b91506103b69050565b505050600160ff1b811682186103b6565b80617fff1415610fc157600160801b600160ff1b038516610fb0575061ffff60ef1b91506103b69050565b505050600160ff1b821681186103b6565b6001600160701b03608086901c1682610fdd5760019250610fe4565b600160701b175b6001600160701b03608086901c16826110005760019250611007565b600160701b175b908102908161103557600160ff1b8787181661102457600061102a565b600160ff1b5b9450505050506103b6565b928201926000600160e11b83101561106857600160e01b8310156110615761105c83611aab565b61106b565b60e061106b565b60e15b90506140708186011015611086576000945060009250611123565b6140e081860110156110c9576140708510156110ab57846140700383901c92506110c0565b6140708511156110c057614070850383901b92505b60009450611123565b61c0dd81860111156110e357617fff945060009250611123565b60708111156110fa576070810383901c925061110d565b607081101561110d578060700383901b92505b6001600160701b03831692506140df8186010394505b82607086901b888a186001607f1b60801b1660801c6001600160801b0316171760801b955050505050506103b6565b6000617fff60f083901c166140fe81111561116c57600080fd5b613fff81101561117f5750600092915050565b600160701b6001600160701b03608085901c161761406f8210156111a95761406f8290031c6111bb565b61406f8211156111bb5761406e1982011b5b6001607f1b608085901c106111e557600160ff1b8111156111db57600080fd5b6000039392505050565b6001600160ff1b03811115610a7e57600080fd5b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b60006112588686868686610a85565b604051636dc2b27160e01b8152336004820152602481018290529091506001600160a01b03871690636dc2b27190604401602060405180830381600087803b1580156112a357600080fd5b505af11580156112b7573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112db9190611c76565b156113255760405181815233906001600160a01b038816907ff03012dd4aab142682aa01439f94e975e2ec77ef558352323bc05f382f74b0829060200160405180910390a3611366565b60405181815233906001600160a01b038816907f08b35d4c86707ba44cdcc5efaa79b8a307e6c7f789f1eb86ca1ff1e9bde056979060200160405180910390a35b505050505050565b60008161137d57506000919050565b81600061138982611aab565b905060708110156113a2578060700382901b91506113b5565b60708111156113b5576070810382901c91505b613fff0160701b6001600160701b03919091161760801b92915050565b6000617fff60f084811c8216919084901c8116908214156114075780617fff1415610f74575061ffff60ef1b91506103b69050565b80617fff141561144b576dffffffffffffffffffffffffffff60801b84161561143a575061ffff60ef1b91506103b69050565b505050808218600160ff1b166103b6565b600160801b600160ff1b03841661149557600160801b600160ff1b03851661147d575061ffff60ef1b91506103b69050565b505050808218600160ff1b16617fff60f01b176103b6565b6001600160701b03608085901c16816114b157600191506114b8565b600160701b175b6001600160701b03608087901c16836114f75780156114f25760006114dc82611aab565b6001955060e20393840160711901939190911b90505b611501565b600160701b1760721b5b81818161151057611510611f45565b0490508061152c57600160ff1b8787181661102457600061102a565b6001606c1b81101561154057611540611f19565b6000600160731b82101561157f57600160721b82101561157457600160711b82101561156d576070611577565b6071611577565b60725b60ff16611588565b61158882611aab565b9050836140710181860111156115a657617fff945060009150611639565b83818601613ffc0110156115c1576000945060009150611639565b83818601613f8c01101561160e578385613ffc0111156115ec578385613ffc010382901b9150611605565b8385613ffc01101561160557613ffc8585030382901c91505b60009450611639565b6070811115611621576070810382901c91505b6001600160701b038216915083818601613f8d010394505b81607086901b888a186001607f1b60801b1660801c6001600160801b0316171760801b955050505050506103b6565b6000617fff60f083901c16613fff8110156116865750600092915050565b6001607f1b608084901c1061169a57600080fd5b6140fe8111156116a957600080fd5b600160701b6001600160701b03608085901c161761406f8210156116d35761406f8290031c610a7e565b61406f821115610a7e5761406e1982011b9392505050565b6000617fff60f084811c8216919084901c8116908214156117395780617fff141561172f576001600160801b03198581169085161415610f435784925050506103b6565b84925050506103b6565b80617fff141561174d5783925050506103b6565b6001607f1b608086901c90811015906001600160701b031683611773576001935061177a565b600160701b175b6001607f1b608087901c90811015906001600160701b0316846117a057600194506117a7565b600160701b175b826117d7576001600160801b03198816600160ff1b146117c757876117ca565b60005b96505050505050506103b6565b806117f7576001600160801b03198916600160ff1b146117c757886117ca565b848603841515831515141561190257607081131561181e57899750505050505050506103b6565b60008113156118305790811c9061185f565b606f1981121561184957889750505050505050506103b6565b600081121561185f578060000384901c93508596505b92810192600160711b841061187a576001968701969390931c925b86617fff14156118ac578461189457617fff60f01b61189e565b6001600160f01b03195b9750505050505050506103b6565b600160701b8410156118c157600096506118ce565b6001600160701b03841693505b83607088901b866118e05760006118e6565b6001607f1b5b6001600160801b0316171760801b9750505050505050506103b6565b600081131561191d57600184901b9350600187039650611934565b600081121561193457600182901b91506001860396505b60708113156119465760019150611993565b6001811315611963576001810360018303901c6001019150611993565b606f198112156119765760019350611993565b600019811215611993576001816000030360018503901c60010193505b8184106119a45781840393506119ad565b83820393508294505b836119c35750600096506103b695505050505050565b60006119ce85611aab565b905080607114156119f457600185901c6001600160701b03169450600188019750611a43565b6070811015611a3657607081900380891115611a23578086901b6001600160701b031695508089039850611a30565b600098600019019590951b945b50611a43565b6001600160701b03851694505b87617fff1415611a765785611a5d57617fff60f01b611a67565b6001600160f01b03195b985050505050505050506103b6565b84607089901b87611a88576000611a8e565b6001607f1b5b6001600160801b0316171760801b985050505050505050506103b6565b6000808211611ab957600080fd5b6000600160801b8310611ace57608092831c92015b680100000000000000008310611ae657604092831c92015b6401000000008310611afa57602092831c92015b620100008310611b0c57601092831c92015b6101008310611b1d57600892831c92015b60108310611b2d57600492831c92015b60048310611b3d57600292831c92015b600283106103b65760010192915050565b600060208284031215611b6057600080fd5b8135610a7e8161202d565b600060208284031215611b7d57600080fd5b8151610a7e8161202d565b600080600060608486031215611b9d57600080fd5b8335611ba88161202d565b95602085013595506040909401359392505050565b600080600080600060a08688031215611bd557600080fd5b8535611be08161202d565b97602087013597506040870135966060810135965060800135945092505050565b60008060208385031215611c1457600080fd5b823567ffffffffffffffff80821115611c2c57600080fd5b818501915085601f830112611c4057600080fd5b813581811115611c4f57600080fd5b8660208260051b8501011115611c6457600080fd5b60209290920196919550909350505050565b600060208284031215611c8857600080fd5b81518015158114610a7e57600080fd5b600060208284031215611caa57600080fd5b5051919050565b60008060008060808587031215611cc757600080fd5b84519350602085015167ffffffffffffffff80821115611ce657600080fd5b818701915087601f830112611cfa57600080fd5b815181811115611d0c57611d0c611f71565b6040519150611d25601f8201601f191660200183611ed1565b808252886020828501011115611d3a57600080fd5b611d4b816020840160208601611ea5565b50604087015160609097015195989097509350505050565b600060208284031215611d7557600080fd5b5035919050565b60008060408385031215611d8f57600080fd5b50508035926020909101359150565b600060208284031215611db057600080fd5b815160ff81168114610a7e57600080fd5b60008151808452611dd9816020860160208601611ea5565b601f01601f19169290920160200192915050565b602081526000610a7e6020830184611dc1565b6020808252818101527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604082015260600190565b60008219821115611e4857611e48611f2f565b500190565b600082611e6a57634e487b7160e01b600052601260045260246000fd5b500490565b6000816000190483118215151615611e8957611e89611f2f565b500290565b600082821015611ea057611ea0611f2f565b500390565b60005b83811015611ec0578181015183820152602001611ea8565b83811115610e415750506000910152565b601f8201601f1916810167ffffffffffffffff81118282101715611ef757611ef7611f71565b6040525050565b6000600019821415611f1257611f12611f2f565b5060010190565b634e487b7160e01b600052600160045260246000fd5b634e487b7160e01b600052601160045260246000fd5b634e487b7160e01b600052601260045260246000fd5b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052604160045260246000fd5b600060033d1115611fa05760046000803e5060005160e01c5b90565b600060443d1015611fb15790565b6040516003193d81016004833e81513d67ffffffffffffffff8160248401118184111715611fe157505050505090565b8285019150815181811115611ff95750505050505090565b843d87010160208285010111156120135750505050505090565b61202260208286010187611ed1565b509095945050505050565b6001600160a01b0381168114610df657600080fdfea2646970667358221220988875ec96a517baf17be9ffbee4e384aa46a79f39a9ed03a243bf502f0c229864736f6c63430008070033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106101375760003560e01c8063b3fbb7c4116100b8578063ce1dcdfc1161007c578063ce1dcdfc14610269578063f2fde38b1461027c578063f6bd4a951461028f578063f930191014610297578063fcab9e981461029f578063fe173b97146102b257600080fd5b8063b3fbb7c4146101fd578063b9c6536514610210578063bf1fe42014610223578063c45a015514610236578063cdd9e1371461024957600080fd5b80638da5cb5b116100ff5780638da5cb5b146101aa57806391a60782146101cf5780639f9a3d95146101e2578063a40d6b80146101ea578063aea8acb1146101e257600080fd5b80630417cf8e1461013c578063225739b1146101575780633c5c7fb31461017a5780635bb478081461018f578063715018a6146101a2575b600080fd5b610144601281565b6040519081526020015b60405180910390f35b61016a610165366004611b4e565b6102bb565b604051901515815260200161014e565b61018d610188366004611b4e565b6103bc565b005b61018d61019d366004611b4e565b6105ca565b61018d610616565b6000546001600160a01b03165b6040516001600160a01b03909116815260200161014e565b61018d6101dd366004611b4e565b61064c565b610144600581565b6101446101f8366004611b88565b610938565b61014461020b366004611bbd565b610a85565b61014461021e366004611d7c565b610c6f565b61018d610231366004611d63565b610ccb565b6002546101b7906001600160a01b031681565b610144610257366004611b4e565b60016020526000908152604090205481565b61016a610277366004611c01565b610cfa565b61018d61028a366004611b4e565b610d5e565b610144606481565b610144600d81565b61018d6102ad366004611c01565b610df9565b61014460035481565b600254604051635ab78ee160e01b81526001600160a01b0383811660048301526000921690635ab78ee19060240160206040518083038186803b15801561030157600080fd5b505afa158015610315573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103399190611c76565b61034557506000919050565b816001600160a01b0316637bbf10336040518163ffffffff1660e01b815260040160206040518083038186803b15801561037e57600080fd5b505afa158015610392573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103b69190611c76565b92915050565b6002546001600160a01b031633146104105760405162461bcd60e51b815260206004820152601260248201527143616c6c6572206e6f7420666163746f727960701b60448201526064015b60405180910390fd5b6000816001600160a01b031663b9ed8abf6040518163ffffffff1660e01b815260040160206040518083038186803b15801561044b57600080fd5b505afa15801561045f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104839190611b6b565b90506000816001600160a01b03166398d5fdca6040518163ffffffff1660e01b815260040160206040518083038186803b1580156104c057600080fd5b505afa1580156104d4573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104f89190611c98565b90506000811361054a5760405162461bcd60e51b815260206004820152601b60248201527f4669727374207072696365206973206e6f6e2d706f73697469766500000000006044820152606401610407565b600061057061056b61055b84610e47565b668075782dace9d960c71b610ed5565b611152565b905081846001600160a01b03167fe950cb32f7a787627d713d7365623fef2d762ef8fcf813b865a04350852deb9b60405160405180910390a36001600160a01b039093166000908152600160205260409020929092555050565b6000546001600160a01b031633146105f45760405162461bcd60e51b815260040161040790611e00565b600280546001600160a01b0319166001600160a01b0392909216919091179055565b6000546001600160a01b031633146106405760405162461bcd60e51b815260040161040790611e00565b61064a60006111f9565b565b60005a905061065a826102bb565b610662575050565b60008290506000816001600160a01b031663b9ed8abf6040518163ffffffff1660e01b815260040160206040518083038186803b1580156106a257600080fd5b505afa1580156106b6573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106da9190611b6b565b9050806001600160a01b031663a11752796040518163ffffffff1660e01b8152600401602060405180830381600087803b15801561071757600080fd5b505af115801561072b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061074f9190611c98565b50600080600080856001600160a01b03166304883c276040518163ffffffff1660e01b815260040160006040518083038186803b15801561078f57600080fd5b505afa1580156107a3573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526107cb9190810190611cb1565b6001600160a01b038c81166000908152600160205260409081902080549087905590516303d8ce9d60e61b81526004810182905260248101879052959950939750919550935090919088169063f633a74090604401600060405180830381600087803b15801561083a57600080fd5b505af192505050801561084b575060015b6108ca57610857611f87565b806308c379a014156108be575061086c611fa3565b8061087757506108c0565b896001600160a01b03167f8a47468bf96478429d382ed6385d9c77fba8b89540cd88199b1b51d5723b11fa826040516108b09190611ded565b60405180910390a25061092d565b505b3d6000803e3d6000fd5b60005a6108d7908a611e8e565b90506108e88a600354838787611249565b85828b6001600160a01b03167f0aa8d2838ad6d4e2a5d7ca0826dfdbc36d922adf8fe5c6d25aee2724b07de074886040516109239190611ded565b60405180910390a4505b505050505050505050565b600080846001600160a01b0316638226f3966040518163ffffffff1660e01b815260040160206040518083038186803b15801561097457600080fd5b505afa158015610988573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109ac9190611b6b565b6001600160a01b03166398d5fdca6040518163ffffffff1660e01b815260040160206040518083038186803b1580156109e457600080fd5b505afa1580156109f8573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a1c9190611c98565b905060008113610a30576000915050610a7e565b6000610a44610a3f8587611e6f565b61136e565b90506000610a518361136e565b9050610a78610a73610a638484610ed5565b668075782dace9d960c71b6113d2565b611668565b93505050505b9392505050565b600080610a93878787610938565b90506000610aa4610a3f8686610c6f565b9050610ab981610ab4606461136e565b6113d2565b90506000610ae661056b610acc8561136e565b610ae1610a63610adb8861136e565b87610ed5565b6116eb565b90506000896001600160a01b031663217a4b706040518163ffffffff1660e01b815260040160206040518083038186803b158015610b2357600080fd5b505afa158015610b37573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b5b9190611b6b565b6001600160a01b031663313ce5676040518163ffffffff1660e01b815260040160206040518083038186803b158015610b9357600080fd5b505afa158015610ba7573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610bcb9190611d9e565b60405163bf36f0e960e01b81526004810184905260ff9190911660248201819052915060009073__$dc3b4b0a367edd91a2d74c73e2da54c142$__9063bf36f0e99060440160206040518083038186803b158015610c2857600080fd5b505af4158015610c3c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c609190611c98565b9b9a5050505050505050505050565b600080610c7c8385611e35565b610c869042611e8e565b90506000600d610c97836005611e6f565b610ca19190611e4d565b610cac906005611e35565b90506064811115610cc2576064925050506103b6565b91506103b69050565b6000546001600160a01b03163314610cf55760405162461bcd60e51b815260040161040790611e00565b600355565b600081815b81811015610d5357610d31858583818110610d1c57610d1c611f5b565b90506020020160208101906101659190611b4e565b15610d41576001925050506103b6565b80610d4b81611efe565b915050610cff565b506000949350505050565b6000546001600160a01b03163314610d885760405162461bcd60e51b815260040161040790611e00565b6001600160a01b038116610ded5760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201526564647265737360d01b6064820152608401610407565b610df6816111f9565b50565b8060005b81811015610e4157610e2f848483818110610e1a57610e1a611f5b565b90506020020160208101906101dd9190611b4e565b80610e3981611efe565b915050610dfd565b50505050565b600081610e5657506000919050565b6000808313610e685782600003610e6a565b825b90506000610e7782611aab565b90506070811015610e90578060700382901b9150610ea3565b6070811115610ea3576070810382901c91505b6001600160701b03909116613fff820160701b17906000841215610ecb576001607f1b821791505b5060801b92915050565b6000617fff60f084811c8216919084901c811690821415610f855780617fff1415610f53576001600160801b03198581169085161415610f2057505050600160ff1b811682186103b6565b600160ff1b6001600160801b0319868618161415610f43575050508181176103b6565b5061ffff60ef1b91506103b69050565b600160801b600160ff1b038416610f74575061ffff60ef1b91506103b69050565b505050600160ff1b811682186103b6565b80617fff1415610fc157600160801b600160ff1b038516610fb0575061ffff60ef1b91506103b69050565b505050600160ff1b821681186103b6565b6001600160701b03608086901c1682610fdd5760019250610fe4565b600160701b175b6001600160701b03608086901c16826110005760019250611007565b600160701b175b908102908161103557600160ff1b8787181661102457600061102a565b600160ff1b5b9450505050506103b6565b928201926000600160e11b83101561106857600160e01b8310156110615761105c83611aab565b61106b565b60e061106b565b60e15b90506140708186011015611086576000945060009250611123565b6140e081860110156110c9576140708510156110ab57846140700383901c92506110c0565b6140708511156110c057614070850383901b92505b60009450611123565b61c0dd81860111156110e357617fff945060009250611123565b60708111156110fa576070810383901c925061110d565b607081101561110d578060700383901b92505b6001600160701b03831692506140df8186010394505b82607086901b888a186001607f1b60801b1660801c6001600160801b0316171760801b955050505050506103b6565b6000617fff60f083901c166140fe81111561116c57600080fd5b613fff81101561117f5750600092915050565b600160701b6001600160701b03608085901c161761406f8210156111a95761406f8290031c6111bb565b61406f8211156111bb5761406e1982011b5b6001607f1b608085901c106111e557600160ff1b8111156111db57600080fd5b6000039392505050565b6001600160ff1b03811115610a7e57600080fd5b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b60006112588686868686610a85565b604051636dc2b27160e01b8152336004820152602481018290529091506001600160a01b03871690636dc2b27190604401602060405180830381600087803b1580156112a357600080fd5b505af11580156112b7573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112db9190611c76565b156113255760405181815233906001600160a01b038816907ff03012dd4aab142682aa01439f94e975e2ec77ef558352323bc05f382f74b0829060200160405180910390a3611366565b60405181815233906001600160a01b038816907f08b35d4c86707ba44cdcc5efaa79b8a307e6c7f789f1eb86ca1ff1e9bde056979060200160405180910390a35b505050505050565b60008161137d57506000919050565b81600061138982611aab565b905060708110156113a2578060700382901b91506113b5565b60708111156113b5576070810382901c91505b613fff0160701b6001600160701b03919091161760801b92915050565b6000617fff60f084811c8216919084901c8116908214156114075780617fff1415610f74575061ffff60ef1b91506103b69050565b80617fff141561144b576dffffffffffffffffffffffffffff60801b84161561143a575061ffff60ef1b91506103b69050565b505050808218600160ff1b166103b6565b600160801b600160ff1b03841661149557600160801b600160ff1b03851661147d575061ffff60ef1b91506103b69050565b505050808218600160ff1b16617fff60f01b176103b6565b6001600160701b03608085901c16816114b157600191506114b8565b600160701b175b6001600160701b03608087901c16836114f75780156114f25760006114dc82611aab565b6001955060e20393840160711901939190911b90505b611501565b600160701b1760721b5b81818161151057611510611f45565b0490508061152c57600160ff1b8787181661102457600061102a565b6001606c1b81101561154057611540611f19565b6000600160731b82101561157f57600160721b82101561157457600160711b82101561156d576070611577565b6071611577565b60725b60ff16611588565b61158882611aab565b9050836140710181860111156115a657617fff945060009150611639565b83818601613ffc0110156115c1576000945060009150611639565b83818601613f8c01101561160e578385613ffc0111156115ec578385613ffc010382901b9150611605565b8385613ffc01101561160557613ffc8585030382901c91505b60009450611639565b6070811115611621576070810382901c91505b6001600160701b038216915083818601613f8d010394505b81607086901b888a186001607f1b60801b1660801c6001600160801b0316171760801b955050505050506103b6565b6000617fff60f083901c16613fff8110156116865750600092915050565b6001607f1b608084901c1061169a57600080fd5b6140fe8111156116a957600080fd5b600160701b6001600160701b03608085901c161761406f8210156116d35761406f8290031c610a7e565b61406f821115610a7e5761406e1982011b9392505050565b6000617fff60f084811c8216919084901c8116908214156117395780617fff141561172f576001600160801b03198581169085161415610f435784925050506103b6565b84925050506103b6565b80617fff141561174d5783925050506103b6565b6001607f1b608086901c90811015906001600160701b031683611773576001935061177a565b600160701b175b6001607f1b608087901c90811015906001600160701b0316846117a057600194506117a7565b600160701b175b826117d7576001600160801b03198816600160ff1b146117c757876117ca565b60005b96505050505050506103b6565b806117f7576001600160801b03198916600160ff1b146117c757886117ca565b848603841515831515141561190257607081131561181e57899750505050505050506103b6565b60008113156118305790811c9061185f565b606f1981121561184957889750505050505050506103b6565b600081121561185f578060000384901c93508596505b92810192600160711b841061187a576001968701969390931c925b86617fff14156118ac578461189457617fff60f01b61189e565b6001600160f01b03195b9750505050505050506103b6565b600160701b8410156118c157600096506118ce565b6001600160701b03841693505b83607088901b866118e05760006118e6565b6001607f1b5b6001600160801b0316171760801b9750505050505050506103b6565b600081131561191d57600184901b9350600187039650611934565b600081121561193457600182901b91506001860396505b60708113156119465760019150611993565b6001811315611963576001810360018303901c6001019150611993565b606f198112156119765760019350611993565b600019811215611993576001816000030360018503901c60010193505b8184106119a45781840393506119ad565b83820393508294505b836119c35750600096506103b695505050505050565b60006119ce85611aab565b905080607114156119f457600185901c6001600160701b03169450600188019750611a43565b6070811015611a3657607081900380891115611a23578086901b6001600160701b031695508089039850611a30565b600098600019019590951b945b50611a43565b6001600160701b03851694505b87617fff1415611a765785611a5d57617fff60f01b611a67565b6001600160f01b03195b985050505050505050506103b6565b84607089901b87611a88576000611a8e565b6001607f1b5b6001600160801b0316171760801b985050505050505050506103b6565b6000808211611ab957600080fd5b6000600160801b8310611ace57608092831c92015b680100000000000000008310611ae657604092831c92015b6401000000008310611afa57602092831c92015b620100008310611b0c57601092831c92015b6101008310611b1d57600892831c92015b60108310611b2d57600492831c92015b60048310611b3d57600292831c92015b600283106103b65760010192915050565b600060208284031215611b6057600080fd5b8135610a7e8161202d565b600060208284031215611b7d57600080fd5b8151610a7e8161202d565b600080600060608486031215611b9d57600080fd5b8335611ba88161202d565b95602085013595506040909401359392505050565b600080600080600060a08688031215611bd557600080fd5b8535611be08161202d565b97602087013597506040870135966060810135965060800135945092505050565b60008060208385031215611c1457600080fd5b823567ffffffffffffffff80821115611c2c57600080fd5b818501915085601f830112611c4057600080fd5b813581811115611c4f57600080fd5b8660208260051b8501011115611c6457600080fd5b60209290920196919550909350505050565b600060208284031215611c8857600080fd5b81518015158114610a7e57600080fd5b600060208284031215611caa57600080fd5b5051919050565b60008060008060808587031215611cc757600080fd5b84519350602085015167ffffffffffffffff80821115611ce657600080fd5b818701915087601f830112611cfa57600080fd5b815181811115611d0c57611d0c611f71565b6040519150611d25601f8201601f191660200183611ed1565b808252886020828501011115611d3a57600080fd5b611d4b816020840160208601611ea5565b50604087015160609097015195989097509350505050565b600060208284031215611d7557600080fd5b5035919050565b60008060408385031215611d8f57600080fd5b50508035926020909101359150565b600060208284031215611db057600080fd5b815160ff81168114610a7e57600080fd5b60008151808452611dd9816020860160208601611ea5565b601f01601f19169290920160200192915050565b602081526000610a7e6020830184611dc1565b6020808252818101527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604082015260600190565b60008219821115611e4857611e48611f2f565b500190565b600082611e6a57634e487b7160e01b600052601260045260246000fd5b500490565b6000816000190483118215151615611e8957611e89611f2f565b500290565b600082821015611ea057611ea0611f2f565b500390565b60005b83811015611ec0578181015183820152602001611ea8565b83811115610e415750506000910152565b601f8201601f1916810167ffffffffffffffff81118282101715611ef757611ef7611f71565b6040525050565b6000600019821415611f1257611f12611f2f565b5060010190565b634e487b7160e01b600052600160045260246000fd5b634e487b7160e01b600052601160045260246000fd5b634e487b7160e01b600052601260045260246000fd5b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052604160045260246000fd5b600060033d1115611fa05760046000803e5060005160e01c5b90565b600060443d1015611fb15790565b6040516003193d81016004833e81513d67ffffffffffffffff8160248401118184111715611fe157505050505090565b8285019150815181811115611ff95750505050505090565b843d87010160208285010111156120135750505050505090565b61202260208286010187611ed1565b509095945050505050565b6001600160a01b0381168114610df657600080fdfea2646970667358221220988875ec96a517baf17be9ffbee4e384aa46a79f39a9ed03a243bf502f0c229864736f6c63430008070033",
  "libraries": {
    "PoolSwapLibrary": "0x2fB38A21cC1cE33a4a49c034893eaA5Fb3D0Dc76"
  },
  "devdoc": {
    "kind": "dev",
    "methods": {
      "checkUpkeepMultiplePools(address[])": {
        "details": "Iterates over the provided array of pool addresses",
        "params": {
          "_pools": "Array of pools to check"
        },
        "returns": {
          "_0": "Whether or not at least one pool needs upkeeping"
        }
      },
      "checkUpkeepSinglePool(address)": {
        "params": {
          "_pool": "The address of the pool to upkeep"
        },
        "returns": {
          "_0": "Whether or not upkeep is needed for this single pool"
        }
      },
      "keeperGas(address,uint256,uint256)": {
        "params": {
          "_gasPrice": "Price of a single gas unit (in ETH (wei))",
          "_gasSpent": "Number of gas units spent",
          "_pool": "Address of the given pool"
        },
        "returns": {
          "_0": "Keeper's gas compensation"
        }
      },
      "keeperReward(address,uint256,uint256,uint256,uint256)": {
        "params": {
          "_gasPrice": "Price of a single gas unit (in ETH (wei))",
          "_gasSpent": "Number of gas units spent",
          "_pool": "Address of the given pool",
          "_poolInterval": "Pool interval of the given pool",
          "_savedPreviousUpdatedTimestamp": "Last timestamp when the pool's price execution happened"
        },
        "returns": {
          "_0": "Number of settlement tokens to give to the keeper for work performed"
        }
      },
      "keeperTip(uint256,uint256)": {
        "params": {
          "_poolInterval": "Pool interval of the given pool",
          "_savedPreviousUpdatedTimestamp": "Last timestamp when the pool's price execution happened"
        },
        "returns": {
          "_0": "Percent of the `keeperGas` cost to add to payment, as a percent"
        }
      },
      "newPool(address)": {
        "details": "Only callable by the associated `PoolFactory` contract",
        "params": {
          "_poolAddress": "The address of the newly-created pools"
        }
      },
      "owner()": {
        "details": "Returns the address of the current owner."
      },
      "performUpkeepMultiplePools(address[])": {
        "details": "Iterates over the provided arrayEssentially wraps calls to `performUpkeepSinglePool`",
        "params": {
          "pools": "Addresses of each pool to upkeep"
        }
      },
      "performUpkeepSinglePool(address)": {
        "details": "Induces an update of the associated `PriceObserver` contractTracks gas usage via `gasleft` accounting and uses this to inform          keeper paymentCatches any failure of the underlying `pool.poolUpkeep` call",
        "params": {
          "_pool": "Address of the pool to be upkept"
        }
      },
      "renounceOwnership()": {
        "details": "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."
      },
      "setFactory(address)": {
        "details": "Only callable by the owner",
        "params": {
          "_factory": "Address of the `PoolFactory` contract"
        }
      },
      "setGasPrice(uint256)": {
        "details": "Only callable by the ownerThis function is only necessary due to the L2 deployment of Pools -- in reality, it should be `BASEFEE`",
        "params": {
          "_price": "Price (in ETH) per unit gas"
        }
      },
      "transferOwnership(address)": {
        "details": "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."
      }
    },
    "title": "The manager contract for multiple markets and the pools in them",
    "version": 1
  },
  "userdoc": {
    "events": {
      "KeeperPaid(address,address,uint256)": {
        "notice": "Creates a notification when a keeper is paid for doing upkeep for a pool"
      },
      "KeeperPaymentError(address,address,uint256)": {
        "notice": "Creates a notification when a keeper's payment for upkeeping a pool failed"
      },
      "PoolAdded(address,int256)": {
        "notice": "Creates a notification when a pool is created"
      },
      "PoolUpkeepError(address,string)": {
        "notice": "Creates a notification of a failed pool update"
      },
      "UpkeepSuccessful(address,bytes,int256,int256)": {
        "notice": "Creates a notification when a call to LeveragedPool:poolUpkeep is successful"
      }
    },
    "kind": "user",
    "methods": {
      "checkUpkeepMultiplePools(address[])": {
        "notice": "Checks multiple pools if any of them need updating"
      },
      "checkUpkeepSinglePool(address)": {
        "notice": "Check if upkeep is required"
      },
      "executionPrice(address)": {
        "notice": "Format: Pool address => last executionPrice"
      },
      "keeperGas(address,uint256,uint256)": {
        "notice": "Compensation a keeper will receive for their gas expenditure"
      },
      "keeperReward(address,uint256,uint256,uint256,uint256)": {
        "notice": "Payment keeper receives for performing upkeep on a given pool"
      },
      "keeperTip(uint256,uint256)": {
        "notice": "Tip a keeper will receive for successfully updating the specified pool"
      },
      "newPool(address)": {
        "notice": "When a pool is created, this function is called by the factory to initiate price trackings"
      },
      "performUpkeepMultiplePools(address[])": {
        "notice": "Called by keepers to perform an update on multiple pools"
      },
      "performUpkeepSinglePool(address)": {
        "notice": "Called by keepers to perform an update on a single pool"
      },
      "setFactory(address)": {
        "notice": "Sets the address of the associated `PoolFactory` contract"
      },
      "setGasPrice(uint256)": {
        "notice": "Sets the gas price to be used in compensating keepers for successful upkeep"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 110,
        "contract": "contracts/implementation/PoolKeeper.sol:PoolKeeper",
        "label": "_owner",
        "offset": 0,
        "slot": "0",
        "type": "t_address"
      },
      {
        "astId": 12616,
        "contract": "contracts/implementation/PoolKeeper.sol:PoolKeeper",
        "label": "executionPrice",
        "offset": 0,
        "slot": "1",
        "type": "t_mapping(t_address,t_int256)"
      },
      {
        "astId": 12619,
        "contract": "contracts/implementation/PoolKeeper.sol:PoolKeeper",
        "label": "factory",
        "offset": 0,
        "slot": "2",
        "type": "t_contract(IPoolFactory)15779"
      },
      {
        "astId": 12625,
        "contract": "contracts/implementation/PoolKeeper.sol:PoolKeeper",
        "label": "gasPrice",
        "offset": 0,
        "slot": "3",
        "type": "t_uint256"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_contract(IPoolFactory)15779": {
        "encoding": "inplace",
        "label": "contract IPoolFactory",
        "numberOfBytes": "20"
      },
      "t_int256": {
        "encoding": "inplace",
        "label": "int256",
        "numberOfBytes": "32"
      },
      "t_mapping(t_address,t_int256)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => int256)",
        "numberOfBytes": "32",
        "value": "t_int256"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}