{
  "address": "0x996Ee119621e9f757dDc3944ee8A56e86586e48b",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_poolFactoryAddress",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "user",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "poolCommitter",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "updateIntervalId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "reward",
          "type": "uint256"
        }
      ],
      "name": "PaidClaimRequest",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "user",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "poolCommitter",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "newReward",
          "type": "uint256"
        }
      ],
      "name": "PaidClaimRequestUpdate",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "user",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "poolCommitter",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "reward",
          "type": "uint256"
        }
      ],
      "name": "PaidRequestExecution",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "user",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "poolCommitter",
          "type": "address"
        }
      ],
      "name": "RequestWithdrawn",
      "type": "event"
    },
    {
      "stateMutability": "payable",
      "type": "fallback"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint128",
              "name": "updateIntervalId",
              "type": "uint128"
            },
            {
              "internalType": "uint256",
              "name": "reward",
              "type": "uint256"
            }
          ],
          "internalType": "struct IAutoClaim.ClaimRequest",
          "name": "request",
          "type": "tuple"
        },
        {
          "internalType": "uint256",
          "name": "currentUpdateIntervalId",
          "type": "uint256"
        }
      ],
      "name": "checkClaim",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "user",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "poolCommitter",
          "type": "address"
        }
      ],
      "name": "checkUserClaim",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "claimRequests",
      "outputs": [
        {
          "internalType": "uint128",
          "name": "updateIntervalId",
          "type": "uint128"
        },
        {
          "internalType": "uint256",
          "name": "reward",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "user",
          "type": "address"
        }
      ],
      "name": "makePaidClaimRequest",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "users",
          "type": "address[]"
        },
        {
          "internalType": "address[]",
          "name": "poolCommitterAddresses",
          "type": "address[]"
        }
      ],
      "name": "multiPaidClaimMultiplePoolCommitters",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "users",
          "type": "address[]"
        },
        {
          "internalType": "address",
          "name": "poolCommitterAddress",
          "type": "address"
        }
      ],
      "name": "multiPaidClaimSinglePoolCommitter",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "user",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "poolCommitterAddress",
          "type": "address"
        }
      ],
      "name": "paidClaim",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "poolCommitter",
          "type": "address"
        }
      ],
      "name": "withdrawClaimRequest",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "user",
          "type": "address"
        }
      ],
      "name": "withdrawUserClaimRequest",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "stateMutability": "payable",
      "type": "receive"
    }
  ],
  "transactionHash": "0x4dbe77fcd86078d75a0b4cd443a8f08729eaed7c097be3171865ee6eeda0b0b4",
  "receipt": {
    "to": null,
    "from": "0xc18fcFFD8c9173faB1684Ec1EEE32976f780B13E",
    "contractAddress": "0x996Ee119621e9f757dDc3944ee8A56e86586e48b",
    "transactionIndex": 0,
    "gasUsed": "13527802",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xc047edd1a2edb798622ab05f1c56f6a597e2c60aff1b87588ef8775f841368f6",
    "transactionHash": "0x4dbe77fcd86078d75a0b4cd443a8f08729eaed7c097be3171865ee6eeda0b0b4",
    "logs": [],
    "blockNumber": 8969852,
    "cumulativeGasUsed": "6016462",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0xcbD0bA56d7b533eb96f13dB7f7D779432d485391"
  ],
  "solcInputHash": "4e236762a3d0441b39001e87e67104bc",
  "metadata": "{\"compiler\":{\"version\":\"0.8.7+commit.e28d00a7\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_poolFactoryAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"poolCommitter\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"updateIntervalId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"PaidClaimRequest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"poolCommitter\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newReward\",\"type\":\"uint256\"}],\"name\":\"PaidClaimRequestUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"poolCommitter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"PaidRequestExecution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"poolCommitter\",\"type\":\"address\"}],\"name\":\"RequestWithdrawn\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint128\",\"name\":\"updateIntervalId\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"internalType\":\"struct IAutoClaim.ClaimRequest\",\"name\":\"request\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"currentUpdateIntervalId\",\"type\":\"uint256\"}],\"name\":\"checkClaim\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"poolCommitter\",\"type\":\"address\"}],\"name\":\"checkUserClaim\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"claimRequests\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"updateIntervalId\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"makePaidClaimRequest\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"users\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"poolCommitterAddresses\",\"type\":\"address[]\"}],\"name\":\"multiPaidClaimMultiplePoolCommitters\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"users\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"poolCommitterAddress\",\"type\":\"address\"}],\"name\":\"multiPaidClaimSinglePoolCommitter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"poolCommitterAddress\",\"type\":\"address\"}],\"name\":\"paidClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolCommitter\",\"type\":\"address\"}],\"name\":\"withdrawClaimRequest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"withdrawUserClaimRequest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}],\"devdoc\":{\"details\":\"A question I had to ask was \\\"What happens if one requests a second claim before one's pending request from a previous update interval one gets executed on?\\\".      My solution to this was to have the committer instantly claim for themself. They have signified their desire to claim their tokens, after all.\",\"kind\":\"dev\",\"methods\":{\"checkClaim((uint128,uint256),uint256)\":{\"details\":\"A claim request can be executed only if one exists and is from an update interval that has passed.\",\"params\":{\"currentUpdateIntervalId\":\"The current update interval. Used to compare to the update interval of the ClaimRequest.\",\"request\":\"The ClaimRequest object to be checked.\"},\"returns\":{\"_0\":\"true if the given claim request can be executed.\"}},\"checkUserClaim(address,address)\":{\"params\":{\"poolCommitter\":\"The pool committer in which to look for a user's claim request.\",\"user\":\"The user whose claim request will be checked.\"},\"returns\":{\"_0\":\"true if the claim request can be executed.\"}},\"makePaidClaimRequest(address)\":{\"details\":\"Only callable by this contract's associated PoolCommitter instance. This prevents griefing. Consider a permissionless function, where a user can claim that somebody else wants to auto claim when they do not.\",\"params\":{\"user\":\"The user who wants to autoclaim.\"}},\"multiPaidClaimMultiplePoolCommitters(address[],address[])\":{\"details\":\"The nth index in poolCommitterAddresses should be the PoolCommitter where the nth address in user requested an auto claim.\",\"params\":{\"poolCommitterAddresses\":\"The PoolCommitter addresses within which you would like to claim for the respective user.\",\"users\":\"All users to execute claims for.\"}},\"multiPaidClaimSinglePoolCommitter(address[],address)\":{\"details\":\"The nth index in poolCommitterAddresses should be the PoolCommitter where the nth address in user requested an auto claim\",\"params\":{\"poolCommitterAddress\":\"The PoolCommitter address within which you would like to claim for the respective user\",\"users\":\"All users to execute claims for.\"}},\"paidClaim(address,address)\":{\"params\":{\"poolCommitterAddress\":\"The PoolCommitter address within which the user's claim will be executed\",\"user\":\"The user who requested an autoclaim.\"}},\"withdrawClaimRequest(address)\":{\"details\":\"Emits a `RequestWithdrawn` event on success\",\"params\":{\"poolCommitter\":\"The PoolCommitter for which the user's commit claim is to be withdrawn.\"}},\"withdrawUserClaimRequest(address)\":{\"details\":\"Only callable by the associated `PoolCommitter` contract\",\"params\":{\"user\":\"The user who will have their claim request withdrawn.\"}}},\"title\":\"The contract to be used for paying to have a keeper claim your commit automatically\",\"version\":1},\"userdoc\":{\"events\":{\"PaidClaimRequest(address,address,uint256,uint256)\":{\"notice\":\"Creates a notification when an auto-claim is requested\"},\"PaidClaimRequestUpdate(address,address,uint256)\":{\"notice\":\"Creates a notification when an auto-claim request is updated. i.e. When another commit is added and reward is incremented.\"},\"PaidRequestExecution(address,address,uint256)\":{\"notice\":\"Creates a notification when an auto-claim request is executed\"},\"RequestWithdrawn(address,address)\":{\"notice\":\"Creates a notification when an auto-claim request is withdrawn\"}},\"kind\":\"user\",\"methods\":{\"checkUserClaim(address,address)\":{\"notice\":\"Check the validity of a user's claim request for a given pool committer.\"},\"makePaidClaimRequest(address)\":{\"notice\":\"Pay for your commit to be claimed. This means that a willing participant can claim on `user`'s behalf when the current update interval ends.\"},\"multiPaidClaimMultiplePoolCommitters(address[],address[])\":{\"notice\":\"Call `paidClaim` for multiple users, across multiple PoolCommitters.\"},\"multiPaidClaimSinglePoolCommitter(address[],address)\":{\"notice\":\"Call `paidClaim` for multiple users, in a single PoolCommitter.\"},\"paidClaim(address,address)\":{\"notice\":\"Claim on the behalf of a user who has requests to have their commit automatically claimed by a keeper.\"},\"withdrawClaimRequest(address)\":{\"notice\":\"If a user's claim request never gets executed (due to not high enough of a reward), or they change their minds, enable them to withdraw their request.\"},\"withdrawUserClaimRequest(address)\":{\"notice\":\"When the user claims themself through poolCommitter, you want the\"}},\"notice\":\"The way this works is when a user commits with `PoolCommitter::commit`, they have the option to set the `bool payForClaim` parameter to `true`.         During this function execution, `AutoClaim::payForClaim` is called, and `msg.value` is taken as the reward to whoever claims for requester (by using `AutoClaim::paidClaim`).\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/implementation/AutoClaim.sol\":\"AutoClaim\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/implementation/AutoClaim.sol\":{\"content\":\"//SPDX-License-Identifier: CC-BY-NC-ND-4.0\\npragma solidity 0.8.7;\\n\\nimport \\\"../interfaces/IPoolFactory.sol\\\";\\nimport \\\"../interfaces/IPoolCommitter.sol\\\";\\nimport \\\"../interfaces/IAutoClaim.sol\\\";\\n\\n/// @title The contract to be used for paying to have a keeper claim your commit automatically\\n/// @notice The way this works is when a user commits with `PoolCommitter::commit`, they have the option to set the `bool payForClaim` parameter to `true`.\\n///         During this function execution, `AutoClaim::payForClaim` is called, and `msg.value` is taken as the reward to whoever claims for requester (by using `AutoClaim::paidClaim`).\\n/// @dev A question I had to ask was \\\"What happens if one requests a second claim before one's pending request from a previous update interval one gets executed on?\\\".\\n///      My solution to this was to have the committer instantly claim for themself. They have signified their desire to claim their tokens, after all.\\ncontract AutoClaim is IAutoClaim {\\n    // User => PoolCommitter address => Claim Request\\n    mapping(address => mapping(address => ClaimRequest)) public claimRequests;\\n    IPoolFactory internal poolFactory;\\n\\n    constructor(address _poolFactoryAddress) {\\n        require(_poolFactoryAddress != address(0), \\\"PoolFactory address == 0\\\");\\n        poolFactory = IPoolFactory(_poolFactoryAddress);\\n    }\\n\\n    /**\\n     * @notice Pay for your commit to be claimed. This means that a willing participant can claim on `user`'s behalf when the current update interval ends.\\n     * @dev Only callable by this contract's associated PoolCommitter instance. This prevents griefing. Consider a permissionless function, where a user can claim that somebody else wants to auto claim when they do not.\\n     * @param user The user who wants to autoclaim.\\n     */\\n    function makePaidClaimRequest(address user) external payable override onlyPoolCommitter {\\n        ClaimRequest storage request = claimRequests[user][msg.sender];\\n        IPoolCommitter poolCommitter = IPoolCommitter(msg.sender);\\n\\n        uint128 requestUpdateIntervalId = request.updateIntervalId;\\n        // Check if a previous claim request is pending...\\n        if (requestUpdateIntervalId > 0) {\\n            // and if it is claimable (the current update interval is greater than the one where the request was made).\\n            if (requestUpdateIntervalId < poolCommitter.updateIntervalId()) {\\n                // If so, this person may as well claim for themself (if allowed). They have signified their want of claim, after all.\\n                // Note that this function is only called by PoolCommitter when a user `commits` and therefore `user` will always equal the original `msg.sender`.\\n                payable(user).transfer(claimRequests[user][msg.sender].reward);\\n                delete claimRequests[user][msg.sender];\\n                poolCommitter.claim(user);\\n            } else {\\n                // If the claim request is pending but not yet valid (it was made in the current commit), we want to add to the value.\\n                // Note that in context, the user *usually* won't need or want to increment `ClaimRequest.reward` more than once because the first call to `payForClaim` should suffice.\\n                request.reward += msg.value;\\n                emit PaidClaimRequestUpdate(user, msg.sender, msg.value);\\n                return;\\n            }\\n        }\\n\\n        // If no previous claim requests are pending, we need to make a new one.\\n        requestUpdateIntervalId = poolCommitter.getAppropriateUpdateIntervalId();\\n        claimRequests[user][msg.sender].updateIntervalId = requestUpdateIntervalId;\\n        claimRequests[user][msg.sender].reward = msg.value;\\n        emit PaidClaimRequestUpdate(user, msg.sender, msg.value);\\n    }\\n\\n    /**\\n     * @notice Claim on the behalf of a user who has requests to have their commit automatically claimed by a keeper.\\n     * @param user The user who requested an autoclaim.\\n     * @param poolCommitterAddress The PoolCommitter address within which the user's claim will be executed\\n     */\\n    function paidClaim(address user, address poolCommitterAddress) public override {\\n        ClaimRequest memory request = claimRequests[user][poolCommitterAddress];\\n        IPoolCommitter poolCommitter = IPoolCommitter(poolCommitterAddress);\\n        uint256 currentUpdateIntervalId = poolCommitter.updateIntervalId();\\n        // Check if a previous claim request has been made, and if it is claimable.\\n        if (checkClaim(request, currentUpdateIntervalId)) {\\n            // Send the reward to msg.sender.\\n            payable(msg.sender).transfer(request.reward);\\n            // delete the ClaimRequest from storage\\n            delete claimRequests[user][poolCommitterAddress];\\n            // execute the claim\\n            poolCommitter.claim(user);\\n            emit PaidRequestExecution(user, poolCommitterAddress, request.reward);\\n        }\\n    }\\n\\n    /**\\n     * @notice Call `paidClaim` for multiple users, across multiple PoolCommitters.\\n     * @param users All users to execute claims for.\\n     * @param poolCommitterAddresses The PoolCommitter addresses within which you would like to claim for the respective user.\\n     * @dev The nth index in poolCommitterAddresses should be the PoolCommitter where the nth address in user requested an auto claim.\\n     */\\n    function multiPaidClaimMultiplePoolCommitters(address[] calldata users, address[] calldata poolCommitterAddresses)\\n        external\\n        override\\n    {\\n        require(users.length == poolCommitterAddresses.length, \\\"Supplied arrays must be same length\\\");\\n        for (uint256 i = 0; i < users.length; i++) {\\n            paidClaim(users[i], poolCommitterAddresses[i]);\\n        }\\n    }\\n\\n    /**\\n     * @notice Call `paidClaim` for multiple users, in a single PoolCommitter.\\n     * @param users All users to execute claims for.\\n     * @param poolCommitterAddress The PoolCommitter address within which you would like to claim for the respective user\\n     * @dev The nth index in poolCommitterAddresses should be the PoolCommitter where the nth address in user requested an auto claim\\n     */\\n    function multiPaidClaimSinglePoolCommitter(address[] calldata users, address poolCommitterAddress)\\n        external\\n        override\\n    {\\n        for (uint256 i = 0; i < users.length; i++) {\\n            paidClaim(users[i], poolCommitterAddress);\\n        }\\n    }\\n\\n    /**\\n     * @notice If a user's claim request never gets executed (due to not high enough of a reward), or they change their minds, enable them to withdraw their request.\\n     * @param poolCommitter The PoolCommitter for which the user's commit claim is to be withdrawn.\\n     * @dev Emits a `RequestWithdrawn` event on success\\n     */\\n    function withdrawClaimRequest(address poolCommitter) external override {\\n        if (claimRequests[msg.sender][poolCommitter].updateIntervalId > 0) {\\n            payable(msg.sender).transfer(claimRequests[msg.sender][poolCommitter].reward);\\n            delete claimRequests[msg.sender][poolCommitter];\\n            emit RequestWithdrawn(msg.sender, poolCommitter);\\n        }\\n    }\\n\\n    /**\\n     * @notice When the user claims themself through poolCommitter, you want the\\n     * @param user The user who will have their claim request withdrawn.\\n     * @dev Only callable by the associated `PoolCommitter` contract\\n     */\\n    function withdrawUserClaimRequest(address user) public override onlyPoolCommitter {\\n        payable(user).transfer(claimRequests[user][msg.sender].reward);\\n        delete claimRequests[user][msg.sender];\\n    }\\n\\n    /**\\n     * @notice Check the validity of a user's claim request for a given pool committer.\\n     * @return true if the claim request can be executed.\\n     * @param user The user whose claim request will be checked.\\n     * @param poolCommitter The pool committer in which to look for a user's claim request.\\n     */\\n    function checkUserClaim(address user, address poolCommitter) public view override returns (bool) {\\n        return checkClaim(claimRequests[user][poolCommitter], IPoolCommitter(poolCommitter).updateIntervalId());\\n    }\\n\\n    /**\\n     * @return true if the given claim request can be executed.\\n     * @dev A claim request can be executed only if one exists and is from an update interval that has passed.\\n     * @param request The ClaimRequest object to be checked.\\n     * @param currentUpdateIntervalId The current update interval. Used to compare to the update interval of the ClaimRequest.\\n     */\\n    function checkClaim(ClaimRequest memory request, uint256 currentUpdateIntervalId)\\n        public\\n        pure\\n        override\\n        returns (bool)\\n    {\\n        return request.updateIntervalId > 0 && request.updateIntervalId < currentUpdateIntervalId;\\n    }\\n\\n    receive() external payable {\\n        revert();\\n    }\\n\\n    fallback() external payable {\\n        revert();\\n    }\\n\\n    modifier onlyPoolCommitter() {\\n        require(poolFactory.isValidPoolCommitter(msg.sender), \\\"msg.sender not valid PoolCommitter\\\");\\n        _;\\n    }\\n}\\n\",\"keccak256\":\"0xee765633443890a275888679a53a405dbc19360ec05531eb1cb758f5b4ecbe76\",\"license\":\"CC-BY-NC-ND-4.0\"},\"contracts/interfaces/IAutoClaim.sol\":{\"content\":\"//SPDX-License-Identifier: CC-BY-NC-ND-4.0\\npragma solidity 0.8.7;\\n\\ninterface IAutoClaim {\\n    /**\\n     * @notice Creates a notification when an auto-claim is requested\\n     * @param user The user who made a request\\n     * @param poolCommitter The PoolCommitter instance in which the commit was made\\n     * @param updateIntervalId The update interval ID that the corresponding commitment was allocated for\\n     * @param reward The reward for the auto-claim\\n     */\\n    event PaidClaimRequest(\\n        address indexed user,\\n        address indexed poolCommitter,\\n        uint256 indexed updateIntervalId,\\n        uint256 reward\\n    );\\n\\n    /**\\n     * @notice Creates a notification when an auto-claim request is updated. i.e. When another commit is added and reward is incremented.\\n     * @param user The user whose request got updated\\n     * @param poolCommitter The PoolCommitter instance in which the commits were made\\n     * @param newReward The new total reward for the auto-claim\\n     */\\n    event PaidClaimRequestUpdate(address indexed user, address indexed poolCommitter, uint256 indexed newReward);\\n\\n    /**\\n     * @notice Creates a notification when an auto-claim request is executed\\n     * @param user The user whose request got executed\\n     * @param poolCommitter The PoolCommitter instance in which the original commit was made\\n     * @param reward The reward for the auto-claim\\n     */\\n    event PaidRequestExecution(address user, address poolCommitter, uint256 reward);\\n\\n    /**\\n     * @notice Creates a notification when an auto-claim request is withdrawn\\n     * @param user The user whose request got withdrawn\\n     * @param poolCommitter The PoolCommitter instance in which the original commit was made\\n     */\\n    event RequestWithdrawn(address user, address poolCommitter);\\n\\n    struct ClaimRequest {\\n        uint128 updateIntervalId; // The update interval during which a user requested a claim.\\n        uint256 reward; // The amount of ETH in wei that was given by the user to pay for upkeep\\n    }\\n\\n    /**\\n     * @notice Pay for your commit to be claimed. This means that a willing participant can claim on `user`'s behalf when the current update interval ends.\\n     * @dev Only callable by this contract's associated PoolCommitter instance. This prevents griefing. Consider a permissionless function, where a user can claim that somebody else wants to auto claim when they do not.\\n     * @param user The user who wants to autoclaim.\\n     */\\n    function makePaidClaimRequest(address user) external payable;\\n\\n    /**\\n     * @notice Claim on the behalf of a user who has requests to have their commit automatically claimed by a keeper.\\n     * @param user The user who requested an autoclaim.\\n     * @param poolCommitterAddress The PoolCommitter address within which the user's claim will be executed\\n     */\\n    function paidClaim(address user, address poolCommitterAddress) external;\\n\\n    /**\\n     * @notice Call `paidClaim` for multiple users, across multiple PoolCommitters\\n     * @param users All users to execute claims for.\\n     * @param poolCommitterAddresses The PoolCommitter addresses within which you would like to claim for the respective user\\n     * @dev The nth index in poolCommitterAddresses should be the PoolCommitter where the nth address in user requested an auto claim\\n     */\\n    function multiPaidClaimMultiplePoolCommitters(address[] calldata users, address[] calldata poolCommitterAddresses)\\n        external;\\n\\n    /**\\n     * @notice Call `paidClaim` for multiple users, in a single PoolCommitter.\\n     * @dev The nth index in poolCommitterAddresses should be the PoolCommitter where the nth address in user requested an auto claim\\n     * @param users All users to execute claims for.\\n     * @param poolCommitterAddress The PoolCommitter address within which you would like to claim for the respective user\\n     */\\n    function multiPaidClaimSinglePoolCommitter(address[] calldata users, address poolCommitterAddress) external;\\n\\n    /**\\n     * @notice If a user's claim request never gets executed (due to not high enough of a reward), or they change their minds, enable them to withdraw their request.\\n     * @param poolCommitter The PoolCommitter for which the user's commit claim is to be withdrawn.\\n     */\\n    function withdrawClaimRequest(address poolCommitter) external;\\n\\n    /**\\n     * @notice When the user claims themself through poolCommitter, you want the\\n     * @param user The user who will have their claim request withdrawn.\\n     */\\n    function withdrawUserClaimRequest(address user) external;\\n\\n    /**\\n     * @notice Check the validity of a user's claim request for a given pool committer.\\n     * @return true if the claim request can be executed.\\n     * @param user The user whose claim request will be checked.\\n     * @param poolCommitter The pool committer in which to look for a user's claim request.\\n     */\\n    function checkUserClaim(address user, address poolCommitter) external view returns (bool);\\n\\n    /**\\n     * @return true if the given claim request can be executed.\\n     * @dev A claim request can be executed only if one exists and is from an update interval that has passed.\\n     * @param request The ClaimRequest object to be checked.\\n     * @param currentUpdateIntervalId The current update interval. Used to compare to the update interval of the ClaimRequest.\\n     */\\n    function checkClaim(ClaimRequest memory request, uint256 currentUpdateIntervalId) external pure returns (bool);\\n}\\n\",\"keccak256\":\"0xd4bdff0ff2a81be7c8f56a0f45b55caedb8af423684b29013f94f0841647553b\",\"license\":\"CC-BY-NC-ND-4.0\"},\"contracts/interfaces/IPoolCommitter.sol\":{\"content\":\"//SPDX-License-Identifier: CC-BY-NC-ND-4.0\\npragma solidity 0.8.7;\\n\\n/// @title The interface for the contract that handles pool commitments\\ninterface IPoolCommitter {\\n    /// Type of commit\\n    enum CommitType {\\n        ShortMint, // Mint short tokens\\n        ShortBurn, // Burn short tokens\\n        LongMint, // Mint long tokens\\n        LongBurn, // Burn long tokens\\n        LongBurnShortMint, // Burn Long tokens, then instantly mint in same upkeep\\n        ShortBurnLongMint // Burn Short tokens, then instantly mint in same upkeep\\n    }\\n\\n    struct BalancesAndSupplies {\\n        uint256 shortBalance;\\n        uint256 longBalance;\\n        uint256 longTotalSupplyBefore;\\n        uint256 shortTotalSupplyBefore;\\n    }\\n\\n    // User aggregate balance\\n    struct Balance {\\n        uint256 longTokens;\\n        uint256 shortTokens;\\n        uint256 settlementTokens;\\n    }\\n\\n    // Token Prices\\n    struct Prices {\\n        bytes16 longPrice;\\n        bytes16 shortPrice;\\n    }\\n\\n    // Commit information\\n    struct Commit {\\n        uint256 amount;\\n        CommitType commitType;\\n        uint40 created;\\n        address owner;\\n    }\\n\\n    // Commit information\\n    struct TotalCommitment {\\n        uint256 longMintAmount;\\n        uint256 longBurnAmount;\\n        uint256 shortMintAmount;\\n        uint256 shortBurnAmount;\\n        uint256 shortBurnLongMintAmount;\\n        uint256 longBurnShortMintAmount;\\n        uint256 updateIntervalId;\\n    }\\n\\n    struct BalanceUpdate {\\n        uint256 _updateIntervalId;\\n        uint256 _newLongTokensSum;\\n        uint256 _newShortTokensSum;\\n        uint256 _newSettlementTokensSum;\\n        uint256 _balanceLongBurnAmount;\\n        uint256 _balanceShortBurnAmount;\\n        uint256 _longBurnFee;\\n        uint256 _shortBurnFee;\\n    }\\n\\n    // Track how much of a user's commitments are being done from their aggregate balance\\n    struct UserCommitment {\\n        uint256 longMintAmount;\\n        uint256 longBurnAmount;\\n        uint256 balanceLongBurnAmount;\\n        uint256 shortMintAmount;\\n        uint256 shortBurnAmount;\\n        uint256 balanceShortBurnAmount;\\n        uint256 shortBurnLongMintAmount;\\n        uint256 balanceShortBurnMintAmount;\\n        uint256 longBurnShortMintAmount;\\n        uint256 balanceLongBurnMintAmount;\\n        uint256 updateIntervalId;\\n    }\\n\\n    /**\\n     * @notice Creates a notification when a commit is created\\n     * @param user The user making the commitment\\n     * @param amount Amount of the commit\\n     * @param commitType Type of the commit (Short v Long, Mint v Burn)\\n     * @param appropriateUpdateIntervalId Id of update interval where this commit can be executed as part of upkeep\\n     * @param mintingFee Minting fee at time of commit creation\\n     */\\n    event CreateCommit(\\n        address indexed user,\\n        uint256 indexed amount,\\n        CommitType indexed commitType,\\n        uint256 appropriateUpdateIntervalId,\\n        bytes16 mintingFee\\n    );\\n\\n    /**\\n     * @notice Creates a notification when a user's aggregate balance is updated\\n     */\\n    event AggregateBalanceUpdated(address indexed user);\\n\\n    /**\\n     * @notice Creates a notification when commits for a given update interval are executed\\n     * @param updateIntervalId Unique identifier for the relevant update interval\\n     * @param burningFee Burning fee at the time of commit execution\\n     */\\n    event ExecutedCommitsForInterval(uint256 indexed updateIntervalId, bytes16 burningFee);\\n\\n    /**\\n     * @notice Creates a notification when a claim is made, depositing pool tokens in user's wallet\\n     */\\n    event Claim(address indexed user);\\n\\n    /**\\n     * @notice Creates a notification when the burningFee is updated\\n     */\\n    event BurningFeeSet(uint256 indexed _burningFee);\\n\\n    /**\\n     * @notice Creates a notification when the mintingFee is updated\\n     */\\n    event MintingFeeSet(uint256 indexed _mintingFee);\\n\\n    /**\\n     * @notice Creates a notification when the changeInterval is updated\\n     */\\n    event ChangeIntervalSet(uint256 indexed _changeInterval);\\n\\n    // #### Functions\\n\\n    function initialize(\\n        address _factory,\\n        address _invariantCheckContract,\\n        address _autoClaim,\\n        uint256 mintingFee,\\n        uint256 burningFee,\\n        uint256 _changeInterval\\n    ) external;\\n\\n    function commit(\\n        CommitType commitType,\\n        uint256 amount,\\n        bool fromAggregateBalance,\\n        bool payForClaim\\n    ) external payable;\\n\\n    function updateIntervalId() external view returns (uint128);\\n\\n    function claim(address user) external;\\n\\n    function executeCommitments() external;\\n\\n    function updateAggregateBalance(address user) external;\\n\\n    function getAggregateBalance(address user) external view returns (Balance memory _balance);\\n\\n    function getAppropriateUpdateIntervalId() external view returns (uint128);\\n\\n    function setQuoteAndPool(address _quoteToken, address _leveragedPool) external;\\n\\n    function setBurningFee(uint256 _burningFee) external;\\n\\n    function setMintingFee(uint256 _mintingFee) external;\\n\\n    function setChangeInterval(uint256 _changeInterval) external;\\n\\n    function getPendingCommits() external view returns (TotalCommitment memory, TotalCommitment memory);\\n}\\n\",\"keccak256\":\"0xace84b7eb356fa095b6ea6cde2b7b5bf58c27b8756fcb74a711ae025f8188937\",\"license\":\"CC-BY-NC-ND-4.0\"},\"contracts/interfaces/IPoolFactory.sol\":{\"content\":\"//SPDX-License-Identifier: CC-BY-NC-ND-4.0\\npragma solidity 0.8.7;\\n\\n/// @title The contract factory for the keeper and pool contracts. Utilizes minimal clones to keep gas costs low\\ninterface IPoolFactory {\\n    struct PoolDeployment {\\n        string poolName; // The name to identify a pool by\\n        uint32 frontRunningInterval; // The minimum number of seconds that must elapse before a commit can be executed. Must be smaller than or equal to the update interval to prevent deadlock\\n        uint32 updateInterval; // The minimum number of seconds that must elapse before a price change\\n        uint16 leverageAmount; // The amount of exposure to price movements for the pool\\n        address quoteToken; // The digital asset that the pool accepts\\n        address oracleWrapper; // The IOracleWrapper implementation for fetching price feed data\\n        address settlementEthOracle; // The oracle to fetch the price of Ether in terms of the settlement token\\n        address invariantCheckContract; // The IInvariantCheck contract that performs invariant checking\\n    }\\n\\n    // #### Events\\n    /**\\n     * @notice Creates a notification when a pool is deployed\\n     * @param pool Address of the new pool\\n     * @param ticker Ticker of the neew pool\\n     */\\n    event DeployPool(address indexed pool, address poolCommitter, string ticker);\\n\\n    /**\\n     * @notice Creates a notification when the pool keeper changes\\n     * @param _poolKeeper Address of the new pool keeper\\n     */\\n    event PoolKeeperChanged(address _poolKeeper);\\n\\n    // #### Getters for Globals\\n    function pools(uint256 id) external view returns (address);\\n\\n    function numPools() external view returns (uint256);\\n\\n    function isValidPool(address _pool) external view returns (bool);\\n\\n    function isValidPoolCommitter(address _poolCommitter) external view returns (bool);\\n\\n    // #### Functions\\n    function deployPool(PoolDeployment calldata deploymentParameters) external returns (address);\\n\\n    function getOwner() external returns (address);\\n\\n    function setPoolKeeper(address _poolKeeper) external;\\n\\n    function setAutoClaim(address _autoClaim) external;\\n\\n    function setMaxLeverage(uint16 newMaxLeverage) external;\\n\\n    function setFeeReceiver(address _feeReceiver) external;\\n\\n    function setFee(uint256 _fee) external;\\n\\n    function setSecondaryFeeSplitPercent(uint256 newFeePercent) external;\\n\\n    function setMintAndBurnFeeAndChangeInterval(\\n        uint256 _mintingFee,\\n        uint256 _burningFee,\\n        uint256 _changeInterval\\n    ) external;\\n}\\n\",\"keccak256\":\"0x3683e0f630a770132d0fec73abd39b9daf72ddf89d950255972ad979c09d1c2c\",\"license\":\"CC-BY-NC-ND-4.0\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50604051610f81380380610f8183398101604081905261002f916100ae565b6001600160a01b0381166100895760405162461bcd60e51b815260206004820152601860248201527f506f6f6c466163746f72792061646472657373203d3d20300000000000000000604482015260640160405180910390fd5b600180546001600160a01b0319166001600160a01b03929092169190911790556100de565b6000602082840312156100c057600080fd5b81516001600160a01b03811681146100d757600080fd5b9392505050565b610e94806100ed6000396000f3fe60806040526004361061008a5760003560e01c8063883e9e4811610059578063883e9e48146101305780638d68dd61146101505780639b42f47e146101b7578063c76ac728146101ca578063f009fc08146101ea57600080fd5b806307119aeb14610099578063351ea38a146100bb5780634c830642146100f057806384de06e41461011057600080fd5b3661009457600080fd5b600080fd5b3480156100a557600080fd5b506100b96100b4366004610be0565b61020a565b005b3480156100c757600080fd5b506100db6100d6366004610d10565b61032b565b60405190151581526020015b60405180910390f35b3480156100fc57600080fd5b506100b961010b366004610be0565b610357565b34801561011c57600080fd5b506100b961012b366004610c2e565b610447565b34801561013c57600080fd5b506100db61014b366004610bfb565b61049a565b34801561015c57600080fd5b5061019861016b366004610bfb565b6000602081815292815260408082209093529081522080546001909101546001600160801b039091169082565b604080516001600160801b0390931683526020830191909152016100e7565b6100b96101c5366004610be0565b61055d565b3480156101d657600080fd5b506100b96101e5366004610bfb565b6108ce565b3480156101f657600080fd5b506100b9610205366004610c82565b610aaf565b6001546040516359e86a9960e01b81523360048201526001600160a01b03909116906359e86a999060240160206040518083038186803b15801561024d57600080fd5b505afa158015610261573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102859190610cee565b6102aa5760405162461bcd60e51b81526004016102a190610da8565b60405180910390fd5b6001600160a01b03811660008181526020818152604080832033845290915280822060010154905181156108fc0292818181858888f193505050501580156102f6573d6000803e3d6000fd5b506001600160a01b0316600090815260208181526040808320338452909152812080546001600160801b031916815560010155565b81516000906001600160801b031615801590610350575082516001600160801b031682115b9392505050565b336000908152602081815260408083206001600160a01b03851684529091529020546001600160801b03161561044457336000818152602081815260408083206001600160a01b038616845290915280822060010154905181156108fc0292818181858888f193505050501580156103d3573d6000803e3d6000fd5b50336000818152602081815260408083206001600160a01b03861680855290835281842080546001600160801b0319168155600101939093558051938452908301919091527fbeb52c9358dfd474b9e79cc7bb7c88a2079664f938ff899c7a54bbaa5e54b08a910160405180910390a15b50565b60005b828110156104945761048284848381811061046757610467610e33565b905060200201602081019061047c9190610be0565b836108ce565b8061048c81610e02565b91505061044a565b50505050565b6001600160a01b038083166000908152602081815260408083209385168084529382528083208151808301835281546001600160801b03168152600190910154818401528151634e81899760e11b8152915193946103509491939092639d03132e9260048083019392829003018186803b15801561051757600080fd5b505afa15801561052b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061054f9190610d8b565b6001600160801b031661032b565b6001546040516359e86a9960e01b81523360048201526001600160a01b03909116906359e86a999060240160206040518083038186803b1580156105a057600080fd5b505afa1580156105b4573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105d89190610cee565b6105f45760405162461bcd60e51b81526004016102a190610da8565b6001600160a01b03811660009081526020818152604080832033808552925290912080549091906001600160801b031680156107e757816001600160a01b0316639d03132e6040518163ffffffff1660e01b815260040160206040518083038186803b15801561066357600080fd5b505afa158015610677573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061069b9190610d8b565b6001600160801b0316816001600160801b03161015610790576001600160a01b03841660008181526020818152604080832033845290915280822060010154905181156108fc0292818181858888f19350505050158015610700573d6000803e3d6000fd5b506001600160a01b0384811660008181526020818152604080832033845290915280822080546001600160801b03191681556001019190915551630f41a04d60e11b8152600481019190915290831690631e83409a90602401600060405180830381600087803b15801561077357600080fd5b505af1158015610787573d6000803e3d6000fd5b505050506107e7565b348360010160008282546107a49190610dea565b9091555050604051349033906001600160a01b038716907f1b0cd6fbb8d6f8911969df04996d8d67f926c059c09a2df27305bb1b36b5917c90600090a450505050565b816001600160a01b031663d4c4e2836040518163ffffffff1660e01b815260040160206040518083038186803b15801561082057600080fd5b505afa158015610834573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108589190610d8b565b6001600160a01b03851660008181526020818152604080832033808552925280832080546001600160801b0319166001600160801b0387161781553460019091018190559051949550939092917f1b0cd6fbb8d6f8911969df04996d8d67f926c059c09a2df27305bb1b36b5917c91a450505050565b6001600160a01b038083166000908152602081815260408083209385168084529382528083208151808301835281546001600160801b03168152600190910154818401528151634e81899760e11b8152915190948694939092639d03132e9260048083019392829003018186803b15801561094857600080fd5b505afa15801561095c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109809190610d8b565b6001600160801b03169050610995838261032b565b15610aa8576020830151604051339180156108fc02916000818181858888f193505050501580156109ca573d6000803e3d6000fd5b506001600160a01b03858116600081815260208181526040808320898616845290915280822080546001600160801b03191681556001019190915551630f41a04d60e11b8152600481019190915290831690631e83409a90602401600060405180830381600087803b158015610a3f57600080fd5b505af1158015610a53573d6000803e3d6000fd5b505050602080850151604080516001600160a01b03808b1682528916938101939093528201527ffc1ef6f920271c53bdf1b6aa6a98b1cd7baa573c736975d7eb1f85b2f0c3d7f3915060600160405180910390a15b5050505050565b828114610b0a5760405162461bcd60e51b815260206004820152602360248201527f537570706c69656420617272617973206d7573742062652073616d65206c656e6044820152620cee8d60eb1b60648201526084016102a1565b60005b83811015610aa857610b66858583818110610b2a57610b2a610e33565b9050602002016020810190610b3f9190610be0565b848484818110610b5157610b51610e33565b90506020020160208101906101e59190610be0565b80610b7081610e02565b915050610b0d565b80356001600160a01b0381168114610b8f57600080fd5b919050565b60008083601f840112610ba657600080fd5b50813567ffffffffffffffff811115610bbe57600080fd5b6020830191508360208260051b8501011115610bd957600080fd5b9250929050565b600060208284031215610bf257600080fd5b61035082610b78565b60008060408385031215610c0e57600080fd5b610c1783610b78565b9150610c2560208401610b78565b90509250929050565b600080600060408486031215610c4357600080fd5b833567ffffffffffffffff811115610c5a57600080fd5b610c6686828701610b94565b9094509250610c79905060208501610b78565b90509250925092565b60008060008060408587031215610c9857600080fd5b843567ffffffffffffffff80821115610cb057600080fd5b610cbc88838901610b94565b90965094506020870135915080821115610cd557600080fd5b50610ce287828801610b94565b95989497509550505050565b600060208284031215610d0057600080fd5b8151801515811461035057600080fd5b6000808284036060811215610d2457600080fd5b6040811215610d3257600080fd5b506040516040810181811067ffffffffffffffff82111715610d6457634e487b7160e01b600052604160045260246000fd5b6040528335610d7281610e49565b8152602084810135908201529460409093013593505050565b600060208284031215610d9d57600080fd5b815161035081610e49565b60208082526022908201527f6d73672e73656e646572206e6f742076616c696420506f6f6c436f6d6d69747460408201526132b960f11b606082015260800190565b60008219821115610dfd57610dfd610e1d565b500190565b6000600019821415610e1657610e16610e1d565b5060010190565b634e487b7160e01b600052601160045260246000fd5b634e487b7160e01b600052603260045260246000fd5b6001600160801b038116811461044457600080fdfea2646970667358221220287dbeef63912f17c6de2e410d550099c9180663d696b521f904e0f04f788c2964736f6c63430008070033",
  "deployedBytecode": "0x60806040526004361061008a5760003560e01c8063883e9e4811610059578063883e9e48146101305780638d68dd61146101505780639b42f47e146101b7578063c76ac728146101ca578063f009fc08146101ea57600080fd5b806307119aeb14610099578063351ea38a146100bb5780634c830642146100f057806384de06e41461011057600080fd5b3661009457600080fd5b600080fd5b3480156100a557600080fd5b506100b96100b4366004610be0565b61020a565b005b3480156100c757600080fd5b506100db6100d6366004610d10565b61032b565b60405190151581526020015b60405180910390f35b3480156100fc57600080fd5b506100b961010b366004610be0565b610357565b34801561011c57600080fd5b506100b961012b366004610c2e565b610447565b34801561013c57600080fd5b506100db61014b366004610bfb565b61049a565b34801561015c57600080fd5b5061019861016b366004610bfb565b6000602081815292815260408082209093529081522080546001909101546001600160801b039091169082565b604080516001600160801b0390931683526020830191909152016100e7565b6100b96101c5366004610be0565b61055d565b3480156101d657600080fd5b506100b96101e5366004610bfb565b6108ce565b3480156101f657600080fd5b506100b9610205366004610c82565b610aaf565b6001546040516359e86a9960e01b81523360048201526001600160a01b03909116906359e86a999060240160206040518083038186803b15801561024d57600080fd5b505afa158015610261573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102859190610cee565b6102aa5760405162461bcd60e51b81526004016102a190610da8565b60405180910390fd5b6001600160a01b03811660008181526020818152604080832033845290915280822060010154905181156108fc0292818181858888f193505050501580156102f6573d6000803e3d6000fd5b506001600160a01b0316600090815260208181526040808320338452909152812080546001600160801b031916815560010155565b81516000906001600160801b031615801590610350575082516001600160801b031682115b9392505050565b336000908152602081815260408083206001600160a01b03851684529091529020546001600160801b03161561044457336000818152602081815260408083206001600160a01b038616845290915280822060010154905181156108fc0292818181858888f193505050501580156103d3573d6000803e3d6000fd5b50336000818152602081815260408083206001600160a01b03861680855290835281842080546001600160801b0319168155600101939093558051938452908301919091527fbeb52c9358dfd474b9e79cc7bb7c88a2079664f938ff899c7a54bbaa5e54b08a910160405180910390a15b50565b60005b828110156104945761048284848381811061046757610467610e33565b905060200201602081019061047c9190610be0565b836108ce565b8061048c81610e02565b91505061044a565b50505050565b6001600160a01b038083166000908152602081815260408083209385168084529382528083208151808301835281546001600160801b03168152600190910154818401528151634e81899760e11b8152915193946103509491939092639d03132e9260048083019392829003018186803b15801561051757600080fd5b505afa15801561052b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061054f9190610d8b565b6001600160801b031661032b565b6001546040516359e86a9960e01b81523360048201526001600160a01b03909116906359e86a999060240160206040518083038186803b1580156105a057600080fd5b505afa1580156105b4573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105d89190610cee565b6105f45760405162461bcd60e51b81526004016102a190610da8565b6001600160a01b03811660009081526020818152604080832033808552925290912080549091906001600160801b031680156107e757816001600160a01b0316639d03132e6040518163ffffffff1660e01b815260040160206040518083038186803b15801561066357600080fd5b505afa158015610677573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061069b9190610d8b565b6001600160801b0316816001600160801b03161015610790576001600160a01b03841660008181526020818152604080832033845290915280822060010154905181156108fc0292818181858888f19350505050158015610700573d6000803e3d6000fd5b506001600160a01b0384811660008181526020818152604080832033845290915280822080546001600160801b03191681556001019190915551630f41a04d60e11b8152600481019190915290831690631e83409a90602401600060405180830381600087803b15801561077357600080fd5b505af1158015610787573d6000803e3d6000fd5b505050506107e7565b348360010160008282546107a49190610dea565b9091555050604051349033906001600160a01b038716907f1b0cd6fbb8d6f8911969df04996d8d67f926c059c09a2df27305bb1b36b5917c90600090a450505050565b816001600160a01b031663d4c4e2836040518163ffffffff1660e01b815260040160206040518083038186803b15801561082057600080fd5b505afa158015610834573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108589190610d8b565b6001600160a01b03851660008181526020818152604080832033808552925280832080546001600160801b0319166001600160801b0387161781553460019091018190559051949550939092917f1b0cd6fbb8d6f8911969df04996d8d67f926c059c09a2df27305bb1b36b5917c91a450505050565b6001600160a01b038083166000908152602081815260408083209385168084529382528083208151808301835281546001600160801b03168152600190910154818401528151634e81899760e11b8152915190948694939092639d03132e9260048083019392829003018186803b15801561094857600080fd5b505afa15801561095c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109809190610d8b565b6001600160801b03169050610995838261032b565b15610aa8576020830151604051339180156108fc02916000818181858888f193505050501580156109ca573d6000803e3d6000fd5b506001600160a01b03858116600081815260208181526040808320898616845290915280822080546001600160801b03191681556001019190915551630f41a04d60e11b8152600481019190915290831690631e83409a90602401600060405180830381600087803b158015610a3f57600080fd5b505af1158015610a53573d6000803e3d6000fd5b505050602080850151604080516001600160a01b03808b1682528916938101939093528201527ffc1ef6f920271c53bdf1b6aa6a98b1cd7baa573c736975d7eb1f85b2f0c3d7f3915060600160405180910390a15b5050505050565b828114610b0a5760405162461bcd60e51b815260206004820152602360248201527f537570706c69656420617272617973206d7573742062652073616d65206c656e6044820152620cee8d60eb1b60648201526084016102a1565b60005b83811015610aa857610b66858583818110610b2a57610b2a610e33565b9050602002016020810190610b3f9190610be0565b848484818110610b5157610b51610e33565b90506020020160208101906101e59190610be0565b80610b7081610e02565b915050610b0d565b80356001600160a01b0381168114610b8f57600080fd5b919050565b60008083601f840112610ba657600080fd5b50813567ffffffffffffffff811115610bbe57600080fd5b6020830191508360208260051b8501011115610bd957600080fd5b9250929050565b600060208284031215610bf257600080fd5b61035082610b78565b60008060408385031215610c0e57600080fd5b610c1783610b78565b9150610c2560208401610b78565b90509250929050565b600080600060408486031215610c4357600080fd5b833567ffffffffffffffff811115610c5a57600080fd5b610c6686828701610b94565b9094509250610c79905060208501610b78565b90509250925092565b60008060008060408587031215610c9857600080fd5b843567ffffffffffffffff80821115610cb057600080fd5b610cbc88838901610b94565b90965094506020870135915080821115610cd557600080fd5b50610ce287828801610b94565b95989497509550505050565b600060208284031215610d0057600080fd5b8151801515811461035057600080fd5b6000808284036060811215610d2457600080fd5b6040811215610d3257600080fd5b506040516040810181811067ffffffffffffffff82111715610d6457634e487b7160e01b600052604160045260246000fd5b6040528335610d7281610e49565b8152602084810135908201529460409093013593505050565b600060208284031215610d9d57600080fd5b815161035081610e49565b60208082526022908201527f6d73672e73656e646572206e6f742076616c696420506f6f6c436f6d6d69747460408201526132b960f11b606082015260800190565b60008219821115610dfd57610dfd610e1d565b500190565b6000600019821415610e1657610e16610e1d565b5060010190565b634e487b7160e01b600052601160045260246000fd5b634e487b7160e01b600052603260045260246000fd5b6001600160801b038116811461044457600080fdfea2646970667358221220287dbeef63912f17c6de2e410d550099c9180663d696b521f904e0f04f788c2964736f6c63430008070033",
  "devdoc": {
    "details": "A question I had to ask was \"What happens if one requests a second claim before one's pending request from a previous update interval one gets executed on?\".      My solution to this was to have the committer instantly claim for themself. They have signified their desire to claim their tokens, after all.",
    "kind": "dev",
    "methods": {
      "checkClaim((uint128,uint256),uint256)": {
        "details": "A claim request can be executed only if one exists and is from an update interval that has passed.",
        "params": {
          "currentUpdateIntervalId": "The current update interval. Used to compare to the update interval of the ClaimRequest.",
          "request": "The ClaimRequest object to be checked."
        },
        "returns": {
          "_0": "true if the given claim request can be executed."
        }
      },
      "checkUserClaim(address,address)": {
        "params": {
          "poolCommitter": "The pool committer in which to look for a user's claim request.",
          "user": "The user whose claim request will be checked."
        },
        "returns": {
          "_0": "true if the claim request can be executed."
        }
      },
      "makePaidClaimRequest(address)": {
        "details": "Only callable by this contract's associated PoolCommitter instance. This prevents griefing. Consider a permissionless function, where a user can claim that somebody else wants to auto claim when they do not.",
        "params": {
          "user": "The user who wants to autoclaim."
        }
      },
      "multiPaidClaimMultiplePoolCommitters(address[],address[])": {
        "details": "The nth index in poolCommitterAddresses should be the PoolCommitter where the nth address in user requested an auto claim.",
        "params": {
          "poolCommitterAddresses": "The PoolCommitter addresses within which you would like to claim for the respective user.",
          "users": "All users to execute claims for."
        }
      },
      "multiPaidClaimSinglePoolCommitter(address[],address)": {
        "details": "The nth index in poolCommitterAddresses should be the PoolCommitter where the nth address in user requested an auto claim",
        "params": {
          "poolCommitterAddress": "The PoolCommitter address within which you would like to claim for the respective user",
          "users": "All users to execute claims for."
        }
      },
      "paidClaim(address,address)": {
        "params": {
          "poolCommitterAddress": "The PoolCommitter address within which the user's claim will be executed",
          "user": "The user who requested an autoclaim."
        }
      },
      "withdrawClaimRequest(address)": {
        "details": "Emits a `RequestWithdrawn` event on success",
        "params": {
          "poolCommitter": "The PoolCommitter for which the user's commit claim is to be withdrawn."
        }
      },
      "withdrawUserClaimRequest(address)": {
        "details": "Only callable by the associated `PoolCommitter` contract",
        "params": {
          "user": "The user who will have their claim request withdrawn."
        }
      }
    },
    "title": "The contract to be used for paying to have a keeper claim your commit automatically",
    "version": 1
  },
  "userdoc": {
    "events": {
      "PaidClaimRequest(address,address,uint256,uint256)": {
        "notice": "Creates a notification when an auto-claim is requested"
      },
      "PaidClaimRequestUpdate(address,address,uint256)": {
        "notice": "Creates a notification when an auto-claim request is updated. i.e. When another commit is added and reward is incremented."
      },
      "PaidRequestExecution(address,address,uint256)": {
        "notice": "Creates a notification when an auto-claim request is executed"
      },
      "RequestWithdrawn(address,address)": {
        "notice": "Creates a notification when an auto-claim request is withdrawn"
      }
    },
    "kind": "user",
    "methods": {
      "checkUserClaim(address,address)": {
        "notice": "Check the validity of a user's claim request for a given pool committer."
      },
      "makePaidClaimRequest(address)": {
        "notice": "Pay for your commit to be claimed. This means that a willing participant can claim on `user`'s behalf when the current update interval ends."
      },
      "multiPaidClaimMultiplePoolCommitters(address[],address[])": {
        "notice": "Call `paidClaim` for multiple users, across multiple PoolCommitters."
      },
      "multiPaidClaimSinglePoolCommitter(address[],address)": {
        "notice": "Call `paidClaim` for multiple users, in a single PoolCommitter."
      },
      "paidClaim(address,address)": {
        "notice": "Claim on the behalf of a user who has requests to have their commit automatically claimed by a keeper."
      },
      "withdrawClaimRequest(address)": {
        "notice": "If a user's claim request never gets executed (due to not high enough of a reward), or they change their minds, enable them to withdraw their request."
      },
      "withdrawUserClaimRequest(address)": {
        "notice": "When the user claims themself through poolCommitter, you want the"
      }
    },
    "notice": "The way this works is when a user commits with `PoolCommitter::commit`, they have the option to set the `bool payForClaim` parameter to `true`.         During this function execution, `AutoClaim::payForClaim` is called, and `msg.value` is taken as the reward to whoever claims for requester (by using `AutoClaim::paidClaim`).",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 7507,
        "contract": "contracts/implementation/AutoClaim.sol:AutoClaim",
        "label": "claimRequests",
        "offset": 0,
        "slot": "0",
        "type": "t_mapping(t_address,t_mapping(t_address,t_struct(ClaimRequest)14990_storage))"
      },
      {
        "astId": 7510,
        "contract": "contracts/implementation/AutoClaim.sol:AutoClaim",
        "label": "poolFactory",
        "offset": 0,
        "slot": "1",
        "type": "t_contract(IPoolFactory)15779"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_contract(IPoolFactory)15779": {
        "encoding": "inplace",
        "label": "contract IPoolFactory",
        "numberOfBytes": "20"
      },
      "t_mapping(t_address,t_mapping(t_address,t_struct(ClaimRequest)14990_storage))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(address => struct IAutoClaim.ClaimRequest))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_address,t_struct(ClaimRequest)14990_storage)"
      },
      "t_mapping(t_address,t_struct(ClaimRequest)14990_storage)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => struct IAutoClaim.ClaimRequest)",
        "numberOfBytes": "32",
        "value": "t_struct(ClaimRequest)14990_storage"
      },
      "t_struct(ClaimRequest)14990_storage": {
        "encoding": "inplace",
        "label": "struct IAutoClaim.ClaimRequest",
        "members": [
          {
            "astId": 14987,
            "contract": "contracts/implementation/AutoClaim.sol:AutoClaim",
            "label": "updateIntervalId",
            "offset": 0,
            "slot": "0",
            "type": "t_uint128"
          },
          {
            "astId": 14989,
            "contract": "contracts/implementation/AutoClaim.sol:AutoClaim",
            "label": "reward",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_uint128": {
        "encoding": "inplace",
        "label": "uint128",
        "numberOfBytes": "16"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}