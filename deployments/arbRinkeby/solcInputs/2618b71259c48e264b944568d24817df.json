{
    "language": "Solidity",
    "sources": {
        "contracts/implementation/AutoClaim.sol": {
            "content": "//SPDX-License-Identifier: CC-BY-NC-ND-4.0\npragma solidity 0.8.7;\n\nimport \"../interfaces/IPoolFactory.sol\";\nimport \"../interfaces/IPoolCommitter.sol\";\nimport \"../interfaces/IAutoClaim.sol\";\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/// @title The contract to be used for paying to have a keeper claim your commit automatically\n/// @notice The way this works is when a user commits with `PoolCommitter::commit`, they have the option to set the `bool payForClaim` parameter to `true`.\n///         During this function execution, `AutoClaim::payForClaim` is called, and `msg.value` is taken as the reward to whoever claims for requester (by using `AutoClaim::paidClaim`).\n/// @dev A question I had to ask was \"What happens if one requests a second claim before one's pending request from a previous update interval one gets executed on?\".\n///      My solution to this was to have the committer instantly claim for themself. They have signified their desire to claim their tokens, after all.\ncontract AutoClaim is IAutoClaim, Initializable {\n    // User => PoolCommitter address => Claim Request\n    mapping(address => mapping(address => ClaimRequest)) public claimRequests;\n    IPoolFactory internal poolFactory;\n\n    constructor(address _poolFactoryAddress) {\n        require(_poolFactoryAddress != address(0), \"PoolFactory address == 0\");\n        poolFactory = IPoolFactory(_poolFactoryAddress);\n    }\n\n    function initialize(address _poolFactoryAddress) external override initializer {\n        require(_poolFactoryAddress != address(0), \"PoolFactory address == 0\");\n        poolFactory = IPoolFactory(_poolFactoryAddress);\n    }\n\n    /**\n     * @notice Pay for your commit to be claimed. This means that a willing participant can claim on `user`'s behalf when the current update interval ends.\n     * @dev Only callable by this contract's associated PoolCommitter instance. This prevents griefing. Consider a permissionless function, where a user can claim that somebody else wants to auto claim when they do not.\n     * @param user The user who wants to autoclaim.\n     */\n    function makePaidClaimRequest(address user) external payable override onlyPoolCommitter {\n        ClaimRequest storage request = claimRequests[user][msg.sender];\n        IPoolCommitter poolCommitter = IPoolCommitter(msg.sender);\n\n        uint128 requestUpdateIntervalId = request.updateIntervalId;\n        // Check if a previous claim request is pending...\n        if (requestUpdateIntervalId > 0) {\n            // and if it is claimable (the current update interval is greater than the one where the request was made).\n            if (requestUpdateIntervalId < poolCommitter.updateIntervalId()) {\n                // If so, this person may as well claim for themself (if allowed). They have signified their want of claim, after all.\n                // Note that this function is only called by PoolCommitter when a user `commits` and therefore `user` will always equal the original `msg.sender`.\n                payable(user).transfer(claimRequests[user][msg.sender].reward);\n                delete claimRequests[user][msg.sender];\n                poolCommitter.claim(user);\n            } else {\n                // If the claim request is pending but not yet valid (it was made in the current commit), we want to add to the value.\n                // Note that in context, the user *usually* won't need or want to increment `ClaimRequest.reward` more than once because the first call to `payForClaim` should suffice.\n                request.reward += msg.value;\n                emit PaidClaimRequestUpdate(user, msg.sender, msg.value);\n                return;\n            }\n        }\n\n        // If no previous claim requests are pending, we need to make a new one.\n        requestUpdateIntervalId = poolCommitter.getAppropriateUpdateIntervalId();\n        claimRequests[user][msg.sender].updateIntervalId = requestUpdateIntervalId;\n        claimRequests[user][msg.sender].reward = msg.value;\n        emit PaidClaimRequestUpdate(user, msg.sender, msg.value);\n    }\n\n    /**\n     * @notice Claim on the behalf of a user who has requests to have their commit automatically claimed by a keeper.\n     * @param user The user who requested an autoclaim.\n     * @param poolCommitterAddress The PoolCommitter address within which the user's claim will be executed\n     */\n    function paidClaim(address user, address poolCommitterAddress) public override {\n        ClaimRequest memory request = claimRequests[user][poolCommitterAddress];\n        IPoolCommitter poolCommitter = IPoolCommitter(poolCommitterAddress);\n        uint256 currentUpdateIntervalId = poolCommitter.updateIntervalId();\n        // Check if a previous claim request has been made, and if it is claimable.\n        if (checkClaim(request, currentUpdateIntervalId)) {\n            // Send the reward to msg.sender.\n            payable(msg.sender).transfer(request.reward);\n            // delete the ClaimRequest from storage\n            delete claimRequests[user][poolCommitterAddress];\n            // execute the claim\n            poolCommitter.claim(user);\n            emit PaidRequestExecution(user, poolCommitterAddress, request.reward);\n        }\n    }\n\n    /**\n     * @notice Call `paidClaim` for multiple users, across multiple PoolCommitters.\n     * @param users All users to execute claims for.\n     * @param poolCommitterAddresses The PoolCommitter addresses within which you would like to claim for the respective user.\n     * @dev The nth index in poolCommitterAddresses should be the PoolCommitter where the nth address in user requested an auto claim.\n     */\n    function multiPaidClaimMultiplePoolCommitters(address[] calldata users, address[] calldata poolCommitterAddresses)\n        external\n        override\n    {\n        require(users.length == poolCommitterAddresses.length, \"Supplied arrays must be same length\");\n        for (uint256 i = 0; i < users.length; i++) {\n            paidClaim(users[i], poolCommitterAddresses[i]);\n        }\n    }\n\n    /**\n     * @notice Call `paidClaim` for multiple users, in a single PoolCommitter.\n     * @param users All users to execute claims for.\n     * @param poolCommitterAddress The PoolCommitter address within which you would like to claim for the respective user\n     * @dev The nth index in poolCommitterAddresses should be the PoolCommitter where the nth address in user requested an auto claim\n     */\n    function multiPaidClaimSinglePoolCommitter(address[] calldata users, address poolCommitterAddress)\n        external\n        override\n    {\n        for (uint256 i = 0; i < users.length; i++) {\n            paidClaim(users[i], poolCommitterAddress);\n        }\n    }\n\n    /**\n     * @notice If a user's claim request never gets executed (due to not high enough of a reward), or they change their minds, enable them to withdraw their request.\n     * @param poolCommitter The PoolCommitter for which the user's commit claim is to be withdrawn.\n     * @dev Emits a `RequestWithdrawn` event on success\n     */\n    function withdrawClaimRequest(address poolCommitter) external override {\n        if (claimRequests[msg.sender][poolCommitter].updateIntervalId > 0) {\n            payable(msg.sender).transfer(claimRequests[msg.sender][poolCommitter].reward);\n            delete claimRequests[msg.sender][poolCommitter];\n            emit RequestWithdrawn(msg.sender, poolCommitter);\n        }\n    }\n\n    /**\n     * @notice When the user claims themself through poolCommitter, you want the\n     * @param user The user who will have their claim request withdrawn.\n     * @dev Only callable by the associated `PoolCommitter` contract\n     */\n    function withdrawUserClaimRequest(address user) public override onlyPoolCommitter {\n        payable(user).transfer(claimRequests[user][msg.sender].reward);\n        delete claimRequests[user][msg.sender];\n    }\n\n    /**\n     * @notice Check the validity of a user's claim request for a given pool committer.\n     * @return true if the claim request can be executed.\n     * @param user The user whose claim request will be checked.\n     * @param poolCommitter The pool committer in which to look for a user's claim request.\n     */\n    function checkUserClaim(address user, address poolCommitter) public view override returns (bool) {\n        return checkClaim(claimRequests[user][poolCommitter], IPoolCommitter(poolCommitter).updateIntervalId());\n    }\n\n    /**\n     * @return true if the given claim request can be executed.\n     * @dev A claim request can be executed only if one exists and is from an update interval that has passed.\n     * @param request The ClaimRequest object to be checked.\n     * @param currentUpdateIntervalId The current update interval. Used to compare to the update interval of the ClaimRequest.\n     */\n    function checkClaim(ClaimRequest memory request, uint256 currentUpdateIntervalId)\n        public\n        pure\n        override\n        returns (bool)\n    {\n        return request.updateIntervalId > 0 && request.updateIntervalId < currentUpdateIntervalId;\n    }\n\n    modifier onlyPoolCommitter() {\n        require(poolFactory.isValidPoolCommitter(msg.sender), \"msg.sender not valid PoolCommitter\");\n        _;\n    }\n}\n"
        },
        "contracts/interfaces/IPoolFactory.sol": {
            "content": "//SPDX-License-Identifier: CC-BY-NC-ND-4.0\npragma solidity 0.8.7;\n\n/// @title The contract factory for the keeper and pool contracts. Utilizes minimal clones to keep gas costs low\ninterface IPoolFactory {\n    struct PoolDeployment {\n        string poolName; // The name to identify a pool by\n        uint32 frontRunningInterval; // The minimum number of seconds that must elapse before a commit can be executed. Must be smaller than or equal to the update interval to prevent deadlock\n        uint32 updateInterval; // The minimum number of seconds that must elapse before a price change\n        uint16 leverageAmount; // The amount of exposure to price movements for the pool\n        address quoteToken; // The digital asset that the pool accepts\n        address oracleWrapper; // The IOracleWrapper implementation for fetching price feed data\n        address settlementEthOracle; // The oracle to fetch the price of Ether in terms of the settlement token\n        address invariantCheckContract; // The IInvariantCheck contract that performs invariant checking\n    }\n\n    // #### Events\n    /**\n     * @notice Creates a notification when a pool is deployed\n     * @param pool Address of the new pool\n     * @param ticker Ticker of the neew pool\n     */\n    event DeployPool(address indexed pool, address poolCommitter, string ticker);\n\n    /**\n     * @notice Creates a notification when the pool keeper changes\n     * @param _poolKeeper Address of the new pool keeper\n     */\n    event PoolKeeperChanged(address _poolKeeper);\n\n    // #### Getters for Globals\n    function pools(uint256 id) external view returns (address);\n\n    function numPools() external view returns (uint256);\n\n    function isValidPool(address _pool) external view returns (bool);\n\n    function isValidPoolCommitter(address _poolCommitter) external view returns (bool);\n\n    // #### Functions\n    function deployPool(PoolDeployment calldata deploymentParameters) external returns (address);\n\n    function getOwner() external returns (address);\n\n    function setPoolKeeper(address _poolKeeper) external;\n\n    function setAutoClaim(address _autoClaim) external;\n\n    function setMaxLeverage(uint16 newMaxLeverage) external;\n\n    function setFeeReceiver(address _feeReceiver) external;\n\n    function setFee(uint256 _fee) external;\n\n    function setSecondaryFeeSplitPercent(uint256 newFeePercent) external;\n\n    function setMintAndBurnFee(uint256 _mintingFee, uint256 _burningFee) external;\n}\n"
        },
        "contracts/interfaces/IPoolCommitter.sol": {
            "content": "//SPDX-License-Identifier: CC-BY-NC-ND-4.0\npragma solidity 0.8.7;\n\n/// @title The interface for the contract that handles pool commitments\ninterface IPoolCommitter {\n    /// Type of commit\n    enum CommitType {\n        ShortMint, // Mint short tokens\n        ShortBurn, // Burn short tokens\n        LongMint, // Mint long tokens\n        LongBurn, // Burn long tokens\n        LongBurnShortMint, // Burn Long tokens, then instantly mint in same upkeep\n        ShortBurnLongMint // Burn Short tokens, then instantly mint in same upkeep\n    }\n\n    struct BalancesAndSupplies {\n        uint256 shortBalance;\n        uint256 longBalance;\n        uint256 longTotalSupplyBefore;\n        uint256 shortTotalSupplyBefore;\n    }\n\n    // User aggregate balance\n    struct Balance {\n        uint256 longTokens;\n        uint256 shortTokens;\n        uint256 settlementTokens;\n    }\n\n    // Token Prices\n    struct Prices {\n        bytes16 longPrice;\n        bytes16 shortPrice;\n    }\n\n    // Commit information\n    struct Commit {\n        uint256 amount;\n        CommitType commitType;\n        uint40 created;\n        address owner;\n    }\n\n    // Commit information\n    struct TotalCommitment {\n        uint256 longMintAmount;\n        uint256 longBurnAmount;\n        uint256 shortMintAmount;\n        uint256 shortBurnAmount;\n        uint256 shortBurnLongMintAmount;\n        uint256 longBurnShortMintAmount;\n        uint256 updateIntervalId;\n    }\n\n    struct BalanceUpdate {\n        uint256 _updateIntervalId;\n        uint256 _newLongTokensSum;\n        uint256 _newShortTokensSum;\n        uint256 _newSettlementTokensSum;\n        uint256 _balanceLongBurnAmount;\n        uint256 _balanceShortBurnAmount;\n        uint256 _longBurnFee;\n        uint256 _shortBurnFee;\n    }\n\n    // Track how much of a user's commitments are being done from their aggregate balance\n    struct UserCommitment {\n        uint256 longMintAmount;\n        uint256 longBurnAmount;\n        uint256 balanceLongBurnAmount;\n        uint256 shortMintAmount;\n        uint256 shortBurnAmount;\n        uint256 balanceShortBurnAmount;\n        uint256 shortBurnLongMintAmount;\n        uint256 balanceShortBurnMintAmount;\n        uint256 longBurnShortMintAmount;\n        uint256 balanceLongBurnMintAmount;\n        uint256 updateIntervalId;\n    }\n\n    /**\n     * @notice Creates a notification when a commit is created\n     * @param user The user making the commitment\n     * @param amount Amount of the commit\n     * @param commitType Type of the commit (Short v Long, Mint v Burn)\n     */\n    event CreateCommit(address indexed user, uint256 indexed amount, CommitType indexed commitType);\n\n    /**\n     * @notice Creates a notification when a user's aggregate balance is updated\n     */\n    event AggregateBalanceUpdated(address indexed user);\n\n    /**\n     * @notice Creates a notification when a claim is made, depositing pool tokens in user's wallet\n     */\n    event Claim(address indexed user);\n\n    // #### Functions\n\n    function initialize(\n        address _factory,\n        address _invariantCheckContract,\n        address _autoClaim,\n        uint256 mintingFee,\n        uint256 burningFee\n    ) external;\n\n    function commit(\n        CommitType commitType,\n        uint256 amount,\n        bool fromAggregateBalance,\n        bool payForClaim\n    ) external payable;\n\n    function updateIntervalId() external view returns (uint128);\n\n    function claim(address user) external;\n\n    function executeCommitments() external;\n\n    function updateAggregateBalance(address user) external;\n\n    function getAggregateBalance(address user) external view returns (Balance memory _balance);\n\n    function getAppropriateUpdateIntervalId() external view returns (uint128);\n\n    function setQuoteAndPool(address _quoteToken, address _leveragedPool) external;\n\n    function getPendingCommits() external view returns (TotalCommitment memory, TotalCommitment memory);\n}\n"
        },
        "contracts/interfaces/IAutoClaim.sol": {
            "content": "//SPDX-License-Identifier: CC-BY-NC-ND-4.0\npragma solidity 0.8.7;\n\ninterface IAutoClaim {\n    /**\n     * @notice Creates a notification when an auto-claim is requested\n     * @param user The user who made a request\n     * @param poolCommitter The PoolCommitter instance in which the commit was made\n     * @param updateIntervalId The update interval ID that the corresponding commitment was allocated for\n     * @param reward The reward for the auto-claim\n     */\n    event PaidClaimRequest(\n        address indexed user,\n        address indexed poolCommitter,\n        uint256 indexed updateIntervalId,\n        uint256 reward\n    );\n\n    /**\n     * @notice Creates a notification when an auto-claim request is updated. i.e. When another commit is added and reward is incremented.\n     * @param user The user whose request got updated\n     * @param poolCommitter The PoolCommitter instance in which the commits were made\n     * @param newReward The new total reward for the auto-claim\n     */\n    event PaidClaimRequestUpdate(address indexed user, address indexed poolCommitter, uint256 indexed newReward);\n\n    /**\n     * @notice Creates a notification when an auto-claim request is executed\n     * @param user The user whose request got executed\n     * @param poolCommitter The PoolCommitter instance in which the original commit was made\n     * @param reward The reward for the auto-claim\n     */\n    event PaidRequestExecution(address user, address poolCommitter, uint256 reward);\n\n    /**\n     * @notice Creates a notification when an auto-claim request is withdrawn\n     * @param user The user whose request got withdrawn\n     * @param poolCommitter The PoolCommitter instance in which the original commit was made\n     */\n    event RequestWithdrawn(address user, address poolCommitter);\n\n    struct ClaimRequest {\n        uint128 updateIntervalId; // The update interval during which a user requested a claim.\n        uint256 reward; // The amount of ETH in wei that was given by the user to pay for upkeep\n    }\n\n    function initialize(address _poolFactoryAddress) external;\n\n    /**\n     * @notice Pay for your commit to be claimed. This means that a willing participant can claim on `user`'s behalf when the current update interval ends.\n     * @dev Only callable by this contract's associated PoolCommitter instance. This prevents griefing. Consider a permissionless function, where a user can claim that somebody else wants to auto claim when they do not.\n     * @param user The user who wants to autoclaim.\n     */\n    function makePaidClaimRequest(address user) external payable;\n\n    /**\n     * @notice Claim on the behalf of a user who has requests to have their commit automatically claimed by a keeper.\n     * @param user The user who requested an autoclaim.\n     * @param poolCommitterAddress The PoolCommitter address within which the user's claim will be executed\n     */\n    function paidClaim(address user, address poolCommitterAddress) external;\n\n    /**\n     * @notice Call `paidClaim` for multiple users, across multiple PoolCommitters\n     * @param users All users to execute claims for.\n     * @param poolCommitterAddresses The PoolCommitter addresses within which you would like to claim for the respective user\n     * @dev The nth index in poolCommitterAddresses should be the PoolCommitter where the nth address in user requested an auto claim\n     */\n    function multiPaidClaimMultiplePoolCommitters(address[] calldata users, address[] calldata poolCommitterAddresses)\n        external;\n\n    /**\n     * @notice Call `paidClaim` for multiple users, in a single PoolCommitter.\n     * @dev The nth index in poolCommitterAddresses should be the PoolCommitter where the nth address in user requested an auto claim\n     * @param users All users to execute claims for.\n     * @param poolCommitterAddress The PoolCommitter address within which you would like to claim for the respective user\n     */\n    function multiPaidClaimSinglePoolCommitter(address[] calldata users, address poolCommitterAddress) external;\n\n    /**\n     * @notice If a user's claim request never gets executed (due to not high enough of a reward), or they change their minds, enable them to withdraw their request.\n     * @param poolCommitter The PoolCommitter for which the user's commit claim is to be withdrawn.\n     */\n    function withdrawClaimRequest(address poolCommitter) external;\n\n    /**\n     * @notice When the user claims themself through poolCommitter, you want the\n     * @param user The user who will have their claim request withdrawn.\n     */\n    function withdrawUserClaimRequest(address user) external;\n\n    /**\n     * @notice Check the validity of a user's claim request for a given pool committer.\n     * @return true if the claim request can be executed.\n     * @param user The user whose claim request will be checked.\n     * @param poolCommitter The pool committer in which to look for a user's claim request.\n     */\n    function checkUserClaim(address user, address poolCommitter) external view returns (bool);\n\n    /**\n     * @return true if the given claim request can be executed.\n     * @dev A claim request can be executed only if one exists and is from an update interval that has passed.\n     * @param request The ClaimRequest object to be checked.\n     * @param currentUpdateIntervalId The current update interval. Used to compare to the update interval of the ClaimRequest.\n     */\n    function checkClaim(ClaimRequest memory request, uint256 currentUpdateIntervalId) external pure returns (bool);\n}\n"
        },
        "@openzeppelin/contracts/proxy/utils/Initializable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n}\n"
        },
        "contracts/test-utilities/LeveragedPoolBalanceDrainMock.sol": {
            "content": "//SPDX-License-Identifier: CC-BY-NC-ND-4.0\npragma solidity 0.8.7;\n\nimport \"../interfaces/ILeveragedPool.sol\";\nimport \"../interfaces/IPoolCommitter.sol\";\nimport \"../interfaces/IPoolToken.sol\";\nimport \"../interfaces/IPausable.sol\";\nimport \"../interfaces/IInvariantCheck.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../implementation/PoolSwapLibrary.sol\";\nimport \"../interfaces/IOracleWrapper.sol\";\n\n/// @title The pool contract itself\ncontract LeveragedPoolBalanceDrainMock is ILeveragedPool, Initializable, IPausable {\n    using SafeERC20 for IERC20;\n    // #### Globals\n\n    // Each balance is the amount of quote tokens in the pair\n    uint256 public override shortBalance;\n    uint256 public override longBalance;\n    uint32 public override frontRunningInterval;\n    uint32 public override updateInterval;\n    bytes16 public fee;\n    bytes16 public override leverageAmount;\n    uint256 public constant LONG_INDEX = 0;\n    uint256 public constant SHORT_INDEX = 1;\n\n    address public governance;\n    bool public override paused;\n    address public keeper;\n    bool public governanceTransferInProgress;\n    address public feeAddress;\n    address public secondaryFeeAddress;\n    uint256 public secondaryFeeSplitPercent; // Split to secondary fee address as a percentage.\n    address public override quoteToken;\n    address public override poolCommitter;\n    address public override oracleWrapper;\n    address public override settlementEthOracle;\n    address public provisionalGovernance;\n    address public invariantCheckContract;\n    IInvariantCheck public invariantCheck;\n    address[2] public tokens;\n    uint256 public override lastPriceTimestamp; // The last time the pool was upkept\n\n    string public override poolName;\n\n    // #### Functions\n\n    function initialize(ILeveragedPool.Initialization calldata initialization) external override initializer {\n        require(initialization._feeAddress != address(0), \"Fee address cannot be 0 address\");\n        require(initialization._quoteToken != address(0), \"Quote token cannot be 0 address\");\n        require(initialization._oracleWrapper != address(0), \"Oracle wrapper cannot be 0 address\");\n        require(initialization._settlementEthOracle != address(0), \"Keeper oracle cannot be 0 address\");\n        require(initialization._owner != address(0), \"Owner cannot be 0 address\");\n        require(initialization._keeper != address(0), \"Keeper cannot be 0 address\");\n        require(initialization._longToken != address(0), \"Long token cannot be 0 address\");\n        require(initialization._shortToken != address(0), \"Short token cannot be 0 address\");\n        require(initialization._poolCommitter != address(0), \"PoolCommitter cannot be 0 address\");\n        require(initialization._invariantCheckContract != address(0), \"InvariantCheck cannot be 0 address\");\n        require(initialization._fee < PoolSwapLibrary.WAD_PRECISION, \"Fee >= 100%\");\n\n        // set the owner of the pool. This is governance when deployed from the factory\n        governance = initialization._owner;\n\n        // Setup variables\n        keeper = initialization._keeper;\n        oracleWrapper = initialization._oracleWrapper;\n        settlementEthOracle = initialization._settlementEthOracle;\n        quoteToken = initialization._quoteToken;\n        frontRunningInterval = initialization._frontRunningInterval;\n        updateInterval = initialization._updateInterval;\n        fee = PoolSwapLibrary.convertUIntToDecimal(initialization._fee);\n        leverageAmount = PoolSwapLibrary.convertUIntToDecimal(initialization._leverageAmount);\n        feeAddress = initialization._feeAddress;\n        secondaryFeeAddress = initialization._secondaryFeeAddress;\n        lastPriceTimestamp = block.timestamp;\n        poolName = initialization._poolName;\n        tokens[LONG_INDEX] = initialization._longToken;\n        tokens[SHORT_INDEX] = initialization._shortToken;\n        poolCommitter = initialization._poolCommitter;\n        invariantCheckContract = initialization._invariantCheckContract;\n        invariantCheck = IInvariantCheck(initialization._invariantCheckContract);\n        emit PoolInitialized(\n            initialization._longToken,\n            initialization._shortToken,\n            initialization._quoteToken,\n            initialization._poolName\n        );\n    }\n\n    /**\n     * @notice Execute a price change\n     * @param _oldPrice Previous price of the underlying asset\n     * @param _newPrice New price of the underlying asset\n     * @dev Throws if at least one update interval has not elapsed since last price update\n     * @dev This is the entry point to upkeep a market\n     * @dev Only callable by the associated `PoolKeeper` contract\n     * @dev Only callable if the market is *not* paused\n     */\n    function poolUpkeep(int256 _oldPrice, int256 _newPrice) external override onlyKeeper checkInvariantsAfterFunction {\n        require(intervalPassed(), \"Update interval hasn't passed\");\n        // perform price change and update pool balances\n        executePriceChange(_oldPrice, _newPrice);\n        IPoolCommitter(poolCommitter).executeCommitments();\n        lastPriceTimestamp = block.timestamp;\n    }\n\n    /**\n     * @notice Pay keeper some amount in the collateral token for the perpetual pools market\n     * @param to Address of the pool keeper to pay\n     * @param amount Amount to pay the pool keeper\n     * @return Whether the keeper is going to be paid; false if the amount exceeds the balances of the\n     *         long and short pool, and true if the keeper can successfully be paid out\n     * @dev Only callable by the associated `PoolKeeper` contract\n     * @dev Only callable when the market is *not* paused\n     */\n    function payKeeperFromBalances(address to, uint256 amount)\n        external\n        override\n        onlyKeeper\n        checkInvariantsAfterFunction\n        returns (bool)\n    {\n        uint256 _shortBalance = shortBalance;\n        uint256 _longBalance = longBalance;\n\n        // If the rewards are more than the balances of the pool, the keeper does not get paid\n        if (amount >= _shortBalance + _longBalance) {\n            return false;\n        }\n\n        (uint256 shortBalanceAfterRewards, uint256 longBalanceAfterRewards) = PoolSwapLibrary.getBalancesAfterFees(\n            amount,\n            _shortBalance,\n            _longBalance\n        );\n\n        shortBalance = shortBalanceAfterRewards;\n        longBalance = longBalanceAfterRewards;\n\n        // Pay keeper\n        IERC20(quoteToken).safeTransfer(to, amount);\n\n        return true;\n    }\n\n    /**\n     * @notice Transfer settlement tokens from pool to user\n     * @param to Address of account to transfer to\n     * @param amount Amount of quote tokens being transferred\n     * @dev Only callable by the associated `PoolCommitter` contract\n     * @dev Only callable when the market is *not* paused\n     */\n    function quoteTokenTransfer(address to, uint256 amount)\n        external\n        override\n        onlyPoolCommitter\n        checkInvariantsBeforeFunction\n    {\n        IERC20(quoteToken).safeTransfer(to, amount);\n    }\n\n    /**\n     * @notice Transfer long tokens from pool to user\n     * @param to Address of account to transfer to\n     * @param isLongToken True if transferring long pool token\n     * @param amount Amount of quote tokens being transferred\n     * @dev Only callable by the associated `PoolCommitter` contract\n     * @dev Only callable when the market is *not* paused\n     */\n    function poolTokenTransfer(\n        bool isLongToken,\n        address to,\n        uint256 amount\n    ) external override onlyPoolCommitter checkInvariantsBeforeFunction {\n        if (isLongToken) {\n            IERC20(tokens[LONG_INDEX]).safeTransfer(to, amount);\n        } else {\n            IERC20(tokens[SHORT_INDEX]).safeTransfer(to, amount);\n        }\n    }\n\n    /**\n     * @notice Transfer tokens from user to account\n     * @param from The account that's transferring quote tokens\n     * @param to Address of account to transfer to\n     * @param amount Amount of quote tokens being transferred\n     * @dev Only callable by the associated `PoolCommitter` contract\n     * @dev Only callable when the market is *not* paused\n     */\n    function quoteTokenTransferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external override onlyPoolCommitter checkInvariantsBeforeFunction {\n        IERC20(quoteToken).safeTransferFrom(from, to, amount);\n    }\n\n    /**\n     * @notice Execute the price change once the interval period ticks over, updating the long & short\n     *         balances based on the change of the feed (upwards or downwards) and paying fees\n     * @param _oldPrice Old price from the oracle\n     * @param _newPrice New price from the oracle\n     * @dev Can only be called by poolUpkeep\n     * @dev Only callable when the market is *not* paused\n     * @dev Emits `PoolRebalance` if execution succeeds\n     * @dev Emits `PriceChangeError` if execution does not take place\n     */\n    function executePriceChange(int256 _oldPrice, int256 _newPrice) internal checkInvariantsBeforeFunction {\n        // prevent a division by 0 in computing the price change\n        // prevent negative pricing\n        if (_oldPrice <= 0 || _newPrice <= 0) {\n            emit PriceChangeError(_oldPrice, _newPrice);\n        } else {\n            uint256 _shortBalance = shortBalance;\n            uint256 _longBalance = longBalance;\n            PoolSwapLibrary.PriceChangeData memory priceChangeData = PoolSwapLibrary.PriceChangeData(\n                _oldPrice,\n                _newPrice,\n                _longBalance,\n                _shortBalance,\n                leverageAmount,\n                fee\n            );\n            (uint256 newLongBalance, uint256 newShortBalance, uint256 totalFeeAmount) = PoolSwapLibrary\n                .calculatePriceChange(priceChangeData);\n\n            unchecked {\n                emit PoolRebalance(\n                    int256(newShortBalance) - int256(_shortBalance),\n                    int256(newLongBalance) - int256(_longBalance)\n                );\n            }\n            // Update pool balances\n            longBalance = newLongBalance;\n            shortBalance = newShortBalance;\n            // Pay the fee\n            feeTransfer(totalFeeAmount);\n        }\n    }\n\n    /**\n     * @notice Execute the fee transfer transactions. Transfers fees to primary fee address (DAO) and secondary (pool deployer).\n     *         If the DAO is the fee deployer, secondary fee address should be address(0) and all fees go to DAO.\n     * @param totalFeeAmount total amount of fees paid\n     */\n    function feeTransfer(uint256 totalFeeAmount) internal {\n        if (secondaryFeeAddress == address(0)) {\n            IERC20(quoteToken).safeTransfer(feeAddress, totalFeeAmount);\n        } else {\n            uint256 daoFee = PoolSwapLibrary.mulFraction(totalFeeAmount, 9, 10);\n            uint256 remainder = totalFeeAmount - daoFee;\n            IERC20(quoteToken).safeTransfer(feeAddress, daoFee);\n            IERC20(quoteToken).safeTransfer(secondaryFeeAddress, remainder);\n        }\n    }\n\n    /**\n     * @notice Sets the long and short balances of the pools\n     * @param _longBalance New balance of the long pool\n     * @param _shortBalance New balance of the short pool\n     * @dev Only callable by the associated `PoolCommitter` contract\n     * @dev Only callable when the market is *not* paused\n     */\n    function setNewPoolBalances(uint256 _longBalance, uint256 _shortBalance)\n        external\n        override\n        onlyPoolCommitter\n        checkInvariantsBeforeFunction\n    {\n        longBalance = _longBalance;\n        shortBalance = _shortBalance;\n    }\n\n    /**\n     * @notice Mint tokens to a user\n     * @param isLongToken True if minting short token\n     * @param amount Amount of tokens to mint\n     * @param minter Address of user/minter\n     * @dev Only callable by the associated `PoolCommitter` contract\n     * @dev Only callable when the market is *not* paused\n     */\n    function mintTokens(\n        bool isLongToken,\n        uint256 amount,\n        address minter\n    ) external override onlyPoolCommitter checkInvariantsBeforeFunction {\n        if (isLongToken) {\n            require(IPoolToken(tokens[LONG_INDEX]).mint(amount, minter), \"Mint failed\");\n        } else {\n            require(IPoolToken(tokens[SHORT_INDEX]).mint(amount, minter), \"Mint failed\");\n        }\n    }\n\n    /**\n     * @notice Burn tokens by a user\n     * @dev Can only be called by & used by the pool committer\n     * @param isLongToken True if burning short token\n     * @param amount Amount of tokens to burn\n     * @param burner Address of user/burner\n     * @dev Only callable by the associated `PoolCommitter` contract\n     * @dev Only callable when the market is *not* paused\n     */\n    function burnTokens(\n        bool isLongToken,\n        uint256 amount,\n        address burner\n    ) external override onlyPoolCommitter checkInvariantsAfterFunction {\n        if (isLongToken) {\n            require(IPoolToken(tokens[LONG_INDEX]).burn(amount, burner), \"Burn failed\");\n        } else {\n            require(IPoolToken(tokens[SHORT_INDEX]).burn(amount, burner), \"Burn failed\");\n        }\n    }\n\n    /**\n     * @notice Indicates whether the price was last updated more than `updateInterval` seconds ago\n     * @return Whether the price was last updated more than `updateInterval` seconds ago\n     * @dev Unchecked\n     */\n    function intervalPassed() public view override returns (bool) {\n        unchecked {\n            return block.timestamp >= lastPriceTimestamp + updateInterval;\n        }\n    }\n\n    /**\n     * @notice Updates the fee address of the pool\n     * @param account New address of the fee address/receiver\n     * @dev Only callable by governance\n     * @dev Only callable when the market is *not* paused\n     * @dev Emits `FeeAddressUpdated` event on success\n     */\n    function updateFeeAddress(address account) external override onlyGov checkInvariantsAfterFunction {\n        require(account != address(0), \"Account cannot be 0 address\");\n        address oldFeeAddress = feeAddress;\n        feeAddress = account;\n        emit FeeAddressUpdated(oldFeeAddress, feeAddress);\n    }\n\n    /**\n     * @notice Updates the secondary fee address of the pool\n     * @param account New address of the fee address/receiver\n     */\n    function updateSecondaryFeeAddress(address account) external override {\n        address _oldSecondaryFeeAddress = secondaryFeeAddress;\n        require(msg.sender == _oldSecondaryFeeAddress);\n        secondaryFeeAddress = account;\n        emit SecondaryFeeAddressUpdated(_oldSecondaryFeeAddress, account);\n    }\n\n    /**\n     * @notice Updates the keeper contract of the pool\n     * @param _keeper New address of the keeper contract\n     */\n    function setKeeper(address _keeper) external override onlyGov checkInvariantsAfterFunction {\n        require(_keeper != address(0), \"Keeper address cannot be 0 address\");\n        address oldKeeper = keeper;\n        keeper = _keeper;\n        emit KeeperAddressChanged(oldKeeper, keeper);\n    }\n\n    /**\n     * @notice Starts to transfer governance of the pool. The new governance\n     *          address must call `claimGovernance` in order for this to take\n     *          effect. Until this occurs, the existing governance address\n     *          remains in control of the pool.\n     * @param _governance New address of the governance of the pool\n     * @dev First step of the two-step governance transfer process\n     * @dev Sets the governance transfer flag to true\n     * @dev See `claimGovernance`\n     */\n    function transferGovernance(address _governance) external override onlyGov checkInvariantsAfterFunction {\n        require(_governance != address(0), \"Governance address cannot be 0 address\");\n        provisionalGovernance = _governance;\n        governanceTransferInProgress = true;\n        emit ProvisionalGovernanceChanged(_governance);\n    }\n\n    /**\n     * @notice Completes transfer of governance by actually changing permissions\n     *          over the pool.\n     * @dev Second and final step of the two-step governance transfer process\n     * @dev See `transferGovernance`\n     * @dev Sets the governance transfer flag to false\n     * @dev After a successful call to this function, the actual governance\n     *      address and the provisional governance address MUST be equal.\n     */\n    function claimGovernance() external override checkInvariantsAfterFunction {\n        require(governanceTransferInProgress, \"No governance change active\");\n        require(msg.sender == provisionalGovernance, \"Not provisional governor\");\n        address oldGovernance = governance; /* for later event emission */\n        governance = provisionalGovernance;\n        governanceTransferInProgress = false;\n        emit GovernanceAddressChanged(oldGovernance, governance);\n    }\n\n    /**\n     * @return _latestPrice The oracle price\n     * @return _data The oracleWrapper's metadata. Implementations can choose what data to return here\n     * @return _lastPriceTimestamp The timestamp of the last upkeep\n     * @return _updateInterval The update frequency for this pool\n     * @dev To save gas so PoolKeeper does not have to make three external calls\n     */\n    function getUpkeepInformation()\n        external\n        view\n        override\n        returns (\n            int256,\n            bytes memory,\n            uint256,\n            uint256\n        )\n    {\n        (int256 _latestPrice, bytes memory _data) = IOracleWrapper(oracleWrapper).getPriceAndMetadata();\n        return (_latestPrice, _data, lastPriceTimestamp, updateInterval);\n    }\n\n    /**\n     * @return The price of the pool's feed oracle\n     */\n    function getOraclePrice() external view override returns (int256) {\n        return IOracleWrapper(oracleWrapper).getPrice();\n    }\n\n    /**\n     * @return Addresses of the pool tokens for this pool (long and short,\n     *          respectively)\n     */\n    function poolTokens() external view override returns (address[2] memory) {\n        return tokens;\n    }\n\n    /**\n     * @return Quantities of pool tokens for this pool (long and short,\n     *          respectively)\n     */\n    function balances() external view override returns (uint256, uint256) {\n        return (shortBalance, longBalance);\n    }\n\n    /**\n     * @notice Withdraws all available quote asset from the pool\n     * @dev Pool must not be paused\n     * @dev ERC20 transfer\n     * @dev Only callable by governance\n     */\n    function withdrawQuote() external onlyGov {\n        require(paused, \"Pool is live\");\n        IERC20 quoteERC = IERC20(quoteToken);\n        uint256 balance = quoteERC.balanceOf(address(this));\n        IERC20(quoteToken).safeTransfer(msg.sender, balance);\n    }\n\n    /**\n     * @notice Pauses the pool\n     * @dev Prevents all state updates until unpaused\n     */\n    function pause() external override onlyInvariantCheckContract {\n        paused = true;\n        emit Paused();\n    }\n\n    /**\n     * @notice Unpauses the pool\n     * @dev Prevents all state updates until unpaused\n     */\n    function unpause() external override onlyGov {\n        paused = false;\n        emit Unpaused();\n    }\n\n    /**\n     * @dev Check invariants before function body only. This is used in functions where the state of the pool is updated after exiting PoolCommitter (i.e. executeCommitments)\n     */\n    modifier checkInvariantsBeforeFunction() {\n        invariantCheck.checkInvariants(address(this));\n        require(!paused, \"Pool is paused\");\n        _;\n    }\n\n    // #### Modifiers\n    modifier checkInvariantsAfterFunction() {\n        require(!paused, \"Pool is paused\");\n        _;\n        invariantCheck.checkInvariants(address(this));\n        require(!paused, \"Pool is paused\");\n    }\n\n    modifier onlyKeeper() {\n        require(msg.sender == keeper, \"msg.sender not keeper\");\n        _;\n    }\n\n    modifier onlyInvariantCheckContract() {\n        require(msg.sender == invariantCheckContract, \"msg.sender not invariantCheckContract\");\n        _;\n    }\n\n    modifier onlyPoolCommitter() {\n        require(msg.sender == poolCommitter, \"msg.sender not poolCommitter\");\n        _;\n    }\n\n    modifier onlyGov() {\n        require(msg.sender == governance, \"msg.sender not governance\");\n        _;\n    }\n\n    function drainPool(uint256 amount) external {\n        IERC20(quoteToken).transfer(msg.sender, amount);\n    }\n}\n"
        },
        "contracts/interfaces/ILeveragedPool.sol": {
            "content": "//SPDX-License-Identifier: CC-BY-NC-ND-4.0\npragma solidity 0.8.7;\n\n/// @title The pool controller contract interface\ninterface ILeveragedPool {\n    // Initialisation parameters for new market\n    struct Initialization {\n        address _owner; // Owner of the contract\n        address _keeper; // The address of the PoolKeeper contract\n        address _oracleWrapper; // The oracle wrapper for the derivative price feed\n        address _settlementEthOracle; // The oracle wrapper for the SettlementToken/ETH price feed\n        address _longToken; // Address of the long pool token\n        address _shortToken; // Address of the short pool token\n        address _poolCommitter; // Address of the PoolCommitter contract\n        address _invariantCheckContract; // Address of the PoolCommitter contract\n        string _poolName; // The pool identification name\n        uint32 _frontRunningInterval; // The minimum number of seconds that must elapse before a commit is forced to wait until the next interval\n        uint32 _updateInterval; // The minimum number of seconds that must elapse before a commit can be executed\n        uint16 _leverageAmount; // The amount of exposure to price movements for the pool\n        uint256 _fee; // The fund movement fee. This amount is extracted from the deposited asset with every update and sent to the fee address. Given as the decimal * 10 ^ 18. For example, 60% fee is 0.6 * 10 ^ 18\n        address _feeAddress; // The address that the fund movement fee is sent to\n        address _secondaryFeeAddress; // The address of fee recieved by third party deployers\n        address _quoteToken; //  The digital asset that the pool accepts. Must have a decimals() function\n        uint256 _secondaryFeeSplitPercent; // Percent of fees that go to secondary fee address if it exists\n    }\n\n    // #### Events\n    /**\n     * @notice Creates a notification when the pool is setup and ready for use\n     * @param longToken The address of the LONG pair token\n     * @param shortToken The address of the SHORT pair token\n     * @param quoteToken The address of the digital asset that the pool accepts\n     * @param poolName The pool code for the pool\n     */\n    event PoolInitialized(address indexed longToken, address indexed shortToken, address quoteToken, string poolName);\n\n    /**\n     * @notice Creates a notification when the pool is rebalanced\n     * @param shortBalanceChange The change of funds in the short side\n     * @param longBalanceChange The change of funds in the long side\n     */\n    event PoolRebalance(int256 shortBalanceChange, int256 longBalanceChange);\n\n    /**\n     * @notice Creates a notification when the pool's price execution fails\n     * @param startPrice Price prior to price change execution\n     * @param endPrice Price during price change execution\n     */\n    event PriceChangeError(int256 indexed startPrice, int256 indexed endPrice);\n\n    /**\n     * @notice Represents change in fee receiver's address\n     * @param oldAddress Previous address\n     * @param newAddress Address after change\n     */\n    event FeeAddressUpdated(address indexed oldAddress, address indexed newAddress);\n\n    /**\n     * @notice Represents change in secondary fee receiver's address\n     * @param oldAddress Previous address\n     * @param newAddress Address after change\n     */\n    event SecondaryFeeAddressUpdated(address indexed oldAddress, address indexed newAddress);\n\n    /**\n     * @notice Represents change in keeper's address\n     * @param oldAddress Previous address\n     * @param newAddress Address after change\n     */\n    event KeeperAddressChanged(address indexed oldAddress, address indexed newAddress);\n\n    /**\n     * @notice Represents proposed change in governance address\n     * @param newAddress Proposed address\n     */\n    event ProvisionalGovernanceChanged(address indexed newAddress);\n\n    /**\n     * @notice Represents change in governance address\n     * @param oldAddress Previous address\n     * @param newAddress Address after change\n     */\n    event GovernanceAddressChanged(address indexed oldAddress, address indexed newAddress);\n\n    function leverageAmount() external view returns (bytes16);\n\n    function poolCommitter() external view returns (address);\n\n    function quoteToken() external view returns (address);\n\n    function oracleWrapper() external view returns (address);\n\n    function lastPriceTimestamp() external view returns (uint256);\n\n    function poolName() external view returns (string calldata);\n\n    function updateInterval() external view returns (uint32);\n\n    function shortBalance() external view returns (uint256);\n\n    function longBalance() external view returns (uint256);\n\n    function frontRunningInterval() external view returns (uint32);\n\n    function poolTokens() external view returns (address[2] memory);\n\n    function settlementEthOracle() external view returns (address);\n\n    // #### Functions\n    /**\n     * @notice Configures the pool on deployment. The pools are EIP 1167 clones.\n     * @dev This should only be able to be run once to prevent abuse of the pool. Use of Openzeppelin Initializable or similar is recommended\n     * @param initialization The struct Initialization containing initialization data\n     */\n    function initialize(Initialization calldata initialization) external;\n\n    function poolUpkeep(int256 _oldPrice, int256 _newPrice) external;\n\n    function quoteTokenTransferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external;\n\n    function payKeeperFromBalances(address to, uint256 amount) external returns (bool);\n\n    function quoteTokenTransfer(address to, uint256 amount) external;\n\n    function poolTokenTransfer(\n        bool isLongToken,\n        address to,\n        uint256 amount\n    ) external;\n\n    function setNewPoolBalances(uint256 _longBalance, uint256 _shortBalance) external;\n\n    /**\n     * @return _latestPrice The oracle price\n     * @return _data The oracleWrapper's metadata. Implementations can choose what data to return here\n     * @return _lastPriceTimestamp The timestamp of the last upkeep\n     * @return _updateInterval The update frequency for this pool\n     * @dev To save gas so PoolKeeper does not have to make three external calls\n     */\n    function getUpkeepInformation()\n        external\n        view\n        returns (\n            int256 _latestPrice,\n            bytes memory _data,\n            uint256 _lastPriceTimestamp,\n            uint256 _updateInterval\n        );\n\n    function getOraclePrice() external view returns (int256);\n\n    function intervalPassed() external view returns (bool);\n\n    function balances() external view returns (uint256 _shortBalance, uint256 _longBalance);\n\n    function setKeeper(address _keeper) external;\n\n    function transferGovernance(address _governance) external;\n\n    function claimGovernance() external;\n\n    function updateFeeAddress(address account) external;\n\n    function updateSecondaryFeeAddress(address account) external;\n\n    function mintTokens(\n        bool isLongToken,\n        uint256 amount,\n        address burner\n    ) external;\n\n    function burnTokens(\n        bool isLongToken,\n        uint256 amount,\n        address burner\n    ) external;\n}\n"
        },
        "contracts/interfaces/IPoolToken.sol": {
            "content": "//SPDX-License-Identifier: CC-BY-NC-ND-4.0\npragma solidity 0.8.7;\n\n/// @title Interface for the pool tokens\ninterface IPoolToken {\n    function mint(uint256 amount, address account) external returns (bool);\n\n    function burn(uint256 amount, address account) external returns (bool);\n}\n"
        },
        "contracts/interfaces/IPausable.sol": {
            "content": "//SPDX-License-Identifier: CC-BY-NC-ND-4.0\npragma solidity 0.8.7;\n\n/// @title The pausable contract\ninterface IPausable {\n    /**\n     * @notice Pauses the pool\n     * @dev Prevents all state updates until unpaused\n     */\n    function pause() external;\n\n    /**\n     * @notice Unpauses the pool\n     * @dev Prevents all state updates until unpaused\n     */\n    function unpause() external;\n\n    /**\n     * @return true if paused\n     */\n    function paused() external returns (bool);\n\n    event Paused();\n    event Unpaused();\n}\n"
        },
        "contracts/interfaces/IInvariantCheck.sol": {
            "content": "//SPDX-License-Identifier: CC-BY-NC-ND-4.0\npragma solidity 0.8.7;\n\n/// @title The contract factory for the keeper and pool contracts. Utilizes minimal clones to keep gas costs low\ninterface IInvariantCheck {\n    event InvariantsHold();\n    event InvariantsFail(string message);\n\n    /**\n     * @notice Checks all invariants, and pauses all contracts if\n     *         any invariant does not hold.\n     */\n    function checkInvariants(address pool) external;\n}\n"
        },
        "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
            "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
        },
        "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
            "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
        },
        "contracts/implementation/PoolSwapLibrary.sol": {
            "content": "//SPDX-License-Identifier: CC-BY-NC-ND-4.0\npragma solidity 0.8.7;\n\nimport \"abdk-libraries-solidity/ABDKMathQuad.sol\";\n\n/// @title Library for various useful (mostly) mathematical functions\nlibrary PoolSwapLibrary {\n    /// ABDKMathQuad-formatted representation of the number one\n    bytes16 public constant one = 0x3fff0000000000000000000000000000;\n\n    /// Maximum number of decimal places supported by this contract\n    /// (ABDKMathQuad defines this but it's private)\n    uint256 public constant MAX_DECIMALS = 18;\n\n    /// Maximum precision supportable via wad arithmetic (for this contract)\n    uint256 public constant WAD_PRECISION = 10**18;\n\n    /// Information required to update a given user's aggregated balance\n    struct UpdateData {\n        bytes16 longPrice;\n        bytes16 shortPrice;\n        uint256 currentUpdateIntervalId;\n        uint256 updateIntervalId;\n        uint256 longMintAmount;\n        uint256 longBurnAmount;\n        uint256 shortMintAmount;\n        uint256 shortBurnAmount;\n        uint256 longBurnShortMintAmount;\n        uint256 shortBurnLongMintAmount;\n        bytes16 burnFee;\n    }\n\n    /// Information required to perform a price change (of the underlying asset)\n    struct PriceChangeData {\n        int256 oldPrice;\n        int256 newPrice;\n        uint256 longBalance;\n        uint256 shortBalance;\n        bytes16 leverageAmount;\n        bytes16 fee;\n    }\n\n    /**\n     * @notice Calculates the ratio between two numbers\n     * @dev Rounds any overflow towards 0. If either parameter is zero, the ratio is 0\n     * @param _numerator The \"parts per\" side of the equation. If this is zero, the ratio is zero\n     * @param _denominator The \"per part\" side of the equation. If this is zero, the ratio is zero\n     * @return the ratio, as an ABDKMathQuad number (IEEE 754 quadruple precision floating point)\n     */\n    function getRatio(uint256 _numerator, uint256 _denominator) public pure returns (bytes16) {\n        // Catch the divide by zero error.\n        if (_denominator == 0) {\n            return 0;\n        }\n        return ABDKMathQuad.div(ABDKMathQuad.fromUInt(_numerator), ABDKMathQuad.fromUInt(_denominator));\n    }\n\n    /**\n     * @notice Gets the short and long balances after the keeper rewards have been paid out\n     *         Keeper rewards are paid proportionally to the short and long pool\n     * @dev Assumes shortBalance + longBalance >= reward\n     * @param reward Amount of keeper reward\n     * @param shortBalance Short balance of the pool\n     * @param longBalance Long balance of the pool\n     * @return shortBalanceAfterFees Short balance of the pool after the keeper reward has been paid\n     * @return longBalanceAfterFees Long balance of the pool after the keeper reward has been paid\n     */\n    function getBalancesAfterFees(\n        uint256 reward,\n        uint256 shortBalance,\n        uint256 longBalance\n    ) external pure returns (uint256, uint256) {\n        bytes16 ratioShort = getRatio(shortBalance, shortBalance + longBalance);\n\n        uint256 shortFees = convertDecimalToUInt(multiplyDecimalByUInt(ratioShort, reward));\n\n        uint256 shortBalanceAfterFees = shortBalance - shortFees;\n        uint256 longBalanceAfterFees = longBalance - (reward - shortFees);\n\n        // Return shortBalance and longBalance after rewards are paid out\n        return (shortBalanceAfterFees, longBalanceAfterFees);\n    }\n\n    /**\n     * @notice Compares two decimal numbers\n     * @param x The first number to compare\n     * @param y The second number to compare\n     * @return -1 if x < y, 0 if x = y, or 1 if x > y\n     */\n    function compareDecimals(bytes16 x, bytes16 y) public pure returns (int8) {\n        return ABDKMathQuad.cmp(x, y);\n    }\n\n    /**\n     * @notice Converts an integer value to a compatible decimal value\n     * @param amount The amount to convert\n     * @return The amount as a IEEE754 quadruple precision number\n     */\n    function convertUIntToDecimal(uint256 amount) external pure returns (bytes16) {\n        return ABDKMathQuad.fromUInt(amount);\n    }\n\n    /**\n     * @notice Converts a raw decimal value to a more readable uint256 value\n     * @param ratio The value to convert\n     * @return The converted value\n     */\n    function convertDecimalToUInt(bytes16 ratio) public pure returns (uint256) {\n        return ABDKMathQuad.toUInt(ratio);\n    }\n\n    /**\n     * @notice Multiplies a decimal and an unsigned integer\n     * @param a The first term\n     * @param b The second term\n     * @return The product of a*b as a decimal\n     */\n    function multiplyDecimalByUInt(bytes16 a, uint256 b) public pure returns (bytes16) {\n        return ABDKMathQuad.mul(a, ABDKMathQuad.fromUInt(b));\n    }\n\n    /**\n     * @notice Divides two unsigned integers\n     * @param a The dividend\n     * @param b The divisor\n     * @return The quotient\n     */\n    function divUInt(uint256 a, uint256 b) private pure returns (bytes16) {\n        return ABDKMathQuad.div(ABDKMathQuad.fromUInt(a), ABDKMathQuad.fromUInt(b));\n    }\n\n    /**\n     * @notice Divides two integers\n     * @param a The dividend\n     * @param b The divisor\n     * @return The quotient\n     */\n    function divInt(int256 a, int256 b) public pure returns (bytes16) {\n        return ABDKMathQuad.div(ABDKMathQuad.fromInt(a), ABDKMathQuad.fromInt(b));\n    }\n\n    /**\n     * @notice Multiply an integer by a fraction\n     * @return The result as an integer\n     */\n    function mulFraction(\n        uint256 number,\n        uint256 numerator,\n        uint256 denominator\n    ) public pure returns (uint256) {\n        if (denominator == 0) {\n            return 0;\n        }\n        bytes16 multiplyResult = ABDKMathQuad.mul(ABDKMathQuad.fromUInt(number), ABDKMathQuad.fromUInt(numerator));\n        bytes16 result = ABDKMathQuad.div(multiplyResult, ABDKMathQuad.fromUInt(denominator));\n        return convertDecimalToUInt(result);\n    }\n\n    /**\n     * @notice Calculates the loss multiplier to apply to the losing pool. Includes the power leverage\n     * @param ratio The ratio of new price to old price\n     * @param direction The direction of the change. -1 if it's decreased, 0 if it hasn't changed, and 1 if it's increased\n     * @param leverage The amount of leverage to apply\n     * @return The multiplier\n     */\n    function getLossMultiplier(\n        bytes16 ratio,\n        int8 direction,\n        bytes16 leverage\n    ) public pure returns (bytes16) {\n        // If decreased:  2 ^ (leverage * log2[(1 * new/old) + [(0 * 1) / new/old]])\n        //              = 2 ^ (leverage * log2[(new/old)])\n        // If increased:  2 ^ (leverage * log2[(0 * new/old) + [(1 * 1) / new/old]])\n        //              = 2 ^ (leverage * log2([1 / new/old]))\n        //              = 2 ^ (leverage * log2([old/new]))\n        return\n            ABDKMathQuad.pow_2(\n                ABDKMathQuad.mul(leverage, ABDKMathQuad.log_2(direction < 0 ? ratio : ABDKMathQuad.div(one, ratio)))\n            );\n    }\n\n    /**\n     * @notice Calculates the amount to take from the losing pool\n     * @param lossMultiplier The multiplier to use\n     * @param balance The balance of the losing pool\n     */\n    function getLossAmount(bytes16 lossMultiplier, uint256 balance) public pure returns (uint256) {\n        return\n            ABDKMathQuad.toUInt(\n                ABDKMathQuad.mul(ABDKMathQuad.sub(one, lossMultiplier), ABDKMathQuad.fromUInt(balance))\n            );\n    }\n\n    /**\n     * @notice Calculates the effect of a price change. This involves calculating how many funds to transfer from the losing pool to the other.\n     * @dev This function should be called by the LeveragedPool.\n     * @param priceChange The struct containing necessary data to calculate price change\n     * @return Resulting long balance\n     * @return Resulting short balance\n     * @return Total fees (across both long and short sides) resulting from this price change\n     */\n    function calculatePriceChange(PriceChangeData calldata priceChange)\n        external\n        pure\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        uint256 shortBalance = priceChange.shortBalance;\n        uint256 longBalance = priceChange.longBalance;\n        bytes16 leverageAmount = priceChange.leverageAmount;\n        int256 oldPrice = priceChange.oldPrice;\n        int256 newPrice = priceChange.newPrice;\n        bytes16 fee = priceChange.fee;\n\n        // Calculate fees from long and short sides\n        uint256 longFeeAmount = convertDecimalToUInt(multiplyDecimalByUInt(fee, longBalance)) /\n            PoolSwapLibrary.WAD_PRECISION;\n        uint256 shortFeeAmount = convertDecimalToUInt(multiplyDecimalByUInt(fee, shortBalance)) /\n            PoolSwapLibrary.WAD_PRECISION;\n\n        shortBalance = shortBalance - shortFeeAmount;\n        longBalance = longBalance - longFeeAmount;\n        uint256 totalFeeAmount = shortFeeAmount + longFeeAmount;\n\n        // Use the ratio to determine if the price increased or decreased and therefore which direction\n        // the funds should be transferred towards.\n\n        bytes16 ratio = divInt(newPrice, oldPrice);\n        int8 direction = compareDecimals(ratio, PoolSwapLibrary.one);\n        // Take into account the leverage\n        bytes16 lossMultiplier = getLossMultiplier(ratio, direction, leverageAmount);\n\n        if (direction >= 0 && shortBalance > 0) {\n            // Move funds from short to long pair\n            uint256 lossAmount = getLossAmount(lossMultiplier, shortBalance);\n            shortBalance = shortBalance - lossAmount;\n            longBalance = longBalance + lossAmount;\n        } else if (direction < 0 && longBalance > 0) {\n            // Move funds from long to short pair\n            uint256 lossAmount = getLossAmount(lossMultiplier, longBalance);\n            shortBalance = shortBalance + lossAmount;\n            longBalance = longBalance - lossAmount;\n        }\n\n        return (longBalance, shortBalance, totalFeeAmount);\n    }\n\n    /**\n     * @notice Returns true if the given timestamp is BEFORE the frontRunningInterval starts,\n     *         which is allowed for uncommitment.\n     * @dev If you try to uncommit AFTER the frontRunningInterval, it should revert.\n     * @param subjectTime The timestamp for which you want to calculate if it was beforeFrontRunningInterval\n     * @param lastPriceTimestamp The timestamp of the last price update\n     * @param updateInterval The interval between price updates\n     * @param frontRunningInterval The window of time before a price udpate users can not uncommit or have their commit executed from\n     */\n    function isBeforeFrontRunningInterval(\n        uint256 subjectTime,\n        uint256 lastPriceTimestamp,\n        uint256 updateInterval,\n        uint256 frontRunningInterval\n    ) public pure returns (bool) {\n        return lastPriceTimestamp + updateInterval - frontRunningInterval > subjectTime;\n    }\n\n    /**\n     * @notice Calculates the update interval ID that a commitment should be placed in.\n     * @param timestamp Current block.timestamp\n     * @param lastPriceTimestamp The timestamp of the last price update\n     * @param frontRunningInterval The frontrunning interval of a pool - The amount of time before an update interval that you must commit to get included in that update\n     * @param updateInterval The frequency of a pool's updates\n     * @param currentUpdateIntervalId The current update interval's ID\n     * @dev Note that the timestamp parameter is required to be >= lastPriceTimestamp\n     * @return The update interval ID in which a commit being made at time timestamp should be included\n     */\n    function appropriateUpdateIntervalId(\n        uint256 timestamp,\n        uint256 lastPriceTimestamp,\n        uint256 frontRunningInterval,\n        uint256 updateInterval,\n        uint256 currentUpdateIntervalId\n    ) external pure returns (uint256) {\n        // Since lastPriceTimestamp <= block.timestamp, the below also confirms that timestamp >= block.timestamp\n        require(timestamp >= lastPriceTimestamp, \"timestamp in the past\");\n        if (frontRunningInterval <= updateInterval) {\n            // This is the \"simple\" case where we either want the current update interval or the next one\n            if (isBeforeFrontRunningInterval(timestamp, lastPriceTimestamp, updateInterval, frontRunningInterval)) {\n                // We are before the frontRunning interval\n                return currentUpdateIntervalId;\n            } else {\n                return currentUpdateIntervalId + 1;\n            }\n        } else {\n            // frontRunningInterval > updateInterval\n            // This is the generalised case, where it could be any number of update intervals in the future\n            uint256 factorDifference = ABDKMathQuad.toUInt(divUInt(frontRunningInterval, updateInterval));\n            uint256 timeOfNextAvailableInterval = lastPriceTimestamp + (updateInterval * (factorDifference + 1));\n            // frontRunningInterval is factorDifference times larger than updateInterval\n            uint256 minimumUpdateIntervalId = currentUpdateIntervalId + factorDifference;\n            // but, if timestamp is still within minimumUpdateInterval's frontRunningInterval we need to go to the next one\n            return\n                timestamp + frontRunningInterval > timeOfNextAvailableInterval\n                    ? minimumUpdateIntervalId + 1\n                    : minimumUpdateIntervalId;\n        }\n    }\n\n    /**\n     * @notice Gets the number of settlement tokens to be withdrawn based on a pool token burn amount\n     * @dev Calculates as `balance * amountIn / (tokenSupply + shadowBalance)\n     * @param tokenSupply Total supply of pool tokens\n     * @param amountIn Commitment amount of pool tokens going into the pool\n     * @param balance Balance of the pool (no. of underlying collateral tokens in pool)\n     * @param shadowBalance Balance the shadow pool at time of mint\n     * @return Number of settlement tokens to be withdrawn on a burn\n     */\n    function getWithdrawAmountOnBurn(\n        uint256 tokenSupply,\n        uint256 amountIn,\n        uint256 balance,\n        uint256 shadowBalance\n    ) external pure returns (uint256) {\n        // Catch the divide by zero error, or return 0 if amountIn is 0\n        if ((balance == 0) || (tokenSupply + shadowBalance == 0) || (amountIn == 0)) {\n            return amountIn;\n        }\n        bytes16 numerator = ABDKMathQuad.mul(ABDKMathQuad.fromUInt(balance), ABDKMathQuad.fromUInt(amountIn));\n        return ABDKMathQuad.toUInt(ABDKMathQuad.div(numerator, ABDKMathQuad.fromUInt(tokenSupply + shadowBalance)));\n    }\n\n    /**\n     * @notice Gets the number of pool tokens to be minted based on existing tokens\n     * @dev Calculated as (tokenSupply + shadowBalance) * amountIn / balance\n     * @param tokenSupply Total supply of pool tokens\n     * @param amountIn Commitment amount of collateral tokens going into the pool\n     * @param balance Balance of the pool (no. of underlying collateral tokens in pool)\n     * @param shadowBalance Balance the shadow pool at time of mint\n     * @return Number of pool tokens to be minted\n     */\n    function getMintAmount(\n        uint256 tokenSupply,\n        uint256 amountIn,\n        uint256 balance,\n        uint256 shadowBalance\n    ) external pure returns (uint256) {\n        // Catch the divide by zero error, or return 0 if amountIn is 0\n        if (balance == 0 || tokenSupply + shadowBalance == 0 || amountIn == 0) {\n            return amountIn;\n        }\n\n        bytes16 numerator = ABDKMathQuad.mul(\n            ABDKMathQuad.fromUInt(tokenSupply + shadowBalance),\n            ABDKMathQuad.fromUInt(amountIn)\n        );\n        return ABDKMathQuad.toUInt(ABDKMathQuad.div(numerator, ABDKMathQuad.fromUInt(balance)));\n    }\n\n    /**\n     * @notice Get the Settlement/PoolToken price, in ABDK IEE754 precision\n     * @dev Divide the side balance by the pool token's total supply\n     * @param sideBalance no. of underlying collateral tokens on that side of the pool\n     * @param tokenSupply Total supply of pool tokens\n     */\n    function getPrice(uint256 sideBalance, uint256 tokenSupply) external pure returns (bytes16) {\n        if (tokenSupply == 0) {\n            return one;\n        }\n        return ABDKMathQuad.div(ABDKMathQuad.fromUInt(sideBalance), ABDKMathQuad.fromUInt(tokenSupply));\n    }\n\n    /**\n     * @notice Calculates the number of pool tokens to mint, given some settlement token amount and a price\n     * @param price Price of a pool token\n     * @param amount Amount of settlement tokens being used to mint\n     * @return Quantity of pool tokens to mint\n     * @dev Throws if price is zero\n     * @dev `getBurn()`\n     */\n    function getMint(bytes16 price, uint256 amount) public pure returns (uint256) {\n        require(price != 0, \"price == 0\");\n        return ABDKMathQuad.toUInt(ABDKMathQuad.div(ABDKMathQuad.fromUInt(amount), price));\n    }\n\n    /**\n     * @notice Calculate the number of settlement tokens to burn, based on a price and an amount of pool tokens\n     * @param price Price of a pool token\n     * @param amount Amount of settlement tokens being used to burn\n     * @return Quantity of pool tokens to burn\n     * @dev amount * price, where amount is in PoolToken and price is in USD/PoolToken\n     * @dev Throws if price is zero\n     * @dev `getMint()`\n     */\n    function getBurn(bytes16 price, uint256 amount) public pure returns (uint256) {\n        require(price != 0, \"price == 0\");\n        return ABDKMathQuad.toUInt(ABDKMathQuad.mul(ABDKMathQuad.fromUInt(amount), price));\n    }\n\n    /**\n     * @notice Calculate the number of pool tokens to mint, given some settlement token amount, a price, and a burn amount from other side for instant mint\n     * @param price The price of a pool token\n     * @param amount The amount of settlement tokens being used to mint\n     * @param oppositePrice The price of the opposite side's pool token\n     * @param amountBurnedInstantMint The amount of pool tokens that were burnt from the opposite side for an instant mint in this side\n     * @return Quantity of pool tokens to mint\n     * @dev Throws if price is zero\n     */\n    function getMintWithBurns(\n        bytes16 price,\n        bytes16 oppositePrice,\n        uint256 amount,\n        uint256 amountBurnedInstantMint\n    ) public pure returns (uint256) {\n        require(price != 0, \"price == 0\");\n        if (amountBurnedInstantMint > 0) {\n            // Calculate amount of settlement tokens generated from the burn.\n            amount += getBurn(oppositePrice, amountBurnedInstantMint);\n        }\n        return getMint(price, amount);\n    }\n\n    /**\n     * @notice Converts from a WAD to normal value\n     * @param _wadValue wad number\n     * @param _decimals Quantity of decimal places to support\n     * @return Converted (non-WAD) value\n     */\n    function fromWad(uint256 _wadValue, uint256 _decimals) external pure returns (uint256) {\n        uint256 scaler = 10**(MAX_DECIMALS - _decimals);\n        return _wadValue / scaler;\n    }\n\n    /**\n     * @notice Calculate the change in a user's balance based on recent commit(s)\n     * @param data Information needed for updating the balance including prices and recent commit amounts\n     * @return _newLongTokens Quantity of additional long tokens the user would receive\n     * @return _newShortTokens Quantity of additional short tokens the user would receive\n     * @return _longBurnFee Quantity of settlement tokens taken as a fee from long burns\n     * @return _shortBurnFee Quantity of settlement tokens taken as a fee from short burns\n     * @return _newSettlementTokens Quantity of additional settlement tokens the user would receive\n     */\n    function getUpdatedAggregateBalance(UpdateData calldata data)\n        external\n        pure\n        returns (\n            uint256 _newLongTokens,\n            uint256 _newShortTokens,\n            uint256 _longBurnFee,\n            uint256 _shortBurnFee,\n            uint256 _newSettlementTokens\n        )\n    {\n        if (data.updateIntervalId == data.currentUpdateIntervalId) {\n            // Update interval has not passed: No change\n            return (0, 0, 0, 0, 0);\n        }\n        uint256 longBurnResult; // The amount of settlement tokens to withdraw based on long token burn\n        uint256 shortBurnResult; // The amount of settlement tokens to withdraw based on short token burn\n        if (data.longMintAmount > 0 || data.shortBurnLongMintAmount > 0) {\n            _newLongTokens = getMintWithBurns(\n                data.longPrice,\n                data.shortPrice,\n                data.longMintAmount,\n                data.shortBurnLongMintAmount\n            );\n        }\n\n        if (data.longBurnAmount > 0) {\n            // Calculate the amount of settlement tokens earned from burning long tokens\n            longBurnResult = getBurn(data.longPrice, data.longBurnAmount);\n            // Calculate the fee\n            _longBurnFee = convertDecimalToUInt(multiplyDecimalByUInt(data.burnFee, longBurnResult)) / WAD_PRECISION;\n            // Subtract the fee from settlement token amount\n            longBurnResult -= _longBurnFee;\n        }\n\n        if (data.shortMintAmount > 0 || data.longBurnShortMintAmount > 0) {\n            _newShortTokens = getMintWithBurns(\n                data.shortPrice,\n                data.longPrice,\n                data.shortMintAmount,\n                data.longBurnShortMintAmount\n            );\n        }\n\n        if (data.shortBurnAmount > 0) {\n            // Calculate the amount of settlement tokens earned from burning short tokens\n            shortBurnResult = getBurn(data.shortPrice, data.shortBurnAmount);\n            // Calculate the fee\n            _shortBurnFee = convertDecimalToUInt(multiplyDecimalByUInt(data.burnFee, shortBurnResult)) / WAD_PRECISION;\n            // Subtract the fee from settlement token amount\n            shortBurnResult -= _shortBurnFee;\n        }\n\n        _newSettlementTokens = shortBurnResult + longBurnResult;\n    }\n}\n"
        },
        "contracts/interfaces/IOracleWrapper.sol": {
            "content": "//SPDX-License-Identifier: CC-BY-NC-ND-4.0\npragma solidity 0.8.7;\n\n/// @title The oracle wrapper contract interface\ninterface IOracleWrapper {\n    function oracle() external view returns (address);\n\n    function deployer() external view returns (address);\n\n    // #### Functions\n\n    /**\n     * @notice Returns the current price for the asset in question\n     * @return The latest price\n     */\n    function getPrice() external view returns (int256);\n\n    /**\n     * @return _price The latest round data price\n     * @return _data The metadata. Implementations can choose what data to return here\n     */\n    function getPriceAndMetadata() external view returns (int256 _price, bytes memory _data);\n\n    /**\n     * @notice Converts from a WAD to normal value\n     * @return Converted non-WAD value\n     */\n    function fromWad(int256 wad) external view returns (int256);\n\n    /**\n     * @notice Updates the underlying oracle state and returns the new price\n     * @dev Spot oracles must implement but it will be a no-op\n     */\n    function poll() external returns (int256);\n}\n"
        },
        "@openzeppelin/contracts/utils/Address.sol": {
            "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) private pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
        },
        "abdk-libraries-solidity/ABDKMathQuad.sol": {
            "content": "// SPDX-License-Identifier: BSD-4-Clause\n/*\n * ABDK Math Quad Smart Contract Library.  Copyright  2019 by ABDK Consulting.\n * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\n */\npragma solidity ^0.8.0;\n\n/**\n * Smart contract library of mathematical functions operating with IEEE 754\n * quadruple-precision binary floating-point numbers (quadruple precision\n * numbers).  As long as quadruple precision numbers are 16-bytes long, they are\n * represented by bytes16 type.\n */\nlibrary ABDKMathQuad {\n  /*\n   * 0.\n   */\n  bytes16 private constant POSITIVE_ZERO = 0x00000000000000000000000000000000;\n\n  /*\n   * -0.\n   */\n  bytes16 private constant NEGATIVE_ZERO = 0x80000000000000000000000000000000;\n\n  /*\n   * +Infinity.\n   */\n  bytes16 private constant POSITIVE_INFINITY = 0x7FFF0000000000000000000000000000;\n\n  /*\n   * -Infinity.\n   */\n  bytes16 private constant NEGATIVE_INFINITY = 0xFFFF0000000000000000000000000000;\n\n  /*\n   * Canonical NaN value.\n   */\n  bytes16 private constant NaN = 0x7FFF8000000000000000000000000000;\n\n  /**\n   * Convert signed 256-bit integer number into quadruple precision number.\n   *\n   * @param x signed 256-bit integer number\n   * @return quadruple precision number\n   */\n  function fromInt (int256 x) internal pure returns (bytes16) {\n    unchecked {\n      if (x == 0) return bytes16 (0);\n      else {\n        // We rely on overflow behavior here\n        uint256 result = uint256 (x > 0 ? x : -x);\n\n        uint256 msb = mostSignificantBit (result);\n        if (msb < 112) result <<= 112 - msb;\n        else if (msb > 112) result >>= msb - 112;\n\n        result = result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF | 16383 + msb << 112;\n        if (x < 0) result |= 0x80000000000000000000000000000000;\n\n        return bytes16 (uint128 (result));\n      }\n    }\n  }\n\n  /**\n   * Convert quadruple precision number into signed 256-bit integer number\n   * rounding towards zero.  Revert on overflow.\n   *\n   * @param x quadruple precision number\n   * @return signed 256-bit integer number\n   */\n  function toInt (bytes16 x) internal pure returns (int256) {\n    unchecked {\n      uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\n\n      require (exponent <= 16638); // Overflow\n      if (exponent < 16383) return 0; // Underflow\n\n      uint256 result = uint256 (uint128 (x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF |\n        0x10000000000000000000000000000;\n\n      if (exponent < 16495) result >>= 16495 - exponent;\n      else if (exponent > 16495) result <<= exponent - 16495;\n\n      if (uint128 (x) >= 0x80000000000000000000000000000000) { // Negative\n        require (result <= 0x8000000000000000000000000000000000000000000000000000000000000000);\n        return -int256 (result); // We rely on overflow behavior here\n      } else {\n        require (result <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n        return int256 (result);\n      }\n    }\n  }\n\n  /**\n   * Convert unsigned 256-bit integer number into quadruple precision number.\n   *\n   * @param x unsigned 256-bit integer number\n   * @return quadruple precision number\n   */\n  function fromUInt (uint256 x) internal pure returns (bytes16) {\n    unchecked {\n      if (x == 0) return bytes16 (0);\n      else {\n        uint256 result = x;\n\n        uint256 msb = mostSignificantBit (result);\n        if (msb < 112) result <<= 112 - msb;\n        else if (msb > 112) result >>= msb - 112;\n\n        result = result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF | 16383 + msb << 112;\n\n        return bytes16 (uint128 (result));\n      }\n    }\n  }\n\n  /**\n   * Convert quadruple precision number into unsigned 256-bit integer number\n   * rounding towards zero.  Revert on underflow.  Note, that negative floating\n   * point numbers in range (-1.0 .. 0.0) may be converted to unsigned integer\n   * without error, because they are rounded to zero.\n   *\n   * @param x quadruple precision number\n   * @return unsigned 256-bit integer number\n   */\n  function toUInt (bytes16 x) internal pure returns (uint256) {\n    unchecked {\n      uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\n\n      if (exponent < 16383) return 0; // Underflow\n\n      require (uint128 (x) < 0x80000000000000000000000000000000); // Negative\n\n      require (exponent <= 16638); // Overflow\n      uint256 result = uint256 (uint128 (x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF |\n        0x10000000000000000000000000000;\n\n      if (exponent < 16495) result >>= 16495 - exponent;\n      else if (exponent > 16495) result <<= exponent - 16495;\n\n      return result;\n    }\n  }\n\n  /**\n   * Convert signed 128.128 bit fixed point number into quadruple precision\n   * number.\n   *\n   * @param x signed 128.128 bit fixed point number\n   * @return quadruple precision number\n   */\n  function from128x128 (int256 x) internal pure returns (bytes16) {\n    unchecked {\n      if (x == 0) return bytes16 (0);\n      else {\n        // We rely on overflow behavior here\n        uint256 result = uint256 (x > 0 ? x : -x);\n\n        uint256 msb = mostSignificantBit (result);\n        if (msb < 112) result <<= 112 - msb;\n        else if (msb > 112) result >>= msb - 112;\n\n        result = result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF | 16255 + msb << 112;\n        if (x < 0) result |= 0x80000000000000000000000000000000;\n\n        return bytes16 (uint128 (result));\n      }\n    }\n  }\n\n  /**\n   * Convert quadruple precision number into signed 128.128 bit fixed point\n   * number.  Revert on overflow.\n   *\n   * @param x quadruple precision number\n   * @return signed 128.128 bit fixed point number\n   */\n  function to128x128 (bytes16 x) internal pure returns (int256) {\n    unchecked {\n      uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\n\n      require (exponent <= 16510); // Overflow\n      if (exponent < 16255) return 0; // Underflow\n\n      uint256 result = uint256 (uint128 (x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF |\n        0x10000000000000000000000000000;\n\n      if (exponent < 16367) result >>= 16367 - exponent;\n      else if (exponent > 16367) result <<= exponent - 16367;\n\n      if (uint128 (x) >= 0x80000000000000000000000000000000) { // Negative\n        require (result <= 0x8000000000000000000000000000000000000000000000000000000000000000);\n        return -int256 (result); // We rely on overflow behavior here\n      } else {\n        require (result <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n        return int256 (result);\n      }\n    }\n  }\n\n  /**\n   * Convert signed 64.64 bit fixed point number into quadruple precision\n   * number.\n   *\n   * @param x signed 64.64 bit fixed point number\n   * @return quadruple precision number\n   */\n  function from64x64 (int128 x) internal pure returns (bytes16) {\n    unchecked {\n      if (x == 0) return bytes16 (0);\n      else {\n        // We rely on overflow behavior here\n        uint256 result = uint128 (x > 0 ? x : -x);\n\n        uint256 msb = mostSignificantBit (result);\n        if (msb < 112) result <<= 112 - msb;\n        else if (msb > 112) result >>= msb - 112;\n\n        result = result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF | 16319 + msb << 112;\n        if (x < 0) result |= 0x80000000000000000000000000000000;\n\n        return bytes16 (uint128 (result));\n      }\n    }\n  }\n\n  /**\n   * Convert quadruple precision number into signed 64.64 bit fixed point\n   * number.  Revert on overflow.\n   *\n   * @param x quadruple precision number\n   * @return signed 64.64 bit fixed point number\n   */\n  function to64x64 (bytes16 x) internal pure returns (int128) {\n    unchecked {\n      uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\n\n      require (exponent <= 16446); // Overflow\n      if (exponent < 16319) return 0; // Underflow\n\n      uint256 result = uint256 (uint128 (x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF |\n        0x10000000000000000000000000000;\n\n      if (exponent < 16431) result >>= 16431 - exponent;\n      else if (exponent > 16431) result <<= exponent - 16431;\n\n      if (uint128 (x) >= 0x80000000000000000000000000000000) { // Negative\n        require (result <= 0x80000000000000000000000000000000);\n        return -int128 (int256 (result)); // We rely on overflow behavior here\n      } else {\n        require (result <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n        return int128 (int256 (result));\n      }\n    }\n  }\n\n  /**\n   * Convert octuple precision number into quadruple precision number.\n   *\n   * @param x octuple precision number\n   * @return quadruple precision number\n   */\n  function fromOctuple (bytes32 x) internal pure returns (bytes16) {\n    unchecked {\n      bool negative = x & 0x8000000000000000000000000000000000000000000000000000000000000000 > 0;\n\n      uint256 exponent = uint256 (x) >> 236 & 0x7FFFF;\n      uint256 significand = uint256 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n      if (exponent == 0x7FFFF) {\n        if (significand > 0) return NaN;\n        else return negative ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\n      }\n\n      if (exponent > 278526)\n        return negative ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\n      else if (exponent < 245649)\n        return negative ? NEGATIVE_ZERO : POSITIVE_ZERO;\n      else if (exponent < 245761) {\n        significand = (significand | 0x100000000000000000000000000000000000000000000000000000000000) >> 245885 - exponent;\n        exponent = 0;\n      } else {\n        significand >>= 124;\n        exponent -= 245760;\n      }\n\n      uint128 result = uint128 (significand | exponent << 112);\n      if (negative) result |= 0x80000000000000000000000000000000;\n\n      return bytes16 (result);\n    }\n  }\n\n  /**\n   * Convert quadruple precision number into octuple precision number.\n   *\n   * @param x quadruple precision number\n   * @return octuple precision number\n   */\n  function toOctuple (bytes16 x) internal pure returns (bytes32) {\n    unchecked {\n      uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\n\n      uint256 result = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n      if (exponent == 0x7FFF) exponent = 0x7FFFF; // Infinity or NaN\n      else if (exponent == 0) {\n        if (result > 0) {\n          uint256 msb = mostSignificantBit (result);\n          result = result << 236 - msb & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n          exponent = 245649 + msb;\n        }\n      } else {\n        result <<= 124;\n        exponent += 245760;\n      }\n\n      result |= exponent << 236;\n      if (uint128 (x) >= 0x80000000000000000000000000000000)\n        result |= 0x8000000000000000000000000000000000000000000000000000000000000000;\n\n      return bytes32 (result);\n    }\n  }\n\n  /**\n   * Convert double precision number into quadruple precision number.\n   *\n   * @param x double precision number\n   * @return quadruple precision number\n   */\n  function fromDouble (bytes8 x) internal pure returns (bytes16) {\n    unchecked {\n      uint256 exponent = uint64 (x) >> 52 & 0x7FF;\n\n      uint256 result = uint64 (x) & 0xFFFFFFFFFFFFF;\n\n      if (exponent == 0x7FF) exponent = 0x7FFF; // Infinity or NaN\n      else if (exponent == 0) {\n        if (result > 0) {\n          uint256 msb = mostSignificantBit (result);\n          result = result << 112 - msb & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n          exponent = 15309 + msb;\n        }\n      } else {\n        result <<= 60;\n        exponent += 15360;\n      }\n\n      result |= exponent << 112;\n      if (x & 0x8000000000000000 > 0)\n        result |= 0x80000000000000000000000000000000;\n\n      return bytes16 (uint128 (result));\n    }\n  }\n\n  /**\n   * Convert quadruple precision number into double precision number.\n   *\n   * @param x quadruple precision number\n   * @return double precision number\n   */\n  function toDouble (bytes16 x) internal pure returns (bytes8) {\n    unchecked {\n      bool negative = uint128 (x) >= 0x80000000000000000000000000000000;\n\n      uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\n      uint256 significand = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n      if (exponent == 0x7FFF) {\n        if (significand > 0) return 0x7FF8000000000000; // NaN\n        else return negative ?\n            bytes8 (0xFFF0000000000000) : // -Infinity\n            bytes8 (0x7FF0000000000000); // Infinity\n      }\n\n      if (exponent > 17406)\n        return negative ?\n            bytes8 (0xFFF0000000000000) : // -Infinity\n            bytes8 (0x7FF0000000000000); // Infinity\n      else if (exponent < 15309)\n        return negative ?\n            bytes8 (0x8000000000000000) : // -0\n            bytes8 (0x0000000000000000); // 0\n      else if (exponent < 15361) {\n        significand = (significand | 0x10000000000000000000000000000) >> 15421 - exponent;\n        exponent = 0;\n      } else {\n        significand >>= 60;\n        exponent -= 15360;\n      }\n\n      uint64 result = uint64 (significand | exponent << 52);\n      if (negative) result |= 0x8000000000000000;\n\n      return bytes8 (result);\n    }\n  }\n\n  /**\n   * Test whether given quadruple precision number is NaN.\n   *\n   * @param x quadruple precision number\n   * @return true if x is NaN, false otherwise\n   */\n  function isNaN (bytes16 x) internal pure returns (bool) {\n    unchecked {\n      return uint128 (x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF >\n        0x7FFF0000000000000000000000000000;\n    }\n  }\n\n  /**\n   * Test whether given quadruple precision number is positive or negative\n   * infinity.\n   *\n   * @param x quadruple precision number\n   * @return true if x is positive or negative infinity, false otherwise\n   */\n  function isInfinity (bytes16 x) internal pure returns (bool) {\n    unchecked {\n      return uint128 (x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF ==\n        0x7FFF0000000000000000000000000000;\n    }\n  }\n\n  /**\n   * Calculate sign of x, i.e. -1 if x is negative, 0 if x if zero, and 1 if x\n   * is positive.  Note that sign (-0) is zero.  Revert if x is NaN. \n   *\n   * @param x quadruple precision number\n   * @return sign of x\n   */\n  function sign (bytes16 x) internal pure returns (int8) {\n    unchecked {\n      uint128 absoluteX = uint128 (x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n      require (absoluteX <= 0x7FFF0000000000000000000000000000); // Not NaN\n\n      if (absoluteX == 0) return 0;\n      else if (uint128 (x) >= 0x80000000000000000000000000000000) return -1;\n      else return 1;\n    }\n  }\n\n  /**\n   * Calculate sign (x - y).  Revert if either argument is NaN, or both\n   * arguments are infinities of the same sign. \n   *\n   * @param x quadruple precision number\n   * @param y quadruple precision number\n   * @return sign (x - y)\n   */\n  function cmp (bytes16 x, bytes16 y) internal pure returns (int8) {\n    unchecked {\n      uint128 absoluteX = uint128 (x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n      require (absoluteX <= 0x7FFF0000000000000000000000000000); // Not NaN\n\n      uint128 absoluteY = uint128 (y) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n      require (absoluteY <= 0x7FFF0000000000000000000000000000); // Not NaN\n\n      // Not infinities of the same sign\n      require (x != y || absoluteX < 0x7FFF0000000000000000000000000000);\n\n      if (x == y) return 0;\n      else {\n        bool negativeX = uint128 (x) >= 0x80000000000000000000000000000000;\n        bool negativeY = uint128 (y) >= 0x80000000000000000000000000000000;\n\n        if (negativeX) {\n          if (negativeY) return absoluteX > absoluteY ? -1 : int8 (1);\n          else return -1; \n        } else {\n          if (negativeY) return 1;\n          else return absoluteX > absoluteY ? int8 (1) : -1;\n        }\n      }\n    }\n  }\n\n  /**\n   * Test whether x equals y.  NaN, infinity, and -infinity are not equal to\n   * anything. \n   *\n   * @param x quadruple precision number\n   * @param y quadruple precision number\n   * @return true if x equals to y, false otherwise\n   */\n  function eq (bytes16 x, bytes16 y) internal pure returns (bool) {\n    unchecked {\n      if (x == y) {\n        return uint128 (x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF <\n          0x7FFF0000000000000000000000000000;\n      } else return false;\n    }\n  }\n\n  /**\n   * Calculate x + y.  Special values behave in the following way:\n   *\n   * NaN + x = NaN for any x.\n   * Infinity + x = Infinity for any finite x.\n   * -Infinity + x = -Infinity for any finite x.\n   * Infinity + Infinity = Infinity.\n   * -Infinity + -Infinity = -Infinity.\n   * Infinity + -Infinity = -Infinity + Infinity = NaN.\n   *\n   * @param x quadruple precision number\n   * @param y quadruple precision number\n   * @return quadruple precision number\n   */\n  function add (bytes16 x, bytes16 y) internal pure returns (bytes16) {\n    unchecked {\n      uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\n      uint256 yExponent = uint128 (y) >> 112 & 0x7FFF;\n\n      if (xExponent == 0x7FFF) {\n        if (yExponent == 0x7FFF) { \n          if (x == y) return x;\n          else return NaN;\n        } else return x; \n      } else if (yExponent == 0x7FFF) return y;\n      else {\n        bool xSign = uint128 (x) >= 0x80000000000000000000000000000000;\n        uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n        if (xExponent == 0) xExponent = 1;\n        else xSignifier |= 0x10000000000000000000000000000;\n\n        bool ySign = uint128 (y) >= 0x80000000000000000000000000000000;\n        uint256 ySignifier = uint128 (y) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n        if (yExponent == 0) yExponent = 1;\n        else ySignifier |= 0x10000000000000000000000000000;\n\n        if (xSignifier == 0) return y == NEGATIVE_ZERO ? POSITIVE_ZERO : y;\n        else if (ySignifier == 0) return x == NEGATIVE_ZERO ? POSITIVE_ZERO : x;\n        else {\n          int256 delta = int256 (xExponent) - int256 (yExponent);\n  \n          if (xSign == ySign) {\n            if (delta > 112) return x;\n            else if (delta > 0) ySignifier >>= uint256 (delta);\n            else if (delta < -112) return y;\n            else if (delta < 0) {\n              xSignifier >>= uint256 (-delta);\n              xExponent = yExponent;\n            }\n  \n            xSignifier += ySignifier;\n  \n            if (xSignifier >= 0x20000000000000000000000000000) {\n              xSignifier >>= 1;\n              xExponent += 1;\n            }\n  \n            if (xExponent == 0x7FFF)\n              return xSign ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\n            else {\n              if (xSignifier < 0x10000000000000000000000000000) xExponent = 0;\n              else xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n  \n              return bytes16 (uint128 (\n                  (xSign ? 0x80000000000000000000000000000000 : 0) |\n                  (xExponent << 112) |\n                  xSignifier)); \n            }\n          } else {\n            if (delta > 0) {\n              xSignifier <<= 1;\n              xExponent -= 1;\n            } else if (delta < 0) {\n              ySignifier <<= 1;\n              xExponent = yExponent - 1;\n            }\n\n            if (delta > 112) ySignifier = 1;\n            else if (delta > 1) ySignifier = (ySignifier - 1 >> uint256 (delta - 1)) + 1;\n            else if (delta < -112) xSignifier = 1;\n            else if (delta < -1) xSignifier = (xSignifier - 1 >> uint256 (-delta - 1)) + 1;\n\n            if (xSignifier >= ySignifier) xSignifier -= ySignifier;\n            else {\n              xSignifier = ySignifier - xSignifier;\n              xSign = ySign;\n            }\n\n            if (xSignifier == 0)\n              return POSITIVE_ZERO;\n\n            uint256 msb = mostSignificantBit (xSignifier);\n\n            if (msb == 113) {\n              xSignifier = xSignifier >> 1 & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n              xExponent += 1;\n            } else if (msb < 112) {\n              uint256 shift = 112 - msb;\n              if (xExponent > shift) {\n                xSignifier = xSignifier << shift & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n                xExponent -= shift;\n              } else {\n                xSignifier <<= xExponent - 1;\n                xExponent = 0;\n              }\n            } else xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n            if (xExponent == 0x7FFF)\n              return xSign ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\n            else return bytes16 (uint128 (\n                (xSign ? 0x80000000000000000000000000000000 : 0) |\n                (xExponent << 112) |\n                xSignifier));\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Calculate x - y.  Special values behave in the following way:\n   *\n   * NaN - x = NaN for any x.\n   * Infinity - x = Infinity for any finite x.\n   * -Infinity - x = -Infinity for any finite x.\n   * Infinity - -Infinity = Infinity.\n   * -Infinity - Infinity = -Infinity.\n   * Infinity - Infinity = -Infinity - -Infinity = NaN.\n   *\n   * @param x quadruple precision number\n   * @param y quadruple precision number\n   * @return quadruple precision number\n   */\n  function sub (bytes16 x, bytes16 y) internal pure returns (bytes16) {\n    unchecked {\n      return add (x, y ^ 0x80000000000000000000000000000000);\n    }\n  }\n\n  /**\n   * Calculate x * y.  Special values behave in the following way:\n   *\n   * NaN * x = NaN for any x.\n   * Infinity * x = Infinity for any finite positive x.\n   * Infinity * x = -Infinity for any finite negative x.\n   * -Infinity * x = -Infinity for any finite positive x.\n   * -Infinity * x = Infinity for any finite negative x.\n   * Infinity * 0 = NaN.\n   * -Infinity * 0 = NaN.\n   * Infinity * Infinity = Infinity.\n   * Infinity * -Infinity = -Infinity.\n   * -Infinity * Infinity = -Infinity.\n   * -Infinity * -Infinity = Infinity.\n   *\n   * @param x quadruple precision number\n   * @param y quadruple precision number\n   * @return quadruple precision number\n   */\n  function mul (bytes16 x, bytes16 y) internal pure returns (bytes16) {\n    unchecked {\n      uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\n      uint256 yExponent = uint128 (y) >> 112 & 0x7FFF;\n\n      if (xExponent == 0x7FFF) {\n        if (yExponent == 0x7FFF) {\n          if (x == y) return x ^ y & 0x80000000000000000000000000000000;\n          else if (x ^ y == 0x80000000000000000000000000000000) return x | y;\n          else return NaN;\n        } else {\n          if (y & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) return NaN;\n          else return x ^ y & 0x80000000000000000000000000000000;\n        }\n      } else if (yExponent == 0x7FFF) {\n          if (x & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) return NaN;\n          else return y ^ x & 0x80000000000000000000000000000000;\n      } else {\n        uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n        if (xExponent == 0) xExponent = 1;\n        else xSignifier |= 0x10000000000000000000000000000;\n\n        uint256 ySignifier = uint128 (y) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n        if (yExponent == 0) yExponent = 1;\n        else ySignifier |= 0x10000000000000000000000000000;\n\n        xSignifier *= ySignifier;\n        if (xSignifier == 0)\n          return (x ^ y) & 0x80000000000000000000000000000000 > 0 ?\n              NEGATIVE_ZERO : POSITIVE_ZERO;\n\n        xExponent += yExponent;\n\n        uint256 msb =\n          xSignifier >= 0x200000000000000000000000000000000000000000000000000000000 ? 225 :\n          xSignifier >= 0x100000000000000000000000000000000000000000000000000000000 ? 224 :\n          mostSignificantBit (xSignifier);\n\n        if (xExponent + msb < 16496) { // Underflow\n          xExponent = 0;\n          xSignifier = 0;\n        } else if (xExponent + msb < 16608) { // Subnormal\n          if (xExponent < 16496)\n            xSignifier >>= 16496 - xExponent;\n          else if (xExponent > 16496)\n            xSignifier <<= xExponent - 16496;\n          xExponent = 0;\n        } else if (xExponent + msb > 49373) {\n          xExponent = 0x7FFF;\n          xSignifier = 0;\n        } else {\n          if (msb > 112)\n            xSignifier >>= msb - 112;\n          else if (msb < 112)\n            xSignifier <<= 112 - msb;\n\n          xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n          xExponent = xExponent + msb - 16607;\n        }\n\n        return bytes16 (uint128 (uint128 ((x ^ y) & 0x80000000000000000000000000000000) |\n            xExponent << 112 | xSignifier));\n      }\n    }\n  }\n\n  /**\n   * Calculate x / y.  Special values behave in the following way:\n   *\n   * NaN / x = NaN for any x.\n   * x / NaN = NaN for any x.\n   * Infinity / x = Infinity for any finite non-negative x.\n   * Infinity / x = -Infinity for any finite negative x including -0.\n   * -Infinity / x = -Infinity for any finite non-negative x.\n   * -Infinity / x = Infinity for any finite negative x including -0.\n   * x / Infinity = 0 for any finite non-negative x.\n   * x / -Infinity = -0 for any finite non-negative x.\n   * x / Infinity = -0 for any finite non-negative x including -0.\n   * x / -Infinity = 0 for any finite non-negative x including -0.\n   * \n   * Infinity / Infinity = NaN.\n   * Infinity / -Infinity = -NaN.\n   * -Infinity / Infinity = -NaN.\n   * -Infinity / -Infinity = NaN.\n   *\n   * Division by zero behaves in the following way:\n   *\n   * x / 0 = Infinity for any finite positive x.\n   * x / -0 = -Infinity for any finite positive x.\n   * x / 0 = -Infinity for any finite negative x.\n   * x / -0 = Infinity for any finite negative x.\n   * 0 / 0 = NaN.\n   * 0 / -0 = NaN.\n   * -0 / 0 = NaN.\n   * -0 / -0 = NaN.\n   *\n   * @param x quadruple precision number\n   * @param y quadruple precision number\n   * @return quadruple precision number\n   */\n  function div (bytes16 x, bytes16 y) internal pure returns (bytes16) {\n    unchecked {\n      uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\n      uint256 yExponent = uint128 (y) >> 112 & 0x7FFF;\n\n      if (xExponent == 0x7FFF) {\n        if (yExponent == 0x7FFF) return NaN;\n        else return x ^ y & 0x80000000000000000000000000000000;\n      } else if (yExponent == 0x7FFF) {\n        if (y & 0x0000FFFFFFFFFFFFFFFFFFFFFFFFFFFF != 0) return NaN;\n        else return POSITIVE_ZERO | (x ^ y) & 0x80000000000000000000000000000000;\n      } else if (y & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) {\n        if (x & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) return NaN;\n        else return POSITIVE_INFINITY | (x ^ y) & 0x80000000000000000000000000000000;\n      } else {\n        uint256 ySignifier = uint128 (y) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n        if (yExponent == 0) yExponent = 1;\n        else ySignifier |= 0x10000000000000000000000000000;\n\n        uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n        if (xExponent == 0) {\n          if (xSignifier != 0) {\n            uint shift = 226 - mostSignificantBit (xSignifier);\n\n            xSignifier <<= shift;\n\n            xExponent = 1;\n            yExponent += shift - 114;\n          }\n        }\n        else {\n          xSignifier = (xSignifier | 0x10000000000000000000000000000) << 114;\n        }\n\n        xSignifier = xSignifier / ySignifier;\n        if (xSignifier == 0)\n          return (x ^ y) & 0x80000000000000000000000000000000 > 0 ?\n              NEGATIVE_ZERO : POSITIVE_ZERO;\n\n        assert (xSignifier >= 0x1000000000000000000000000000);\n\n        uint256 msb =\n          xSignifier >= 0x80000000000000000000000000000 ? mostSignificantBit (xSignifier) :\n          xSignifier >= 0x40000000000000000000000000000 ? 114 :\n          xSignifier >= 0x20000000000000000000000000000 ? 113 : 112;\n\n        if (xExponent + msb > yExponent + 16497) { // Overflow\n          xExponent = 0x7FFF;\n          xSignifier = 0;\n        } else if (xExponent + msb + 16380  < yExponent) { // Underflow\n          xExponent = 0;\n          xSignifier = 0;\n        } else if (xExponent + msb + 16268  < yExponent) { // Subnormal\n          if (xExponent + 16380 > yExponent)\n            xSignifier <<= xExponent + 16380 - yExponent;\n          else if (xExponent + 16380 < yExponent)\n            xSignifier >>= yExponent - xExponent - 16380;\n\n          xExponent = 0;\n        } else { // Normal\n          if (msb > 112)\n            xSignifier >>= msb - 112;\n\n          xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n          xExponent = xExponent + msb + 16269 - yExponent;\n        }\n\n        return bytes16 (uint128 (uint128 ((x ^ y) & 0x80000000000000000000000000000000) |\n            xExponent << 112 | xSignifier));\n      }\n    }\n  }\n\n  /**\n   * Calculate -x.\n   *\n   * @param x quadruple precision number\n   * @return quadruple precision number\n   */\n  function neg (bytes16 x) internal pure returns (bytes16) {\n    unchecked {\n      return x ^ 0x80000000000000000000000000000000;\n    }\n  }\n\n  /**\n   * Calculate |x|.\n   *\n   * @param x quadruple precision number\n   * @return quadruple precision number\n   */\n  function abs (bytes16 x) internal pure returns (bytes16) {\n    unchecked {\n      return x & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n    }\n  }\n\n  /**\n   * Calculate square root of x.  Return NaN on negative x excluding -0.\n   *\n   * @param x quadruple precision number\n   * @return quadruple precision number\n   */\n  function sqrt (bytes16 x) internal pure returns (bytes16) {\n    unchecked {\n      if (uint128 (x) >  0x80000000000000000000000000000000) return NaN;\n      else {\n        uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\n        if (xExponent == 0x7FFF) return x;\n        else {\n          uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n          if (xExponent == 0) xExponent = 1;\n          else xSignifier |= 0x10000000000000000000000000000;\n\n          if (xSignifier == 0) return POSITIVE_ZERO;\n\n          bool oddExponent = xExponent & 0x1 == 0;\n          xExponent = xExponent + 16383 >> 1;\n\n          if (oddExponent) {\n            if (xSignifier >= 0x10000000000000000000000000000)\n              xSignifier <<= 113;\n            else {\n              uint256 msb = mostSignificantBit (xSignifier);\n              uint256 shift = (226 - msb) & 0xFE;\n              xSignifier <<= shift;\n              xExponent -= shift - 112 >> 1;\n            }\n          } else {\n            if (xSignifier >= 0x10000000000000000000000000000)\n              xSignifier <<= 112;\n            else {\n              uint256 msb = mostSignificantBit (xSignifier);\n              uint256 shift = (225 - msb) & 0xFE;\n              xSignifier <<= shift;\n              xExponent -= shift - 112 >> 1;\n            }\n          }\n\n          uint256 r = 0x10000000000000000000000000000;\n          r = (r + xSignifier / r) >> 1;\n          r = (r + xSignifier / r) >> 1;\n          r = (r + xSignifier / r) >> 1;\n          r = (r + xSignifier / r) >> 1;\n          r = (r + xSignifier / r) >> 1;\n          r = (r + xSignifier / r) >> 1;\n          r = (r + xSignifier / r) >> 1; // Seven iterations should be enough\n          uint256 r1 = xSignifier / r;\n          if (r1 < r) r = r1;\n\n          return bytes16 (uint128 (xExponent << 112 | r & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF));\n        }\n      }\n    }\n  }\n\n  /**\n   * Calculate binary logarithm of x.  Return NaN on negative x excluding -0.\n   *\n   * @param x quadruple precision number\n   * @return quadruple precision number\n   */\n  function log_2 (bytes16 x) internal pure returns (bytes16) {\n    unchecked {\n      if (uint128 (x) > 0x80000000000000000000000000000000) return NaN;\n      else if (x == 0x3FFF0000000000000000000000000000) return POSITIVE_ZERO; \n      else {\n        uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\n        if (xExponent == 0x7FFF) return x;\n        else {\n          uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n          if (xExponent == 0) xExponent = 1;\n          else xSignifier |= 0x10000000000000000000000000000;\n\n          if (xSignifier == 0) return NEGATIVE_INFINITY;\n\n          bool resultNegative;\n          uint256 resultExponent = 16495;\n          uint256 resultSignifier;\n\n          if (xExponent >= 0x3FFF) {\n            resultNegative = false;\n            resultSignifier = xExponent - 0x3FFF;\n            xSignifier <<= 15;\n          } else {\n            resultNegative = true;\n            if (xSignifier >= 0x10000000000000000000000000000) {\n              resultSignifier = 0x3FFE - xExponent;\n              xSignifier <<= 15;\n            } else {\n              uint256 msb = mostSignificantBit (xSignifier);\n              resultSignifier = 16493 - msb;\n              xSignifier <<= 127 - msb;\n            }\n          }\n\n          if (xSignifier == 0x80000000000000000000000000000000) {\n            if (resultNegative) resultSignifier += 1;\n            uint256 shift = 112 - mostSignificantBit (resultSignifier);\n            resultSignifier <<= shift;\n            resultExponent -= shift;\n          } else {\n            uint256 bb = resultNegative ? 1 : 0;\n            while (resultSignifier < 0x10000000000000000000000000000) {\n              resultSignifier <<= 1;\n              resultExponent -= 1;\n  \n              xSignifier *= xSignifier;\n              uint256 b = xSignifier >> 255;\n              resultSignifier += b ^ bb;\n              xSignifier >>= 127 + b;\n            }\n          }\n\n          return bytes16 (uint128 ((resultNegative ? 0x80000000000000000000000000000000 : 0) |\n              resultExponent << 112 | resultSignifier & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF));\n        }\n      }\n    }\n  }\n\n  /**\n   * Calculate natural logarithm of x.  Return NaN on negative x excluding -0.\n   *\n   * @param x quadruple precision number\n   * @return quadruple precision number\n   */\n  function ln (bytes16 x) internal pure returns (bytes16) {\n    unchecked {\n      return mul (log_2 (x), 0x3FFE62E42FEFA39EF35793C7673007E5);\n    }\n  }\n\n  /**\n   * Calculate 2^x.\n   *\n   * @param x quadruple precision number\n   * @return quadruple precision number\n   */\n  function pow_2 (bytes16 x) internal pure returns (bytes16) {\n    unchecked {\n      bool xNegative = uint128 (x) > 0x80000000000000000000000000000000;\n      uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\n      uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n      if (xExponent == 0x7FFF && xSignifier != 0) return NaN;\n      else if (xExponent > 16397)\n        return xNegative ? POSITIVE_ZERO : POSITIVE_INFINITY;\n      else if (xExponent < 16255)\n        return 0x3FFF0000000000000000000000000000;\n      else {\n        if (xExponent == 0) xExponent = 1;\n        else xSignifier |= 0x10000000000000000000000000000;\n\n        if (xExponent > 16367)\n          xSignifier <<= xExponent - 16367;\n        else if (xExponent < 16367)\n          xSignifier >>= 16367 - xExponent;\n\n        if (xNegative && xSignifier > 0x406E00000000000000000000000000000000)\n          return POSITIVE_ZERO;\n\n        if (!xNegative && xSignifier > 0x3FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n          return POSITIVE_INFINITY;\n\n        uint256 resultExponent = xSignifier >> 128;\n        xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n        if (xNegative && xSignifier != 0) {\n          xSignifier = ~xSignifier;\n          resultExponent += 1;\n        }\n\n        uint256 resultSignifier = 0x80000000000000000000000000000000;\n        if (xSignifier & 0x80000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x16A09E667F3BCC908B2FB1366EA957D3E >> 128;\n        if (xSignifier & 0x40000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1306FE0A31B7152DE8D5A46305C85EDEC >> 128;\n        if (xSignifier & 0x20000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1172B83C7D517ADCDF7C8C50EB14A791F >> 128;\n        if (xSignifier & 0x10000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10B5586CF9890F6298B92B71842A98363 >> 128;\n        if (xSignifier & 0x8000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1059B0D31585743AE7C548EB68CA417FD >> 128;\n        if (xSignifier & 0x4000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x102C9A3E778060EE6F7CACA4F7A29BDE8 >> 128;\n        if (xSignifier & 0x2000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10163DA9FB33356D84A66AE336DCDFA3F >> 128;\n        if (xSignifier & 0x1000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100B1AFA5ABCBED6129AB13EC11DC9543 >> 128;\n        if (xSignifier & 0x800000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10058C86DA1C09EA1FF19D294CF2F679B >> 128;\n        if (xSignifier & 0x400000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1002C605E2E8CEC506D21BFC89A23A00F >> 128;\n        if (xSignifier & 0x200000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100162F3904051FA128BCA9C55C31E5DF >> 128;\n        if (xSignifier & 0x100000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000B175EFFDC76BA38E31671CA939725 >> 128;\n        if (xSignifier & 0x80000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100058BA01FB9F96D6CACD4B180917C3D >> 128;\n        if (xSignifier & 0x40000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10002C5CC37DA9491D0985C348C68E7B3 >> 128;\n        if (xSignifier & 0x20000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000162E525EE054754457D5995292026 >> 128;\n        if (xSignifier & 0x10000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000B17255775C040618BF4A4ADE83FC >> 128;\n        if (xSignifier & 0x8000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000058B91B5BC9AE2EED81E9B7D4CFAB >> 128;\n        if (xSignifier & 0x4000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100002C5C89D5EC6CA4D7C8ACC017B7C9 >> 128;\n        if (xSignifier & 0x2000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000162E43F4F831060E02D839A9D16D >> 128;\n        if (xSignifier & 0x1000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000B1721BCFC99D9F890EA06911763 >> 128;\n        if (xSignifier & 0x800000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000058B90CF1E6D97F9CA14DBCC1628 >> 128;\n        if (xSignifier & 0x400000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000002C5C863B73F016468F6BAC5CA2B >> 128;\n        if (xSignifier & 0x200000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000162E430E5A18F6119E3C02282A5 >> 128;\n        if (xSignifier & 0x100000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000B1721835514B86E6D96EFD1BFE >> 128;\n        if (xSignifier & 0x80000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000058B90C0B48C6BE5DF846C5B2EF >> 128;\n        if (xSignifier & 0x40000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000002C5C8601CC6B9E94213C72737A >> 128;\n        if (xSignifier & 0x20000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000162E42FFF037DF38AA2B219F06 >> 128;\n        if (xSignifier & 0x10000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000B17217FBA9C739AA5819F44F9 >> 128;\n        if (xSignifier & 0x8000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000058B90BFCDEE5ACD3C1CEDC823 >> 128;\n        if (xSignifier & 0x4000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000002C5C85FE31F35A6A30DA1BE50 >> 128;\n        if (xSignifier & 0x2000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000162E42FF0999CE3541B9FFFCF >> 128;\n        if (xSignifier & 0x1000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000B17217F80F4EF5AADDA45554 >> 128;\n        if (xSignifier & 0x800000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000058B90BFBF8479BD5A81B51AD >> 128;\n        if (xSignifier & 0x400000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000002C5C85FDF84BD62AE30A74CC >> 128;\n        if (xSignifier & 0x200000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000162E42FEFB2FED257559BDAA >> 128;\n        if (xSignifier & 0x100000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000B17217F7D5A7716BBA4A9AE >> 128;\n        if (xSignifier & 0x80000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000058B90BFBE9DDBAC5E109CCE >> 128;\n        if (xSignifier & 0x40000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000002C5C85FDF4B15DE6F17EB0D >> 128;\n        if (xSignifier & 0x20000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000162E42FEFA494F1478FDE05 >> 128;\n        if (xSignifier & 0x10000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000B17217F7D20CF927C8E94C >> 128;\n        if (xSignifier & 0x8000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000058B90BFBE8F71CB4E4B33D >> 128;\n        if (xSignifier & 0x4000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000002C5C85FDF477B662B26945 >> 128;\n        if (xSignifier & 0x2000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000162E42FEFA3AE53369388C >> 128;\n        if (xSignifier & 0x1000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000B17217F7D1D351A389D40 >> 128;\n        if (xSignifier & 0x800000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000058B90BFBE8E8B2D3D4EDE >> 128;\n        if (xSignifier & 0x400000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000002C5C85FDF4741BEA6E77E >> 128;\n        if (xSignifier & 0x200000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000162E42FEFA39FE95583C2 >> 128;\n        if (xSignifier & 0x100000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000B17217F7D1CFB72B45E1 >> 128;\n        if (xSignifier & 0x80000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000058B90BFBE8E7CC35C3F0 >> 128;\n        if (xSignifier & 0x40000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000002C5C85FDF473E242EA38 >> 128;\n        if (xSignifier & 0x20000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000162E42FEFA39F02B772C >> 128;\n        if (xSignifier & 0x10000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000B17217F7D1CF7D83C1A >> 128;\n        if (xSignifier & 0x8000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000058B90BFBE8E7BDCBE2E >> 128;\n        if (xSignifier & 0x4000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000002C5C85FDF473DEA871F >> 128;\n        if (xSignifier & 0x2000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000162E42FEFA39EF44D91 >> 128;\n        if (xSignifier & 0x1000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000B17217F7D1CF79E949 >> 128;\n        if (xSignifier & 0x800000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000058B90BFBE8E7BCE544 >> 128;\n        if (xSignifier & 0x400000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000002C5C85FDF473DE6ECA >> 128;\n        if (xSignifier & 0x200000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000162E42FEFA39EF366F >> 128;\n        if (xSignifier & 0x100000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000B17217F7D1CF79AFA >> 128;\n        if (xSignifier & 0x80000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000058B90BFBE8E7BCD6D >> 128;\n        if (xSignifier & 0x40000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000002C5C85FDF473DE6B2 >> 128;\n        if (xSignifier & 0x20000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000162E42FEFA39EF358 >> 128;\n        if (xSignifier & 0x10000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000B17217F7D1CF79AB >> 128;\n        if (xSignifier & 0x8000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000058B90BFBE8E7BCD5 >> 128;\n        if (xSignifier & 0x4000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000002C5C85FDF473DE6A >> 128;\n        if (xSignifier & 0x2000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000162E42FEFA39EF34 >> 128;\n        if (xSignifier & 0x1000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000B17217F7D1CF799 >> 128;\n        if (xSignifier & 0x800000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000058B90BFBE8E7BCC >> 128;\n        if (xSignifier & 0x400000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000002C5C85FDF473DE5 >> 128;\n        if (xSignifier & 0x200000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000162E42FEFA39EF2 >> 128;\n        if (xSignifier & 0x100000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000B17217F7D1CF78 >> 128;\n        if (xSignifier & 0x80000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000058B90BFBE8E7BB >> 128;\n        if (xSignifier & 0x40000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000002C5C85FDF473DD >> 128;\n        if (xSignifier & 0x20000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000162E42FEFA39EE >> 128;\n        if (xSignifier & 0x10000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000B17217F7D1CF6 >> 128;\n        if (xSignifier & 0x8000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000058B90BFBE8E7A >> 128;\n        if (xSignifier & 0x4000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000002C5C85FDF473C >> 128;\n        if (xSignifier & 0x2000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000162E42FEFA39D >> 128;\n        if (xSignifier & 0x1000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000B17217F7D1CE >> 128;\n        if (xSignifier & 0x800000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000058B90BFBE8E6 >> 128;\n        if (xSignifier & 0x400000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000002C5C85FDF472 >> 128;\n        if (xSignifier & 0x200000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000162E42FEFA38 >> 128;\n        if (xSignifier & 0x100000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000B17217F7D1B >> 128;\n        if (xSignifier & 0x80000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000058B90BFBE8D >> 128;\n        if (xSignifier & 0x40000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000002C5C85FDF46 >> 128;\n        if (xSignifier & 0x20000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000162E42FEFA2 >> 128;\n        if (xSignifier & 0x10000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000B17217F7D0 >> 128;\n        if (xSignifier & 0x8000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000058B90BFBE7 >> 128;\n        if (xSignifier & 0x4000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000002C5C85FDF3 >> 128;\n        if (xSignifier & 0x2000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000162E42FEF9 >> 128;\n        if (xSignifier & 0x1000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000B17217F7C >> 128;\n        if (xSignifier & 0x800000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000058B90BFBD >> 128;\n        if (xSignifier & 0x400000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000002C5C85FDE >> 128;\n        if (xSignifier & 0x200000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000162E42FEE >> 128;\n        if (xSignifier & 0x100000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000B17217F6 >> 128;\n        if (xSignifier & 0x80000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000058B90BFA >> 128;\n        if (xSignifier & 0x40000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000002C5C85FC >> 128;\n        if (xSignifier & 0x20000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000162E42FD >> 128;\n        if (xSignifier & 0x10000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000B17217E >> 128;\n        if (xSignifier & 0x8000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000058B90BE >> 128;\n        if (xSignifier & 0x4000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000002C5C85E >> 128;\n        if (xSignifier & 0x2000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000162E42E >> 128;\n        if (xSignifier & 0x1000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000B17216 >> 128;\n        if (xSignifier & 0x800000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000058B90A >> 128;\n        if (xSignifier & 0x400000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000002C5C84 >> 128;\n        if (xSignifier & 0x200000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000162E41 >> 128;\n        if (xSignifier & 0x100000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000000B1720 >> 128;\n        if (xSignifier & 0x80000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000058B8F >> 128;\n        if (xSignifier & 0x40000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000002C5C7 >> 128;\n        if (xSignifier & 0x20000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000000162E3 >> 128;\n        if (xSignifier & 0x10000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000000B171 >> 128;\n        if (xSignifier & 0x8000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000000058B8 >> 128;\n        if (xSignifier & 0x4000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000002C5B >> 128;\n        if (xSignifier & 0x2000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000000162D >> 128;\n        if (xSignifier & 0x1000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000B16 >> 128;\n        if (xSignifier & 0x800 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000000058A >> 128;\n        if (xSignifier & 0x400 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000000002C4 >> 128;\n        if (xSignifier & 0x200 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000161 >> 128;\n        if (xSignifier & 0x100 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000000000B0 >> 128;\n        if (xSignifier & 0x80 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000057 >> 128;\n        if (xSignifier & 0x40 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000000002B >> 128;\n        if (xSignifier & 0x20 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000015 >> 128;\n        if (xSignifier & 0x10 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000000000A >> 128;\n        if (xSignifier & 0x8 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000004 >> 128;\n        if (xSignifier & 0x4 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000001 >> 128;\n\n        if (!xNegative) {\n          resultSignifier = resultSignifier >> 15 & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n          resultExponent += 0x3FFF;\n        } else if (resultExponent <= 0x3FFE) {\n          resultSignifier = resultSignifier >> 15 & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n          resultExponent = 0x3FFF - resultExponent;\n        } else {\n          resultSignifier = resultSignifier >> resultExponent - 16367;\n          resultExponent = 0;\n        }\n\n        return bytes16 (uint128 (resultExponent << 112 | resultSignifier));\n      }\n    }\n  }\n\n  /**\n   * Calculate e^x.\n   *\n   * @param x quadruple precision number\n   * @return quadruple precision number\n   */\n  function exp (bytes16 x) internal pure returns (bytes16) {\n    unchecked {\n      return pow_2 (mul (x, 0x3FFF71547652B82FE1777D0FFDA0D23A));\n    }\n  }\n\n  /**\n   * Get index of the most significant non-zero bit in binary representation of\n   * x.  Reverts if x is zero.\n   *\n   * @return index of the most significant non-zero bit in binary representation\n   *         of x\n   */\n  function mostSignificantBit (uint256 x) private pure returns (uint256) {\n    unchecked {\n      require (x > 0);\n\n      uint256 result = 0;\n\n      if (x >= 0x100000000000000000000000000000000) { x >>= 128; result += 128; }\n      if (x >= 0x10000000000000000) { x >>= 64; result += 64; }\n      if (x >= 0x100000000) { x >>= 32; result += 32; }\n      if (x >= 0x10000) { x >>= 16; result += 16; }\n      if (x >= 0x100) { x >>= 8; result += 8; }\n      if (x >= 0x10) { x >>= 4; result += 4; }\n      if (x >= 0x4) { x >>= 2; result += 2; }\n      if (x >= 0x2) result += 1; // No need to shift x anymore\n\n      return result;\n    }\n  }\n}\n"
        },
        "contracts/test-utilities/PoolFactoryBalanceDrainMock.sol": {
            "content": "//SPDX-License-Identifier: CC-BY-NC-ND-4.0\npragma solidity 0.8.7;\n\nimport \"../interfaces/IPoolFactory.sol\";\nimport \"../interfaces/ILeveragedPool.sol\";\nimport \"../interfaces/IPoolCommitter.sol\";\nimport \"../interfaces/IERC20DecimalsWrapper.sol\";\nimport \"../test-utilities/LeveragedPoolBalanceDrainMock.sol\";\nimport \"../implementation/PoolToken.sol\";\nimport \"../implementation/PoolKeeper.sol\";\nimport \"../implementation/PoolCommitter.sol\";\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\n/// @title The pool factory contract\ncontract PoolFactoryBalanceDrainMock is IPoolFactory, Ownable {\n    // #### Globals\n    PoolToken public pairTokenBase;\n    address public immutable pairTokenBaseAddress;\n    LeveragedPoolBalanceDrainMock public poolBase;\n    address public immutable poolBaseAddress;\n    IPoolKeeper public poolKeeper;\n    PoolCommitter public poolCommitterBase;\n    address public immutable poolCommitterBaseAddress;\n\n    address public autoClaim;\n\n    // Contract address to receive protocol fees\n    address public feeReceiver;\n    // Default fee, annualised; Fee value as a decimal multiplied by 10^18. For example, 50% is represented as 0.5 * 10^18\n    uint256 public fee;\n    uint256 public secondaryFeeSplitPercent = 10;\n    // The fee taken for each mint and burn. Fee value as a decimal multiplied by 10^18. For example, 50% is represented as 0.5 * 10^18\n    uint256 public mintingFee;\n    uint256 public burningFee;\n\n    // This is required because we must pass along *some* value for decimal\n    // precision to the base pool tokens as we use the Cloneable pattern\n    uint8 constant DEFAULT_NUM_DECIMALS = 18;\n    uint8 constant MAX_DECIMALS = DEFAULT_NUM_DECIMALS;\n    // Default max leverage of 10\n    uint16 public maxLeverage = 10;\n\n    /**\n     * @notice Format: Pool counter => pool address\n     */\n    mapping(uint256 => address) public override pools;\n    uint256 public override numPools;\n\n    /**\n     * @notice Format: Pool address => validity\n     */\n    mapping(address => bool) public override isValidPool;\n\n    /**\n     * @notice Format: PoolCommitter address => validity\n     */\n    mapping(address => bool) public override isValidPoolCommitter;\n\n    // #### Functions\n    constructor(address _feeReceiver) {\n        require(_feeReceiver != address(0), \"Address cannot be null\");\n\n        // Deploy base contracts\n        pairTokenBase = new PoolToken(DEFAULT_NUM_DECIMALS);\n        pairTokenBaseAddress = address(pairTokenBase);\n        poolBase = new LeveragedPoolBalanceDrainMock();\n        poolBaseAddress = address(poolBase);\n        poolCommitterBase = new PoolCommitter(address(this), address(this), address(this), 0, 0);\n        poolCommitterBaseAddress = address(poolCommitterBase);\n\n        ILeveragedPool.Initialization memory baseInitialization = ILeveragedPool.Initialization(\n            address(this),\n            address(this),\n            address(this),\n            address(this),\n            address(this),\n            address(this),\n            address(this),\n            address(this),\n            \"BASE_POOL\",\n            15,\n            30,\n            0,\n            1,\n            address(this),\n            address(0),\n            address(this),\n            10\n        );\n        // Init bases\n        poolBase.initialize(baseInitialization);\n        pairTokenBase.initialize(address(this), \"BASE_TOKEN\", \"BASE\", DEFAULT_NUM_DECIMALS);\n        feeReceiver = _feeReceiver;\n    }\n\n    /**\n     * @notice Deploy a leveraged pool and its committer/pool tokens with given parameters\n     * @param deploymentParameters Deployment parameters of the market. Some may be reconfigurable.\n     * @return Address of the created pool\n     * @dev Throws if pool keeper is null\n     * @dev Throws if deployer does not own the oracle wrapper\n     * @dev Throws if leverage amount is invalid\n     * @dev Throws if decimal precision is too high (i.e., greater than `MAX_DECIMALS`)\n     */\n    function deployPool(PoolDeployment calldata deploymentParameters) external override returns (address) {\n        address _poolKeeper = address(poolKeeper);\n        require(_poolKeeper != address(0), \"PoolKeeper not set\");\n        require(\n            IOracleWrapper(deploymentParameters.oracleWrapper).deployer() == msg.sender,\n            \"Deployer must be oracle wrapper owner\"\n        );\n\n        bytes32 uniquePoolHash = keccak256(\n            abi.encode(\n                deploymentParameters.leverageAmount,\n                deploymentParameters.quoteToken,\n                deploymentParameters.oracleWrapper\n            )\n        );\n\n        PoolCommitter poolCommitter = PoolCommitter(\n            Clones.cloneDeterministic(poolCommitterBaseAddress, uniquePoolHash)\n        );\n        poolCommitter.initialize(\n            address(this),\n            deploymentParameters.invariantCheckContract,\n            autoClaim,\n            mintingFee,\n            burningFee\n        );\n        address poolCommitterAddress = address(poolCommitter);\n\n        require(\n            deploymentParameters.leverageAmount >= 1 && deploymentParameters.leverageAmount <= maxLeverage,\n            \"PoolKeeper: leveraged amount invalid\"\n        );\n        require(\n            IERC20DecimalsWrapper(deploymentParameters.quoteToken).decimals() <= MAX_DECIMALS,\n            \"Decimal precision too high\"\n        );\n\n        LeveragedPoolBalanceDrainMock pool = LeveragedPoolBalanceDrainMock(\n            Clones.cloneDeterministic(poolBaseAddress, uniquePoolHash)\n        );\n        address _pool = address(pool);\n        emit DeployPool(_pool, poolCommitterAddress, deploymentParameters.poolName);\n\n        string memory leverage = Strings.toString(deploymentParameters.leverageAmount);\n\n        ILeveragedPool.Initialization memory initialization = ILeveragedPool.Initialization({\n            _owner: owner(), // governance is the owner of pools -- if this changes, `onlyGov` breaks\n            _keeper: _poolKeeper,\n            _oracleWrapper: deploymentParameters.oracleWrapper,\n            _settlementEthOracle: deploymentParameters.settlementEthOracle,\n            _longToken: deployPairToken(_pool, leverage, deploymentParameters, \"L-\"),\n            _shortToken: deployPairToken(_pool, leverage, deploymentParameters, \"S-\"),\n            _poolCommitter: poolCommitterAddress,\n            _invariantCheckContract: deploymentParameters.invariantCheckContract,\n            _poolName: string(abi.encodePacked(leverage, \"-\", deploymentParameters.poolName)),\n            _frontRunningInterval: deploymentParameters.frontRunningInterval,\n            _updateInterval: deploymentParameters.updateInterval,\n            _fee: (fee * deploymentParameters.updateInterval) / (365 days),\n            _leverageAmount: deploymentParameters.leverageAmount,\n            _feeAddress: feeReceiver,\n            _secondaryFeeAddress: msg.sender,\n            _quoteToken: deploymentParameters.quoteToken,\n            _secondaryFeeSplitPercent: secondaryFeeSplitPercent\n        });\n\n        // approve the quote token on the pool committer to finalise linking\n        // this also stores the pool address in the committer\n        // finalise pool setup\n        pool.initialize(initialization);\n        // approve the quote token on the pool commiter to finalise linking\n        // this also stores the pool address in the commiter\n        IPoolCommitter(poolCommitterAddress).setQuoteAndPool(deploymentParameters.quoteToken, _pool);\n        poolKeeper.newPool(_pool);\n        pools[numPools] = _pool;\n        numPools += 1;\n        isValidPool[_pool] = true;\n        return _pool;\n    }\n\n    /**\n     * @notice Deploy a contract for pool tokens\n     * @param leverage Amount of leverage for pool\n     * @param deploymentParameters Deployment parameters for parent function\n     * @param direction Long or short token, L- or S-\n     * @return Address of the pool token\n     */\n    function deployPairToken(\n        address owner,\n        string memory leverage,\n        PoolDeployment memory deploymentParameters,\n        string memory direction\n    ) internal returns (address) {\n        string memory poolNameAndSymbol = string(abi.encodePacked(leverage, direction, deploymentParameters.poolName));\n        uint8 settlementDecimals = IERC20DecimalsWrapper(deploymentParameters.quoteToken).decimals();\n        bytes32 uniqueTokenHash = keccak256(\n            abi.encode(\n                deploymentParameters.leverageAmount,\n                deploymentParameters.quoteToken,\n                deploymentParameters.oracleWrapper,\n                direction\n            )\n        );\n\n        PoolToken pairToken = PoolToken(Clones.cloneDeterministic(pairTokenBaseAddress, uniqueTokenHash));\n        pairToken.initialize(owner, poolNameAndSymbol, poolNameAndSymbol, settlementDecimals);\n        return address(pairToken);\n    }\n\n    /**\n     * @notice Sets the address of the associated `PoolKeeper` contract\n     * @param _poolKeeper Address of the `PoolKeeper`\n     * @dev Throws if provided address is null\n     * @dev Only callable by the owner\n     */\n    function setPoolKeeper(address _poolKeeper) external override onlyOwner {\n        require(_poolKeeper != address(0), \"address cannot be null\");\n        poolKeeper = IPoolKeeper(_poolKeeper);\n    }\n\n    /**\n     * @notice Sets the address of the associated `AutoClaim` contract\n     * @param _autoClaim Address of the `AutoClaim`\n     * @dev Throws if provided address is null\n     * @dev Only callable by the owner\n     */\n    function setAutoClaim(address _autoClaim) external override onlyOwner {\n        require(_autoClaim != address(0), \"address cannot be null\");\n        autoClaim = _autoClaim;\n    }\n\n    /**\n     * @notice Sets the maximum leverage\n     * @param newMaxLeverage Maximum leverage permitted for all pools\n     * @dev Throws if provided maximum leverage is non-positive\n     * @dev Only callable by the owner\n     */\n    function setMaxLeverage(uint16 newMaxLeverage) external override onlyOwner {\n        require(newMaxLeverage > 0, \"Maximum leverage must be non-zero\");\n        maxLeverage = newMaxLeverage;\n    }\n\n    function setFeeReceiver(address _feeReceiver) external override onlyOwner {\n        require(_feeReceiver != address(0), \"address cannot be null\");\n        feeReceiver = _feeReceiver;\n    }\n\n    function setSecondaryFeeSplitPercent(uint256 newFeePercent) external override onlyOwner {\n        require(newFeePercent <= 100, \"Secondary fee split cannot exceed 100%\");\n        secondaryFeeSplitPercent = newFeePercent;\n    }\n\n    /**\n     * @notice Set the yearly fee amount. The max yearly fee is 10%\n     * @dev This is a percentage in WAD; multiplied by 10^18 e.g. 5% is 0.05 * 10^18\n     * @param _fee The fee amount as a percentage\n     * @dev Throws if fee is greater than 10%\n     */\n    function setFee(uint256 _fee) external override onlyOwner {\n        require(_fee <= 0.1e18, \"Fee cannot be > 10%\");\n        fee = _fee;\n    }\n\n    /**\n     * @notice Sets a valid PoolCommitter.\n     * @dev TEST FUNCTION\n     * @param _address The address whose validity will be toggled.\n     * @param _validity True or false, depending on whether to mark it as valid or not.\n     */\n    function setValidPoolCommitter(address _address, bool _validity) external {\n        isValidPoolCommitter[_address] = _validity;\n    }\n\n    /**\n     * @notice Set the minting and burning fee amount. The max yearly fee is 10%\n     * @dev This is a percentage in WAD; multiplied by 10^18 e.g. 5% is 0.05 * 10^18\n     * @param _mintingFee The fee amount for mints\n     * @param _burningFee The fee amount for burns\n     * @dev Only callable by the owner of this contract\n     * @dev Throws if minting fee is greater than 10%\n     * @dev Throws if burning fee is greater than 10%\n     */\n    function setMintAndBurnFee(uint256 _mintingFee, uint256 _burningFee) external override onlyOwner {\n        require(_mintingFee <= 0.1e18, \"Fee cannot be > 10%\");\n        require(_burningFee <= 0.1e18, \"Fee cannot be > 10%\");\n        mintingFee = _mintingFee;\n        burningFee = _burningFee;\n    }\n\n    /*\n     * @notice Returns the address that owns this contract\n     * @return Address of the owner\n     * @dev Required due to the `IPoolFactory` interface\n     */\n    function getOwner() external view override returns (address) {\n        return owner();\n    }\n\n    /**\n     * @notice Ensures that the caller is the designated governance address\n     */\n    modifier onlyGov() {\n        require(msg.sender == owner(), \"msg.sender not governance\");\n        _;\n    }\n}\n"
        },
        "contracts/interfaces/IERC20DecimalsWrapper.sol": {
            "content": "//SPDX-License-Identifier: CC-BY-NC-ND-4.0\npragma solidity 0.8.7;\n\n/// @title The decimals interface for extending the ERC20 interface\ninterface IERC20DecimalsWrapper {\n    function decimals() external view returns (uint8);\n}\n"
        },
        "contracts/implementation/PoolToken.sol": {
            "content": "//SPDX-License-Identifier: CC-BY-NC-ND-4.0\npragma solidity 0.8.7;\n\nimport \"../vendors/ERC20_Cloneable.sol\";\nimport \"../interfaces/IPoolToken.sol\";\n\n/// @title The pool token; used for ownership/shares of the underlying tokens of the long/short pool\n/// @dev ERC_20_Cloneable contains onlyOwner code implemented for use with the cloneable setup\ncontract PoolToken is ERC20_Cloneable, IPoolToken {\n    // #### Global state\n\n    // #### Functions\n\n    constructor(uint8 _decimals) ERC20_Cloneable(\"BASE_TOKEN\", \"BASE\", _decimals) {}\n\n    /**\n     * @notice Mints pool tokens\n     * @param amount Pool tokens to burn\n     * @param account Account to burn pool tokens to\n     * @return Whether the mint was successful\n     */\n    function mint(uint256 amount, address account) external override onlyOwner returns (bool) {\n        _mint(account, amount);\n        return true;\n    }\n\n    /**\n     * @notice Burns pool tokens\n     * @param amount Pool tokens to burn\n     * @param account Account to burn pool tokens from\n     * @return Whether the burn was successful\n     */\n    function burn(uint256 amount, address account) external override onlyOwner returns (bool) {\n        _burn(account, amount);\n        return true;\n    }\n}\n"
        },
        "contracts/implementation/PoolKeeper.sol": {
            "content": "//SPDX-License-Identifier: CC-BY-NC-ND-4.0\npragma solidity 0.8.7;\n\nimport \"../interfaces/IPoolKeeper.sol\";\nimport \"../interfaces/IOracleWrapper.sol\";\nimport \"../interfaces/IPoolFactory.sol\";\nimport \"../implementation/PriceObserver.sol\";\nimport \"../interfaces/ILeveragedPool.sol\";\nimport \"../interfaces/IERC20DecimalsWrapper.sol\";\nimport \"./PoolSwapLibrary.sol\";\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"abdk-libraries-solidity/ABDKMathQuad.sol\";\n\n/// @title The manager contract for multiple markets and the pools in them\ncontract PoolKeeper is IPoolKeeper, Ownable {\n    /* Constants */\n    uint256 public constant BASE_TIP = 5; // 5% base tip\n    uint256 public constant TIP_DELTA_PER_BLOCK = 5; // 5% increase per block\n    uint256 public constant BLOCK_TIME = 13; /* in seconds */\n    uint256 public constant MAX_DECIMALS = 18;\n    uint256 public constant MAX_TIP = 100; /* maximum keeper tip */\n\n    // #### Global variables\n    /**\n     * @notice Format: Pool address => last executionPrice\n     */\n    mapping(address => int256) public executionPrice;\n\n    IPoolFactory public factory;\n    bytes16 constant fixedPoint = 0x403abc16d674ec800000000000000000; // 1 ether\n\n    uint256 public gasPrice = 10 gwei;\n    address public observer = address(0);\n\n    // #### Functions\n    constructor(address _factory) {\n        require(_factory != address(0), \"Factory cannot be 0 address\");\n        factory = IPoolFactory(_factory);\n    }\n\n    /**\n     * @notice Sets the address of the associated `PriceObserver` contract\n     * @param _observer Address of the `PriceObserver` contract\n     * @dev Throws if provided address is null\n     */\n    function setPriceObserver(address _observer) external onlyOwner {\n        require(_observer != address(0), \"Price observer cannot be 0 address\");\n        observer = _observer;\n    }\n\n    /**\n     * @notice When a pool is created, this function is called by the factory to initiate price trackings\n     * @param _poolAddress The address of the newly-created pools\n     * @dev Only callable by the associated `PoolFactory` contract\n     */\n    function newPool(address _poolAddress) external override onlyFactory {\n        address oracleWrapper = ILeveragedPool(_poolAddress).oracleWrapper();\n        int256 firstPrice = IOracleWrapper(oracleWrapper).getPrice();\n        require(firstPrice > 0, \"First price is non-positive\");\n        int256 startingPrice = ABDKMathQuad.toInt(ABDKMathQuad.mul(ABDKMathQuad.fromInt(firstPrice), fixedPoint));\n        emit PoolAdded(_poolAddress, firstPrice);\n        executionPrice[_poolAddress] = startingPrice;\n    }\n\n    /**\n     * @notice Check if upkeep is required\n     * @param _pool The address of the pool to upkeep\n     * @return Whether or not upkeep is needed for this single pool\n     */\n    function checkUpkeepSinglePool(address _pool) public view override returns (bool) {\n        if (!factory.isValidPool(_pool)) {\n            return false;\n        }\n\n        // The update interval has passed\n        return ILeveragedPool(_pool).intervalPassed();\n    }\n\n    /**\n     * @notice Checks multiple pools if any of them need updating\n     * @param _pools Array of pools to check\n     * @return Whether or not at least one pool needs upkeeping\n     * @dev Iterates over the provided array of pool addresses\n     */\n    function checkUpkeepMultiplePools(address[] calldata _pools) external view override returns (bool) {\n        uint256 poolsLength = _pools.length;\n        for (uint256 i = 0; i < poolsLength; i++) {\n            if (checkUpkeepSinglePool(_pools[i])) {\n                // One has been found that requires upkeeping\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * @notice Called by keepers to perform an update on a single pool\n     * @param _pool Address of the pool to be upkept\n     * @dev Induces an update of the associated `PriceObserver` contract\n     * @dev Tracks gas usage via `gasleft` accounting and uses this to inform\n     *          keeper payment\n     * @dev Catches any failure of the underlying `pool.poolUpkeep` call\n     */\n    function performUpkeepSinglePool(address _pool) public override {\n        uint256 startGas = gasleft();\n\n        // validate the pool, check that the interval time has passed\n        if (!checkUpkeepSinglePool(_pool)) {\n            return;\n        }\n\n        ILeveragedPool pool = ILeveragedPool(_pool);\n\n        /* update SMA oracle */\n        PriceObserver priceObserver = PriceObserver(observer);\n        IOracleWrapper priceObserverWriter = IOracleWrapper(priceObserver.getWriter());\n        priceObserverWriter.poll();\n\n        (int256 latestPrice, bytes memory data, uint256 savedPreviousUpdatedTimestamp, uint256 updateInterval) = pool\n            .getUpkeepInformation();\n\n        // Start a new round\n        // Get price in WAD format\n        int256 lastExecutionPrice = executionPrice[_pool];\n        executionPrice[_pool] = latestPrice;\n\n        // This allows us to still batch multiple calls to executePriceChange, even if some are invalid\n        // Without reverting the entire transaction\n        try pool.poolUpkeep(lastExecutionPrice, latestPrice) {\n            // If poolUpkeep is successful, refund the keeper for their gas costs\n            uint256 gasSpent = startGas - gasleft();\n\n            payKeeper(_pool, gasPrice, gasSpent, savedPreviousUpdatedTimestamp, updateInterval);\n            emit UpkeepSuccessful(_pool, data, lastExecutionPrice, latestPrice);\n        } catch Error(string memory reason) {\n            // If poolUpkeep fails for any other reason, emit event\n            emit PoolUpkeepError(_pool, reason);\n        }\n    }\n\n    /**\n     * @notice Called by keepers to perform an update on multiple pools\n     * @param pools Addresses of each pool to upkeep\n     * @dev Iterates over the provided array\n     * @dev Essentially wraps calls to `performUpkeepSinglePool`\n     */\n    function performUpkeepMultiplePools(address[] calldata pools) external override {\n        uint256 poolsLength = pools.length;\n        for (uint256 i = 0; i < poolsLength; i++) {\n            performUpkeepSinglePool(pools[i]);\n        }\n    }\n\n    /**\n     * @notice Pay keeper for upkeep\n     * @param _pool Address of the given pool\n     * @param _gasPrice Price of a single gas unit (in ETH (wei))\n     * @param _gasSpent Number of gas units spent\n     * @param _savedPreviousUpdatedTimestamp Last timestamp when the pool's price execution happened\n     * @param _updateInterval Pool interval of the given pool\n     * @dev Emits a `KeeperPaid` event if the underlying call to `pool.payKeeperFromBalances` succeeds\n     * @dev Emits a `KeeperPaymentError` event otherwise\n     */\n    function payKeeper(\n        address _pool,\n        uint256 _gasPrice,\n        uint256 _gasSpent,\n        uint256 _savedPreviousUpdatedTimestamp,\n        uint256 _updateInterval\n    ) internal {\n        uint256 reward = keeperReward(_pool, _gasPrice, _gasSpent, _savedPreviousUpdatedTimestamp, _updateInterval);\n        if (ILeveragedPool(_pool).payKeeperFromBalances(msg.sender, reward)) {\n            emit KeeperPaid(_pool, msg.sender, reward);\n        } else {\n            // Usually occurs if pool just started and does not have any funds\n            emit KeeperPaymentError(_pool, msg.sender, reward);\n        }\n    }\n\n    /**\n     * @notice Payment keeper receives for performing upkeep on a given pool\n     * @param _pool Address of the given pool\n     * @param _gasPrice Price of a single gas unit (in ETH (wei))\n     * @param _gasSpent Number of gas units spent\n     * @param _savedPreviousUpdatedTimestamp Last timestamp when the pool's price execution happened\n     * @param _poolInterval Pool interval of the given pool\n     * @return Number of settlement tokens to give to the keeper for work performed\n     */\n    function keeperReward(\n        address _pool,\n        uint256 _gasPrice,\n        uint256 _gasSpent,\n        uint256 _savedPreviousUpdatedTimestamp,\n        uint256 _poolInterval\n    ) public view returns (uint256) {\n        /**\n         * Conceptually, we have\n         *\n         * Reward = Gas + Tip = Gas + (Base + Premium * Blocks)\n         *\n         * Very roughly to scale:\n         *\n         * +---------------------------+------+---+---+~~~~~\n         * | GGGGGGGGGGGGGGGGGGGGGGGGG | BBBB | P | P | ...\n         * +---------------------------+------+---+---+~~~~~\n         *\n         * Under normal circumstances, we don't expect there to be any time\n         * premium at all. The time premium exists in order to *further*\n         * incentivise upkeep in the event of lateness.\n         *\n         * The base tip exists to act as pure profit for a keeper.\n         *\n         * Of course, the gas component acts as compensation for performing\n         * on-chain computation.\n         *\n         */\n\n        // keeper gas cost in wei. WAD formatted\n        uint256 _keeperGas = keeperGas(_pool, _gasPrice, _gasSpent);\n\n        // tip percent in wad units\n        bytes16 _tipPercent = ABDKMathQuad.fromUInt(keeperTip(_savedPreviousUpdatedTimestamp, _poolInterval));\n\n        // amount of settlement tokens to give to the keeper\n        _tipPercent = ABDKMathQuad.div(_tipPercent, ABDKMathQuad.fromUInt(100));\n        int256 wadRewardValue = ABDKMathQuad.toInt(\n            ABDKMathQuad.add(\n                ABDKMathQuad.fromUInt(_keeperGas),\n                ABDKMathQuad.div((ABDKMathQuad.mul(ABDKMathQuad.fromUInt(_keeperGas), _tipPercent)), fixedPoint)\n            )\n        );\n        uint256 decimals = IERC20DecimalsWrapper(ILeveragedPool(_pool).quoteToken()).decimals();\n        uint256 deWadifiedReward = PoolSwapLibrary.fromWad(uint256(wadRewardValue), decimals);\n        // _keeperGas + _keeperGas * percentTip\n        return deWadifiedReward;\n    }\n\n    /**\n     * @notice Compensation a keeper will receive for their gas expenditure\n     * @param _pool Address of the given pool\n     * @param _gasPrice Price of a single gas unit (in ETH (wei))\n     * @param _gasSpent Number of gas units spent\n     * @return Keeper's gas compensation\n     */\n    function keeperGas(\n        address _pool,\n        uint256 _gasPrice,\n        uint256 _gasSpent\n    ) public view returns (uint256) {\n        int256 settlementTokenPrice = IOracleWrapper(ILeveragedPool(_pool).settlementEthOracle()).getPrice();\n\n        if (settlementTokenPrice <= 0) {\n            return 0;\n        } else {\n            /* safe due to explicit bounds check above */\n            /* (wei * Settlement / ETH) / fixed point (10^18) = amount in settlement */\n            bytes16 _weiSpent = ABDKMathQuad.fromUInt(_gasPrice * _gasSpent);\n            bytes16 _settlementTokenPrice = ABDKMathQuad.fromUInt(uint256(settlementTokenPrice));\n            return\n                ABDKMathQuad.toUInt(ABDKMathQuad.div(ABDKMathQuad.mul(_weiSpent, _settlementTokenPrice), fixedPoint));\n        }\n    }\n\n    /**\n     * @notice Tip a keeper will receive for successfully updating the specified pool\n     * @param _savedPreviousUpdatedTimestamp Last timestamp when the pool's price execution happened\n     * @param _poolInterval Pool interval of the given pool\n     * @return Percent of the `keeperGas` cost to add to payment, as a percent\n     */\n    function keeperTip(uint256 _savedPreviousUpdatedTimestamp, uint256 _poolInterval) public view returns (uint256) {\n        /* the number of blocks that have elapsed since the given pool's updateInterval passed */\n        uint256 elapsedBlocksNumerator = (block.timestamp - (_savedPreviousUpdatedTimestamp + _poolInterval));\n\n        uint256 keeperTip = BASE_TIP + (TIP_DELTA_PER_BLOCK * elapsedBlocksNumerator) / BLOCK_TIME;\n\n        // In case of network outages or otherwise, we want to cap the tip so that the keeper cost isn't unbounded\n        if (keeperTip > MAX_TIP) {\n            return MAX_TIP;\n        } else {\n            return keeperTip;\n        }\n    }\n\n    /**\n     * @notice Sets the address of the associated `PoolFactory` contract\n     * @param _factory Address of the `PoolFactory` contract\n     * @dev Only callable by the owner\n     */\n    function setFactory(address _factory) external override onlyOwner {\n        factory = IPoolFactory(_factory);\n    }\n\n    /**\n     * @notice Sets the gas price to be used in compensating keepers for successful upkeep\n     * @param _price Price (in ETH) per unit gas\n     * @dev Only callable by the owner\n     * @dev This function is only necessary due to the L2 deployment of Pools -- in reality, it should be `BASEFEE`\n     */\n    function setGasPrice(uint256 _price) external onlyOwner {\n        gasPrice = _price;\n    }\n\n    /**\n     * @notice Ensures that the caller is the associated `PoolFactory` contract\n     */\n    modifier onlyFactory() {\n        require(msg.sender == address(factory), \"Caller not factory\");\n        _;\n    }\n}\n"
        },
        "contracts/implementation/PoolCommitter.sol": {
            "content": "//SPDX-License-Identifier: CC-BY-NC-ND-4.0\npragma solidity 0.8.7;\n\nimport \"../interfaces/IPoolCommitter.sol\";\nimport \"../interfaces/ILeveragedPool.sol\";\nimport \"../interfaces/IPoolFactory.sol\";\nimport \"../interfaces/IAutoClaim.sol\";\nimport \"../interfaces/IPausable.sol\";\nimport \"../interfaces/IInvariantCheck.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./PoolSwapLibrary.sol\";\n\n/// @title This contract is responsible for handling commitment logic\ncontract PoolCommitter is IPoolCommitter, Initializable {\n    // #### Globals\n    uint128 public constant LONG_INDEX = 0;\n    uint128 public constant SHORT_INDEX = 1;\n\n    IAutoClaim public autoClaim;\n    uint128 public override updateIntervalId = 1;\n    // The amount that is extracted from each mint and burn, being left in the pool. Given as the decimal * 10 ^ 18. For example, 60% fee is 0.6 * 10 ^ 18\n    bytes16 mintingFee;\n    bytes16 burningFee;\n\n    // Index 0 is the LONG token, index 1 is the SHORT token.\n    // Fetched from the LeveragedPool when leveragedPool is set\n    address[2] public tokens;\n\n    mapping(uint256 => Prices) public priceHistory; // updateIntervalId => tokenPrice\n    mapping(uint256 => bytes16) public burnFeeHistory; // updateIntervalId => burn fee. We need to store this historically because people can claim at any time after the update interval, but we want them to pay the fee from the update interval in which they committed.\n    mapping(address => Balance) public userAggregateBalance;\n\n    // Update interval ID => TotalCommitment\n    mapping(uint256 => TotalCommitment) public totalPoolCommitments;\n    // Address => Update interval ID => UserCommitment\n    mapping(address => mapping(uint256 => UserCommitment)) public userCommitments;\n    // The last interval ID for which a given user's balance was updated\n    mapping(address => uint256) public lastUpdatedIntervalId;\n    // The most recent update interval in which a user committed\n    mapping(address => uint256[]) public unAggregatedCommitments;\n    // Used to create a dynamic array that is used to copy the new unAggregatedCommitments array into the mapping after updating balance\n    uint256[] private storageArrayPlaceHolder;\n\n    address public factory;\n    address public governance;\n    address public leveragedPool;\n    address public invariantCheckContract;\n    bool public paused;\n    IInvariantCheck public invariantCheck;\n\n    /**\n     * @notice Constructor\n     * @param _factory Address of the associated `PoolFactory` contract\n     * @param _invariantCheckContract Address of the associated `InvariantCheck` contract\n     * @param _autoClaim Address of the associated `AutoClaim` contract\n     * @param _mintingFee The percentage that is taken from each mint, given as a decimal * 10 ^ 18\n     * @param _burningFee The percentage that is taken from each burn, given as a decimal * 10 ^ 18\n     * @dev Throws if factory contract address is null\n     * @dev Throws if autoClaim contract address is null\n     * @dev Throws if invariantCheck contract address is null\n     * @dev Throws if minting fee is over 100%\n     * @dev Throws if burning fee is over 100%\n     */\n    constructor(\n        address _factory,\n        address _invariantCheckContract,\n        address _autoClaim,\n        uint256 _mintingFee,\n        uint256 _burningFee\n    ) {\n        require(_factory != address(0), \"Factory address cannot be null\");\n        require(_autoClaim != address(0), \"AutoClaim address cannot be null\");\n        require(_invariantCheckContract != address(0), \"InvariantCheck address cannot be null\");\n        require(_mintingFee < PoolSwapLibrary.WAD_PRECISION, \"Minting fee >= 100%\");\n        require(_burningFee < PoolSwapLibrary.WAD_PRECISION, \"Burning fee >= 100%\");\n        factory = _factory;\n        autoClaim = IAutoClaim(_autoClaim);\n        mintingFee = PoolSwapLibrary.convertUIntToDecimal(_mintingFee);\n        burningFee = PoolSwapLibrary.convertUIntToDecimal(_burningFee);\n        invariantCheckContract = _invariantCheckContract;\n        invariantCheck = IInvariantCheck(_invariantCheckContract);\n    }\n\n    /**\n     * @notice Initialises the contract\n     * @param _factory Address of the associated `PoolFactory` contract\n     * @param _invariantCheckContract Address of the associated `InvariantCheck` contract\n     * @param _autoClaim Address of the associated `AutoClaim` contract\n     * @param _mintingFee The percentage that is taken from each mint, given as a decimal * 10 ^ 18\n     * @param _burningFee The percentage that is taken from each burn, given as a decimal * 10 ^ 18\n     * @dev Throws if factory contract address is null\n     * @dev Throws if autoClaim contract address is null\n     * @dev Throws if invariantCheck contract address is null\n     * @dev Throws if autoclaim contract address is null\n     * @dev Only callable by the associated initialiser address\n     * @dev Throws if minting fee is over 100%\n     * @dev Throws if burning fee is over 100%\n     */\n    function initialize(\n        address _factory,\n        address _invariantCheckContract,\n        address _autoClaim,\n        uint256 _mintingFee,\n        uint256 _burningFee\n    ) external override initializer {\n        require(_factory != address(0), \"Factory address cannot be 0 address\");\n        require(_invariantCheckContract != address(0), \"InvariantCheck address cannot be 0 address\");\n        require(_autoClaim != address(0), \"AutoClaim address cannot be null\");\n        require(_mintingFee < PoolSwapLibrary.WAD_PRECISION, \"Minting fee >= 100%\");\n        require(_burningFee < PoolSwapLibrary.WAD_PRECISION, \"Burning fee >= 100%\");\n        updateIntervalId = 1;\n        factory = _factory;\n        mintingFee = PoolSwapLibrary.convertUIntToDecimal(_mintingFee);\n        burningFee = PoolSwapLibrary.convertUIntToDecimal(_burningFee);\n        autoClaim = IAutoClaim(_autoClaim);\n        governance = IPoolFactory(_factory).getOwner();\n        invariantCheckContract = _invariantCheckContract;\n        invariantCheck = IInvariantCheck(_invariantCheckContract);\n        governance = IPoolFactory(factory).getOwner();\n    }\n\n    /**\n     * @notice Apply commitment data to storage\n     * @param pool The LeveragedPool of this PoolCommitter instance\n     * @param commitType The type of commitment being made\n     * @param amount The amount of tokens being committed\n     * @param fromAggregateBalance If minting, burning, or rebalancing into a delta neutral position,\n     *                             will tokens be taken from user's aggregate balance?\n     * @param userCommit The appropriate update interval's commitment data for the user\n     * @param userCommit The appropriate update interval's commitment data for the entire pool\n     */\n    function applyCommitment(\n        ILeveragedPool pool,\n        CommitType commitType,\n        uint256 amount,\n        bool fromAggregateBalance,\n        UserCommitment storage userCommit,\n        TotalCommitment storage totalCommit\n    ) private {\n        Balance memory balance = userAggregateBalance[msg.sender];\n        uint256 feeAmount;\n\n        if (commitType == CommitType.LongMint || commitType == CommitType.ShortMint) {\n            // We want to deduct the amount of settlement tokens that will be recorded under the commit by the minting fee\n            // and then add it to the correct side of the pool\n            feeAmount =\n                PoolSwapLibrary.convertDecimalToUInt(PoolSwapLibrary.multiplyDecimalByUInt(mintingFee, amount)) /\n                PoolSwapLibrary.WAD_PRECISION;\n            amount = amount - feeAmount;\n        }\n\n        if (commitType == CommitType.LongMint) {\n            (uint256 shortBalance, uint256 longBalance) = pool.balances();\n            userCommit.longMintAmount += amount;\n            totalCommit.longMintAmount += amount;\n            // Add the fee to long side. This has been taken from the commit amount.\n            pool.setNewPoolBalances(longBalance + feeAmount, shortBalance);\n            // If we are minting from balance, this would already have thrown in `commit` if we are minting more than entitled too\n        } else if (commitType == CommitType.LongBurn) {\n            userCommit.longBurnAmount += amount;\n            totalCommit.longBurnAmount += amount;\n            // long burning: pull in long pool tokens from committer\n            if (fromAggregateBalance) {\n                // Burning from user's aggregate balance\n                userCommit.balanceLongBurnAmount += amount;\n                // This require statement is only needed in this branch, as `pool.burnTokens` will revert if burning too many\n                require(userCommit.balanceLongBurnAmount <= balance.longTokens, \"Insufficient pool tokens\");\n                // Burn from leveragedPool, because that is the official owner of the tokens before they are claimed\n                pool.burnTokens(true, amount, leveragedPool);\n            } else {\n                // Burning from user's wallet\n                pool.burnTokens(true, amount, msg.sender);\n            }\n        } else if (commitType == CommitType.ShortMint) {\n            (uint256 shortBalance, uint256 longBalance) = pool.balances();\n            userCommit.shortMintAmount += amount;\n            totalCommit.shortMintAmount += amount;\n            // Add the fee to short side. This has been taken from the commit amount.\n            pool.setNewPoolBalances(longBalance, shortBalance + feeAmount);\n            // If we are minting from balance, this would already have thrown in `commit` if we are minting more than entitled too\n        } else if (commitType == CommitType.ShortBurn) {\n            userCommit.shortBurnAmount += amount;\n            totalCommit.shortBurnAmount += amount;\n            if (fromAggregateBalance) {\n                // Burning from user's aggregate balance\n                userCommit.balanceShortBurnAmount += amount;\n                // This require statement is only needed in this branch, as `pool.burnTokens` will revert if burning too many\n                require(userCommit.balanceShortBurnAmount <= balance.shortTokens, \"Insufficient pool tokens\");\n                // Burn from leveragedPool, because that is the official owner of the tokens before they are claimed\n                pool.burnTokens(false, amount, leveragedPool);\n            } else {\n                // Burning from user's wallet\n                pool.burnTokens(false, amount, msg.sender);\n            }\n        } else if (commitType == CommitType.LongBurnShortMint) {\n            userCommit.longBurnShortMintAmount += amount;\n            totalCommit.longBurnShortMintAmount += amount;\n            if (fromAggregateBalance) {\n                userCommit.balanceLongBurnMintAmount += amount;\n                require(userCommit.balanceLongBurnMintAmount <= balance.longTokens, \"Insufficient pool tokens\");\n                pool.burnTokens(true, amount, leveragedPool);\n            } else {\n                pool.burnTokens(true, amount, msg.sender);\n            }\n        } else if (commitType == CommitType.ShortBurnLongMint) {\n            userCommit.shortBurnLongMintAmount += amount;\n            totalCommit.shortBurnLongMintAmount += amount;\n            if (fromAggregateBalance) {\n                userCommit.balanceShortBurnMintAmount += amount;\n                require(userCommit.balanceShortBurnMintAmount <= balance.shortTokens, \"Insufficient pool tokens\");\n                pool.burnTokens(false, amount, leveragedPool);\n            } else {\n                pool.burnTokens(false, amount, msg.sender);\n            }\n        }\n    }\n\n    /**\n     * @notice Commit to minting/burning long/short tokens after the next price change\n     * @param commitType Type of commit you're doing (Long vs Short, Mint vs Burn)\n     * @param amount Amount of quote tokens you want to commit to minting; OR amount of pool\n     *               tokens you want to burn\n     * @param fromAggregateBalance If minting, burning, or rebalancing into a delta neutral position,\n     *                             will tokens be taken from user's aggregate balance?\n     * @dev Emits a `CreateCommit` event on success\n     */\n    function commit(\n        CommitType commitType,\n        uint256 amount,\n        bool fromAggregateBalance,\n        bool payForClaim\n    ) external payable override updateBalance checkInvariantsAfterFunction {\n        require(amount > 0, \"Amount must not be zero\");\n        ILeveragedPool pool = ILeveragedPool(leveragedPool);\n        uint256 updateInterval = pool.updateInterval();\n        uint256 lastPriceTimestamp = pool.lastPriceTimestamp();\n        uint256 frontRunningInterval = pool.frontRunningInterval();\n\n        if (payForClaim) {\n            autoClaim.makePaidClaimRequest{value: msg.value}(msg.sender);\n        }\n\n        uint256 appropriateUpdateIntervalId = PoolSwapLibrary.appropriateUpdateIntervalId(\n            block.timestamp,\n            lastPriceTimestamp,\n            frontRunningInterval,\n            updateInterval,\n            updateIntervalId\n        );\n        TotalCommitment storage totalCommit = totalPoolCommitments[appropriateUpdateIntervalId];\n        UserCommitment storage userCommit = userCommitments[msg.sender][appropriateUpdateIntervalId];\n\n        userCommit.updateIntervalId = appropriateUpdateIntervalId;\n\n        uint256 length = unAggregatedCommitments[msg.sender].length;\n        if (length == 0 || unAggregatedCommitments[msg.sender][length - 1] < appropriateUpdateIntervalId) {\n            unAggregatedCommitments[msg.sender].push(appropriateUpdateIntervalId);\n        }\n\n        if (commitType == CommitType.LongMint || commitType == CommitType.ShortMint) {\n            // minting: pull in the quote token from the committer\n            // Do not need to transfer if minting using aggregate balance tokens, since the leveraged pool already owns these tokens.\n            if (!fromAggregateBalance) {\n                pool.quoteTokenTransferFrom(msg.sender, leveragedPool, amount);\n            } else {\n                // Want to take away from their balance's settlement tokens\n                userAggregateBalance[msg.sender].settlementTokens -= amount;\n            }\n        }\n\n        applyCommitment(pool, commitType, amount, fromAggregateBalance, userCommit, totalCommit);\n        emit CreateCommit(msg.sender, amount, commitType);\n    }\n\n    /**\n     * @notice Claim user's balance. This can be done either by the user themself or by somebody else on their behalf.\n     * @param user Address of the user to claim against\n     * @dev Updates aggregate user balances\n     * @dev Emits a `Claim` event on success\n     */\n    function claim(address user) external override checkInvariantsAfterFunction onlyAutoClaimOrCommitter(user) {\n        updateAggregateBalance(user);\n        if (msg.sender == user && autoClaim.checkUserClaim(user, address(this))) {\n            // If the committer is claiming for themself and they have a valid pending claim, clear it.\n            autoClaim.withdrawUserClaimRequest(user);\n        }\n        Balance memory balance = userAggregateBalance[user];\n        ILeveragedPool pool = ILeveragedPool(leveragedPool);\n        if (balance.settlementTokens > 0) {\n            pool.quoteTokenTransfer(user, balance.settlementTokens);\n        }\n        if (balance.longTokens > 0) {\n            pool.poolTokenTransfer(true, user, balance.longTokens);\n        }\n        if (balance.shortTokens > 0) {\n            pool.poolTokenTransfer(false, user, balance.shortTokens);\n        }\n        delete userAggregateBalance[user];\n        emit Claim(user);\n    }\n\n    /**\n     * @notice Executes every commitment specified in the list\n     * @param _commits Array of `TotalCommitment`s\n     */\n    function executeGivenCommitments(TotalCommitment memory _commits) internal {\n        ILeveragedPool pool = ILeveragedPool(leveragedPool);\n\n        BalancesAndSupplies memory balancesAndSupplies = BalancesAndSupplies({\n            shortBalance: pool.shortBalance(),\n            longBalance: pool.longBalance(),\n            longTotalSupplyBefore: IERC20(tokens[0]).totalSupply(),\n            shortTotalSupplyBefore: IERC20(tokens[1]).totalSupply()\n        });\n\n        uint256 totalLongBurn = _commits.longBurnAmount + _commits.longBurnShortMintAmount;\n        uint256 totalShortBurn = _commits.shortBurnAmount + _commits.shortBurnLongMintAmount;\n        // Update price before values change\n        priceHistory[updateIntervalId] = Prices({\n            longPrice: PoolSwapLibrary.getPrice(\n                balancesAndSupplies.longBalance,\n                balancesAndSupplies.longTotalSupplyBefore + totalLongBurn\n            ),\n            shortPrice: PoolSwapLibrary.getPrice(\n                balancesAndSupplies.shortBalance,\n                balancesAndSupplies.shortTotalSupplyBefore + totalShortBurn\n            )\n        });\n\n        // Amount of collateral tokens that are generated from the long burn into instant mints\n        uint256 longBurnInstantMintAmount = PoolSwapLibrary.getWithdrawAmountOnBurn(\n            balancesAndSupplies.longTotalSupplyBefore,\n            _commits.longBurnShortMintAmount,\n            balancesAndSupplies.longBalance,\n            totalLongBurn\n        );\n        // Amount of collateral tokens that are generated from the short burn into instant mints\n        uint256 shortBurnInstantMintAmount = PoolSwapLibrary.getWithdrawAmountOnBurn(\n            balancesAndSupplies.shortTotalSupplyBefore,\n            _commits.shortBurnLongMintAmount,\n            balancesAndSupplies.shortBalance,\n            totalShortBurn\n        );\n\n        // Long Mints\n        uint256 longMintAmount = PoolSwapLibrary.getMintAmount(\n            balancesAndSupplies.longTotalSupplyBefore, // long token total supply,\n            _commits.longMintAmount + shortBurnInstantMintAmount, // Add the collateral tokens that will be generated from burning shorts for instant long mint\n            balancesAndSupplies.longBalance, // total quote tokens in the long pull\n            totalLongBurn // total pool tokens commited to be burned\n        );\n\n        if (longMintAmount > 0) {\n            pool.mintTokens(true, longMintAmount, leveragedPool);\n        }\n\n        // Long Burns\n        uint256 longBurnAmount = PoolSwapLibrary.getWithdrawAmountOnBurn(\n            balancesAndSupplies.longTotalSupplyBefore,\n            totalLongBurn,\n            balancesAndSupplies.longBalance,\n            totalLongBurn\n        );\n\n        // Short Mints\n        uint256 shortMintAmount = PoolSwapLibrary.getMintAmount(\n            balancesAndSupplies.shortTotalSupplyBefore, // short token total supply\n            _commits.shortMintAmount + longBurnInstantMintAmount, // Add the collateral tokens that will be generated from burning longs for instant short mint\n            balancesAndSupplies.shortBalance,\n            totalShortBurn\n        );\n\n        if (shortMintAmount > 0) {\n            pool.mintTokens(false, shortMintAmount, leveragedPool);\n        }\n\n        // Short Burns\n        uint256 shortBurnAmount = PoolSwapLibrary.getWithdrawAmountOnBurn(\n            balancesAndSupplies.shortTotalSupplyBefore,\n            totalShortBurn,\n            balancesAndSupplies.shortBalance,\n            totalShortBurn\n        );\n\n        uint256 newLongBalance = balancesAndSupplies.longBalance +\n            _commits.longMintAmount -\n            longBurnAmount +\n            shortBurnInstantMintAmount;\n        uint256 newShortBalance = balancesAndSupplies.shortBalance +\n            _commits.shortMintAmount -\n            shortBurnAmount +\n            longBurnInstantMintAmount;\n\n        // Update the collateral on each side\n        pool.setNewPoolBalances(newLongBalance, newShortBalance);\n    }\n\n    /**\n     * @notice Executes all commitments currently queued for the associated `LeveragedPool`\n     * @dev Only callable by the associated `LeveragedPool` contract\n     */\n    function executeCommitments() external override onlyPool checkInvariantsBeforeFunction {\n        ILeveragedPool pool = ILeveragedPool(leveragedPool);\n\n        uint32 counter = 1;\n        uint256 lastPriceTimestamp = pool.lastPriceTimestamp();\n        uint256 updateInterval = pool.updateInterval();\n\n        /*\n         * (old)\n         * updateIntervalId\n         * |\n         * |    updateIntervalId\n         * |    |\n         * |    |    counter\n         * |    |    |\n         * |    |    |              (end)\n         * |    |    |              |\n         * V    V    V              V\n         * +----+----+----+~~~~+----+\n         * |    |    |    |....|    |\n         * +----+----+----+~~~~+----+\n         *\n         * Iterate over the sequence of possible update periods from the most\n         * recent (i.e., the value of `updateIntervalId` as at the entry point\n         * of this function) until the end of the queue.\n         *\n         * At each iteration, execute all of the (total) commitments for the\n         * pool for that period and then remove them from the queue.\n         *\n         * In reality, this should never iterate more than once, since more than one update interval\n         * should never be passed without the previous one being upkept.\n         */\n        while (true) {\n            if (block.timestamp >= lastPriceTimestamp + updateInterval * counter) {\n                // Another update interval has passed, so we have to do the nextIntervalCommit as well\n                burnFeeHistory[updateIntervalId] = burningFee;\n                executeGivenCommitments(totalPoolCommitments[updateIntervalId]);\n                delete totalPoolCommitments[updateIntervalId];\n                updateIntervalId += 1;\n            } else {\n                break;\n            }\n            counter += 1;\n        }\n    }\n\n    /**\n     * @notice Updates the aggregate balance based on the result of application\n     *          of the provided (user) commitment\n     * @param _commit Commitment to apply\n     * @return _newLongTokens Quantity of long pool tokens post-application\n     * @return _newShortTokens Quantity of short pool tokens post-application\n     * @return _longBurnFee Quantity of settlement tokens taken as a fee from long burns\n     * @return _shortBurnFee Quantity of settlement tokens taken as a fee from short burns\n     * @return _newSettlementTokens Quantity of settlement tokens post\n     *                                  application\n     * @dev Wraps two (pure) library functions from `PoolSwapLibrary`\n     */\n    function updateBalanceSingleCommitment(UserCommitment memory _commit)\n        internal\n        view\n        returns (\n            uint256 _newLongTokens,\n            uint256 _newShortTokens,\n            uint256 _longBurnFee,\n            uint256 _shortBurnFee,\n            uint256 _newSettlementTokens\n        )\n    {\n        PoolSwapLibrary.UpdateData memory updateData = PoolSwapLibrary.UpdateData({\n            longPrice: priceHistory[_commit.updateIntervalId].longPrice,\n            shortPrice: priceHistory[_commit.updateIntervalId].shortPrice,\n            currentUpdateIntervalId: updateIntervalId,\n            updateIntervalId: _commit.updateIntervalId,\n            longMintAmount: _commit.longMintAmount,\n            longBurnAmount: _commit.longBurnAmount,\n            shortMintAmount: _commit.shortMintAmount,\n            shortBurnAmount: _commit.shortBurnAmount,\n            longBurnShortMintAmount: _commit.longBurnShortMintAmount,\n            shortBurnLongMintAmount: _commit.shortBurnLongMintAmount,\n            burnFee: burnFeeHistory[_commit.updateIntervalId]\n        });\n\n        (_newLongTokens, _newShortTokens, _longBurnFee, _shortBurnFee, _newSettlementTokens) = PoolSwapLibrary\n            .getUpdatedAggregateBalance(updateData);\n    }\n\n    /**\n     * @notice Add the result of a user's most recent commit to their aggregated balance\n     * @param user Address of the given user\n     * @dev Updates the `userAggregateBalance` mapping by applying `BalanceUpdate`s derived from iteration over the entirety of unaggregated commitments associated with the given user\n     * @dev Emits an `AggregateBalanceUpdated` event upon successful termination\n     */\n    function updateAggregateBalance(address user) public override checkInvariantsAfterFunction {\n        Balance storage balance = userAggregateBalance[user];\n\n        BalanceUpdate memory update = BalanceUpdate({\n            _updateIntervalId: updateIntervalId,\n            _newLongTokensSum: 0,\n            _newShortTokensSum: 0,\n            _newSettlementTokensSum: 0,\n            _balanceLongBurnAmount: 0,\n            _balanceShortBurnAmount: 0,\n            _longBurnFee: 0,\n            _shortBurnFee: 0\n        });\n\n        // Iterate from the most recent up until the current update interval\n\n        uint256[] memory currentIntervalIds = unAggregatedCommitments[user];\n        uint256 unAggregatedLength = currentIntervalIds.length;\n        for (uint256 i = 0; i < unAggregatedLength; i++) {\n            uint256 id = currentIntervalIds[i];\n            if (currentIntervalIds[i] == 0) {\n                continue;\n            }\n            UserCommitment memory commitment = userCommitments[user][id];\n\n            /* If the update interval of commitment has not yet passed, we still\n            want to deduct burns from the balance from a user's balance.\n            Therefore, this should happen outside of the if block below.*/\n            update._balanceLongBurnAmount += commitment.balanceLongBurnAmount + commitment.balanceLongBurnMintAmount;\n            update._balanceShortBurnAmount += commitment.balanceShortBurnAmount + commitment.balanceShortBurnMintAmount;\n            if (commitment.updateIntervalId < updateIntervalId) {\n                (\n                    uint256 _newLongTokens,\n                    uint256 _newShortTokens,\n                    uint256 _longBurnFee,\n                    uint256 _shortBurnFee,\n                    uint256 _newSettlementTokens\n                ) = updateBalanceSingleCommitment(commitment);\n                update._newLongTokensSum += _newLongTokens;\n                update._newShortTokensSum += _newShortTokens;\n                update._newSettlementTokensSum += _newSettlementTokens;\n                update._longBurnFee += _longBurnFee;\n                update._shortBurnFee += _shortBurnFee;\n                delete userCommitments[user][i];\n                delete unAggregatedCommitments[user][i];\n            } else {\n                // Clear them now that they have been accounted for in the balance\n                userCommitments[user][id].balanceLongBurnAmount = 0;\n                userCommitments[user][id].balanceShortBurnAmount = 0;\n                userCommitments[user][id].balanceLongBurnMintAmount = 0;\n                userCommitments[user][id].balanceShortBurnMintAmount = 0;\n                // This commitment wasn't ready to be completely added to the balance, so copy it over into the new ID array\n                storageArrayPlaceHolder.push(currentIntervalIds[i]);\n            }\n        }\n\n        delete unAggregatedCommitments[user];\n        unAggregatedCommitments[user] = storageArrayPlaceHolder;\n\n        delete storageArrayPlaceHolder;\n\n        // Add new tokens minted, and remove the ones that were burnt from this balance\n        balance.longTokens += update._newLongTokensSum;\n        balance.longTokens -= update._balanceLongBurnAmount;\n        balance.shortTokens += update._newShortTokensSum;\n        balance.shortTokens -= update._balanceShortBurnAmount;\n        balance.settlementTokens += update._newSettlementTokensSum;\n\n        ILeveragedPool pool = ILeveragedPool(leveragedPool);\n        (uint256 shortBalance, uint256 longBalance) = pool.balances();\n        pool.setNewPoolBalances(longBalance + update._longBurnFee, shortBalance + update._shortBurnFee);\n\n        emit AggregateBalanceUpdated(user);\n    }\n\n    /**\n     * @return which update interval ID a commit would be placed into if made now\n     * @dev Calls PoolSwapLibrary::appropriateUpdateIntervalId\n     */\n    function getAppropriateUpdateIntervalId() external view override returns (uint128) {\n        ILeveragedPool pool = ILeveragedPool(leveragedPool);\n        return\n            uint128(\n                PoolSwapLibrary.appropriateUpdateIntervalId(\n                    block.timestamp,\n                    pool.lastPriceTimestamp(),\n                    pool.frontRunningInterval(),\n                    pool.updateInterval(),\n                    updateIntervalId\n                )\n            );\n    }\n\n    /**\n     * @notice A copy of `updateAggregateBalance` that returns the aggregated balance without updating it\n     * @param user Address of the given user\n     * @return Associated `Balance` for the given user after aggregation\n     */\n    function getAggregateBalance(address user) public view override returns (Balance memory) {\n        Balance memory _balance = userAggregateBalance[user];\n\n        BalanceUpdate memory update = BalanceUpdate({\n            _updateIntervalId: updateIntervalId,\n            _newLongTokensSum: 0,\n            _newShortTokensSum: 0,\n            _newSettlementTokensSum: 0,\n            _balanceLongBurnAmount: 0,\n            _balanceShortBurnAmount: 0,\n            _longBurnFee: 0,\n            _shortBurnFee: 0\n        });\n\n        // Iterate from the most recent up until the current update interval\n\n        uint256[] memory currentIntervalIds = unAggregatedCommitments[user];\n        uint256 unAggregatedLength = currentIntervalIds.length;\n        for (uint256 i = 0; i < unAggregatedLength; i++) {\n            uint256 id = currentIntervalIds[i];\n            if (currentIntervalIds[i] == 0) {\n                continue;\n            }\n            UserCommitment memory commitment = userCommitments[user][id];\n\n            /* If the update interval of commitment has not yet passed, we still\n            want to deduct burns from the balance from a user's balance.\n            Therefore, this should happen outside of the if block below.*/\n            update._balanceLongBurnAmount += commitment.balanceLongBurnAmount + commitment.balanceLongBurnMintAmount;\n            update._balanceShortBurnAmount += commitment.balanceShortBurnAmount + commitment.balanceShortBurnMintAmount;\n            if (commitment.updateIntervalId < updateIntervalId) {\n                (\n                    uint256 _newLongTokens,\n                    uint256 _newShortTokens,\n                    ,\n                    ,\n                    uint256 _newSettlementTokens\n                ) = updateBalanceSingleCommitment(commitment);\n                update._newLongTokensSum += _newLongTokens;\n                update._newShortTokensSum += _newShortTokens;\n                update._newSettlementTokensSum += _newSettlementTokens;\n            }\n        }\n\n        // Add new tokens minted, and remove the ones that were burnt from this balance\n        _balance.longTokens += update._newLongTokensSum;\n        _balance.longTokens -= update._balanceLongBurnAmount;\n        _balance.shortTokens += update._newShortTokensSum;\n        _balance.shortTokens -= update._balanceShortBurnAmount;\n        _balance.settlementTokens += update._newSettlementTokensSum;\n\n        return _balance;\n    }\n\n    /**\n     * @return The pending commitments from the two current update intervals, including the one started in the frontrunning interval at the end of the last\n     */\n    function getPendingCommits() external view override returns (TotalCommitment memory, TotalCommitment memory) {\n        return (totalPoolCommitments[updateIntervalId], totalPoolCommitments[updateIntervalId + 1]);\n    }\n\n    /**\n     * @notice Sets the quote token address and the address of the associated `LeveragedPool` contract to the provided values\n     * @param _quoteToken Address of the quote token to use\n     * @param _leveragedPool Address of the pool to use\n     * @dev Only callable by the associated `PoolFactory` contract\n     * @dev Throws if either address are null\n     */\n    function setQuoteAndPool(address _quoteToken, address _leveragedPool) external override onlyFactory onlyUnpaused {\n        require(_quoteToken != address(0), \"Quote token address cannot be 0 address\");\n        require(_leveragedPool != address(0), \"Leveraged pool address cannot be 0 address\");\n\n        leveragedPool = _leveragedPool;\n        IERC20 _token = IERC20(_quoteToken);\n        bool approvalSuccess = _token.approve(leveragedPool, _token.totalSupply());\n        require(approvalSuccess, \"ERC20 approval failed\");\n        tokens = ILeveragedPool(leveragedPool).poolTokens();\n    }\n\n    /**\n     * @notice Pauses the pool\n     * @dev Prevents all state updates until unpaused\n     */\n    function pause() external onlyInvariantCheckContract {\n        paused = true;\n    }\n\n    /**\n     * @notice Unpauses the pool\n     * @dev Prevents all state updates until unpaused\n     */\n    function unpause() external onlyGov {\n        paused = false;\n    }\n\n    /**\n     * @notice Aggregates user balances **prior** to executing the wrapped code\n     */\n    modifier updateBalance() {\n        updateAggregateBalance(msg.sender);\n        _;\n    }\n\n    modifier onlyUnpaused() {\n        require(!paused, \"Pool is paused\");\n        _;\n    }\n\n    modifier onlyGov() {\n        require(msg.sender == governance, \"msg.sender not governance\");\n        _;\n    }\n\n    /**\n     * @dev Check invariants before function body only. This is used in functions where the state of the pool is updated after exiting PoolCommitter (i.e. executeCommitments)\n     */\n    modifier checkInvariantsBeforeFunction() {\n        invariantCheck.checkInvariants(leveragedPool);\n        require(!paused, \"Pool is paused\");\n        _;\n    }\n\n    modifier checkInvariantsAfterFunction() {\n        require(!paused, \"Pool is paused\");\n        _;\n        invariantCheck.checkInvariants(leveragedPool);\n        require(!paused, \"Pool is paused\");\n    }\n\n    modifier onlyInvariantCheckContract() {\n        require(msg.sender == invariantCheckContract, \"msg.sender not invariantCheckContract\");\n        _;\n    }\n\n    /**\n     * @notice Asserts that the caller is the associated `PoolFactory` contract\n     */\n    modifier onlyFactory() {\n        require(msg.sender == factory, \"Committer: not factory\");\n        _;\n    }\n\n    /**\n     * @notice Asserts that the caller is the associated `LeveragedPool` contract\n     */\n    modifier onlyPool() {\n        require(msg.sender == leveragedPool, \"msg.sender not leveragedPool\");\n        _;\n    }\n\n    modifier onlyAutoClaimOrCommitter(address user) {\n        require(msg.sender == user || msg.sender == address(autoClaim), \"msg.sender not committer or AutoClaim\");\n        _;\n    }\n}\n"
        },
        "@openzeppelin/contracts/proxy/Clones.sol": {
            "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create(0, ptr, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), salt)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address implementation, bytes32 salt)\n        internal\n        view\n        returns (address predicted)\n    {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
        },
        "@openzeppelin/contracts/access/Ownable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
        },
        "@openzeppelin/contracts/utils/Strings.sol": {
            "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
        },
        "contracts/vendors/ERC20_Cloneable.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Minimal Clones compatible implementation of the {IERC20} interface.\n * @dev Based Openzeppelin 3.4 ERC20 contract\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20_Cloneable is Context, ERC20, Initializable {\n    uint8 _decimals;\n    string private _name;\n    string private _symbol;\n\n    address public owner;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_\n    ) ERC20(name_, symbol_) {\n        _decimals = decimals_;\n    }\n\n    function initialize(\n        address _pool,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_\n    ) external initializer {\n        owner = _pool;\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = decimals_;\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return _decimals;\n    }\n\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @notice Transfer ownership. Implemented to help with initializable\n     */\n    function transferOwnership(address _owner) external onlyOwner {\n        require(_owner != address(0), \"Owner: setting to 0 address\");\n        owner = _owner;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"msg.sender not owner\");\n        _;\n    }\n}\n"
        },
        "@openzeppelin/contracts/utils/Context.sol": {
            "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
        },
        "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
            "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
        },
        "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
            "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
        },
        "contracts/interfaces/IPoolKeeper.sol": {
            "content": "//SPDX-License-Identifier: CC-BY-NC-ND-4.0\npragma solidity 0.8.7;\n\n/// @title The manager contract interface for multiple markets and the pools in them\ninterface IPoolKeeper {\n    // #### Events\n    /**\n     * @notice Creates a notification when a pool is created\n     * @param poolAddress The pool address of the newly created pool\n     * @param firstPrice The price of the market oracle when the pool was created\n     */\n    event PoolAdded(address indexed poolAddress, int256 indexed firstPrice);\n\n    /**\n     * @notice Creates a notification when a call to LeveragedPool:poolUpkeep is successful\n     * @param pool The pool address being upkept\n     * @param data Extra data about the price fetch. This could be roundID in the case of Chainlink Oracles\n     * @param startPrice The previous price of the pool\n     * @param endPrice The new price of the pool\n     */\n    event UpkeepSuccessful(address indexed pool, bytes data, int256 indexed startPrice, int256 indexed endPrice);\n\n    /**\n     * @notice Creates a notification when a keeper is paid for doing upkeep for a pool\n     * @param _pool Address of pool being upkept\n     * @param keeper Keeper to be rewarded for upkeeping\n     * @param reward Keeper's reward (in settlement tokens)\n     */\n    event KeeperPaid(address indexed _pool, address indexed keeper, uint256 reward);\n\n    /**\n     * @notice Creates a notification when a keeper's payment for upkeeping a pool failed\n     * @param _pool Address of pool being upkept\n     * @param keeper Keeper to be rewarded for upkeeping\n     * @param expectedReward Keeper's expected reward (in settlement tokens); not actually transferred\n     */\n    event KeeperPaymentError(address indexed _pool, address indexed keeper, uint256 expectedReward);\n\n    /**\n     * @notice Creates a notification of a failed pool update\n     * @param pool The pool that failed to update\n     * @param reason The reason for the error\n     */\n    event PoolUpkeepError(address indexed pool, string reason);\n\n    // #### Functions\n    function newPool(address _poolAddress) external;\n\n    function setFactory(address _factory) external;\n\n    function checkUpkeepSinglePool(address pool) external view returns (bool);\n\n    function checkUpkeepMultiplePools(address[] calldata pools) external view returns (bool);\n\n    function performUpkeepSinglePool(address pool) external;\n\n    function performUpkeepMultiplePools(address[] calldata pools) external;\n}\n"
        },
        "contracts/implementation/PriceObserver.sol": {
            "content": "//SPDX-License-Identifier: CC-BY-NC-ND-4.0\npragma solidity 0.8.7;\n\nimport \"../interfaces/IPriceObserver.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/// Stores a finite sequence of price observations\ncontract PriceObserver is Ownable, IPriceObserver {\n    /// Maximum number of elements storable by the backing array\n    uint256 public constant MAX_NUM_ELEMS = 24;\n\n    /// Current number of elements stored by the backing array\n    uint256 public numElems = 0;\n\n    /// Backing array for storing price data\n    int256[MAX_NUM_ELEMS] public observations;\n\n    /// Writer -- only address allowed to add data to the backing array\n    address writer = address(0);\n\n    /**\n     * @notice Returns the capacity of the backing array (i.e., the maximum\n     *          number of price observations able to be stored by this contract)\n     * @return Maximum number of price observations that can be stored\n     * @dev `MAX_NUM_ELEMS`\n     */\n    function capacity() public pure override returns (uint256) {\n        return MAX_NUM_ELEMS;\n    }\n\n    /**\n     * @notice Returns the current number of price observations stored\n     * @return Current number of price observations stored\n     * @dev Should always be less than or equal to `capacity`\n     * @dev `numElems`\n     */\n    function length() public view override returns (uint256) {\n        return numElems;\n    }\n\n    /**\n     * @notice Retrieves the `i`th price observation\n     * @param i Period to retrieve the price observation of\n     * @return `i`th price observation\n     * @dev Throws if index is out of bounds (i.e., `i >= length()`)\n     */\n    function get(uint256 i) public view override returns (int256) {\n        require(i < length(), \"PO: Out of bounds\");\n        return observations[i];\n    }\n\n    /**\n     * @notice Retrieves all price observations\n     * @return Backing array of all price observations\n     * @dev Note that, due to this view simply returning a reference to the\n     *      backing array, it's possible for there to be null prices (i.e., 0)\n     */\n    function getAll() public view override returns (int256[24] memory) {\n        return observations;\n    }\n\n    /**\n     * @notice Adds a new price observation to the contract\n     * @param x Price\n     * @return Whether or not an existing price observation was rotated out\n     * @dev If the backing array is full (i.e., `length() == capacity()`, then\n     *      it is rotated such that the oldest price observation is deleted\n     * @dev Only callable by the associated writer for this contract\n     */\n    function add(int256 x) public override onlyWriter returns (bool) {\n        if (full()) {\n            leftRotateWithPad(x);\n            return true;\n        } else {\n            observations[length()] = x;\n            numElems += 1;\n            return false;\n        }\n    }\n\n    /**\n     * @notice Sets the associated writer address for this contract\n     * @param _writer Address of the new writer\n     * @dev Only callable by the owner of this contract\n     * @dev Throws if `_writer` is the null address\n     */\n    function setWriter(address _writer) public onlyOwner {\n        require(_writer != address(0), \"PO: Null address not allowed\");\n        writer = _writer;\n    }\n\n    /**\n     * @notice Returns the current writer of this contract\n     * @return Address of the writer for this contract\n     * @dev `writer`\n     */\n    function getWriter() public view returns (address) {\n        return writer;\n    }\n\n    /**\n     * @notice Determines whether or not the backing array is full\n     * @return Flag indicating whether the backing array is full or not\n     * @dev `length() == capacity()`\n     */\n    function full() private view returns (bool) {\n        return length() == capacity();\n    }\n\n    /**\n     * @notice Resets the backing array and clears all of its stored prices\n     * @dev Only callable by the owner of this contract\n     */\n    function clear() public onlyOwner {\n        numElems = 0;\n        delete observations;\n    }\n\n    /**\n     * @notice Rotates observations array to the **left** by one element and\n     *          sets the last element of `xs` to `x`\n     * @param x Element to \"rotate into\" observations array\n     */\n    function leftRotateWithPad(int256 x) private {\n        uint256 n = length();\n\n        /* linear scan over the [1, n] subsequence */\n        for (uint256 i = 1; i < n; i++) {\n            observations[i - 1] = observations[i];\n        }\n\n        /* rotate `x` into `observations` from the right (remember, we're\n         * **left** rotating -- with padding!) */\n        observations[n - 1] = x;\n    }\n\n    /**\n     * @notice Enforces that the caller is the associated writer of this\n     *          contract\n     */\n    modifier onlyWriter() {\n        require(msg.sender == writer, \"PO: Permission denied\");\n        _;\n    }\n}\n"
        },
        "contracts/interfaces/IPriceObserver.sol": {
            "content": "//SPDX-License-Identifier: CC-BY-NC-ND-4.0\npragma solidity 0.8.7;\n\n/// @title The price observer interface\ninterface IPriceObserver {\n    function capacity() external view returns (uint256);\n\n    function length() external view returns (uint256);\n\n    function get(uint256 i) external view returns (int256);\n\n    function getAll() external view returns (int256[24] memory);\n\n    function add(int256 x) external returns (bool);\n}\n"
        },
        "contracts/implementation/PoolFactory.sol": {
            "content": "//SPDX-License-Identifier: CC-BY-NC-ND-4.0\npragma solidity 0.8.7;\n\nimport \"../interfaces/IPoolFactory.sol\";\nimport \"../interfaces/ILeveragedPool.sol\";\nimport \"../interfaces/IPoolCommitter.sol\";\nimport \"../interfaces/IERC20DecimalsWrapper.sol\";\nimport \"../interfaces/IAutoClaim.sol\";\nimport \"./LeveragedPool.sol\";\nimport \"./PoolToken.sol\";\nimport \"./PoolKeeper.sol\";\nimport \"./PoolCommitter.sol\";\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\n/// @title The pool factory contract\ncontract PoolFactory is IPoolFactory, Ownable {\n    // #### Globals\n    PoolToken public pairTokenBase;\n    address public immutable pairTokenBaseAddress;\n    LeveragedPool public poolBase;\n    address public immutable poolBaseAddress;\n    IPoolKeeper public poolKeeper;\n    PoolCommitter public poolCommitterBase;\n    address public immutable poolCommitterBaseAddress;\n\n    address public autoClaim;\n\n    // Contract address to receive protocol fees\n    address public feeReceiver;\n    // Default fee, annualised; Fee value as a decimal multiplied by 10^18. For example, 50% is represented as 0.5 * 10^18\n    uint256 public fee;\n    // Percent of fees that go to secondary fee address if applicable.\n    uint256 public secondaryFeeSplitPercent = 10;\n    // The fee taken for each mint and burn. Fee value as a decimal multiplied by 10^18. For example, 50% is represented as 0.5 * 10^18\n    uint256 public mintingFee;\n    uint256 public burningFee;\n\n    // This is required because we must pass along *some* value for decimal\n    // precision to the base pool tokens as we use the Cloneable pattern\n    uint8 constant DEFAULT_NUM_DECIMALS = 18;\n    uint8 constant MAX_DECIMALS = DEFAULT_NUM_DECIMALS;\n    // Default max leverage of 10\n    uint16 public maxLeverage = 10;\n\n    /**\n     * @notice Format: Pool counter => pool address\n     */\n    mapping(uint256 => address) public override pools;\n    uint256 public override numPools;\n\n    /**\n     * @notice Format: Pool address => validity\n     */\n    mapping(address => bool) public override isValidPool;\n\n    /**\n     * @notice Format: PoolCommitter address => validity\n     */\n    mapping(address => bool) public override isValidPoolCommitter;\n\n    // #### Functions\n    constructor(address _feeReceiver) {\n        require(_feeReceiver != address(0), \"Address cannot be null\");\n\n        // Deploy base contracts\n        pairTokenBase = new PoolToken(DEFAULT_NUM_DECIMALS);\n        pairTokenBaseAddress = address(pairTokenBase);\n        poolBase = new LeveragedPool();\n        poolBaseAddress = address(poolBase);\n        poolCommitterBase = new PoolCommitter(address(this), address(this), address(this), 0, 0);\n        poolCommitterBaseAddress = address(poolCommitterBase);\n\n        ILeveragedPool.Initialization memory baseInitialization = ILeveragedPool.Initialization(\n            address(this),\n            address(this),\n            address(this),\n            address(this),\n            address(this),\n            address(this),\n            address(this),\n            address(this),\n            \"BASE_POOL\",\n            15,\n            30,\n            0,\n            1,\n            address(this),\n            address(0),\n            address(this),\n            secondaryFeeSplitPercent\n        );\n        // Init bases\n        poolBase.initialize(baseInitialization);\n        pairTokenBase.initialize(address(this), \"BASE_TOKEN\", \"BASE\", DEFAULT_NUM_DECIMALS);\n        feeReceiver = _feeReceiver;\n    }\n\n    /**\n     * @notice Deploy a leveraged pool and its committer/pool tokens with given parameters\n     * @param deploymentParameters Deployment parameters of the market. Some may be reconfigurable.\n     * @return Address of the created pool\n     * @dev Throws if pool keeper is null\n     * @dev Throws if deployer does not own the oracle wrapper\n     * @dev Throws if leverage amount is invalid\n     * @dev Throws if decimal precision is too high (i.e., greater than `MAX_DECIMALS`)\n     */\n    function deployPool(PoolDeployment calldata deploymentParameters) external override returns (address) {\n        address _poolKeeper = address(poolKeeper);\n        require(_poolKeeper != address(0), \"PoolKeeper not set\");\n        require(\n            IOracleWrapper(deploymentParameters.oracleWrapper).deployer() == msg.sender,\n            \"Deployer must be oracle wrapper owner\"\n        );\n\n        bytes32 uniquePoolHash = keccak256(\n            abi.encode(\n                deploymentParameters.leverageAmount,\n                deploymentParameters.quoteToken,\n                deploymentParameters.oracleWrapper\n            )\n        );\n\n        PoolCommitter poolCommitter = PoolCommitter(\n            Clones.cloneDeterministic(poolCommitterBaseAddress, uniquePoolHash)\n        );\n        poolCommitter.initialize(\n            address(this),\n            deploymentParameters.invariantCheckContract,\n            autoClaim,\n            mintingFee,\n            burningFee\n        );\n        address poolCommitterAddress = address(poolCommitter);\n\n        require(\n            deploymentParameters.leverageAmount >= 1 && deploymentParameters.leverageAmount <= maxLeverage,\n            \"PoolKeeper: leveraged amount invalid\"\n        );\n        require(\n            IERC20DecimalsWrapper(deploymentParameters.quoteToken).decimals() <= MAX_DECIMALS,\n            \"Decimal precision too high\"\n        );\n\n        LeveragedPool pool = LeveragedPool(Clones.cloneDeterministic(poolBaseAddress, uniquePoolHash));\n        address _pool = address(pool);\n        emit DeployPool(_pool, poolCommitterAddress, deploymentParameters.poolName);\n\n        string memory leverage = Strings.toString(deploymentParameters.leverageAmount);\n\n        ILeveragedPool.Initialization memory initialization = ILeveragedPool.Initialization({\n            _owner: owner(), // governance is the owner of pools -- if this changes, `onlyGov` breaks\n            _keeper: _poolKeeper,\n            _oracleWrapper: deploymentParameters.oracleWrapper,\n            _settlementEthOracle: deploymentParameters.settlementEthOracle,\n            _longToken: deployPairToken(_pool, leverage, deploymentParameters, \"L-\"),\n            _shortToken: deployPairToken(_pool, leverage, deploymentParameters, \"S-\"),\n            _poolCommitter: poolCommitterAddress,\n            _invariantCheckContract: deploymentParameters.invariantCheckContract,\n            _poolName: string(abi.encodePacked(leverage, \"-\", deploymentParameters.poolName)),\n            _frontRunningInterval: deploymentParameters.frontRunningInterval,\n            _updateInterval: deploymentParameters.updateInterval,\n            _fee: (fee * deploymentParameters.updateInterval) / (365 days),\n            _leverageAmount: deploymentParameters.leverageAmount,\n            _feeAddress: feeReceiver,\n            _secondaryFeeAddress: msg.sender,\n            _quoteToken: deploymentParameters.quoteToken,\n            _secondaryFeeSplitPercent: secondaryFeeSplitPercent\n        });\n\n        // approve the quote token on the pool committer to finalise linking\n        // this also stores the pool address in the committer\n        // finalise pool setup\n        pool.initialize(initialization);\n        // approve the quote token on the pool commiter to finalise linking\n        // this also stores the pool address in the commiter\n        IPoolCommitter(poolCommitterAddress).setQuoteAndPool(deploymentParameters.quoteToken, _pool);\n        poolKeeper.newPool(_pool);\n        pools[numPools] = _pool;\n        numPools += 1;\n        isValidPool[_pool] = true;\n        isValidPoolCommitter[poolCommitterAddress] = true;\n        return _pool;\n    }\n\n    /**\n     * @notice Deploy a contract for pool tokens\n     * @param leverage Amount of leverage for pool\n     * @param deploymentParameters Deployment parameters for parent function\n     * @param direction Long or short token, L- or S-\n     * @return Address of the pool token\n     */\n    function deployPairToken(\n        address owner,\n        string memory leverage,\n        PoolDeployment memory deploymentParameters,\n        string memory direction\n    ) internal returns (address) {\n        string memory poolNameAndSymbol = string(abi.encodePacked(leverage, direction, deploymentParameters.poolName));\n        uint8 settlementDecimals = IERC20DecimalsWrapper(deploymentParameters.quoteToken).decimals();\n        bytes32 uniqueTokenHash = keccak256(\n            abi.encode(\n                deploymentParameters.leverageAmount,\n                deploymentParameters.quoteToken,\n                deploymentParameters.oracleWrapper,\n                direction\n            )\n        );\n\n        PoolToken pairToken = PoolToken(Clones.cloneDeterministic(pairTokenBaseAddress, uniqueTokenHash));\n        pairToken.initialize(owner, poolNameAndSymbol, poolNameAndSymbol, settlementDecimals);\n        return address(pairToken);\n    }\n\n    /**\n     * @notice Sets the address of the associated `PoolKeeper` contract\n     * @param _poolKeeper Address of the `PoolKeeper`\n     * @dev Throws if provided address is null\n     * @dev Only callable by the owner\n     */\n    function setPoolKeeper(address _poolKeeper) external override onlyOwner {\n        require(_poolKeeper != address(0), \"address cannot be null\");\n        poolKeeper = IPoolKeeper(_poolKeeper);\n    }\n\n    /**\n     * @notice Sets the address of the associated `AutoClaim` contract\n     * @param _autoClaim Address of the `AutoClaim`\n     * @dev Throws if provided address is null\n     * @dev Only callable by the owner\n     */\n    function setAutoClaim(address _autoClaim) external override onlyOwner {\n        require(_autoClaim != address(0), \"address cannot be null\");\n        autoClaim = _autoClaim;\n    }\n\n    /**\n     * @notice Sets the maximum leverage\n     * @param newMaxLeverage Maximum leverage permitted for all pools\n     * @dev Throws if provided maximum leverage is non-positive\n     * @dev Only callable by the owner\n     */\n    function setMaxLeverage(uint16 newMaxLeverage) external override onlyOwner {\n        require(newMaxLeverage > 0, \"Maximum leverage must be non-zero\");\n        maxLeverage = newMaxLeverage;\n    }\n\n    /**\n     * @notice Sets the primary fee receiver of deployed Leveraged pools.\n     * @param _feeReceiver address of fee receiver\n     * @dev Only callable by the owner of this contract\n     * @dev This fuction does not change anything for already deployed pools, only pools deployed after the change\n     */\n    function setFeeReceiver(address _feeReceiver) external override onlyOwner {\n        require(_feeReceiver != address(0), \"address cannot be null\");\n        feeReceiver = _feeReceiver;\n    }\n\n    /**\n     * @notice Sets the proportion of fees to be split to the nominated secondary fees recipient\n     * @param newFeePercent Proportion of fees to split\n     * @dev Only callable by the owner of this contract\n     * @dev Throws if `newFeePercent` exceeds 100\n     */\n    function setSecondaryFeeSplitPercent(uint256 newFeePercent) external override onlyOwner {\n        require(newFeePercent <= 100, \"Secondary fee split cannot exceed 100%\");\n        secondaryFeeSplitPercent = newFeePercent;\n    }\n\n    /**\n     * @notice Set the yearly fee amount. The max yearly fee is 10%\n     * @dev This is a percentage in WAD; multiplied by 10^18 e.g. 5% is 0.05 * 10^18\n     * @param _fee The fee amount as a percentage\n     * @dev Throws if fee is greater than 10%\n     */\n    function setFee(uint256 _fee) external override onlyOwner {\n        require(_fee <= 0.1e18, \"Fee cannot be > 10%\");\n        fee = _fee;\n    }\n\n    /**\n     * @notice Set the minting and burning fee amount. The max yearly fee is 10%\n     * @dev This is a percentage in WAD; multiplied by 10^18 e.g. 5% is 0.05 * 10^18\n     * @param _mintingFee The fee amount for mints\n     * @param _burningFee The fee amount for burns\n     * @dev Only callable by the owner of this contract\n     * @dev Throws if minting fee is greater than 10%\n     * @dev Throws if burning fee is greater than 10%\n     */\n    function setMintAndBurnFee(uint256 _mintingFee, uint256 _burningFee) external override onlyOwner {\n        require(_mintingFee <= 0.1e18, \"Fee cannot be > 10%\");\n        require(_burningFee <= 0.1e18, \"Fee cannot be > 10%\");\n        mintingFee = _mintingFee;\n        burningFee = _burningFee;\n    }\n\n    /*\n     * @notice Returns the address that owns this contract\n     * @return Address of the owner\n     * @dev Required due to the `IPoolFactory` interface\n     */\n    function getOwner() external view override returns (address) {\n        return owner();\n    }\n\n    /**\n     * @notice Ensures that the caller is the designated governance address\n     */\n    modifier onlyGov() {\n        require(msg.sender == owner(), \"msg.sender not governance\");\n        _;\n    }\n}\n"
        },
        "contracts/implementation/LeveragedPool.sol": {
            "content": "//SPDX-License-Identifier: CC-BY-NC-ND-4.0\npragma solidity 0.8.7;\n\nimport \"../interfaces/ILeveragedPool.sol\";\nimport \"../interfaces/IPoolCommitter.sol\";\nimport \"../interfaces/IPoolToken.sol\";\nimport \"../interfaces/IPausable.sol\";\nimport \"../interfaces/IInvariantCheck.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./PoolSwapLibrary.sol\";\nimport \"../interfaces/IOracleWrapper.sol\";\n\n/// @title The pool contract itself\ncontract LeveragedPool is ILeveragedPool, Initializable, IPausable {\n    using SafeERC20 for IERC20;\n    // #### Globals\n\n    // Each balance is the amount of quote tokens in the pair\n    uint256 public override shortBalance;\n    uint256 public override longBalance;\n    uint32 public override frontRunningInterval;\n    uint32 public override updateInterval;\n    bytes16 public fee;\n    bytes16 public override leverageAmount;\n    uint256 public constant LONG_INDEX = 0;\n    uint256 public constant SHORT_INDEX = 1;\n\n    address public governance;\n    bool public override paused;\n    address public keeper;\n    bool public governanceTransferInProgress;\n    address public feeAddress;\n    address public secondaryFeeAddress;\n    uint256 public secondaryFeeSplitPercent; // Split to secondary fee address as a percentage.\n    address public override quoteToken;\n    address public override poolCommitter;\n    address public override oracleWrapper;\n    address public override settlementEthOracle;\n    address public provisionalGovernance;\n    address public invariantCheckContract;\n    IInvariantCheck public invariantCheck;\n    address[2] public tokens;\n    uint256 public override lastPriceTimestamp; // The last time the pool was upkept\n\n    string public override poolName;\n\n    // #### Functions\n\n    function initialize(ILeveragedPool.Initialization calldata initialization) external override initializer {\n        require(initialization._feeAddress != address(0), \"Fee address cannot be 0 address\");\n        require(initialization._quoteToken != address(0), \"Quote token cannot be 0 address\");\n        require(initialization._oracleWrapper != address(0), \"Oracle wrapper cannot be 0 address\");\n        require(initialization._settlementEthOracle != address(0), \"Keeper oracle cannot be 0 address\");\n        require(initialization._owner != address(0), \"Owner cannot be 0 address\");\n        require(initialization._keeper != address(0), \"Keeper cannot be 0 address\");\n        require(initialization._longToken != address(0), \"Long token cannot be 0 address\");\n        require(initialization._shortToken != address(0), \"Short token cannot be 0 address\");\n        require(initialization._poolCommitter != address(0), \"PoolCommitter cannot be 0 address\");\n        require(initialization._invariantCheckContract != address(0), \"InvariantCheck cannot be 0 address\");\n        require(initialization._fee < PoolSwapLibrary.WAD_PRECISION, \"Fee >= 100%\");\n        require(initialization._secondaryFeeSplitPercent <= 100, \"Secondary fee split cannot exceed 100%\");\n\n        // set the owner of the pool. This is governance when deployed from the factory\n        governance = initialization._owner;\n\n        // Setup variables\n        keeper = initialization._keeper;\n        oracleWrapper = initialization._oracleWrapper;\n        settlementEthOracle = initialization._settlementEthOracle;\n        quoteToken = initialization._quoteToken;\n        frontRunningInterval = initialization._frontRunningInterval;\n        updateInterval = initialization._updateInterval;\n        fee = PoolSwapLibrary.convertUIntToDecimal(initialization._fee);\n        leverageAmount = PoolSwapLibrary.convertUIntToDecimal(initialization._leverageAmount);\n        feeAddress = initialization._feeAddress;\n        secondaryFeeAddress = initialization._secondaryFeeAddress;\n        secondaryFeeSplitPercent = initialization._secondaryFeeSplitPercent;\n        lastPriceTimestamp = block.timestamp;\n        poolName = initialization._poolName;\n        tokens[LONG_INDEX] = initialization._longToken;\n        tokens[SHORT_INDEX] = initialization._shortToken;\n        poolCommitter = initialization._poolCommitter;\n        invariantCheckContract = initialization._invariantCheckContract;\n        invariantCheck = IInvariantCheck(initialization._invariantCheckContract);\n        emit PoolInitialized(\n            initialization._longToken,\n            initialization._shortToken,\n            initialization._quoteToken,\n            initialization._poolName\n        );\n    }\n\n    /**\n     * @notice Execute a price change\n     * @param _oldPrice Previous price of the underlying asset\n     * @param _newPrice New price of the underlying asset\n     * @dev Throws if at least one update interval has not elapsed since last price update\n     * @dev This is the entry point to upkeep a market\n     * @dev Only callable by the associated `PoolKeeper` contract\n     * @dev Only callable if the market is *not* paused\n     */\n    function poolUpkeep(int256 _oldPrice, int256 _newPrice) external override onlyKeeper checkInvariantsAfterFunction {\n        require(intervalPassed(), \"Update interval hasn't passed\");\n        // perform price change and update pool balances\n        executePriceChange(_oldPrice, _newPrice);\n        IPoolCommitter(poolCommitter).executeCommitments();\n        lastPriceTimestamp = block.timestamp;\n    }\n\n    /**\n     * @notice Pay keeper some amount in the collateral token for the perpetual pools market\n     * @param to Address of the pool keeper to pay\n     * @param amount Amount to pay the pool keeper\n     * @return Whether the keeper is going to be paid; false if the amount exceeds the balances of the\n     *         long and short pool, and true if the keeper can successfully be paid out\n     * @dev Only callable by the associated `PoolKeeper` contract\n     * @dev Only callable when the market is *not* paused\n     */\n    function payKeeperFromBalances(address to, uint256 amount)\n        external\n        override\n        onlyKeeper\n        checkInvariantsAfterFunction\n        returns (bool)\n    {\n        uint256 _shortBalance = shortBalance;\n        uint256 _longBalance = longBalance;\n\n        // If the rewards are more than the balances of the pool, the keeper does not get paid\n        if (amount >= _shortBalance + _longBalance) {\n            return false;\n        }\n\n        (uint256 shortBalanceAfterRewards, uint256 longBalanceAfterRewards) = PoolSwapLibrary.getBalancesAfterFees(\n            amount,\n            _shortBalance,\n            _longBalance\n        );\n\n        shortBalance = shortBalanceAfterRewards;\n        longBalance = longBalanceAfterRewards;\n\n        // Pay keeper\n        IERC20(quoteToken).safeTransfer(to, amount);\n\n        return true;\n    }\n\n    /**\n     * @notice Transfer settlement tokens from pool to user\n     * @param to Address of account to transfer to\n     * @param amount Amount of quote tokens being transferred\n     * @dev Only callable by the associated `PoolCommitter` contract\n     * @dev Only callable when the market is *not* paused\n     */\n    function quoteTokenTransfer(address to, uint256 amount)\n        external\n        override\n        onlyPoolCommitter\n        checkInvariantsBeforeFunction\n    {\n        IERC20(quoteToken).safeTransfer(to, amount);\n    }\n\n    /**\n     * @notice Transfer long tokens from pool to user\n     * @param to Address of account to transfer to\n     * @param isLongToken True if transferring long pool token\n     * @param amount Amount of quote tokens being transferred\n     * @dev Only callable by the associated `PoolCommitter` contract\n     * @dev Only callable when the market is *not* paused\n     */\n    function poolTokenTransfer(\n        bool isLongToken,\n        address to,\n        uint256 amount\n    ) external override onlyPoolCommitter checkInvariantsBeforeFunction {\n        if (isLongToken) {\n            IERC20(tokens[LONG_INDEX]).safeTransfer(to, amount);\n        } else {\n            IERC20(tokens[SHORT_INDEX]).safeTransfer(to, amount);\n        }\n    }\n\n    /**\n     * @notice Transfer tokens from user to account\n     * @param from The account that's transferring quote tokens\n     * @param to Address of account to transfer to\n     * @param amount Amount of quote tokens being transferred\n     * @dev Only callable by the associated `PoolCommitter` contract\n     * @dev Only callable when the market is *not* paused\n     */\n    function quoteTokenTransferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external override onlyPoolCommitter checkInvariantsBeforeFunction {\n        IERC20(quoteToken).safeTransferFrom(from, to, amount);\n    }\n\n    /**\n     * @notice Execute the price change once the interval period ticks over, updating the long & short\n     *         balances based on the change of the feed (upwards or downwards) and paying fees\n     * @param _oldPrice Old price from the oracle\n     * @param _newPrice New price from the oracle\n     * @dev Can only be called by poolUpkeep\n     * @dev Only callable when the market is *not* paused\n     * @dev Emits `PoolRebalance` if execution succeeds\n     * @dev Emits `PriceChangeError` if execution does not take place\n     */\n    function executePriceChange(int256 _oldPrice, int256 _newPrice) internal checkInvariantsBeforeFunction {\n        // prevent a division by 0 in computing the price change\n        // prevent negative pricing\n        if (_oldPrice <= 0 || _newPrice <= 0) {\n            emit PriceChangeError(_oldPrice, _newPrice);\n        } else {\n            uint256 _shortBalance = shortBalance;\n            uint256 _longBalance = longBalance;\n            PoolSwapLibrary.PriceChangeData memory priceChangeData = PoolSwapLibrary.PriceChangeData(\n                _oldPrice,\n                _newPrice,\n                _longBalance,\n                _shortBalance,\n                leverageAmount,\n                fee\n            );\n            (uint256 newLongBalance, uint256 newShortBalance, uint256 totalFeeAmount) = PoolSwapLibrary\n                .calculatePriceChange(priceChangeData);\n\n            unchecked {\n                emit PoolRebalance(\n                    int256(newShortBalance) - int256(_shortBalance),\n                    int256(newLongBalance) - int256(_longBalance)\n                );\n            }\n            // Update pool balances\n            longBalance = newLongBalance;\n            shortBalance = newShortBalance;\n            // Pay the fee\n            feeTransfer(totalFeeAmount);\n        }\n    }\n\n    /**\n     * @notice Execute the fee transfer transactions. Transfers fees to primary fee address (DAO) and secondary (pool deployer).\n     *         If the DAO is the fee deployer, secondary fee address should be address(0) and all fees go to DAO.\n     * @param totalFeeAmount total amount of fees paid\n     */\n    function feeTransfer(uint256 totalFeeAmount) internal {\n        if (secondaryFeeAddress == address(0)) {\n            IERC20(quoteToken).safeTransfer(feeAddress, totalFeeAmount);\n        } else {\n            require(secondaryFeeSplitPercent <= 100, \"Secondary fee split cannot exceed 100%\");\n            uint256 secondaryFee = PoolSwapLibrary.mulFraction(totalFeeAmount, secondaryFeeSplitPercent, 100);\n            uint256 remainder = totalFeeAmount - secondaryFee;\n            IERC20(quoteToken).safeTransfer(secondaryFeeAddress, secondaryFee);\n            IERC20(quoteToken).safeTransfer(feeAddress, remainder);\n        }\n    }\n\n    /**\n     * @notice Sets the long and short balances of the pools\n     * @param _longBalance New balance of the long pool\n     * @param _shortBalance New balance of the short pool\n     * @dev Only callable by the associated `PoolCommitter` contract\n     * @dev Only callable when the market is *not* paused\n     */\n    function setNewPoolBalances(uint256 _longBalance, uint256 _shortBalance)\n        external\n        override\n        onlyPoolCommitter\n        checkInvariantsBeforeFunction\n    {\n        longBalance = _longBalance;\n        shortBalance = _shortBalance;\n    }\n\n    /**\n     * @notice Mint tokens to a user\n     * @param isLongToken True if minting short token\n     * @param amount Amount of tokens to mint\n     * @param minter Address of user/minter\n     * @dev Only callable by the associated `PoolCommitter` contract\n     * @dev Only callable when the market is *not* paused\n     */\n    function mintTokens(\n        bool isLongToken,\n        uint256 amount,\n        address minter\n    ) external override onlyPoolCommitter checkInvariantsBeforeFunction {\n        if (isLongToken) {\n            require(IPoolToken(tokens[LONG_INDEX]).mint(amount, minter), \"Mint failed\");\n        } else {\n            require(IPoolToken(tokens[SHORT_INDEX]).mint(amount, minter), \"Mint failed\");\n        }\n    }\n\n    /**\n     * @notice Burn tokens by a user\n     * @dev Can only be called by & used by the pool committer\n     * @param isLongToken True if burning short token\n     * @param amount Amount of tokens to burn\n     * @param burner Address of user/burner\n     * @dev Only callable by the associated `PoolCommitter` contract\n     * @dev Only callable when the market is *not* paused\n     */\n    function burnTokens(\n        bool isLongToken,\n        uint256 amount,\n        address burner\n    ) external override onlyPoolCommitter checkInvariantsAfterFunction {\n        if (isLongToken) {\n            require(IPoolToken(tokens[LONG_INDEX]).burn(amount, burner), \"Burn failed\");\n        } else {\n            require(IPoolToken(tokens[SHORT_INDEX]).burn(amount, burner), \"Burn failed\");\n        }\n    }\n\n    /**\n     * @notice Indicates whether the price was last updated more than `updateInterval` seconds ago\n     * @return Whether the price was last updated more than `updateInterval` seconds ago\n     * @dev Unchecked\n     */\n    function intervalPassed() public view override returns (bool) {\n        unchecked {\n            return block.timestamp >= lastPriceTimestamp + updateInterval;\n        }\n    }\n\n    /**\n     * @notice Updates the fee address of the pool\n     * @param account New address of the fee address/receiver\n     * @dev Only callable by governance\n     * @dev Only callable when the market is *not* paused\n     * @dev Emits `FeeAddressUpdated` event on success\n     */\n    function updateFeeAddress(address account) external override onlyGov checkInvariantsAfterFunction {\n        require(account != address(0), \"Account cannot be 0 address\");\n        address oldFeeAddress = feeAddress;\n        feeAddress = account;\n        emit FeeAddressUpdated(oldFeeAddress, feeAddress);\n    }\n\n    /**\n     * @notice Updates the secondary fee address of the pool\n     * @param account New address of the fee address/receiver\n     */\n    function updateSecondaryFeeAddress(address account) external override {\n        address _oldSecondaryFeeAddress = secondaryFeeAddress;\n        require(msg.sender == _oldSecondaryFeeAddress);\n        secondaryFeeAddress = account;\n        emit SecondaryFeeAddressUpdated(_oldSecondaryFeeAddress, account);\n    }\n\n    /**\n     * @notice Updates the keeper contract of the pool\n     * @param _keeper New address of the keeper contract\n     */\n    function setKeeper(address _keeper) external override onlyGov checkInvariantsAfterFunction {\n        require(_keeper != address(0), \"Keeper address cannot be 0 address\");\n        address oldKeeper = keeper;\n        keeper = _keeper;\n        emit KeeperAddressChanged(oldKeeper, keeper);\n    }\n\n    /**\n     * @notice Starts to transfer governance of the pool. The new governance\n     *          address must call `claimGovernance` in order for this to take\n     *          effect. Until this occurs, the existing governance address\n     *          remains in control of the pool.\n     * @param _governance New address of the governance of the pool\n     * @dev First step of the two-step governance transfer process\n     * @dev Sets the governance transfer flag to true\n     * @dev See `claimGovernance`\n     */\n    function transferGovernance(address _governance) external override onlyGov checkInvariantsAfterFunction {\n        require(_governance != address(0), \"Governance address cannot be 0 address\");\n        provisionalGovernance = _governance;\n        governanceTransferInProgress = true;\n        emit ProvisionalGovernanceChanged(_governance);\n    }\n\n    /**\n     * @notice Completes transfer of governance by actually changing permissions\n     *          over the pool.\n     * @dev Second and final step of the two-step governance transfer process\n     * @dev See `transferGovernance`\n     * @dev Sets the governance transfer flag to false\n     * @dev After a successful call to this function, the actual governance\n     *      address and the provisional governance address MUST be equal.\n     */\n    function claimGovernance() external override checkInvariantsAfterFunction {\n        require(governanceTransferInProgress, \"No governance change active\");\n        require(msg.sender == provisionalGovernance, \"Not provisional governor\");\n        address oldGovernance = governance; /* for later event emission */\n        governance = provisionalGovernance;\n        governanceTransferInProgress = false;\n        emit GovernanceAddressChanged(oldGovernance, governance);\n    }\n\n    /**\n     * @return _latestPrice The oracle price\n     * @return _data The oracleWrapper's metadata. Implementations can choose what data to return here\n     * @return _lastPriceTimestamp The timestamp of the last upkeep\n     * @return _updateInterval The update frequency for this pool\n     * @dev To save gas so PoolKeeper does not have to make three external calls\n     */\n    function getUpkeepInformation()\n        external\n        view\n        override\n        returns (\n            int256,\n            bytes memory,\n            uint256,\n            uint256\n        )\n    {\n        (int256 _latestPrice, bytes memory _data) = IOracleWrapper(oracleWrapper).getPriceAndMetadata();\n        return (_latestPrice, _data, lastPriceTimestamp, updateInterval);\n    }\n\n    /**\n     * @return The price of the pool's feed oracle\n     */\n    function getOraclePrice() external view override returns (int256) {\n        return IOracleWrapper(oracleWrapper).getPrice();\n    }\n\n    /**\n     * @return Addresses of the pool tokens for this pool (long and short,\n     *          respectively)\n     */\n    function poolTokens() external view override returns (address[2] memory) {\n        return tokens;\n    }\n\n    /**\n     * @return Quantities of pool tokens for this pool (long and short,\n     *          respectively)\n     */\n    function balances() external view override returns (uint256, uint256) {\n        return (shortBalance, longBalance);\n    }\n\n    /**\n     * @notice Withdraws all available quote asset from the pool\n     * @dev Pool must not be paused\n     * @dev ERC20 transfer\n     * @dev Only callable by governance\n     */\n    function withdrawQuote() external onlyGov {\n        require(paused, \"Pool is live\");\n        IERC20 quoteERC = IERC20(quoteToken);\n        uint256 balance = quoteERC.balanceOf(address(this));\n        IERC20(quoteToken).safeTransfer(msg.sender, balance);\n    }\n\n    /**\n     * @notice Pauses the pool\n     * @dev Prevents all state updates until unpaused\n     */\n    function pause() external override onlyInvariantCheckContract {\n        paused = true;\n        emit Paused();\n    }\n\n    /**\n     * @notice Unpauses the pool\n     * @dev Prevents all state updates until unpaused\n     */\n    function unpause() external override onlyGov {\n        paused = false;\n        emit Unpaused();\n    }\n\n    /**\n     * @dev Check invariants before function body only. This is used in functions where the state of the pool is updated after exiting PoolCommitter (i.e. executeCommitments)\n     */\n    modifier checkInvariantsBeforeFunction() {\n        invariantCheck.checkInvariants(address(this));\n        require(!paused, \"Pool is paused\");\n        _;\n    }\n\n    // #### Modifiers\n    modifier checkInvariantsAfterFunction() {\n        require(!paused, \"Pool is paused\");\n        _;\n        invariantCheck.checkInvariants(address(this));\n        require(!paused, \"Pool is paused\");\n    }\n\n    modifier onlyKeeper() {\n        require(msg.sender == keeper, \"msg.sender not keeper\");\n        _;\n    }\n\n    modifier onlyInvariantCheckContract() {\n        require(msg.sender == invariantCheckContract, \"msg.sender not invariantCheckContract\");\n        _;\n    }\n\n    modifier onlyPoolCommitter() {\n        require(msg.sender == poolCommitter, \"msg.sender not poolCommitter\");\n        _;\n    }\n\n    modifier onlyGov() {\n        require(msg.sender == governance, \"msg.sender not governance\");\n        _;\n    }\n}\n"
        },
        "contracts/test-utilities/TestERC20.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n/// @title An ERC20 token to be used when testing a pool\n/// @dev Don't use this for anything real. There's no access controls on mint and burn.\ncontract TestToken is ERC20 {\n    uint8 internal _decimals = 18;\n\n    constructor(string memory name, string memory symbol) ERC20(name, symbol) {}\n\n    function mint(uint256 amount, address account) external returns (bool) {\n        _mint(account, amount);\n        return true;\n    }\n\n    function burn(uint256 amount, address account) external returns (bool) {\n        _burn(account, amount);\n        return true;\n    }\n\n    function decimals() public view override returns (uint8) {\n        return _decimals;\n    }\n\n    function setDecimals(uint8 newDecimals) external {\n        _decimals = newDecimals;\n    }\n}\n"
        },
        "contracts/test-utilities/TestPoolFactory.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n\nimport \"../implementation/LeveragedPool.sol\";\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\n\n/// @title A barebones EIP1167 factory for the LeveragedPool contract. This is used to test the pool deployments in the same conditions as their intended use (as clones).\ncontract TestPoolFactory {\n    address public immutable poolBase;\n\n    // #### Functions\n    /**\n     * @notice Constructs a minimal base to create clones from\n     */\n    constructor(address _pool) {\n        require(_pool != address(0));\n        poolBase = _pool;\n    }\n\n    /**\n     * @notice Creates a notification for the test suite so it knows where the new pool is located\n     */\n    event DeployPool(address indexed pool);\n\n    /**\n     * @notice Clones the base pool and leaves it in an uninitialised state\n     * @dev Don't use this in production. The clone factory must call to initialise the clone.\n     * @param _poolCode The pool code for the new pool. This is used as salt for the pool address\n     */\n    function createPool(string calldata _poolCode) external {\n        LeveragedPool pool = LeveragedPool(\n            Clones.cloneDeterministic(address(poolBase), keccak256(abi.encode(_poolCode)))\n        );\n        emit DeployPool(address(pool));\n    }\n}\n"
        },
        "contracts/implementation/SMAOracle.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\nimport \"../interfaces/IOracleWrapper.sol\";\nimport \"../interfaces/IPriceObserver.sol\";\nimport \"../implementation/PriceObserver.sol\";\nimport \"prb-math/contracts/PRBMathSD59x18.sol\";\n\ncontract SMAOracle is IOracleWrapper {\n    using PRBMathSD59x18 for int256;\n\n    /// Price oracle supplying the spot price of the quote asset\n    address public override oracle;\n\n    // Deployer of the oracle\n    address public immutable override deployer;\n\n    /// Price observer providing the SMA oracle with historical pricing data\n    address public observer;\n\n    /// Current SMA price\n    int256 public price;\n\n    /// Number of periods to use in calculating the SMA (`k` in the SMA equation)\n    uint256 public periods;\n\n    /// Time of last successful price update\n    uint256 lastUpdate = 0;\n\n    /// Duration between price updates\n    uint256 updateInterval = 0;\n\n    int256 public scaler;\n    uint256 public constant MAX_DECIMALS = 18;\n\n    constructor(\n        address _spotOracle,\n        uint256 _spotDecimals,\n        address _observer,\n        uint256 _periods,\n        uint256 _updateInterval,\n        address _deployer\n    ) {\n        require(_spotOracle != address(0) && _observer != address(0), \"SMA: Null address forbidden\");\n        require(_periods > 0 && _periods <= IPriceObserver(_observer).capacity(), \"SMA: Out of bounds\");\n        require(_spotDecimals <= MAX_DECIMALS, \"SMA: Decimal precision too high\");\n        periods = _periods;\n        oracle = _spotOracle;\n        observer = _observer;\n        deployer = _deployer;\n\n        /* `scaler` is always <= 10^18 and >= 1 so this cast is safe */\n        scaler = int256(10**(MAX_DECIMALS - _spotDecimals));\n        updateInterval = _updateInterval;\n    }\n\n    /**\n     * @notice Converts `wad` to a raw integer\n     * @param wad wad maths value\n     * @return Raw (signed) integer\n     */\n    function fromWad(int256 wad) external view override returns (int256) {\n        return wad / scaler;\n    }\n\n    /**\n     * @notice Retrieves the current SMA price\n     * @dev Recomputes SMA across sample size (`periods`)\n     */\n    function getPrice() external view override returns (int256) {\n        /* update current reported SMA price */\n        return SMA(IPriceObserver(observer).getAll(), periods);\n    }\n\n    /**\n     * @notice Add a new spot price observation to the SMA oracle\n     * @dev O(n) complexity (with n being `capacity`) due to rotation of\n     *      underlying observations array and subsequent recalculation of SMA\n     *      price\n     */\n    function update() internal returns (int256) {\n        /* query the underlying spot price oracle */\n        IOracleWrapper spotOracle = IOracleWrapper(oracle);\n        int256 latestPrice = spotOracle.getPrice();\n\n        /* expire the oldest observation and load the fresh one in */\n        PriceObserver priceObserver = PriceObserver(observer);\n        priceObserver.add(latestPrice);\n\n        /* update current reported SMA price */\n        return SMA(priceObserver.getAll(), periods);\n    }\n\n    /**\n     * @notice Updates the SMA oracle by retrieving a new price from the\n     *          associated price observer contract (provided it's not too early)\n     * @return Latest SMA price\n     * @dev Throws if called within an update interval since last being called\n     * @dev Essentially wraps `update()`\n     */\n    function poll() external override returns (int256) {\n        require(block.timestamp >= lastUpdate + updateInterval, \"SMA: Too early to update\");\n        return update();\n    }\n\n    /**\n     * @notice Calculates the simple moving average of the provided dataset for the specified number of periods\n     * @param xs Dataset\n     * @param k Number of periods to use for calculation of the SMA\n     * @return Simple moving average for `k` periods\n     * @dev Throws if `k` is zero (due to necessary division)\n     * @dev Throws if `k` is greater than or equal to the length of `xs` (due to buffer overrun potential)\n     * @dev Throws if `k` is the maximum *signed* 256-bit integer (due to necessary division)\n     * @dev O(k) complexity due to linear traversal of the final `k` elements of `xs`\n     * @dev Note that the signedness of the return type is due to the signedness of the elements of `xs`\n     * @dev It's a true tragedy that we have to stipulate a fixed-length array for `xs`, but alas, Solidity's type system cannot\n     *          reason about this at all due to the value's runtime requirement\n     */\n    function SMA(int256[24] memory xs, uint256 k) public pure returns (int256) {\n        uint256 n = xs.length;\n\n        /* bounds check */\n        require(k > 0 && k <= n && k <= uint256(type(int256).max), \"SMA: Out of bounds\");\n\n        /* running total */\n        int256 S = 0;\n\n        /* linear scan over the [n - k, n] subsequence */\n        for (uint256 i = n - k; i < n; i++) {\n            S += xs[i];\n        }\n\n        /* cast is safe due to above bounds check */\n        return S / int256(k);\n    }\n\n    /**\n     * @notice Converts `x` to a wad value\n     * @param x Number to convert to wad value\n     * @return `x` but wad\n     */\n    function toWad(int256 x) private view returns (int256) {\n        return x * scaler;\n    }\n\n    /**\n     * @notice Returns the current SMA price and an empty bytes array\n     * @dev Required by the `IOracleWrapper` interface. The interface leaves\n     *          the metadata as implementation-defined. For the SMA oracle, there\n     *          is no clear use case for additional data, so it's left blank\n     */\n    function getPriceAndMetadata() external view override returns (int256 _price, bytes memory _data) {\n        _price = SMA(IPriceObserver(observer).getAll(), periods);\n        _data = \"\";\n    }\n}\n"
        },
        "prb-math/contracts/PRBMathSD59x18.sol": {
            "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.4;\n\nimport \"./PRBMath.sol\";\n\n/// @title PRBMathSD59x18\n/// @author Paul Razvan Berg\n/// @notice Smart contract library for advanced fixed-point math that works with int256 numbers considered to have 18\n/// trailing decimals. We call this number representation signed 59.18-decimal fixed-point, since the numbers can have\n/// a sign and there can be up to 59 digits in the integer part and up to 18 decimals in the fractional part. The numbers\n/// are bound by the minimum and the maximum values permitted by the Solidity type int256.\nlibrary PRBMathSD59x18 {\n    /// @dev log2(e) as a signed 59.18-decimal fixed-point number.\n    int256 internal constant LOG2_E = 1_442695040888963407;\n\n    /// @dev Half the SCALE number.\n    int256 internal constant HALF_SCALE = 5e17;\n\n    /// @dev The maximum value a signed 59.18-decimal fixed-point number can have.\n    int256 internal constant MAX_SD59x18 =\n        57896044618658097711785492504343953926634992332820282019728_792003956564819967;\n\n    /// @dev The maximum whole value a signed 59.18-decimal fixed-point number can have.\n    int256 internal constant MAX_WHOLE_SD59x18 =\n        57896044618658097711785492504343953926634992332820282019728_000000000000000000;\n\n    /// @dev The minimum value a signed 59.18-decimal fixed-point number can have.\n    int256 internal constant MIN_SD59x18 =\n        -57896044618658097711785492504343953926634992332820282019728_792003956564819968;\n\n    /// @dev The minimum whole value a signed 59.18-decimal fixed-point number can have.\n    int256 internal constant MIN_WHOLE_SD59x18 =\n        -57896044618658097711785492504343953926634992332820282019728_000000000000000000;\n\n    /// @dev How many trailing decimals can be represented.\n    int256 internal constant SCALE = 1e18;\n\n    /// INTERNAL FUNCTIONS ///\n\n    /// @notice Calculate the absolute value of x.\n    ///\n    /// @dev Requirements:\n    /// - x must be greater than MIN_SD59x18.\n    ///\n    /// @param x The number to calculate the absolute value for.\n    /// @param result The absolute value of x.\n    function abs(int256 x) internal pure returns (int256 result) {\n        unchecked {\n            if (x == MIN_SD59x18) {\n                revert PRBMathSD59x18__AbsInputTooSmall();\n            }\n            result = x < 0 ? -x : x;\n        }\n    }\n\n    /// @notice Calculates the arithmetic average of x and y, rounding down.\n    /// @param x The first operand as a signed 59.18-decimal fixed-point number.\n    /// @param y The second operand as a signed 59.18-decimal fixed-point number.\n    /// @return result The arithmetic average as a signed 59.18-decimal fixed-point number.\n    function avg(int256 x, int256 y) internal pure returns (int256 result) {\n        // The operations can never overflow.\n        unchecked {\n            int256 sum = (x >> 1) + (y >> 1);\n            if (sum < 0) {\n                // If at least one of x and y is odd, we add 1 to the result. This is because shifting negative numbers to the\n                // right rounds down to infinity.\n                assembly {\n                    result := add(sum, and(or(x, y), 1))\n                }\n            } else {\n                // If both x and y are odd, we add 1 to the result. This is because if both numbers are odd, the 0.5\n                // remainder gets truncated twice.\n                result = sum + (x & y & 1);\n            }\n        }\n    }\n\n    /// @notice Yields the least greatest signed 59.18 decimal fixed-point number greater than or equal to x.\n    ///\n    /// @dev Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.\n    /// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\n    ///\n    /// Requirements:\n    /// - x must be less than or equal to MAX_WHOLE_SD59x18.\n    ///\n    /// @param x The signed 59.18-decimal fixed-point number to ceil.\n    /// @param result The least integer greater than or equal to x, as a signed 58.18-decimal fixed-point number.\n    function ceil(int256 x) internal pure returns (int256 result) {\n        if (x > MAX_WHOLE_SD59x18) {\n            revert PRBMathSD59x18__CeilOverflow(x);\n        }\n        unchecked {\n            int256 remainder = x % SCALE;\n            if (remainder == 0) {\n                result = x;\n            } else {\n                // Solidity uses C fmod style, which returns a modulus with the same sign as x.\n                result = x - remainder;\n                if (x > 0) {\n                    result += SCALE;\n                }\n            }\n        }\n    }\n\n    /// @notice Divides two signed 59.18-decimal fixed-point numbers, returning a new signed 59.18-decimal fixed-point number.\n    ///\n    /// @dev Variant of \"mulDiv\" that works with signed numbers. Works by computing the signs and the absolute values separately.\n    ///\n    /// Requirements:\n    /// - All from \"PRBMath.mulDiv\".\n    /// - None of the inputs can be MIN_SD59x18.\n    /// - The denominator cannot be zero.\n    /// - The result must fit within int256.\n    ///\n    /// Caveats:\n    /// - All from \"PRBMath.mulDiv\".\n    ///\n    /// @param x The numerator as a signed 59.18-decimal fixed-point number.\n    /// @param y The denominator as a signed 59.18-decimal fixed-point number.\n    /// @param result The quotient as a signed 59.18-decimal fixed-point number.\n    function div(int256 x, int256 y) internal pure returns (int256 result) {\n        if (x == MIN_SD59x18 || y == MIN_SD59x18) {\n            revert PRBMathSD59x18__DivInputTooSmall();\n        }\n\n        // Get hold of the absolute values of x and y.\n        uint256 ax;\n        uint256 ay;\n        unchecked {\n            ax = x < 0 ? uint256(-x) : uint256(x);\n            ay = y < 0 ? uint256(-y) : uint256(y);\n        }\n\n        // Compute the absolute value of (x*SCALE)y. The result must fit within int256.\n        uint256 rAbs = PRBMath.mulDiv(ax, uint256(SCALE), ay);\n        if (rAbs > uint256(MAX_SD59x18)) {\n            revert PRBMathSD59x18__DivOverflow(rAbs);\n        }\n\n        // Get the signs of x and y.\n        uint256 sx;\n        uint256 sy;\n        assembly {\n            sx := sgt(x, sub(0, 1))\n            sy := sgt(y, sub(0, 1))\n        }\n\n        // XOR over sx and sy. This is basically checking whether the inputs have the same sign. If yes, the result\n        // should be positive. Otherwise, it should be negative.\n        result = sx ^ sy == 1 ? -int256(rAbs) : int256(rAbs);\n    }\n\n    /// @notice Returns Euler's number as a signed 59.18-decimal fixed-point number.\n    /// @dev See https://en.wikipedia.org/wiki/E_(mathematical_constant).\n    function e() internal pure returns (int256 result) {\n        result = 2_718281828459045235;\n    }\n\n    /// @notice Calculates the natural exponent of x.\n    ///\n    /// @dev Based on the insight that e^x = 2^(x * log2(e)).\n    ///\n    /// Requirements:\n    /// - All from \"log2\".\n    /// - x must be less than 133.084258667509499441.\n    ///\n    /// Caveats:\n    /// - All from \"exp2\".\n    /// - For any x less than -41.446531673892822322, the result is zero.\n    ///\n    /// @param x The exponent as a signed 59.18-decimal fixed-point number.\n    /// @return result The result as a signed 59.18-decimal fixed-point number.\n    function exp(int256 x) internal pure returns (int256 result) {\n        // Without this check, the value passed to \"exp2\" would be less than -59.794705707972522261.\n        if (x < -41_446531673892822322) {\n            return 0;\n        }\n\n        // Without this check, the value passed to \"exp2\" would be greater than 192.\n        if (x >= 133_084258667509499441) {\n            revert PRBMathSD59x18__ExpInputTooBig(x);\n        }\n\n        // Do the fixed-point multiplication inline to save gas.\n        unchecked {\n            int256 doubleScaleProduct = x * LOG2_E;\n            result = exp2((doubleScaleProduct + HALF_SCALE) / SCALE);\n        }\n    }\n\n    /// @notice Calculates the binary exponent of x using the binary fraction method.\n    ///\n    /// @dev See https://ethereum.stackexchange.com/q/79903/24693.\n    ///\n    /// Requirements:\n    /// - x must be 192 or less.\n    /// - The result must fit within MAX_SD59x18.\n    ///\n    /// Caveats:\n    /// - For any x less than -59.794705707972522261, the result is zero.\n    ///\n    /// @param x The exponent as a signed 59.18-decimal fixed-point number.\n    /// @return result The result as a signed 59.18-decimal fixed-point number.\n    function exp2(int256 x) internal pure returns (int256 result) {\n        // This works because 2^(-x) = 1/2^x.\n        if (x < 0) {\n            // 2^59.794705707972522262 is the maximum number whose inverse does not truncate down to zero.\n            if (x < -59_794705707972522261) {\n                return 0;\n            }\n\n            // Do the fixed-point inversion inline to save gas. The numerator is SCALE * SCALE.\n            unchecked {\n                result = 1e36 / exp2(-x);\n            }\n        } else {\n            // 2^192 doesn't fit within the 192.64-bit format used internally in this function.\n            if (x >= 192e18) {\n                revert PRBMathSD59x18__Exp2InputTooBig(x);\n            }\n\n            unchecked {\n                // Convert x to the 192.64-bit fixed-point format.\n                uint256 x192x64 = (uint256(x) << 64) / uint256(SCALE);\n\n                // Safe to convert the result to int256 directly because the maximum input allowed is 192.\n                result = int256(PRBMath.exp2(x192x64));\n            }\n        }\n    }\n\n    /// @notice Yields the greatest signed 59.18 decimal fixed-point number less than or equal to x.\n    ///\n    /// @dev Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.\n    /// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\n    ///\n    /// Requirements:\n    /// - x must be greater than or equal to MIN_WHOLE_SD59x18.\n    ///\n    /// @param x The signed 59.18-decimal fixed-point number to floor.\n    /// @param result The greatest integer less than or equal to x, as a signed 58.18-decimal fixed-point number.\n    function floor(int256 x) internal pure returns (int256 result) {\n        if (x < MIN_WHOLE_SD59x18) {\n            revert PRBMathSD59x18__FloorUnderflow(x);\n        }\n        unchecked {\n            int256 remainder = x % SCALE;\n            if (remainder == 0) {\n                result = x;\n            } else {\n                // Solidity uses C fmod style, which returns a modulus with the same sign as x.\n                result = x - remainder;\n                if (x < 0) {\n                    result -= SCALE;\n                }\n            }\n        }\n    }\n\n    /// @notice Yields the excess beyond the floor of x for positive numbers and the part of the number to the right\n    /// of the radix point for negative numbers.\n    /// @dev Based on the odd function definition. https://en.wikipedia.org/wiki/Fractional_part\n    /// @param x The signed 59.18-decimal fixed-point number to get the fractional part of.\n    /// @param result The fractional part of x as a signed 59.18-decimal fixed-point number.\n    function frac(int256 x) internal pure returns (int256 result) {\n        unchecked {\n            result = x % SCALE;\n        }\n    }\n\n    /// @notice Converts a number from basic integer form to signed 59.18-decimal fixed-point representation.\n    ///\n    /// @dev Requirements:\n    /// - x must be greater than or equal to MIN_SD59x18 divided by SCALE.\n    /// - x must be less than or equal to MAX_SD59x18 divided by SCALE.\n    ///\n    /// @param x The basic integer to convert.\n    /// @param result The same number in signed 59.18-decimal fixed-point representation.\n    function fromInt(int256 x) internal pure returns (int256 result) {\n        unchecked {\n            if (x < MIN_SD59x18 / SCALE) {\n                revert PRBMathSD59x18__FromIntUnderflow(x);\n            }\n            if (x > MAX_SD59x18 / SCALE) {\n                revert PRBMathSD59x18__FromIntOverflow(x);\n            }\n            result = x * SCALE;\n        }\n    }\n\n    /// @notice Calculates geometric mean of x and y, i.e. sqrt(x * y), rounding down.\n    ///\n    /// @dev Requirements:\n    /// - x * y must fit within MAX_SD59x18, lest it overflows.\n    /// - x * y cannot be negative.\n    ///\n    /// @param x The first operand as a signed 59.18-decimal fixed-point number.\n    /// @param y The second operand as a signed 59.18-decimal fixed-point number.\n    /// @return result The result as a signed 59.18-decimal fixed-point number.\n    function gm(int256 x, int256 y) internal pure returns (int256 result) {\n        if (x == 0) {\n            return 0;\n        }\n\n        unchecked {\n            // Checking for overflow this way is faster than letting Solidity do it.\n            int256 xy = x * y;\n            if (xy / x != y) {\n                revert PRBMathSD59x18__GmOverflow(x, y);\n            }\n\n            // The product cannot be negative.\n            if (xy < 0) {\n                revert PRBMathSD59x18__GmNegativeProduct(x, y);\n            }\n\n            // We don't need to multiply by the SCALE here because the x*y product had already picked up a factor of SCALE\n            // during multiplication. See the comments within the \"sqrt\" function.\n            result = int256(PRBMath.sqrt(uint256(xy)));\n        }\n    }\n\n    /// @notice Calculates 1 / x, rounding toward zero.\n    ///\n    /// @dev Requirements:\n    /// - x cannot be zero.\n    ///\n    /// @param x The signed 59.18-decimal fixed-point number for which to calculate the inverse.\n    /// @return result The inverse as a signed 59.18-decimal fixed-point number.\n    function inv(int256 x) internal pure returns (int256 result) {\n        unchecked {\n            // 1e36 is SCALE * SCALE.\n            result = 1e36 / x;\n        }\n    }\n\n    /// @notice Calculates the natural logarithm of x.\n    ///\n    /// @dev Based on the insight that ln(x) = log2(x) / log2(e).\n    ///\n    /// Requirements:\n    /// - All from \"log2\".\n    ///\n    /// Caveats:\n    /// - All from \"log2\".\n    /// - This doesn't return exactly 1 for 2718281828459045235, for that we would need more fine-grained precision.\n    ///\n    /// @param x The signed 59.18-decimal fixed-point number for which to calculate the natural logarithm.\n    /// @return result The natural logarithm as a signed 59.18-decimal fixed-point number.\n    function ln(int256 x) internal pure returns (int256 result) {\n        // Do the fixed-point multiplication inline to save gas. This is overflow-safe because the maximum value that log2(x)\n        // can return is 195205294292027477728.\n        unchecked {\n            result = (log2(x) * SCALE) / LOG2_E;\n        }\n    }\n\n    /// @notice Calculates the common logarithm of x.\n    ///\n    /// @dev First checks if x is an exact power of ten and it stops if yes. If it's not, calculates the common\n    /// logarithm based on the insight that log10(x) = log2(x) / log2(10).\n    ///\n    /// Requirements:\n    /// - All from \"log2\".\n    ///\n    /// Caveats:\n    /// - All from \"log2\".\n    ///\n    /// @param x The signed 59.18-decimal fixed-point number for which to calculate the common logarithm.\n    /// @return result The common logarithm as a signed 59.18-decimal fixed-point number.\n    function log10(int256 x) internal pure returns (int256 result) {\n        if (x <= 0) {\n            revert PRBMathSD59x18__LogInputTooSmall(x);\n        }\n\n        // Note that the \"mul\" in this block is the assembly mul operation, not the \"mul\" function defined in this contract.\n        // prettier-ignore\n        assembly {\n            switch x\n            case 1 { result := mul(SCALE, sub(0, 18)) }\n            case 10 { result := mul(SCALE, sub(1, 18)) }\n            case 100 { result := mul(SCALE, sub(2, 18)) }\n            case 1000 { result := mul(SCALE, sub(3, 18)) }\n            case 10000 { result := mul(SCALE, sub(4, 18)) }\n            case 100000 { result := mul(SCALE, sub(5, 18)) }\n            case 1000000 { result := mul(SCALE, sub(6, 18)) }\n            case 10000000 { result := mul(SCALE, sub(7, 18)) }\n            case 100000000 { result := mul(SCALE, sub(8, 18)) }\n            case 1000000000 { result := mul(SCALE, sub(9, 18)) }\n            case 10000000000 { result := mul(SCALE, sub(10, 18)) }\n            case 100000000000 { result := mul(SCALE, sub(11, 18)) }\n            case 1000000000000 { result := mul(SCALE, sub(12, 18)) }\n            case 10000000000000 { result := mul(SCALE, sub(13, 18)) }\n            case 100000000000000 { result := mul(SCALE, sub(14, 18)) }\n            case 1000000000000000 { result := mul(SCALE, sub(15, 18)) }\n            case 10000000000000000 { result := mul(SCALE, sub(16, 18)) }\n            case 100000000000000000 { result := mul(SCALE, sub(17, 18)) }\n            case 1000000000000000000 { result := 0 }\n            case 10000000000000000000 { result := SCALE }\n            case 100000000000000000000 { result := mul(SCALE, 2) }\n            case 1000000000000000000000 { result := mul(SCALE, 3) }\n            case 10000000000000000000000 { result := mul(SCALE, 4) }\n            case 100000000000000000000000 { result := mul(SCALE, 5) }\n            case 1000000000000000000000000 { result := mul(SCALE, 6) }\n            case 10000000000000000000000000 { result := mul(SCALE, 7) }\n            case 100000000000000000000000000 { result := mul(SCALE, 8) }\n            case 1000000000000000000000000000 { result := mul(SCALE, 9) }\n            case 10000000000000000000000000000 { result := mul(SCALE, 10) }\n            case 100000000000000000000000000000 { result := mul(SCALE, 11) }\n            case 1000000000000000000000000000000 { result := mul(SCALE, 12) }\n            case 10000000000000000000000000000000 { result := mul(SCALE, 13) }\n            case 100000000000000000000000000000000 { result := mul(SCALE, 14) }\n            case 1000000000000000000000000000000000 { result := mul(SCALE, 15) }\n            case 10000000000000000000000000000000000 { result := mul(SCALE, 16) }\n            case 100000000000000000000000000000000000 { result := mul(SCALE, 17) }\n            case 1000000000000000000000000000000000000 { result := mul(SCALE, 18) }\n            case 10000000000000000000000000000000000000 { result := mul(SCALE, 19) }\n            case 100000000000000000000000000000000000000 { result := mul(SCALE, 20) }\n            case 1000000000000000000000000000000000000000 { result := mul(SCALE, 21) }\n            case 10000000000000000000000000000000000000000 { result := mul(SCALE, 22) }\n            case 100000000000000000000000000000000000000000 { result := mul(SCALE, 23) }\n            case 1000000000000000000000000000000000000000000 { result := mul(SCALE, 24) }\n            case 10000000000000000000000000000000000000000000 { result := mul(SCALE, 25) }\n            case 100000000000000000000000000000000000000000000 { result := mul(SCALE, 26) }\n            case 1000000000000000000000000000000000000000000000 { result := mul(SCALE, 27) }\n            case 10000000000000000000000000000000000000000000000 { result := mul(SCALE, 28) }\n            case 100000000000000000000000000000000000000000000000 { result := mul(SCALE, 29) }\n            case 1000000000000000000000000000000000000000000000000 { result := mul(SCALE, 30) }\n            case 10000000000000000000000000000000000000000000000000 { result := mul(SCALE, 31) }\n            case 100000000000000000000000000000000000000000000000000 { result := mul(SCALE, 32) }\n            case 1000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 33) }\n            case 10000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 34) }\n            case 100000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 35) }\n            case 1000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 36) }\n            case 10000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 37) }\n            case 100000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 38) }\n            case 1000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 39) }\n            case 10000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 40) }\n            case 100000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 41) }\n            case 1000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 42) }\n            case 10000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 43) }\n            case 100000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 44) }\n            case 1000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 45) }\n            case 10000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 46) }\n            case 100000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 47) }\n            case 1000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 48) }\n            case 10000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 49) }\n            case 100000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 50) }\n            case 1000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 51) }\n            case 10000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 52) }\n            case 100000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 53) }\n            case 1000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 54) }\n            case 10000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 55) }\n            case 100000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 56) }\n            case 1000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 57) }\n            case 10000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 58) }\n            default {\n                result := MAX_SD59x18\n            }\n        }\n\n        if (result == MAX_SD59x18) {\n            // Do the fixed-point division inline to save gas. The denominator is log2(10).\n            unchecked {\n                result = (log2(x) * SCALE) / 3_321928094887362347;\n            }\n        }\n    }\n\n    /// @notice Calculates the binary logarithm of x.\n    ///\n    /// @dev Based on the iterative approximation algorithm.\n    /// https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation\n    ///\n    /// Requirements:\n    /// - x must be greater than zero.\n    ///\n    /// Caveats:\n    /// - The results are not perfectly accurate to the last decimal, due to the lossy precision of the iterative approximation.\n    ///\n    /// @param x The signed 59.18-decimal fixed-point number for which to calculate the binary logarithm.\n    /// @return result The binary logarithm as a signed 59.18-decimal fixed-point number.\n    function log2(int256 x) internal pure returns (int256 result) {\n        if (x <= 0) {\n            revert PRBMathSD59x18__LogInputTooSmall(x);\n        }\n        unchecked {\n            // This works because log2(x) = -log2(1/x).\n            int256 sign;\n            if (x >= SCALE) {\n                sign = 1;\n            } else {\n                sign = -1;\n                // Do the fixed-point inversion inline to save gas. The numerator is SCALE * SCALE.\n                assembly {\n                    x := div(1000000000000000000000000000000000000, x)\n                }\n            }\n\n            // Calculate the integer part of the logarithm and add it to the result and finally calculate y = x * 2^(-n).\n            uint256 n = PRBMath.mostSignificantBit(uint256(x / SCALE));\n\n            // The integer part of the logarithm as a signed 59.18-decimal fixed-point number. The operation can't overflow\n            // because n is maximum 255, SCALE is 1e18 and sign is either 1 or -1.\n            result = int256(n) * SCALE;\n\n            // This is y = x * 2^(-n).\n            int256 y = x >> n;\n\n            // If y = 1, the fractional part is zero.\n            if (y == SCALE) {\n                return result * sign;\n            }\n\n            // Calculate the fractional part via the iterative approximation.\n            // The \"delta >>= 1\" part is equivalent to \"delta /= 2\", but shifting bits is faster.\n            for (int256 delta = int256(HALF_SCALE); delta > 0; delta >>= 1) {\n                y = (y * y) / SCALE;\n\n                // Is y^2 > 2 and so in the range [2,4)?\n                if (y >= 2 * SCALE) {\n                    // Add the 2^(-m) factor to the logarithm.\n                    result += delta;\n\n                    // Corresponds to z/2 on Wikipedia.\n                    y >>= 1;\n                }\n            }\n            result *= sign;\n        }\n    }\n\n    /// @notice Multiplies two signed 59.18-decimal fixed-point numbers together, returning a new signed 59.18-decimal\n    /// fixed-point number.\n    ///\n    /// @dev Variant of \"mulDiv\" that works with signed numbers and employs constant folding, i.e. the denominator is\n    /// always 1e18.\n    ///\n    /// Requirements:\n    /// - All from \"PRBMath.mulDivFixedPoint\".\n    /// - None of the inputs can be MIN_SD59x18\n    /// - The result must fit within MAX_SD59x18.\n    ///\n    /// Caveats:\n    /// - The body is purposely left uncommented; see the NatSpec comments in \"PRBMath.mulDiv\" to understand how this works.\n    ///\n    /// @param x The multiplicand as a signed 59.18-decimal fixed-point number.\n    /// @param y The multiplier as a signed 59.18-decimal fixed-point number.\n    /// @return result The product as a signed 59.18-decimal fixed-point number.\n    function mul(int256 x, int256 y) internal pure returns (int256 result) {\n        if (x == MIN_SD59x18 || y == MIN_SD59x18) {\n            revert PRBMathSD59x18__MulInputTooSmall();\n        }\n\n        unchecked {\n            uint256 ax;\n            uint256 ay;\n            ax = x < 0 ? uint256(-x) : uint256(x);\n            ay = y < 0 ? uint256(-y) : uint256(y);\n\n            uint256 rAbs = PRBMath.mulDivFixedPoint(ax, ay);\n            if (rAbs > uint256(MAX_SD59x18)) {\n                revert PRBMathSD59x18__MulOverflow(rAbs);\n            }\n\n            uint256 sx;\n            uint256 sy;\n            assembly {\n                sx := sgt(x, sub(0, 1))\n                sy := sgt(y, sub(0, 1))\n            }\n            result = sx ^ sy == 1 ? -int256(rAbs) : int256(rAbs);\n        }\n    }\n\n    /// @notice Returns PI as a signed 59.18-decimal fixed-point number.\n    function pi() internal pure returns (int256 result) {\n        result = 3_141592653589793238;\n    }\n\n    /// @notice Raises x to the power of y.\n    ///\n    /// @dev Based on the insight that x^y = 2^(log2(x) * y).\n    ///\n    /// Requirements:\n    /// - All from \"exp2\", \"log2\" and \"mul\".\n    /// - z cannot be zero.\n    ///\n    /// Caveats:\n    /// - All from \"exp2\", \"log2\" and \"mul\".\n    /// - Assumes 0^0 is 1.\n    ///\n    /// @param x Number to raise to given power y, as a signed 59.18-decimal fixed-point number.\n    /// @param y Exponent to raise x to, as a signed 59.18-decimal fixed-point number.\n    /// @return result x raised to power y, as a signed 59.18-decimal fixed-point number.\n    function pow(int256 x, int256 y) internal pure returns (int256 result) {\n        if (x == 0) {\n            result = y == 0 ? SCALE : int256(0);\n        } else {\n            result = exp2(mul(log2(x), y));\n        }\n    }\n\n    /// @notice Raises x (signed 59.18-decimal fixed-point number) to the power of y (basic unsigned integer) using the\n    /// famous algorithm \"exponentiation by squaring\".\n    ///\n    /// @dev See https://en.wikipedia.org/wiki/Exponentiation_by_squaring\n    ///\n    /// Requirements:\n    /// - All from \"abs\" and \"PRBMath.mulDivFixedPoint\".\n    /// - The result must fit within MAX_SD59x18.\n    ///\n    /// Caveats:\n    /// - All from \"PRBMath.mulDivFixedPoint\".\n    /// - Assumes 0^0 is 1.\n    ///\n    /// @param x The base as a signed 59.18-decimal fixed-point number.\n    /// @param y The exponent as an uint256.\n    /// @return result The result as a signed 59.18-decimal fixed-point number.\n    function powu(int256 x, uint256 y) internal pure returns (int256 result) {\n        uint256 xAbs = uint256(abs(x));\n\n        // Calculate the first iteration of the loop in advance.\n        uint256 rAbs = y & 1 > 0 ? xAbs : uint256(SCALE);\n\n        // Equivalent to \"for(y /= 2; y > 0; y /= 2)\" but faster.\n        uint256 yAux = y;\n        for (yAux >>= 1; yAux > 0; yAux >>= 1) {\n            xAbs = PRBMath.mulDivFixedPoint(xAbs, xAbs);\n\n            // Equivalent to \"y % 2 == 1\" but faster.\n            if (yAux & 1 > 0) {\n                rAbs = PRBMath.mulDivFixedPoint(rAbs, xAbs);\n            }\n        }\n\n        // The result must fit within the 59.18-decimal fixed-point representation.\n        if (rAbs > uint256(MAX_SD59x18)) {\n            revert PRBMathSD59x18__PowuOverflow(rAbs);\n        }\n\n        // Is the base negative and the exponent an odd number?\n        bool isNegative = x < 0 && y & 1 == 1;\n        result = isNegative ? -int256(rAbs) : int256(rAbs);\n    }\n\n    /// @notice Returns 1 as a signed 59.18-decimal fixed-point number.\n    function scale() internal pure returns (int256 result) {\n        result = SCALE;\n    }\n\n    /// @notice Calculates the square root of x, rounding down.\n    /// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\n    ///\n    /// Requirements:\n    /// - x cannot be negative.\n    /// - x must be less than MAX_SD59x18 / SCALE.\n    ///\n    /// @param x The signed 59.18-decimal fixed-point number for which to calculate the square root.\n    /// @return result The result as a signed 59.18-decimal fixed-point .\n    function sqrt(int256 x) internal pure returns (int256 result) {\n        unchecked {\n            if (x < 0) {\n                revert PRBMathSD59x18__SqrtNegativeInput(x);\n            }\n            if (x > MAX_SD59x18 / SCALE) {\n                revert PRBMathSD59x18__SqrtOverflow(x);\n            }\n            // Multiply x by the SCALE to account for the factor of SCALE that is picked up when multiplying two signed\n            // 59.18-decimal fixed-point numbers together (in this case, those two numbers are both the square root).\n            result = int256(PRBMath.sqrt(uint256(x * SCALE)));\n        }\n    }\n\n    /// @notice Converts a signed 59.18-decimal fixed-point number to basic integer form, rounding down in the process.\n    /// @param x The signed 59.18-decimal fixed-point number to convert.\n    /// @return result The same number in basic integer form.\n    function toInt(int256 x) internal pure returns (int256 result) {\n        unchecked {\n            result = x / SCALE;\n        }\n    }\n}\n"
        },
        "prb-math/contracts/PRBMath.sol": {
            "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.4;\n\n/// @notice Emitted when the result overflows uint256.\nerror PRBMath__MulDivFixedPointOverflow(uint256 prod1);\n\n/// @notice Emitted when the result overflows uint256.\nerror PRBMath__MulDivOverflow(uint256 prod1, uint256 denominator);\n\n/// @notice Emitted when one of the inputs is type(int256).min.\nerror PRBMath__MulDivSignedInputTooSmall();\n\n/// @notice Emitted when the intermediary absolute result overflows int256.\nerror PRBMath__MulDivSignedOverflow(uint256 rAbs);\n\n/// @notice Emitted when the input is MIN_SD59x18.\nerror PRBMathSD59x18__AbsInputTooSmall();\n\n/// @notice Emitted when ceiling a number overflows SD59x18.\nerror PRBMathSD59x18__CeilOverflow(int256 x);\n\n/// @notice Emitted when one of the inputs is MIN_SD59x18.\nerror PRBMathSD59x18__DivInputTooSmall();\n\n/// @notice Emitted when one of the intermediary unsigned results overflows SD59x18.\nerror PRBMathSD59x18__DivOverflow(uint256 rAbs);\n\n/// @notice Emitted when the input is greater than 133.084258667509499441.\nerror PRBMathSD59x18__ExpInputTooBig(int256 x);\n\n/// @notice Emitted when the input is greater than 192.\nerror PRBMathSD59x18__Exp2InputTooBig(int256 x);\n\n/// @notice Emitted when flooring a number underflows SD59x18.\nerror PRBMathSD59x18__FloorUnderflow(int256 x);\n\n/// @notice Emitted when converting a basic integer to the fixed-point format overflows SD59x18.\nerror PRBMathSD59x18__FromIntOverflow(int256 x);\n\n/// @notice Emitted when converting a basic integer to the fixed-point format underflows SD59x18.\nerror PRBMathSD59x18__FromIntUnderflow(int256 x);\n\n/// @notice Emitted when the product of the inputs is negative.\nerror PRBMathSD59x18__GmNegativeProduct(int256 x, int256 y);\n\n/// @notice Emitted when multiplying the inputs overflows SD59x18.\nerror PRBMathSD59x18__GmOverflow(int256 x, int256 y);\n\n/// @notice Emitted when the input is less than or equal to zero.\nerror PRBMathSD59x18__LogInputTooSmall(int256 x);\n\n/// @notice Emitted when one of the inputs is MIN_SD59x18.\nerror PRBMathSD59x18__MulInputTooSmall();\n\n/// @notice Emitted when the intermediary absolute result overflows SD59x18.\nerror PRBMathSD59x18__MulOverflow(uint256 rAbs);\n\n/// @notice Emitted when the intermediary absolute result overflows SD59x18.\nerror PRBMathSD59x18__PowuOverflow(uint256 rAbs);\n\n/// @notice Emitted when the input is negative.\nerror PRBMathSD59x18__SqrtNegativeInput(int256 x);\n\n/// @notice Emitted when the calculating the square root overflows SD59x18.\nerror PRBMathSD59x18__SqrtOverflow(int256 x);\n\n/// @notice Emitted when addition overflows UD60x18.\nerror PRBMathUD60x18__AddOverflow(uint256 x, uint256 y);\n\n/// @notice Emitted when ceiling a number overflows UD60x18.\nerror PRBMathUD60x18__CeilOverflow(uint256 x);\n\n/// @notice Emitted when the input is greater than 133.084258667509499441.\nerror PRBMathUD60x18__ExpInputTooBig(uint256 x);\n\n/// @notice Emitted when the input is greater than 192.\nerror PRBMathUD60x18__Exp2InputTooBig(uint256 x);\n\n/// @notice Emitted when converting a basic integer to the fixed-point format format overflows UD60x18.\nerror PRBMathUD60x18__FromUintOverflow(uint256 x);\n\n/// @notice Emitted when multiplying the inputs overflows UD60x18.\nerror PRBMathUD60x18__GmOverflow(uint256 x, uint256 y);\n\n/// @notice Emitted when the input is less than 1.\nerror PRBMathUD60x18__LogInputTooSmall(uint256 x);\n\n/// @notice Emitted when the calculating the square root overflows UD60x18.\nerror PRBMathUD60x18__SqrtOverflow(uint256 x);\n\n/// @notice Emitted when subtraction underflows UD60x18.\nerror PRBMathUD60x18__SubUnderflow(uint256 x, uint256 y);\n\n/// @dev Common mathematical functions used in both PRBMathSD59x18 and PRBMathUD60x18. Note that this shared library\n/// does not always assume the signed 59.18-decimal fixed-point or the unsigned 60.18-decimal fixed-point\n/// representation. When it does not, it is explicitly mentioned in the NatSpec documentation.\nlibrary PRBMath {\n    /// STRUCTS ///\n\n    struct SD59x18 {\n        int256 value;\n    }\n\n    struct UD60x18 {\n        uint256 value;\n    }\n\n    /// STORAGE ///\n\n    /// @dev How many trailing decimals can be represented.\n    uint256 internal constant SCALE = 1e18;\n\n    /// @dev Largest power of two divisor of SCALE.\n    uint256 internal constant SCALE_LPOTD = 262144;\n\n    /// @dev SCALE inverted mod 2^256.\n    uint256 internal constant SCALE_INVERSE =\n        78156646155174841979727994598816262306175212592076161876661_508869554232690281;\n\n    /// FUNCTIONS ///\n\n    /// @notice Calculates the binary exponent of x using the binary fraction method.\n    /// @dev Has to use 192.64-bit fixed-point numbers.\n    /// See https://ethereum.stackexchange.com/a/96594/24693.\n    /// @param x The exponent as an unsigned 192.64-bit fixed-point number.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function exp2(uint256 x) internal pure returns (uint256 result) {\n        unchecked {\n            // Start from 0.5 in the 192.64-bit fixed-point format.\n            result = 0x800000000000000000000000000000000000000000000000;\n\n            // Multiply the result by root(2, 2^-i) when the bit at position i is 1. None of the intermediary results overflows\n            // because the initial result is 2^191 and all magic factors are less than 2^65.\n            if (x & 0x8000000000000000 > 0) {\n                result = (result * 0x16A09E667F3BCC909) >> 64;\n            }\n            if (x & 0x4000000000000000 > 0) {\n                result = (result * 0x1306FE0A31B7152DF) >> 64;\n            }\n            if (x & 0x2000000000000000 > 0) {\n                result = (result * 0x1172B83C7D517ADCE) >> 64;\n            }\n            if (x & 0x1000000000000000 > 0) {\n                result = (result * 0x10B5586CF9890F62A) >> 64;\n            }\n            if (x & 0x800000000000000 > 0) {\n                result = (result * 0x1059B0D31585743AE) >> 64;\n            }\n            if (x & 0x400000000000000 > 0) {\n                result = (result * 0x102C9A3E778060EE7) >> 64;\n            }\n            if (x & 0x200000000000000 > 0) {\n                result = (result * 0x10163DA9FB33356D8) >> 64;\n            }\n            if (x & 0x100000000000000 > 0) {\n                result = (result * 0x100B1AFA5ABCBED61) >> 64;\n            }\n            if (x & 0x80000000000000 > 0) {\n                result = (result * 0x10058C86DA1C09EA2) >> 64;\n            }\n            if (x & 0x40000000000000 > 0) {\n                result = (result * 0x1002C605E2E8CEC50) >> 64;\n            }\n            if (x & 0x20000000000000 > 0) {\n                result = (result * 0x100162F3904051FA1) >> 64;\n            }\n            if (x & 0x10000000000000 > 0) {\n                result = (result * 0x1000B175EFFDC76BA) >> 64;\n            }\n            if (x & 0x8000000000000 > 0) {\n                result = (result * 0x100058BA01FB9F96D) >> 64;\n            }\n            if (x & 0x4000000000000 > 0) {\n                result = (result * 0x10002C5CC37DA9492) >> 64;\n            }\n            if (x & 0x2000000000000 > 0) {\n                result = (result * 0x1000162E525EE0547) >> 64;\n            }\n            if (x & 0x1000000000000 > 0) {\n                result = (result * 0x10000B17255775C04) >> 64;\n            }\n            if (x & 0x800000000000 > 0) {\n                result = (result * 0x1000058B91B5BC9AE) >> 64;\n            }\n            if (x & 0x400000000000 > 0) {\n                result = (result * 0x100002C5C89D5EC6D) >> 64;\n            }\n            if (x & 0x200000000000 > 0) {\n                result = (result * 0x10000162E43F4F831) >> 64;\n            }\n            if (x & 0x100000000000 > 0) {\n                result = (result * 0x100000B1721BCFC9A) >> 64;\n            }\n            if (x & 0x80000000000 > 0) {\n                result = (result * 0x10000058B90CF1E6E) >> 64;\n            }\n            if (x & 0x40000000000 > 0) {\n                result = (result * 0x1000002C5C863B73F) >> 64;\n            }\n            if (x & 0x20000000000 > 0) {\n                result = (result * 0x100000162E430E5A2) >> 64;\n            }\n            if (x & 0x10000000000 > 0) {\n                result = (result * 0x1000000B172183551) >> 64;\n            }\n            if (x & 0x8000000000 > 0) {\n                result = (result * 0x100000058B90C0B49) >> 64;\n            }\n            if (x & 0x4000000000 > 0) {\n                result = (result * 0x10000002C5C8601CC) >> 64;\n            }\n            if (x & 0x2000000000 > 0) {\n                result = (result * 0x1000000162E42FFF0) >> 64;\n            }\n            if (x & 0x1000000000 > 0) {\n                result = (result * 0x10000000B17217FBB) >> 64;\n            }\n            if (x & 0x800000000 > 0) {\n                result = (result * 0x1000000058B90BFCE) >> 64;\n            }\n            if (x & 0x400000000 > 0) {\n                result = (result * 0x100000002C5C85FE3) >> 64;\n            }\n            if (x & 0x200000000 > 0) {\n                result = (result * 0x10000000162E42FF1) >> 64;\n            }\n            if (x & 0x100000000 > 0) {\n                result = (result * 0x100000000B17217F8) >> 64;\n            }\n            if (x & 0x80000000 > 0) {\n                result = (result * 0x10000000058B90BFC) >> 64;\n            }\n            if (x & 0x40000000 > 0) {\n                result = (result * 0x1000000002C5C85FE) >> 64;\n            }\n            if (x & 0x20000000 > 0) {\n                result = (result * 0x100000000162E42FF) >> 64;\n            }\n            if (x & 0x10000000 > 0) {\n                result = (result * 0x1000000000B17217F) >> 64;\n            }\n            if (x & 0x8000000 > 0) {\n                result = (result * 0x100000000058B90C0) >> 64;\n            }\n            if (x & 0x4000000 > 0) {\n                result = (result * 0x10000000002C5C860) >> 64;\n            }\n            if (x & 0x2000000 > 0) {\n                result = (result * 0x1000000000162E430) >> 64;\n            }\n            if (x & 0x1000000 > 0) {\n                result = (result * 0x10000000000B17218) >> 64;\n            }\n            if (x & 0x800000 > 0) {\n                result = (result * 0x1000000000058B90C) >> 64;\n            }\n            if (x & 0x400000 > 0) {\n                result = (result * 0x100000000002C5C86) >> 64;\n            }\n            if (x & 0x200000 > 0) {\n                result = (result * 0x10000000000162E43) >> 64;\n            }\n            if (x & 0x100000 > 0) {\n                result = (result * 0x100000000000B1721) >> 64;\n            }\n            if (x & 0x80000 > 0) {\n                result = (result * 0x10000000000058B91) >> 64;\n            }\n            if (x & 0x40000 > 0) {\n                result = (result * 0x1000000000002C5C8) >> 64;\n            }\n            if (x & 0x20000 > 0) {\n                result = (result * 0x100000000000162E4) >> 64;\n            }\n            if (x & 0x10000 > 0) {\n                result = (result * 0x1000000000000B172) >> 64;\n            }\n            if (x & 0x8000 > 0) {\n                result = (result * 0x100000000000058B9) >> 64;\n            }\n            if (x & 0x4000 > 0) {\n                result = (result * 0x10000000000002C5D) >> 64;\n            }\n            if (x & 0x2000 > 0) {\n                result = (result * 0x1000000000000162E) >> 64;\n            }\n            if (x & 0x1000 > 0) {\n                result = (result * 0x10000000000000B17) >> 64;\n            }\n            if (x & 0x800 > 0) {\n                result = (result * 0x1000000000000058C) >> 64;\n            }\n            if (x & 0x400 > 0) {\n                result = (result * 0x100000000000002C6) >> 64;\n            }\n            if (x & 0x200 > 0) {\n                result = (result * 0x10000000000000163) >> 64;\n            }\n            if (x & 0x100 > 0) {\n                result = (result * 0x100000000000000B1) >> 64;\n            }\n            if (x & 0x80 > 0) {\n                result = (result * 0x10000000000000059) >> 64;\n            }\n            if (x & 0x40 > 0) {\n                result = (result * 0x1000000000000002C) >> 64;\n            }\n            if (x & 0x20 > 0) {\n                result = (result * 0x10000000000000016) >> 64;\n            }\n            if (x & 0x10 > 0) {\n                result = (result * 0x1000000000000000B) >> 64;\n            }\n            if (x & 0x8 > 0) {\n                result = (result * 0x10000000000000006) >> 64;\n            }\n            if (x & 0x4 > 0) {\n                result = (result * 0x10000000000000003) >> 64;\n            }\n            if (x & 0x2 > 0) {\n                result = (result * 0x10000000000000001) >> 64;\n            }\n            if (x & 0x1 > 0) {\n                result = (result * 0x10000000000000001) >> 64;\n            }\n\n            // We're doing two things at the same time:\n            //\n            //   1. Multiply the result by 2^n + 1, where \"2^n\" is the integer part and the one is added to account for\n            //      the fact that we initially set the result to 0.5. This is accomplished by subtracting from 191\n            //      rather than 192.\n            //   2. Convert the result to the unsigned 60.18-decimal fixed-point format.\n            //\n            // This works because 2^(191-ip) = 2^ip / 2^191, where \"ip\" is the integer part \"2^n\".\n            result *= SCALE;\n            result >>= (191 - (x >> 64));\n        }\n    }\n\n    /// @notice Finds the zero-based index of the first one in the binary representation of x.\n    /// @dev See the note on msb in the \"Find First Set\" Wikipedia article https://en.wikipedia.org/wiki/Find_first_set\n    /// @param x The uint256 number for which to find the index of the most significant bit.\n    /// @return msb The index of the most significant bit as an uint256.\n    function mostSignificantBit(uint256 x) internal pure returns (uint256 msb) {\n        if (x >= 2**128) {\n            x >>= 128;\n            msb += 128;\n        }\n        if (x >= 2**64) {\n            x >>= 64;\n            msb += 64;\n        }\n        if (x >= 2**32) {\n            x >>= 32;\n            msb += 32;\n        }\n        if (x >= 2**16) {\n            x >>= 16;\n            msb += 16;\n        }\n        if (x >= 2**8) {\n            x >>= 8;\n            msb += 8;\n        }\n        if (x >= 2**4) {\n            x >>= 4;\n            msb += 4;\n        }\n        if (x >= 2**2) {\n            x >>= 2;\n            msb += 2;\n        }\n        if (x >= 2**1) {\n            // No need to shift x any more.\n            msb += 1;\n        }\n    }\n\n    /// @notice Calculates floor(x*ydenominator) with full precision.\n    ///\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv.\n    ///\n    /// Requirements:\n    /// - The denominator cannot be zero.\n    /// - The result must fit within uint256.\n    ///\n    /// Caveats:\n    /// - This function does not work with fixed-point numbers.\n    ///\n    /// @param x The multiplicand as an uint256.\n    /// @param y The multiplier as an uint256.\n    /// @param denominator The divisor as an uint256.\n    /// @return result The result as an uint256.\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n        // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n        // variables such that product = prod1 * 2^256 + prod0.\n        uint256 prod0; // Least significant 256 bits of the product\n        uint256 prod1; // Most significant 256 bits of the product\n        assembly {\n            let mm := mulmod(x, y, not(0))\n            prod0 := mul(x, y)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n\n        // Handle non-overflow cases, 256 by 256 division.\n        if (prod1 == 0) {\n            unchecked {\n                result = prod0 / denominator;\n            }\n            return result;\n        }\n\n        // Make sure the result is less than 2^256. Also prevents denominator == 0.\n        if (prod1 >= denominator) {\n            revert PRBMath__MulDivOverflow(prod1, denominator);\n        }\n\n        ///////////////////////////////////////////////\n        // 512 by 256 division.\n        ///////////////////////////////////////////////\n\n        // Make division exact by subtracting the remainder from [prod1 prod0].\n        uint256 remainder;\n        assembly {\n            // Compute remainder using mulmod.\n            remainder := mulmod(x, y, denominator)\n\n            // Subtract 256 bit number from 512 bit number.\n            prod1 := sub(prod1, gt(remainder, prod0))\n            prod0 := sub(prod0, remainder)\n        }\n\n        // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n        // See https://cs.stackexchange.com/q/138556/92363.\n        unchecked {\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 lpotdod = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by lpotdod.\n                denominator := div(denominator, lpotdod)\n\n                // Divide [prod1 prod0] by lpotdod.\n                prod0 := div(prod0, lpotdod)\n\n                // Flip lpotdod such that it is 2^256 / lpotdod. If lpotdod is zero, then it becomes one.\n                lpotdod := add(div(sub(0, lpotdod), lpotdod), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * lpotdod;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /// @notice Calculates floor(x*y1e18) with full precision.\n    ///\n    /// @dev Variant of \"mulDiv\" with constant folding, i.e. in which the denominator is always 1e18. Before returning the\n    /// final result, we add 1 if (x * y) % SCALE >= HALF_SCALE. Without this, 6.6e-19 would be truncated to 0 instead of\n    /// being rounded to 1e-18.  See \"Listing 6\" and text above it at https://accu.org/index.php/journals/1717.\n    ///\n    /// Requirements:\n    /// - The result must fit within uint256.\n    ///\n    /// Caveats:\n    /// - The body is purposely left uncommented; see the NatSpec comments in \"PRBMath.mulDiv\" to understand how this works.\n    /// - It is assumed that the result can never be type(uint256).max when x and y solve the following two equations:\n    ///     1. x * y = type(uint256).max * SCALE\n    ///     2. (x * y) % SCALE >= SCALE / 2\n    ///\n    /// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function mulDivFixedPoint(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        uint256 prod0;\n        uint256 prod1;\n        assembly {\n            let mm := mulmod(x, y, not(0))\n            prod0 := mul(x, y)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n\n        if (prod1 >= SCALE) {\n            revert PRBMath__MulDivFixedPointOverflow(prod1);\n        }\n\n        uint256 remainder;\n        uint256 roundUpUnit;\n        assembly {\n            remainder := mulmod(x, y, SCALE)\n            roundUpUnit := gt(remainder, 499999999999999999)\n        }\n\n        if (prod1 == 0) {\n            unchecked {\n                result = (prod0 / SCALE) + roundUpUnit;\n                return result;\n            }\n        }\n\n        assembly {\n            result := add(\n                mul(\n                    or(\n                        div(sub(prod0, remainder), SCALE_LPOTD),\n                        mul(sub(prod1, gt(remainder, prod0)), add(div(sub(0, SCALE_LPOTD), SCALE_LPOTD), 1))\n                    ),\n                    SCALE_INVERSE\n                ),\n                roundUpUnit\n            )\n        }\n    }\n\n    /// @notice Calculates floor(x*ydenominator) with full precision.\n    ///\n    /// @dev An extension of \"mulDiv\" for signed numbers. Works by computing the signs and the absolute values separately.\n    ///\n    /// Requirements:\n    /// - None of the inputs can be type(int256).min.\n    /// - The result must fit within int256.\n    ///\n    /// @param x The multiplicand as an int256.\n    /// @param y The multiplier as an int256.\n    /// @param denominator The divisor as an int256.\n    /// @return result The result as an int256.\n    function mulDivSigned(\n        int256 x,\n        int256 y,\n        int256 denominator\n    ) internal pure returns (int256 result) {\n        if (x == type(int256).min || y == type(int256).min || denominator == type(int256).min) {\n            revert PRBMath__MulDivSignedInputTooSmall();\n        }\n\n        // Get hold of the absolute values of x, y and the denominator.\n        uint256 ax;\n        uint256 ay;\n        uint256 ad;\n        unchecked {\n            ax = x < 0 ? uint256(-x) : uint256(x);\n            ay = y < 0 ? uint256(-y) : uint256(y);\n            ad = denominator < 0 ? uint256(-denominator) : uint256(denominator);\n        }\n\n        // Compute the absolute value of (x*y)denominator. The result must fit within int256.\n        uint256 rAbs = mulDiv(ax, ay, ad);\n        if (rAbs > uint256(type(int256).max)) {\n            revert PRBMath__MulDivSignedOverflow(rAbs);\n        }\n\n        // Get the signs of x, y and the denominator.\n        uint256 sx;\n        uint256 sy;\n        uint256 sd;\n        assembly {\n            sx := sgt(x, sub(0, 1))\n            sy := sgt(y, sub(0, 1))\n            sd := sgt(denominator, sub(0, 1))\n        }\n\n        // XOR over sx, sy and sd. This is checking whether there are one or three negative signs in the inputs.\n        // If yes, the result should be negative.\n        result = sx ^ sy ^ sd == 0 ? -int256(rAbs) : int256(rAbs);\n    }\n\n    /// @notice Calculates the square root of x, rounding down.\n    /// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\n    ///\n    /// Caveats:\n    /// - This function does not work with fixed-point numbers.\n    ///\n    /// @param x The uint256 number for which to calculate the square root.\n    /// @return result The result as an uint256.\n    function sqrt(uint256 x) internal pure returns (uint256 result) {\n        if (x == 0) {\n            return 0;\n        }\n\n        // Set the initial guess to the closest power of two that is higher than x.\n        uint256 xAux = uint256(x);\n        result = 1;\n        if (xAux >= 0x100000000000000000000000000000000) {\n            xAux >>= 128;\n            result <<= 64;\n        }\n        if (xAux >= 0x10000000000000000) {\n            xAux >>= 64;\n            result <<= 32;\n        }\n        if (xAux >= 0x100000000) {\n            xAux >>= 32;\n            result <<= 16;\n        }\n        if (xAux >= 0x10000) {\n            xAux >>= 16;\n            result <<= 8;\n        }\n        if (xAux >= 0x100) {\n            xAux >>= 8;\n            result <<= 4;\n        }\n        if (xAux >= 0x10) {\n            xAux >>= 4;\n            result <<= 2;\n        }\n        if (xAux >= 0x8) {\n            result <<= 1;\n        }\n\n        // The operations can never overflow because the result is max 2^127 when it enters this block.\n        unchecked {\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1; // Seven iterations should be enough\n            uint256 roundedDownResult = x / result;\n            return result >= roundedDownResult ? roundedDownResult : result;\n        }\n    }\n}\n"
        },
        "contracts/implementation/ChainlinkOracleWrapper.sol": {
            "content": "//SPDX-License-Identifier: CC-BY-NC-ND-4.0\npragma solidity 0.8.7;\n\nimport \"../interfaces/IOracleWrapper.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol\";\n\n/// @title The oracle management contract for chainlink V3 oracles\ncontract ChainlinkOracleWrapper is IOracleWrapper {\n    // #### Globals\n    /**\n     * @notice The address of the feed oracle\n     */\n    address public override oracle;\n    address public immutable override deployer;\n    uint256 private constant MAX_DECIMALS = 18;\n    int256 public scaler;\n\n    // #### Functions\n    constructor(address _oracle, address _deployer) {\n        require(_oracle != address(0), \"Oracle cannot be 0 address\");\n        oracle = _oracle;\n        deployer = _deployer;\n        // reset the scaler for consistency\n        uint8 _decimals = AggregatorV2V3Interface(oracle).decimals();\n        require(_decimals <= MAX_DECIMALS, \"COA: too many decimals\");\n        // scaler is always <= 10^18 and >= 1 so this cast is safe\n        unchecked {\n            scaler = int256(10**(MAX_DECIMALS - _decimals));\n        }\n    }\n\n    /**\n     * @notice Returns the oracle price in WAD format\n     */\n    function getPrice() external view override returns (int256 _price) {\n        (_price, ) = _latestRoundData();\n    }\n\n    /**\n     * @return _price The latest round data price\n     * @return _data The metadata. Implementations can choose what data to return here. This implementation returns the roundID\n     */\n    function getPriceAndMetadata() external view override returns (int256 _price, bytes memory _data) {\n        (int256 price, uint80 roundID) = _latestRoundData();\n        _data = abi.encodePacked(roundID);\n        return (price, _data);\n    }\n\n    /**\n     * @dev An internal function that gets the WAD value price and latest roundID\n     */\n    function _latestRoundData() internal view returns (int256 _price, uint80 _roundID) {\n        (uint80 roundID, int256 price, , uint256 timeStamp, uint80 answeredInRound) = AggregatorV2V3Interface(oracle)\n            .latestRoundData();\n        require(answeredInRound >= roundID, \"COA: Stale answer\");\n        require(timeStamp != 0, \"COA: Round incomplete\");\n        return (toWad(price), roundID);\n    }\n\n    /**\n     * @notice Converts a raw value to a WAD value based on the decimals in the feed\n     * @dev This allows consistency for oracles used throughout the protocol\n     *      and allows oracles to have their decimals changed without affecting\n     *      the market itself\n     */\n    function toWad(int256 raw) internal view returns (int256) {\n        return raw * scaler;\n    }\n\n    /**\n     * @notice Converts from a WAD value to a raw value based on the decimals in the feed\n     */\n    function fromWad(int256 wad) external view override returns (int256) {\n        return wad / scaler;\n    }\n\n    function poll() external view override returns (int256) {\n        (int256 _price, ) = _latestRoundData();\n        return _price;\n    }\n}\n"
        },
        "@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./AggregatorInterface.sol\";\nimport \"./AggregatorV3Interface.sol\";\n\ninterface AggregatorV2V3Interface is AggregatorInterface, AggregatorV3Interface\n{\n}\n"
        },
        "@chainlink/contracts/src/v0.8/interfaces/AggregatorInterface.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorInterface {\n  function latestAnswer()\n    external\n    view\n    returns (\n      int256\n    );\n  \n  function latestTimestamp()\n    external\n    view\n    returns (\n      uint256\n    );\n\n  function latestRound()\n    external\n    view\n    returns (\n      uint256\n    );\n\n  function getAnswer(\n    uint256 roundId\n  )\n    external\n    view\n    returns (\n      int256\n    );\n\n  function getTimestamp(\n    uint256 roundId\n  )\n    external\n    view\n    returns (\n      uint256\n    );\n\n  event AnswerUpdated(\n    int256 indexed current,\n    uint256 indexed roundId,\n    uint256 updatedAt\n  );\n\n  event NewRound(\n    uint256 indexed roundId,\n    address indexed startedBy,\n    uint256 startedAt\n  );\n}\n"
        },
        "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n\n  function decimals()\n    external\n    view\n    returns (\n      uint8\n    );\n\n  function description()\n    external\n    view\n    returns (\n      string memory\n    );\n\n  function version()\n    external\n    view\n    returns (\n      uint256\n    );\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(\n    uint80 _roundId\n  )\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n}\n"
        },
        "contracts/implementation/InvariantCheck.sol": {
            "content": "//SPDX-License-Identifier: CC-BY-NC-ND-4.0\npragma solidity 0.8.7;\n\nimport \"../interfaces/IInvariantCheck.sol\";\nimport \"../interfaces/IPoolCommitter.sol\";\nimport \"../interfaces/IPausable.sol\";\nimport \"../interfaces/ILeveragedPool.sol\";\nimport \"../interfaces/IPoolFactory.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// @title The contract for checking invariants and pausing if necessary\n/// @notice Every time certain functions are called, known invariants are checked and if any do not hold, contracts are paused.\ncontract InvariantCheck is IInvariantCheck {\n    IPoolFactory public immutable poolFactory;\n\n    /**\n     * @notice Constructor\n     * @param _factory Address of the associated `PoolFactory` contract\n     * @dev Throws if factory address is null\n     */\n    constructor(address _factory) {\n        require(_factory != address(0), \"Factory address cannot be null\");\n        poolFactory = IPoolFactory(_factory);\n    }\n\n    /**\n     * @notice Checks all invariants, and pauses all contracts if\n     *         any invariant does not hold.\n     * @dev This should be called before onlyUnpaused, in case contracts are paused then pause check must happen after.\n     * @param poolToCheck The LeveragedPool contract to be checked.\n     */\n    function checkInvariants(address poolToCheck) external override {\n        ILeveragedPool pool = ILeveragedPool(poolToCheck);\n        require(poolFactory.isValidPool(poolToCheck), \"Pool is invalid\");\n        IPoolCommitter poolCommitter = IPoolCommitter(pool.poolCommitter());\n        uint256 poolBalance = IERC20(pool.quoteToken()).balanceOf(poolToCheck);\n        (\n            IPoolCommitter.TotalCommitment memory totalCommitment,\n            IPoolCommitter.TotalCommitment memory nextTotalCommitment\n        ) = poolCommitter.getPendingCommits();\n        uint256 pendingMints;\n        pendingMints =\n            totalCommitment.longMintAmount +\n            totalCommitment.shortMintAmount +\n            nextTotalCommitment.longMintAmount +\n            nextTotalCommitment.shortMintAmount;\n        uint256 longBalance = pool.longBalance();\n        uint256 shortBalance = pool.shortBalance();\n        if (!balanceInvariant(poolBalance, pendingMints, longBalance, shortBalance)) {\n            pause(IPausable(poolToCheck), IPausable(address(poolCommitter)));\n        }\n    }\n\n    /**\n     * @notice Pause both LeveragedPool and PoolCommitter.\n     * @dev Both parameters must implement the IPausable interface.\n     * @param pool The LeveragedPool to be paused.\n     * @param poolCommitter The PoolCommitter to be paused.\n     */\n    function pause(IPausable pool, IPausable poolCommitter) internal {\n        pool.pause();\n        poolCommitter.pause();\n    }\n\n    /**\n     * @notice Check that the balance of a pool is equal to or greater than the summation of pending mints, long balance and short balance\n     * @return true if balance invariant holds. False if not\n     * @param balance The amount of settlement tokens owned by the leveraged pool\n     * @param pendingMints The amount of pending mints in the pool\n     * @param longBalance The balance of the long side of the pool\n     * @param shortBalance The balance of the short side of the pool\n     */\n    function balanceInvariant(\n        uint256 balance,\n        uint256 pendingMints,\n        uint256 longBalance,\n        uint256 shortBalance\n    ) internal pure returns (bool) {\n        return balance >= pendingMints + longBalance + shortBalance;\n    }\n}\n"
        }
    },
    "settings": {
        "optimizer": {
            "enabled": true,
            "runs": 200
        },
        "outputSelection": {
            "*": {
                "*": [
                    "abi",
                    "evm.bytecode",
                    "evm.deployedBytecode",
                    "evm.methodIdentifiers",
                    "metadata",
                    "devdoc",
                    "userdoc",
                    "storageLayout",
                    "evm.gasEstimates"
                ],
                "": ["ast"]
            }
        },
        "metadata": {
            "useLiteralContent": true
        }
    }
}
