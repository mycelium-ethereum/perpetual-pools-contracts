{
    "address": "0x121e4341b39cE0Debc28CD1Ffe5e8FD8Dcf5BbC7",
    "abi": [
        {
            "inputs": [
                {
                    "internalType": "address",
                    "name": "_factory",
                    "type": "address"
                }
            ],
            "stateMutability": "nonpayable",
            "type": "constructor"
        },
        {
            "anonymous": false,
            "inputs": [
                {
                    "indexed": false,
                    "internalType": "string",
                    "name": "message",
                    "type": "string"
                }
            ],
            "name": "InvariantsFail",
            "type": "event"
        },
        {
            "anonymous": false,
            "inputs": [],
            "name": "InvariantsHold",
            "type": "event"
        },
        {
            "inputs": [
                {
                    "internalType": "address",
                    "name": "poolToCheck",
                    "type": "address"
                }
            ],
            "name": "checkInvariants",
            "outputs": [],
            "stateMutability": "nonpayable",
            "type": "function"
        },
        {
            "inputs": [],
            "name": "poolFactory",
            "outputs": [
                {
                    "internalType": "contract IPoolFactory",
                    "name": "",
                    "type": "address"
                }
            ],
            "stateMutability": "view",
            "type": "function"
        }
    ],
    "transactionHash": "0x9df7cf622c1650cb52fd8c976fb406aa54aca724dc1a89ae711b73fc777af596",
    "receipt": {
        "to": null,
        "from": "0xc18fcFFD8c9173faB1684Ec1EEE32976f780B13E",
        "contractAddress": "0x121e4341b39cE0Debc28CD1Ffe5e8FD8Dcf5BbC7",
        "transactionIndex": 0,
        "gasUsed": "6900221",
        "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
        "blockHash": "0x5c5eb9cc520565acadb18264875f8b296c1e2684e71403b2b81dd9a4f3e09c2d",
        "transactionHash": "0x9df7cf622c1650cb52fd8c976fb406aa54aca724dc1a89ae711b73fc777af596",
        "logs": [],
        "blockNumber": 8969840,
        "cumulativeGasUsed": "2907421",
        "status": 1,
        "byzantium": true
    },
    "args": ["0xcbD0bA56d7b533eb96f13dB7f7D779432d485391"],
    "solcInputHash": "4e236762a3d0441b39001e87e67104bc",
    "metadata": "{\"compiler\":{\"version\":\"0.8.7+commit.e28d00a7\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"name\":\"InvariantsFail\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"InvariantsHold\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolToCheck\",\"type\":\"address\"}],\"name\":\"checkInvariants\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolFactory\",\"outputs\":[{\"internalType\":\"contract IPoolFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"checkInvariants(address)\":{\"details\":\"This should be called before onlyUnpaused, in case contracts are paused then pause check must happen after.\",\"params\":{\"poolToCheck\":\"The LeveragedPool contract to be checked.\"}},\"constructor\":{\"details\":\"Throws if factory address is null\",\"params\":{\"_factory\":\"Address of the associated `PoolFactory` contract\"}}},\"title\":\"The contract for checking invariants and pausing if necessary\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"checkInvariants(address)\":{\"notice\":\"Checks all invariants, and pauses all contracts if         any invariant does not hold.\"},\"constructor\":{\"notice\":\"Constructor\"}},\"notice\":\"Every time certain functions are called, known invariants are checked and if any do not hold, contracts are paused.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/implementation/InvariantCheck.sol\":\"InvariantCheck\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\",\"keccak256\":\"0xc1452b054778f1926419196ef12ae200758a4ee728df69ae1cd13e5c16ca7df7\",\"license\":\"MIT\"},\"contracts/implementation/InvariantCheck.sol\":{\"content\":\"//SPDX-License-Identifier: CC-BY-NC-ND-4.0\\npragma solidity 0.8.7;\\n\\nimport \\\"../interfaces/IInvariantCheck.sol\\\";\\nimport \\\"../interfaces/IPoolCommitter.sol\\\";\\nimport \\\"../interfaces/IPausable.sol\\\";\\nimport \\\"../interfaces/ILeveragedPool.sol\\\";\\nimport \\\"../interfaces/IPoolFactory.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/// @title The contract for checking invariants and pausing if necessary\\n/// @notice Every time certain functions are called, known invariants are checked and if any do not hold, contracts are paused.\\ncontract InvariantCheck is IInvariantCheck {\\n    IPoolFactory public immutable poolFactory;\\n\\n    /**\\n     * @notice Constructor\\n     * @param _factory Address of the associated `PoolFactory` contract\\n     * @dev Throws if factory address is null\\n     */\\n    constructor(address _factory) {\\n        require(_factory != address(0), \\\"Factory address cannot be null\\\");\\n        poolFactory = IPoolFactory(_factory);\\n    }\\n\\n    /**\\n     * @notice Checks all invariants, and pauses all contracts if\\n     *         any invariant does not hold.\\n     * @dev This should be called before onlyUnpaused, in case contracts are paused then pause check must happen after.\\n     * @param poolToCheck The LeveragedPool contract to be checked.\\n     */\\n    function checkInvariants(address poolToCheck) external override {\\n        ILeveragedPool pool = ILeveragedPool(poolToCheck);\\n        require(poolFactory.isValidPool(poolToCheck), \\\"Pool is invalid\\\");\\n        IPoolCommitter poolCommitter = IPoolCommitter(pool.poolCommitter());\\n        uint256 poolBalance = IERC20(pool.quoteToken()).balanceOf(poolToCheck);\\n        (\\n            IPoolCommitter.TotalCommitment memory totalCommitment,\\n            IPoolCommitter.TotalCommitment memory nextTotalCommitment\\n        ) = poolCommitter.getPendingCommits();\\n        uint256 pendingMints;\\n        pendingMints =\\n            totalCommitment.longMintAmount +\\n            totalCommitment.shortMintAmount +\\n            nextTotalCommitment.longMintAmount +\\n            nextTotalCommitment.shortMintAmount;\\n        uint256 longBalance = pool.longBalance();\\n        uint256 shortBalance = pool.shortBalance();\\n        if (!balanceInvariant(poolBalance, pendingMints, longBalance, shortBalance)) {\\n            pause(IPausable(poolToCheck), IPausable(address(poolCommitter)));\\n        }\\n    }\\n\\n    /**\\n     * @notice Pause both LeveragedPool and PoolCommitter.\\n     * @dev Both parameters must implement the IPausable interface.\\n     * @param pool The LeveragedPool to be paused.\\n     * @param poolCommitter The PoolCommitter to be paused.\\n     */\\n    function pause(IPausable pool, IPausable poolCommitter) internal {\\n        pool.pause();\\n        poolCommitter.pause();\\n    }\\n\\n    /**\\n     * @notice Check that the balance of a pool is equal to or greater than the summation of pending mints, long balance and short balance\\n     * @return true if balance invariant holds. False if not\\n     * @param balance The amount of settlement tokens owned by the leveraged pool\\n     * @param pendingMints The amount of pending mints in the pool\\n     * @param longBalance The balance of the long side of the pool\\n     * @param shortBalance The balance of the short side of the pool\\n     */\\n    function balanceInvariant(\\n        uint256 balance,\\n        uint256 pendingMints,\\n        uint256 longBalance,\\n        uint256 shortBalance\\n    ) internal pure returns (bool) {\\n        return balance >= pendingMints + longBalance + shortBalance;\\n    }\\n}\\n\",\"keccak256\":\"0xcfadfe9efc62379711a209d92456cb0acd009730f3d4d48c20f38389eb639803\",\"license\":\"CC-BY-NC-ND-4.0\"},\"contracts/interfaces/IInvariantCheck.sol\":{\"content\":\"//SPDX-License-Identifier: CC-BY-NC-ND-4.0\\npragma solidity 0.8.7;\\n\\n/// @title The contract factory for the keeper and pool contracts. Utilizes minimal clones to keep gas costs low\\ninterface IInvariantCheck {\\n    event InvariantsHold();\\n    event InvariantsFail(string message);\\n\\n    /**\\n     * @notice Checks all invariants, and pauses all contracts if\\n     *         any invariant does not hold.\\n     */\\n    function checkInvariants(address pool) external;\\n}\\n\",\"keccak256\":\"0x108b25ee123c6fe445b11b50cf862832aec2d12b9a6187d7cfd83bf579ee05dc\",\"license\":\"CC-BY-NC-ND-4.0\"},\"contracts/interfaces/ILeveragedPool.sol\":{\"content\":\"//SPDX-License-Identifier: CC-BY-NC-ND-4.0\\npragma solidity 0.8.7;\\n\\n/// @title The pool controller contract interface\\ninterface ILeveragedPool {\\n    // Initialisation parameters for new market\\n    struct Initialization {\\n        address _owner; // Owner of the contract\\n        address _keeper; // The address of the PoolKeeper contract\\n        address _oracleWrapper; // The oracle wrapper for the derivative price feed\\n        address _settlementEthOracle; // The oracle wrapper for the SettlementToken/ETH price feed\\n        address _longToken; // Address of the long pool token\\n        address _shortToken; // Address of the short pool token\\n        address _poolCommitter; // Address of the PoolCommitter contract\\n        address _invariantCheckContract; // Address of the PoolCommitter contract\\n        string _poolName; // The pool identification name\\n        uint32 _frontRunningInterval; // The minimum number of seconds that must elapse before a commit is forced to wait until the next interval\\n        uint32 _updateInterval; // The minimum number of seconds that must elapse before a commit can be executed\\n        uint16 _leverageAmount; // The amount of exposure to price movements for the pool\\n        uint256 _fee; // The fund movement fee. This amount is extracted from the deposited asset with every update and sent to the fee address. Given as the decimal * 10 ^ 18. For example, 60% fee is 0.6 * 10 ^ 18\\n        address _feeAddress; // The address that the fund movement fee is sent to\\n        address _secondaryFeeAddress; // The address of fee recieved by third party deployers\\n        address _quoteToken; //  The digital asset that the pool accepts. Must have a decimals() function\\n        uint256 _secondaryFeeSplitPercent; // Percent of fees that go to secondary fee address if it exists\\n    }\\n\\n    // #### Events\\n    /**\\n     * @notice Creates a notification when the pool is setup and ready for use\\n     * @param longToken The address of the LONG pair token\\n     * @param shortToken The address of the SHORT pair token\\n     * @param quoteToken The address of the digital asset that the pool accepts\\n     * @param poolName The pool code for the pool\\n     */\\n    event PoolInitialized(address indexed longToken, address indexed shortToken, address quoteToken, string poolName);\\n\\n    /**\\n     * @notice Creates a notification when the pool is rebalanced\\n     * @param shortBalanceChange The change of funds in the short side\\n     * @param longBalanceChange The change of funds in the long side\\n     * @param shortFeeAmount Proportional fee taken from short side\\n     * @param longFeeAmount Proportional fee taken from long side\\n     */\\n    event PoolRebalance(\\n        int256 shortBalanceChange,\\n        int256 longBalanceChange,\\n        uint256 shortFeeAmount,\\n        uint256 longFeeAmount\\n    );\\n\\n    /**\\n     * @notice Creates a notification when the pool's price execution fails\\n     * @param startPrice Price prior to price change execution\\n     * @param endPrice Price during price change execution\\n     */\\n    event PriceChangeError(int256 indexed startPrice, int256 indexed endPrice);\\n\\n    /**\\n     * @notice Represents change in fee receiver's address\\n     * @param oldAddress Previous address\\n     * @param newAddress Address after change\\n     */\\n    event FeeAddressUpdated(address indexed oldAddress, address indexed newAddress);\\n\\n    /**\\n     * @notice Represents change in secondary fee receiver's address\\n     * @param oldAddress Previous address\\n     * @param newAddress Address after change\\n     */\\n    event SecondaryFeeAddressUpdated(address indexed oldAddress, address indexed newAddress);\\n\\n    /**\\n     * @notice Represents change in keeper's address\\n     * @param oldAddress Previous address\\n     * @param newAddress Address after change\\n     */\\n    event KeeperAddressChanged(address indexed oldAddress, address indexed newAddress);\\n\\n    /**\\n     * @notice Represents proposed change in governance address\\n     * @param newAddress Proposed address\\n     */\\n    event ProvisionalGovernanceChanged(address indexed newAddress);\\n\\n    /**\\n     * @notice Represents change in governance address\\n     * @param oldAddress Previous address\\n     * @param newAddress Address after change\\n     */\\n    event GovernanceAddressChanged(address indexed oldAddress, address indexed newAddress);\\n\\n    function leverageAmount() external view returns (bytes16);\\n\\n    function poolCommitter() external view returns (address);\\n\\n    function quoteToken() external view returns (address);\\n\\n    function oracleWrapper() external view returns (address);\\n\\n    function lastPriceTimestamp() external view returns (uint256);\\n\\n    function poolName() external view returns (string calldata);\\n\\n    function updateInterval() external view returns (uint32);\\n\\n    function shortBalance() external view returns (uint256);\\n\\n    function longBalance() external view returns (uint256);\\n\\n    function frontRunningInterval() external view returns (uint32);\\n\\n    function poolTokens() external view returns (address[2] memory);\\n\\n    function settlementEthOracle() external view returns (address);\\n\\n    // #### Functions\\n    /**\\n     * @notice Configures the pool on deployment. The pools are EIP 1167 clones.\\n     * @dev This should only be able to be run once to prevent abuse of the pool. Use of Openzeppelin Initializable or similar is recommended\\n     * @param initialization The struct Initialization containing initialization data\\n     */\\n    function initialize(Initialization calldata initialization) external;\\n\\n    function poolUpkeep(int256 _oldPrice, int256 _newPrice) external;\\n\\n    function quoteTokenTransferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external;\\n\\n    function payKeeperFromBalances(address to, uint256 amount) external returns (bool);\\n\\n    function quoteTokenTransfer(address to, uint256 amount) external;\\n\\n    function poolTokenTransfer(\\n        bool isLongToken,\\n        address to,\\n        uint256 amount\\n    ) external;\\n\\n    function setNewPoolBalances(uint256 _longBalance, uint256 _shortBalance) external;\\n\\n    /**\\n     * @return _latestPrice The oracle price\\n     * @return _data The oracleWrapper's metadata. Implementations can choose what data to return here\\n     * @return _lastPriceTimestamp The timestamp of the last upkeep\\n     * @return _updateInterval The update frequency for this pool\\n     * @dev To save gas so PoolKeeper does not have to make three external calls\\n     */\\n    function getUpkeepInformation()\\n        external\\n        view\\n        returns (\\n            int256 _latestPrice,\\n            bytes memory _data,\\n            uint256 _lastPriceTimestamp,\\n            uint256 _updateInterval\\n        );\\n\\n    function getOraclePrice() external view returns (int256);\\n\\n    function intervalPassed() external view returns (bool);\\n\\n    function balances() external view returns (uint256 _shortBalance, uint256 _longBalance);\\n\\n    function setKeeper(address _keeper) external;\\n\\n    function transferGovernance(address _governance) external;\\n\\n    function claimGovernance() external;\\n\\n    function updateFeeAddress(address account) external;\\n\\n    function updateSecondaryFeeAddress(address account) external;\\n\\n    function mintTokens(\\n        bool isLongToken,\\n        uint256 amount,\\n        address burner\\n    ) external;\\n\\n    function burnTokens(\\n        bool isLongToken,\\n        uint256 amount,\\n        address burner\\n    ) external;\\n}\\n\",\"keccak256\":\"0x94db9525799587472455f725b69475418c1fe64490f324d6e5e6cc3a28341fb9\",\"license\":\"CC-BY-NC-ND-4.0\"},\"contracts/interfaces/IPausable.sol\":{\"content\":\"//SPDX-License-Identifier: CC-BY-NC-ND-4.0\\npragma solidity 0.8.7;\\n\\n/// @title The pausable contract\\ninterface IPausable {\\n    /**\\n     * @notice Pauses the pool\\n     * @dev Prevents all state updates until unpaused\\n     */\\n    function pause() external;\\n\\n    /**\\n     * @notice Unpauses the pool\\n     * @dev Prevents all state updates until unpaused\\n     */\\n    function unpause() external;\\n\\n    /**\\n     * @return true if paused\\n     */\\n    function paused() external returns (bool);\\n\\n    event Paused();\\n    event Unpaused();\\n}\\n\",\"keccak256\":\"0x33e6187d3d403a66b6de93f1097933f202d8f16d8981d18b6bb168ccdcbad3a3\",\"license\":\"CC-BY-NC-ND-4.0\"},\"contracts/interfaces/IPoolCommitter.sol\":{\"content\":\"//SPDX-License-Identifier: CC-BY-NC-ND-4.0\\npragma solidity 0.8.7;\\n\\n/// @title The interface for the contract that handles pool commitments\\ninterface IPoolCommitter {\\n    /// Type of commit\\n    enum CommitType {\\n        ShortMint, // Mint short tokens\\n        ShortBurn, // Burn short tokens\\n        LongMint, // Mint long tokens\\n        LongBurn, // Burn long tokens\\n        LongBurnShortMint, // Burn Long tokens, then instantly mint in same upkeep\\n        ShortBurnLongMint // Burn Short tokens, then instantly mint in same upkeep\\n    }\\n\\n    struct BalancesAndSupplies {\\n        uint256 shortBalance;\\n        uint256 longBalance;\\n        uint256 longTotalSupplyBefore;\\n        uint256 shortTotalSupplyBefore;\\n    }\\n\\n    // User aggregate balance\\n    struct Balance {\\n        uint256 longTokens;\\n        uint256 shortTokens;\\n        uint256 settlementTokens;\\n    }\\n\\n    // Token Prices\\n    struct Prices {\\n        bytes16 longPrice;\\n        bytes16 shortPrice;\\n    }\\n\\n    // Commit information\\n    struct Commit {\\n        uint256 amount;\\n        CommitType commitType;\\n        uint40 created;\\n        address owner;\\n    }\\n\\n    // Commit information\\n    struct TotalCommitment {\\n        uint256 longMintAmount;\\n        uint256 longBurnAmount;\\n        uint256 shortMintAmount;\\n        uint256 shortBurnAmount;\\n        uint256 shortBurnLongMintAmount;\\n        uint256 longBurnShortMintAmount;\\n        uint256 updateIntervalId;\\n    }\\n\\n    struct BalanceUpdate {\\n        uint256 _updateIntervalId;\\n        uint256 _newLongTokensSum;\\n        uint256 _newShortTokensSum;\\n        uint256 _newSettlementTokensSum;\\n        uint256 _balanceLongBurnAmount;\\n        uint256 _balanceShortBurnAmount;\\n        uint256 _longBurnFee;\\n        uint256 _shortBurnFee;\\n    }\\n\\n    // Track how much of a user's commitments are being done from their aggregate balance\\n    struct UserCommitment {\\n        uint256 longMintAmount;\\n        uint256 longBurnAmount;\\n        uint256 balanceLongBurnAmount;\\n        uint256 shortMintAmount;\\n        uint256 shortBurnAmount;\\n        uint256 balanceShortBurnAmount;\\n        uint256 shortBurnLongMintAmount;\\n        uint256 balanceShortBurnMintAmount;\\n        uint256 longBurnShortMintAmount;\\n        uint256 balanceLongBurnMintAmount;\\n        uint256 updateIntervalId;\\n    }\\n\\n    /**\\n     * @notice Creates a notification when a commit is created\\n     * @param user The user making the commitment\\n     * @param amount Amount of the commit\\n     * @param commitType Type of the commit (Short v Long, Mint v Burn)\\n     * @param appropriateUpdateIntervalId Id of update interval where this commit can be executed as part of upkeep\\n     * @param mintingFee Minting fee at time of commit creation\\n     */\\n    event CreateCommit(\\n        address indexed user,\\n        uint256 indexed amount,\\n        CommitType indexed commitType,\\n        uint256 appropriateUpdateIntervalId,\\n        bytes16 mintingFee\\n    );\\n\\n    /**\\n     * @notice Creates a notification when a user's aggregate balance is updated\\n     */\\n    event AggregateBalanceUpdated(address indexed user);\\n\\n    /**\\n     * @notice Creates a notification when commits for a given update interval are executed\\n     * @param updateIntervalId Unique identifier for the relevant update interval\\n     * @param burningFee Burning fee at the time of commit execution\\n     */\\n    event ExecutedCommitsForInterval(uint256 indexed updateIntervalId, bytes16 burningFee);\\n\\n    /**\\n     * @notice Creates a notification when a claim is made, depositing pool tokens in user's wallet\\n     */\\n    event Claim(address indexed user);\\n\\n    /**\\n     * @notice Creates a notification when the burningFee is updated\\n     */\\n    event BurningFeeSet(uint256 indexed _burningFee);\\n\\n    /**\\n     * @notice Creates a notification when the mintingFee is updated\\n     */\\n    event MintingFeeSet(uint256 indexed _mintingFee);\\n\\n    /**\\n     * @notice Creates a notification when the changeInterval is updated\\n     */\\n    event ChangeIntervalSet(uint256 indexed _changeInterval);\\n\\n    // #### Functions\\n\\n    function initialize(\\n        address _factory,\\n        address _invariantCheckContract,\\n        address _autoClaim,\\n        uint256 mintingFee,\\n        uint256 burningFee,\\n        uint256 _changeInterval\\n    ) external;\\n\\n    function commit(\\n        CommitType commitType,\\n        uint256 amount,\\n        bool fromAggregateBalance,\\n        bool payForClaim\\n    ) external payable;\\n\\n    function updateIntervalId() external view returns (uint128);\\n\\n    function claim(address user) external;\\n\\n    function executeCommitments() external;\\n\\n    function updateAggregateBalance(address user) external;\\n\\n    function getAggregateBalance(address user) external view returns (Balance memory _balance);\\n\\n    function getAppropriateUpdateIntervalId() external view returns (uint128);\\n\\n    function setQuoteAndPool(address _quoteToken, address _leveragedPool) external;\\n\\n    function setBurningFee(uint256 _burningFee) external;\\n\\n    function setMintingFee(uint256 _mintingFee) external;\\n\\n    function setChangeInterval(uint256 _changeInterval) external;\\n\\n    function getPendingCommits() external view returns (TotalCommitment memory, TotalCommitment memory);\\n}\\n\",\"keccak256\":\"0xace84b7eb356fa095b6ea6cde2b7b5bf58c27b8756fcb74a711ae025f8188937\",\"license\":\"CC-BY-NC-ND-4.0\"},\"contracts/interfaces/IPoolFactory.sol\":{\"content\":\"//SPDX-License-Identifier: CC-BY-NC-ND-4.0\\npragma solidity 0.8.7;\\n\\n/// @title The contract factory for the keeper and pool contracts. Utilizes minimal clones to keep gas costs low\\ninterface IPoolFactory {\\n    struct PoolDeployment {\\n        string poolName; // The name to identify a pool by\\n        uint32 frontRunningInterval; // The minimum number of seconds that must elapse before a commit can be executed. Must be smaller than or equal to the update interval to prevent deadlock\\n        uint32 updateInterval; // The minimum number of seconds that must elapse before a price change\\n        uint16 leverageAmount; // The amount of exposure to price movements for the pool\\n        address quoteToken; // The digital asset that the pool accepts\\n        address oracleWrapper; // The IOracleWrapper implementation for fetching price feed data\\n        address settlementEthOracle; // The oracle to fetch the price of Ether in terms of the settlement token\\n        address invariantCheckContract; // The IInvariantCheck contract that performs invariant checking\\n    }\\n\\n    // #### Events\\n    /**\\n     * @notice Creates a notification when a pool is deployed\\n     * @param pool Address of the new pool\\n     * @param ticker Ticker of the neew pool\\n     */\\n    event DeployPool(address indexed pool, address poolCommitter, string ticker);\\n\\n    /**\\n     * @notice Creates a notification when the pool keeper changes\\n     * @param _poolKeeper Address of the new pool keeper\\n     */\\n    event PoolKeeperChanged(address _poolKeeper);\\n\\n    // #### Getters for Globals\\n    function pools(uint256 id) external view returns (address);\\n\\n    function numPools() external view returns (uint256);\\n\\n    function isValidPool(address _pool) external view returns (bool);\\n\\n    function isValidPoolCommitter(address _poolCommitter) external view returns (bool);\\n\\n    // #### Functions\\n    function deployPool(PoolDeployment calldata deploymentParameters) external returns (address);\\n\\n    function getOwner() external returns (address);\\n\\n    function setPoolKeeper(address _poolKeeper) external;\\n\\n    function setAutoClaim(address _autoClaim) external;\\n\\n    function setMaxLeverage(uint16 newMaxLeverage) external;\\n\\n    function setFeeReceiver(address _feeReceiver) external;\\n\\n    function setFee(uint256 _fee) external;\\n\\n    function setSecondaryFeeSplitPercent(uint256 newFeePercent) external;\\n\\n    function setMintAndBurnFeeAndChangeInterval(\\n        uint256 _mintingFee,\\n        uint256 _burningFee,\\n        uint256 _changeInterval\\n    ) external;\\n}\\n\",\"keccak256\":\"0x3683e0f630a770132d0fec73abd39b9daf72ddf89d950255972ad979c09d1c2c\",\"license\":\"CC-BY-NC-ND-4.0\"}},\"version\":1}",
    "bytecode": "0x60a060405234801561001057600080fd5b5060405161080b38038061080b83398101604081905261002f9161009e565b6001600160a01b0381166100895760405162461bcd60e51b815260206004820152601e60248201527f466163746f727920616464726573732063616e6e6f74206265206e756c6c0000604482015260640160405180910390fd5b60601b6001600160601b0319166080526100ce565b6000602082840312156100b057600080fd5b81516001600160a01b03811681146100c757600080fd5b9392505050565b60805160601c61071a6100f1600039600081816040015260b4015261071a6000f3fe608060405234801561001057600080fd5b50600436106100365760003560e01c80634219dc401461003b5780639e079fc41461007e575b600080fd5b6100627f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b03909116815260200160405180910390f35b61009161008c3660046105f4565b610093565b005b604051635ab78ee160e01b81526001600160a01b03808316600483015282917f000000000000000000000000000000000000000000000000000000000000000090911690635ab78ee19060240160206040518083038186803b1580156100f857600080fd5b505afa15801561010c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101309190610635565b6101725760405162461bcd60e51b815260206004820152600f60248201526e141bdbdb081a5cc81a5b9d985b1a59608a1b604482015260640160405180910390fd5b6000816001600160a01b031663cd39f30f6040518163ffffffff1660e01b815260040160206040518083038186803b1580156101ad57600080fd5b505afa1580156101c1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101e59190610618565b90506000826001600160a01b031663217a4b706040518163ffffffff1660e01b815260040160206040518083038186803b15801561022257600080fd5b505afa158015610236573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061025a9190610618565b6040516370a0823160e01b81526001600160a01b03868116600483015291909116906370a082319060240160206040518083038186803b15801561029d57600080fd5b505afa1580156102b1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102d5919061068d565b9050600080836001600160a01b0316636a9dfc646040518163ffffffff1660e01b81526004016101c06040518083038186803b15801561031457600080fd5b505afa158015610328573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061034c9190610657565b915091506000816040015182600001518460400151856000015161037091906106a6565b61037a91906106a6565b61038491906106a6565b90506000866001600160a01b0316637e71fc7d6040518163ffffffff1660e01b815260040160206040518083038186803b1580156103c157600080fd5b505afa1580156103d5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103f9919061068d565b90506000876001600160a01b031663ba8d54686040518163ffffffff1660e01b815260040160206040518083038186803b15801561043657600080fd5b505afa15801561044a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061046e919061068d565b905061047c86848484610495565b61048a5761048a89886104b8565b505050505050505050565b6000816104a284866106a6565b6104ac91906106a6565b90941015949350505050565b816001600160a01b0316638456cb596040518163ffffffff1660e01b8152600401600060405180830381600087803b1580156104f357600080fd5b505af1158015610507573d6000803e3d6000fd5b50505050806001600160a01b0316638456cb596040518163ffffffff1660e01b8152600401600060405180830381600087803b15801561054657600080fd5b505af115801561055a573d6000803e3d6000fd5b505050505050565b600060e0828403121561057457600080fd5b60405160e0810181811067ffffffffffffffff821117156105a557634e487b7160e01b600052604160045260246000fd5b8060405250809150825181526020830151602082015260408301516040820152606083015160608201526080830151608082015260a083015160a082015260c083015160c08201525092915050565b60006020828403121561060657600080fd5b8135610611816106cc565b9392505050565b60006020828403121561062a57600080fd5b8151610611816106cc565b60006020828403121561064757600080fd5b8151801515811461061157600080fd5b6000806101c0838503121561066b57600080fd5b6106758484610562565b91506106848460e08501610562565b90509250929050565b60006020828403121561069f57600080fd5b5051919050565b600082198211156106c757634e487b7160e01b600052601160045260246000fd5b500190565b6001600160a01b03811681146106e157600080fd5b5056fea26469706673582212203ee92d067a8510c71e4463deb8901b6e6251f9267664fc8b9c671e61cb3f450064736f6c63430008070033",
    "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100365760003560e01c80634219dc401461003b5780639e079fc41461007e575b600080fd5b6100627f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b03909116815260200160405180910390f35b61009161008c3660046105f4565b610093565b005b604051635ab78ee160e01b81526001600160a01b03808316600483015282917f000000000000000000000000000000000000000000000000000000000000000090911690635ab78ee19060240160206040518083038186803b1580156100f857600080fd5b505afa15801561010c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101309190610635565b6101725760405162461bcd60e51b815260206004820152600f60248201526e141bdbdb081a5cc81a5b9d985b1a59608a1b604482015260640160405180910390fd5b6000816001600160a01b031663cd39f30f6040518163ffffffff1660e01b815260040160206040518083038186803b1580156101ad57600080fd5b505afa1580156101c1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101e59190610618565b90506000826001600160a01b031663217a4b706040518163ffffffff1660e01b815260040160206040518083038186803b15801561022257600080fd5b505afa158015610236573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061025a9190610618565b6040516370a0823160e01b81526001600160a01b03868116600483015291909116906370a082319060240160206040518083038186803b15801561029d57600080fd5b505afa1580156102b1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102d5919061068d565b9050600080836001600160a01b0316636a9dfc646040518163ffffffff1660e01b81526004016101c06040518083038186803b15801561031457600080fd5b505afa158015610328573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061034c9190610657565b915091506000816040015182600001518460400151856000015161037091906106a6565b61037a91906106a6565b61038491906106a6565b90506000866001600160a01b0316637e71fc7d6040518163ffffffff1660e01b815260040160206040518083038186803b1580156103c157600080fd5b505afa1580156103d5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103f9919061068d565b90506000876001600160a01b031663ba8d54686040518163ffffffff1660e01b815260040160206040518083038186803b15801561043657600080fd5b505afa15801561044a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061046e919061068d565b905061047c86848484610495565b61048a5761048a89886104b8565b505050505050505050565b6000816104a284866106a6565b6104ac91906106a6565b90941015949350505050565b816001600160a01b0316638456cb596040518163ffffffff1660e01b8152600401600060405180830381600087803b1580156104f357600080fd5b505af1158015610507573d6000803e3d6000fd5b50505050806001600160a01b0316638456cb596040518163ffffffff1660e01b8152600401600060405180830381600087803b15801561054657600080fd5b505af115801561055a573d6000803e3d6000fd5b505050505050565b600060e0828403121561057457600080fd5b60405160e0810181811067ffffffffffffffff821117156105a557634e487b7160e01b600052604160045260246000fd5b8060405250809150825181526020830151602082015260408301516040820152606083015160608201526080830151608082015260a083015160a082015260c083015160c08201525092915050565b60006020828403121561060657600080fd5b8135610611816106cc565b9392505050565b60006020828403121561062a57600080fd5b8151610611816106cc565b60006020828403121561064757600080fd5b8151801515811461061157600080fd5b6000806101c0838503121561066b57600080fd5b6106758484610562565b91506106848460e08501610562565b90509250929050565b60006020828403121561069f57600080fd5b5051919050565b600082198211156106c757634e487b7160e01b600052601160045260246000fd5b500190565b6001600160a01b03811681146106e157600080fd5b5056fea26469706673582212203ee92d067a8510c71e4463deb8901b6e6251f9267664fc8b9c671e61cb3f450064736f6c63430008070033",
    "devdoc": {
        "kind": "dev",
        "methods": {
            "checkInvariants(address)": {
                "details": "This should be called before onlyUnpaused, in case contracts are paused then pause check must happen after.",
                "params": {
                    "poolToCheck": "The LeveragedPool contract to be checked."
                }
            },
            "constructor": {
                "details": "Throws if factory address is null",
                "params": {
                    "_factory": "Address of the associated `PoolFactory` contract"
                }
            }
        },
        "title": "The contract for checking invariants and pausing if necessary",
        "version": 1
    },
    "userdoc": {
        "kind": "user",
        "methods": {
            "checkInvariants(address)": {
                "notice": "Checks all invariants, and pauses all contracts if         any invariant does not hold."
            },
            "constructor": {
                "notice": "Constructor"
            }
        },
        "notice": "Every time certain functions are called, known invariants are checked and if any do not hold, contracts are paused.",
        "version": 1
    },
    "storageLayout": {
        "storage": [],
        "types": null
    }
}
