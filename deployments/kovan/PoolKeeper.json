{
    "address": "0x205Bfd2f07d69483a1a1ecC7a2174BBE3356485D",
    "abi": [
        {
            "inputs": [
                {
                    "internalType": "address",
                    "name": "_factory",
                    "type": "address"
                }
            ],
            "stateMutability": "nonpayable",
            "type": "constructor"
        },
        {
            "anonymous": false,
            "inputs": [
                {
                    "indexed": true,
                    "internalType": "address",
                    "name": "_pool",
                    "type": "address"
                },
                {
                    "indexed": true,
                    "internalType": "address",
                    "name": "keeper",
                    "type": "address"
                },
                {
                    "indexed": false,
                    "internalType": "uint256",
                    "name": "reward",
                    "type": "uint256"
                }
            ],
            "name": "KeeperPaid",
            "type": "event"
        },
        {
            "anonymous": false,
            "inputs": [
                {
                    "indexed": true,
                    "internalType": "address",
                    "name": "_pool",
                    "type": "address"
                },
                {
                    "indexed": true,
                    "internalType": "address",
                    "name": "keeper",
                    "type": "address"
                },
                {
                    "indexed": false,
                    "internalType": "uint256",
                    "name": "expectedReward",
                    "type": "uint256"
                }
            ],
            "name": "KeeperPaymentError",
            "type": "event"
        },
        {
            "anonymous": false,
            "inputs": [
                {
                    "indexed": true,
                    "internalType": "address",
                    "name": "previousOwner",
                    "type": "address"
                },
                {
                    "indexed": true,
                    "internalType": "address",
                    "name": "newOwner",
                    "type": "address"
                }
            ],
            "name": "OwnershipTransferred",
            "type": "event"
        },
        {
            "anonymous": false,
            "inputs": [
                {
                    "indexed": true,
                    "internalType": "address",
                    "name": "poolAddress",
                    "type": "address"
                },
                {
                    "indexed": true,
                    "internalType": "int256",
                    "name": "firstPrice",
                    "type": "int256"
                }
            ],
            "name": "PoolAdded",
            "type": "event"
        },
        {
            "anonymous": false,
            "inputs": [
                {
                    "indexed": true,
                    "internalType": "address",
                    "name": "pool",
                    "type": "address"
                },
                {
                    "indexed": false,
                    "internalType": "string",
                    "name": "reason",
                    "type": "string"
                }
            ],
            "name": "PoolUpkeepError",
            "type": "event"
        },
        {
            "inputs": [],
            "name": "BASE_TIP",
            "outputs": [
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                }
            ],
            "stateMutability": "view",
            "type": "function"
        },
        {
            "inputs": [],
            "name": "BLOCK_TIME",
            "outputs": [
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                }
            ],
            "stateMutability": "view",
            "type": "function"
        },
        {
            "inputs": [],
            "name": "MAX_DECIMALS",
            "outputs": [
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                }
            ],
            "stateMutability": "view",
            "type": "function"
        },
        {
            "inputs": [],
            "name": "TIP_DELTA_PER_BLOCK",
            "outputs": [
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                }
            ],
            "stateMutability": "view",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "address[]",
                    "name": "_pools",
                    "type": "address[]"
                }
            ],
            "name": "checkUpkeepMultiplePools",
            "outputs": [
                {
                    "internalType": "bool",
                    "name": "",
                    "type": "bool"
                }
            ],
            "stateMutability": "view",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "address",
                    "name": "_pool",
                    "type": "address"
                }
            ],
            "name": "checkUpkeepSinglePool",
            "outputs": [
                {
                    "internalType": "bool",
                    "name": "",
                    "type": "bool"
                }
            ],
            "stateMutability": "view",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "address",
                    "name": "",
                    "type": "address"
                }
            ],
            "name": "executionPrice",
            "outputs": [
                {
                    "internalType": "int256",
                    "name": "",
                    "type": "int256"
                }
            ],
            "stateMutability": "view",
            "type": "function"
        },
        {
            "inputs": [],
            "name": "factory",
            "outputs": [
                {
                    "internalType": "contract IPoolFactory",
                    "name": "",
                    "type": "address"
                }
            ],
            "stateMutability": "view",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "address",
                    "name": "_pool",
                    "type": "address"
                },
                {
                    "internalType": "uint256",
                    "name": "_gasPrice",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "_gasSpent",
                    "type": "uint256"
                }
            ],
            "name": "keeperGas",
            "outputs": [
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                }
            ],
            "stateMutability": "view",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "address",
                    "name": "_pool",
                    "type": "address"
                },
                {
                    "internalType": "uint256",
                    "name": "_gasPrice",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "_gasSpent",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "_savedPreviousUpdatedTimestamp",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "_poolInterval",
                    "type": "uint256"
                }
            ],
            "name": "keeperReward",
            "outputs": [
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                }
            ],
            "stateMutability": "view",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "uint256",
                    "name": "_savedPreviousUpdatedTimestamp",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "_poolInterval",
                    "type": "uint256"
                }
            ],
            "name": "keeperTip",
            "outputs": [
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                }
            ],
            "stateMutability": "view",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "address",
                    "name": "_poolAddress",
                    "type": "address"
                }
            ],
            "name": "newPool",
            "outputs": [],
            "stateMutability": "nonpayable",
            "type": "function"
        },
        {
            "inputs": [],
            "name": "owner",
            "outputs": [
                {
                    "internalType": "address",
                    "name": "",
                    "type": "address"
                }
            ],
            "stateMutability": "view",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "address[]",
                    "name": "pools",
                    "type": "address[]"
                }
            ],
            "name": "performUpkeepMultiplePools",
            "outputs": [],
            "stateMutability": "nonpayable",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "address",
                    "name": "_pool",
                    "type": "address"
                }
            ],
            "name": "performUpkeepSinglePool",
            "outputs": [],
            "stateMutability": "nonpayable",
            "type": "function"
        },
        {
            "inputs": [],
            "name": "renounceOwnership",
            "outputs": [],
            "stateMutability": "nonpayable",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "address",
                    "name": "_factory",
                    "type": "address"
                }
            ],
            "name": "setFactory",
            "outputs": [],
            "stateMutability": "nonpayable",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "address",
                    "name": "newOwner",
                    "type": "address"
                }
            ],
            "name": "transferOwnership",
            "outputs": [],
            "stateMutability": "nonpayable",
            "type": "function"
        }
    ],
    "transactionHash": "0x14fc4b17a74975424b5e61ea15b4c6e4a9cab3fb05ad032d9820185f076fa469",
    "receipt": {
        "to": null,
        "from": "0x8CDbEBeeE5B70749be0FAD211CaDA13BD07C9f9F",
        "contractAddress": "0x205Bfd2f07d69483a1a1ecC7a2174BBE3356485D",
        "transactionIndex": 10,
        "gasUsed": "3032826",
        "logsBloom": "0x00000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000000000001000000000000000000008000000000000000020000000000000000010800000000000000000000000000000000400000000000008000000000000000000100000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000",
        "blockHash": "0x99909394e26deb40a9bc97e7d6876c945c26dde32383feceec3d145192367b3d",
        "transactionHash": "0x14fc4b17a74975424b5e61ea15b4c6e4a9cab3fb05ad032d9820185f076fa469",
        "logs": [
            {
                "transactionIndex": 10,
                "blockNumber": 27001110,
                "transactionHash": "0x14fc4b17a74975424b5e61ea15b4c6e4a9cab3fb05ad032d9820185f076fa469",
                "address": "0x205Bfd2f07d69483a1a1ecC7a2174BBE3356485D",
                "topics": [
                    "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0",
                    "0x0000000000000000000000000000000000000000000000000000000000000000",
                    "0x0000000000000000000000008cdbebeee5b70749be0fad211cada13bd07c9f9f"
                ],
                "data": "0x",
                "logIndex": 38,
                "blockHash": "0x99909394e26deb40a9bc97e7d6876c945c26dde32383feceec3d145192367b3d"
            }
        ],
        "blockNumber": 27001110,
        "cumulativeGasUsed": "4334425",
        "status": 1,
        "byzantium": true
    },
    "args": ["0x24d73Dd9Aa5ca7C7eA59e5aB3B5f5BA9784733F5"],
    "solcInputHash": "fbe836eae600467d274908d7e5994f61",
    "metadata": "{\"compiler\":{\"version\":\"0.8.6+commit.11564f7e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"keeper\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"KeeperPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"keeper\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"expectedReward\",\"type\":\"uint256\"}],\"name\":\"KeeperPaymentError\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"poolAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"int256\",\"name\":\"firstPrice\",\"type\":\"int256\"}],\"name\":\"PoolAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"reason\",\"type\":\"string\"}],\"name\":\"PoolUpkeepError\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BASE_TIP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BLOCK_TIME\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_DECIMALS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TIP_DELTA_PER_BLOCK\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_pools\",\"type\":\"address[]\"}],\"name\":\"checkUpkeepMultiplePools\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"}],\"name\":\"checkUpkeepSinglePool\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"executionPrice\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"contract IPoolFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_gasPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_gasSpent\",\"type\":\"uint256\"}],\"name\":\"keeperGas\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_gasPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_gasSpent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_savedPreviousUpdatedTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_poolInterval\",\"type\":\"uint256\"}],\"name\":\"keeperReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_savedPreviousUpdatedTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_poolInterval\",\"type\":\"uint256\"}],\"name\":\"keeperTip\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_poolAddress\",\"type\":\"address\"}],\"name\":\"newPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"pools\",\"type\":\"address[]\"}],\"name\":\"performUpkeepMultiplePools\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"}],\"name\":\"performUpkeepSinglePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"}],\"name\":\"setFactory\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"checkUpkeepMultiplePools(address[])\":{\"params\":{\"_pools\":\"The array of pools to check\"},\"returns\":{\"_0\":\"upkeepNeeded Whether or not at least one pool needs upkeeping\"}},\"checkUpkeepSinglePool(address)\":{\"params\":{\"_pool\":\"The address of the pool to upkeep\"},\"returns\":{\"_0\":\"upkeepNeeded Whether or not upkeep is needed for this single pool\"}},\"keeperGas(address,uint256,uint256)\":{\"params\":{\"_gasPrice\":\"Price of a single gas unit (in ETH)\",\"_gasSpent\":\"Number of gas units spent\",\"_pool\":\"Address of the given pool\"},\"returns\":{\"_0\":\"Keeper's gas compensation\"}},\"keeperReward(address,uint256,uint256,uint256,uint256)\":{\"params\":{\"_gasPrice\":\"Price of a single gas unit (in ETH)\",\"_gasSpent\":\"Number of gas units spent\",\"_pool\":\"Address of the given pool\",\"_poolInterval\":\"Pool interval of the given pool\",\"_savedPreviousUpdatedTimestamp\":\"Last timestamp when the pool's price execution happened\"},\"returns\":{\"_0\":\"Number of settlement tokens to give to the keeper for work performed\"}},\"keeperTip(uint256,uint256)\":{\"params\":{\"_poolInterval\":\"Pool interval of the given pool\",\"_savedPreviousUpdatedTimestamp\":\"Last timestamp when the pool's price execution happened\"},\"returns\":{\"_0\":\"Percent of the `keeperGas` cost to add to payment, as a percent\"}},\"newPool(address)\":{\"params\":{\"_poolAddress\":\"The address of the newly-created pools\"}},\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"performUpkeepMultiplePools(address[])\":{\"params\":{\"pools\":\"pool codes to perform the update for\"}},\"performUpkeepSinglePool(address)\":{\"params\":{\"_pool\":\"The pool code to perform the update for\"}},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.\"},\"transferOwnership(address)\":{\"details\":\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\"}},\"title\":\"The manager contract for multiple markets and the pools in them\",\"version\":1},\"userdoc\":{\"events\":{\"KeeperPaid(address,address,uint256)\":{\"notice\":\"Creates a notification when a keeper is paid for doing upkeep for a pool\"},\"KeeperPaymentError(address,address,uint256)\":{\"notice\":\"Creates a notification when a keeper's payment for upkeeping a pool failed\"},\"PoolAdded(address,int256)\":{\"notice\":\"Creates a notification when a pool is created\"},\"PoolUpkeepError(address,string)\":{\"notice\":\"Creates a notification of a failed pool update\"}},\"kind\":\"user\",\"methods\":{\"checkUpkeepMultiplePools(address[])\":{\"notice\":\"Checks multiple pools if any of them need updating\"},\"checkUpkeepSinglePool(address)\":{\"notice\":\"Check if upkeep is required\"},\"executionPrice(address)\":{\"notice\":\"Format: Pool address => last executionPrice\"},\"keeperGas(address,uint256,uint256)\":{\"notice\":\"Compensation a keeper will receive for their gas expenditure\"},\"keeperReward(address,uint256,uint256,uint256,uint256)\":{\"notice\":\"Payment keeper receives for performing upkeep on a given pool\"},\"keeperTip(uint256,uint256)\":{\"notice\":\"Tip a keeper will receive for successfully updating the specified pool\"},\"newPool(address)\":{\"notice\":\"When a pool is created, this function is called by the factory to initiate price trackings\"},\"performUpkeepMultiplePools(address[])\":{\"notice\":\"Called by keepers to perform an update on multiple pools\"},\"performUpkeepSinglePool(address)\":{\"notice\":\"Called by keepers to perform an update on a single pool\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/implementation/PoolKeeper.sol\":\"PoolKeeper\"},\"evmVersion\":\"berlin\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[]},\"sources\":{\"@chainlink/contracts/src/v0.8/interfaces/AggregatorInterface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorInterface {\\n  function latestAnswer()\\n    external\\n    view\\n    returns (\\n      int256\\n    );\\n  \\n  function latestTimestamp()\\n    external\\n    view\\n    returns (\\n      uint256\\n    );\\n\\n  function latestRound()\\n    external\\n    view\\n    returns (\\n      uint256\\n    );\\n\\n  function getAnswer(\\n    uint256 roundId\\n  )\\n    external\\n    view\\n    returns (\\n      int256\\n    );\\n\\n  function getTimestamp(\\n    uint256 roundId\\n  )\\n    external\\n    view\\n    returns (\\n      uint256\\n    );\\n\\n  event AnswerUpdated(\\n    int256 indexed current,\\n    uint256 indexed roundId,\\n    uint256 updatedAt\\n  );\\n\\n  event NewRound(\\n    uint256 indexed roundId,\\n    address indexed startedBy,\\n    uint256 startedAt\\n  );\\n}\\n\",\"keccak256\":\"0x1a5dc81544a6479f64437a8aca22c869769dd54ee3522c7ef5ebae0d329a28f0\",\"license\":\"MIT\"},\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./AggregatorInterface.sol\\\";\\nimport \\\"./AggregatorV3Interface.sol\\\";\\n\\ninterface AggregatorV2V3Interface is AggregatorInterface, AggregatorV3Interface\\n{\\n}\\n\",\"keccak256\":\"0xe8f8d98b515366730824d24269c7267eee7f0288cf737db8659acbb0c751eb53\",\"license\":\"MIT\"},\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorV3Interface {\\n\\n  function decimals()\\n    external\\n    view\\n    returns (\\n      uint8\\n    );\\n\\n  function description()\\n    external\\n    view\\n    returns (\\n      string memory\\n    );\\n\\n  function version()\\n    external\\n    view\\n    returns (\\n      uint256\\n    );\\n\\n  // getRoundData and latestRoundData should both raise \\\"No data present\\\"\\n  // if they do not have data to report, instead of returning unset values\\n  // which could be misinterpreted as actual reported values.\\n  function getRoundData(\\n    uint80 _roundId\\n  )\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n}\\n\",\"keccak256\":\"0xe6f5ac8c47f3b9b6135051efb9216f9ba5b312a6ecc20209b4f66a780443c328\",\"license\":\"MIT\"},\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0x6bb804a310218875e89d12c053e94a13a4607cdf7cc2052f3e52bd32a0dc50a1\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/Clones.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\\n * deploying minimal proxy contracts, also known as \\\"clones\\\".\\n *\\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\\n *\\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\\n * deterministic method.\\n *\\n * _Available since v3.4._\\n */\\nlibrary Clones {\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create opcode, which should never revert.\\n     */\\n    function clone(address implementation) internal returns (address instance) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n            instance := create(0, ptr, 0x37)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create failed\\\");\\n    }\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\\n     * the clones cannot be deployed twice at the same address.\\n     */\\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n            instance := create2(0, ptr, 0x37, salt)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create2 failed\\\");\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\\n            mstore(add(ptr, 0x4c), salt)\\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\\n            predicted := keccak256(add(ptr, 0x37), 0x55)\\n        }\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(address implementation, bytes32 salt)\\n        internal\\n        view\\n        returns (address predicted)\\n    {\\n        return predictDeterministicAddress(implementation, salt, address(this));\\n    }\\n}\\n\",\"keccak256\":\"0xa3bbab77849522b73d8c6cd3d2ac54bef7580e4354484f35f4cabf55d3d2b3f9\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\",\"keccak256\":\"0x027b891937d20ccf213fdb9c31531574256de774bda99d3a70ecef6e1913ed2a\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0x95098bd1d9c8dec4d80d3dedb88a0d949fa0d740ee99f2aa466bc308216ca6d5\",\"license\":\"MIT\"},\"abdk-libraries-solidity/ABDKMathQuad.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-4-Clause\\n/*\\n * ABDK Math Quad Smart Contract Library.  Copyright \\u00a9 2019 by ABDK Consulting.\\n * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\\n */\\npragma solidity ^0.8.0;\\n\\n/**\\n * Smart contract library of mathematical functions operating with IEEE 754\\n * quadruple-precision binary floating-point numbers (quadruple precision\\n * numbers).  As long as quadruple precision numbers are 16-bytes long, they are\\n * represented by bytes16 type.\\n */\\nlibrary ABDKMathQuad {\\n  /*\\n   * 0.\\n   */\\n  bytes16 private constant POSITIVE_ZERO = 0x00000000000000000000000000000000;\\n\\n  /*\\n   * -0.\\n   */\\n  bytes16 private constant NEGATIVE_ZERO = 0x80000000000000000000000000000000;\\n\\n  /*\\n   * +Infinity.\\n   */\\n  bytes16 private constant POSITIVE_INFINITY = 0x7FFF0000000000000000000000000000;\\n\\n  /*\\n   * -Infinity.\\n   */\\n  bytes16 private constant NEGATIVE_INFINITY = 0xFFFF0000000000000000000000000000;\\n\\n  /*\\n   * Canonical NaN value.\\n   */\\n  bytes16 private constant NaN = 0x7FFF8000000000000000000000000000;\\n\\n  /**\\n   * Convert signed 256-bit integer number into quadruple precision number.\\n   *\\n   * @param x signed 256-bit integer number\\n   * @return quadruple precision number\\n   */\\n  function fromInt (int256 x) internal pure returns (bytes16) {\\n    unchecked {\\n      if (x == 0) return bytes16 (0);\\n      else {\\n        // We rely on overflow behavior here\\n        uint256 result = uint256 (x > 0 ? x : -x);\\n\\n        uint256 msb = mostSignificantBit (result);\\n        if (msb < 112) result <<= 112 - msb;\\n        else if (msb > 112) result >>= msb - 112;\\n\\n        result = result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF | 16383 + msb << 112;\\n        if (x < 0) result |= 0x80000000000000000000000000000000;\\n\\n        return bytes16 (uint128 (result));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert quadruple precision number into signed 256-bit integer number\\n   * rounding towards zero.  Revert on overflow.\\n   *\\n   * @param x quadruple precision number\\n   * @return signed 256-bit integer number\\n   */\\n  function toInt (bytes16 x) internal pure returns (int256) {\\n    unchecked {\\n      uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\\n\\n      require (exponent <= 16638); // Overflow\\n      if (exponent < 16383) return 0; // Underflow\\n\\n      uint256 result = uint256 (uint128 (x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF |\\n        0x10000000000000000000000000000;\\n\\n      if (exponent < 16495) result >>= 16495 - exponent;\\n      else if (exponent > 16495) result <<= exponent - 16495;\\n\\n      if (uint128 (x) >= 0x80000000000000000000000000000000) { // Negative\\n        require (result <= 0x8000000000000000000000000000000000000000000000000000000000000000);\\n        return -int256 (result); // We rely on overflow behavior here\\n      } else {\\n        require (result <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n        return int256 (result);\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert unsigned 256-bit integer number into quadruple precision number.\\n   *\\n   * @param x unsigned 256-bit integer number\\n   * @return quadruple precision number\\n   */\\n  function fromUInt (uint256 x) internal pure returns (bytes16) {\\n    unchecked {\\n      if (x == 0) return bytes16 (0);\\n      else {\\n        uint256 result = x;\\n\\n        uint256 msb = mostSignificantBit (result);\\n        if (msb < 112) result <<= 112 - msb;\\n        else if (msb > 112) result >>= msb - 112;\\n\\n        result = result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF | 16383 + msb << 112;\\n\\n        return bytes16 (uint128 (result));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert quadruple precision number into unsigned 256-bit integer number\\n   * rounding towards zero.  Revert on underflow.  Note, that negative floating\\n   * point numbers in range (-1.0 .. 0.0) may be converted to unsigned integer\\n   * without error, because they are rounded to zero.\\n   *\\n   * @param x quadruple precision number\\n   * @return unsigned 256-bit integer number\\n   */\\n  function toUInt (bytes16 x) internal pure returns (uint256) {\\n    unchecked {\\n      uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\\n\\n      if (exponent < 16383) return 0; // Underflow\\n\\n      require (uint128 (x) < 0x80000000000000000000000000000000); // Negative\\n\\n      require (exponent <= 16638); // Overflow\\n      uint256 result = uint256 (uint128 (x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF |\\n        0x10000000000000000000000000000;\\n\\n      if (exponent < 16495) result >>= 16495 - exponent;\\n      else if (exponent > 16495) result <<= exponent - 16495;\\n\\n      return result;\\n    }\\n  }\\n\\n  /**\\n   * Convert signed 128.128 bit fixed point number into quadruple precision\\n   * number.\\n   *\\n   * @param x signed 128.128 bit fixed point number\\n   * @return quadruple precision number\\n   */\\n  function from128x128 (int256 x) internal pure returns (bytes16) {\\n    unchecked {\\n      if (x == 0) return bytes16 (0);\\n      else {\\n        // We rely on overflow behavior here\\n        uint256 result = uint256 (x > 0 ? x : -x);\\n\\n        uint256 msb = mostSignificantBit (result);\\n        if (msb < 112) result <<= 112 - msb;\\n        else if (msb > 112) result >>= msb - 112;\\n\\n        result = result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF | 16255 + msb << 112;\\n        if (x < 0) result |= 0x80000000000000000000000000000000;\\n\\n        return bytes16 (uint128 (result));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert quadruple precision number into signed 128.128 bit fixed point\\n   * number.  Revert on overflow.\\n   *\\n   * @param x quadruple precision number\\n   * @return signed 128.128 bit fixed point number\\n   */\\n  function to128x128 (bytes16 x) internal pure returns (int256) {\\n    unchecked {\\n      uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\\n\\n      require (exponent <= 16510); // Overflow\\n      if (exponent < 16255) return 0; // Underflow\\n\\n      uint256 result = uint256 (uint128 (x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF |\\n        0x10000000000000000000000000000;\\n\\n      if (exponent < 16367) result >>= 16367 - exponent;\\n      else if (exponent > 16367) result <<= exponent - 16367;\\n\\n      if (uint128 (x) >= 0x80000000000000000000000000000000) { // Negative\\n        require (result <= 0x8000000000000000000000000000000000000000000000000000000000000000);\\n        return -int256 (result); // We rely on overflow behavior here\\n      } else {\\n        require (result <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n        return int256 (result);\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert signed 64.64 bit fixed point number into quadruple precision\\n   * number.\\n   *\\n   * @param x signed 64.64 bit fixed point number\\n   * @return quadruple precision number\\n   */\\n  function from64x64 (int128 x) internal pure returns (bytes16) {\\n    unchecked {\\n      if (x == 0) return bytes16 (0);\\n      else {\\n        // We rely on overflow behavior here\\n        uint256 result = uint128 (x > 0 ? x : -x);\\n\\n        uint256 msb = mostSignificantBit (result);\\n        if (msb < 112) result <<= 112 - msb;\\n        else if (msb > 112) result >>= msb - 112;\\n\\n        result = result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF | 16319 + msb << 112;\\n        if (x < 0) result |= 0x80000000000000000000000000000000;\\n\\n        return bytes16 (uint128 (result));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert quadruple precision number into signed 64.64 bit fixed point\\n   * number.  Revert on overflow.\\n   *\\n   * @param x quadruple precision number\\n   * @return signed 64.64 bit fixed point number\\n   */\\n  function to64x64 (bytes16 x) internal pure returns (int128) {\\n    unchecked {\\n      uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\\n\\n      require (exponent <= 16446); // Overflow\\n      if (exponent < 16319) return 0; // Underflow\\n\\n      uint256 result = uint256 (uint128 (x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF |\\n        0x10000000000000000000000000000;\\n\\n      if (exponent < 16431) result >>= 16431 - exponent;\\n      else if (exponent > 16431) result <<= exponent - 16431;\\n\\n      if (uint128 (x) >= 0x80000000000000000000000000000000) { // Negative\\n        require (result <= 0x80000000000000000000000000000000);\\n        return -int128 (int256 (result)); // We rely on overflow behavior here\\n      } else {\\n        require (result <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n        return int128 (int256 (result));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert octuple precision number into quadruple precision number.\\n   *\\n   * @param x octuple precision number\\n   * @return quadruple precision number\\n   */\\n  function fromOctuple (bytes32 x) internal pure returns (bytes16) {\\n    unchecked {\\n      bool negative = x & 0x8000000000000000000000000000000000000000000000000000000000000000 > 0;\\n\\n      uint256 exponent = uint256 (x) >> 236 & 0x7FFFF;\\n      uint256 significand = uint256 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      if (exponent == 0x7FFFF) {\\n        if (significand > 0) return NaN;\\n        else return negative ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\\n      }\\n\\n      if (exponent > 278526)\\n        return negative ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\\n      else if (exponent < 245649)\\n        return negative ? NEGATIVE_ZERO : POSITIVE_ZERO;\\n      else if (exponent < 245761) {\\n        significand = (significand | 0x100000000000000000000000000000000000000000000000000000000000) >> 245885 - exponent;\\n        exponent = 0;\\n      } else {\\n        significand >>= 124;\\n        exponent -= 245760;\\n      }\\n\\n      uint128 result = uint128 (significand | exponent << 112);\\n      if (negative) result |= 0x80000000000000000000000000000000;\\n\\n      return bytes16 (result);\\n    }\\n  }\\n\\n  /**\\n   * Convert quadruple precision number into octuple precision number.\\n   *\\n   * @param x quadruple precision number\\n   * @return octuple precision number\\n   */\\n  function toOctuple (bytes16 x) internal pure returns (bytes32) {\\n    unchecked {\\n      uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\\n\\n      uint256 result = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      if (exponent == 0x7FFF) exponent = 0x7FFFF; // Infinity or NaN\\n      else if (exponent == 0) {\\n        if (result > 0) {\\n          uint256 msb = mostSignificantBit (result);\\n          result = result << 236 - msb & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n          exponent = 245649 + msb;\\n        }\\n      } else {\\n        result <<= 124;\\n        exponent += 245760;\\n      }\\n\\n      result |= exponent << 236;\\n      if (uint128 (x) >= 0x80000000000000000000000000000000)\\n        result |= 0x8000000000000000000000000000000000000000000000000000000000000000;\\n\\n      return bytes32 (result);\\n    }\\n  }\\n\\n  /**\\n   * Convert double precision number into quadruple precision number.\\n   *\\n   * @param x double precision number\\n   * @return quadruple precision number\\n   */\\n  function fromDouble (bytes8 x) internal pure returns (bytes16) {\\n    unchecked {\\n      uint256 exponent = uint64 (x) >> 52 & 0x7FF;\\n\\n      uint256 result = uint64 (x) & 0xFFFFFFFFFFFFF;\\n\\n      if (exponent == 0x7FF) exponent = 0x7FFF; // Infinity or NaN\\n      else if (exponent == 0) {\\n        if (result > 0) {\\n          uint256 msb = mostSignificantBit (result);\\n          result = result << 112 - msb & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n          exponent = 15309 + msb;\\n        }\\n      } else {\\n        result <<= 60;\\n        exponent += 15360;\\n      }\\n\\n      result |= exponent << 112;\\n      if (x & 0x8000000000000000 > 0)\\n        result |= 0x80000000000000000000000000000000;\\n\\n      return bytes16 (uint128 (result));\\n    }\\n  }\\n\\n  /**\\n   * Convert quadruple precision number into double precision number.\\n   *\\n   * @param x quadruple precision number\\n   * @return double precision number\\n   */\\n  function toDouble (bytes16 x) internal pure returns (bytes8) {\\n    unchecked {\\n      bool negative = uint128 (x) >= 0x80000000000000000000000000000000;\\n\\n      uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\\n      uint256 significand = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      if (exponent == 0x7FFF) {\\n        if (significand > 0) return 0x7FF8000000000000; // NaN\\n        else return negative ?\\n            bytes8 (0xFFF0000000000000) : // -Infinity\\n            bytes8 (0x7FF0000000000000); // Infinity\\n      }\\n\\n      if (exponent > 17406)\\n        return negative ?\\n            bytes8 (0xFFF0000000000000) : // -Infinity\\n            bytes8 (0x7FF0000000000000); // Infinity\\n      else if (exponent < 15309)\\n        return negative ?\\n            bytes8 (0x8000000000000000) : // -0\\n            bytes8 (0x0000000000000000); // 0\\n      else if (exponent < 15361) {\\n        significand = (significand | 0x10000000000000000000000000000) >> 15421 - exponent;\\n        exponent = 0;\\n      } else {\\n        significand >>= 60;\\n        exponent -= 15360;\\n      }\\n\\n      uint64 result = uint64 (significand | exponent << 52);\\n      if (negative) result |= 0x8000000000000000;\\n\\n      return bytes8 (result);\\n    }\\n  }\\n\\n  /**\\n   * Test whether given quadruple precision number is NaN.\\n   *\\n   * @param x quadruple precision number\\n   * @return true if x is NaN, false otherwise\\n   */\\n  function isNaN (bytes16 x) internal pure returns (bool) {\\n    unchecked {\\n      return uint128 (x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF >\\n        0x7FFF0000000000000000000000000000;\\n    }\\n  }\\n\\n  /**\\n   * Test whether given quadruple precision number is positive or negative\\n   * infinity.\\n   *\\n   * @param x quadruple precision number\\n   * @return true if x is positive or negative infinity, false otherwise\\n   */\\n  function isInfinity (bytes16 x) internal pure returns (bool) {\\n    unchecked {\\n      return uint128 (x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF ==\\n        0x7FFF0000000000000000000000000000;\\n    }\\n  }\\n\\n  /**\\n   * Calculate sign of x, i.e. -1 if x is negative, 0 if x if zero, and 1 if x\\n   * is positive.  Note that sign (-0) is zero.  Revert if x is NaN. \\n   *\\n   * @param x quadruple precision number\\n   * @return sign of x\\n   */\\n  function sign (bytes16 x) internal pure returns (int8) {\\n    unchecked {\\n      uint128 absoluteX = uint128 (x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      require (absoluteX <= 0x7FFF0000000000000000000000000000); // Not NaN\\n\\n      if (absoluteX == 0) return 0;\\n      else if (uint128 (x) >= 0x80000000000000000000000000000000) return -1;\\n      else return 1;\\n    }\\n  }\\n\\n  /**\\n   * Calculate sign (x - y).  Revert if either argument is NaN, or both\\n   * arguments are infinities of the same sign. \\n   *\\n   * @param x quadruple precision number\\n   * @param y quadruple precision number\\n   * @return sign (x - y)\\n   */\\n  function cmp (bytes16 x, bytes16 y) internal pure returns (int8) {\\n    unchecked {\\n      uint128 absoluteX = uint128 (x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      require (absoluteX <= 0x7FFF0000000000000000000000000000); // Not NaN\\n\\n      uint128 absoluteY = uint128 (y) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      require (absoluteY <= 0x7FFF0000000000000000000000000000); // Not NaN\\n\\n      // Not infinities of the same sign\\n      require (x != y || absoluteX < 0x7FFF0000000000000000000000000000);\\n\\n      if (x == y) return 0;\\n      else {\\n        bool negativeX = uint128 (x) >= 0x80000000000000000000000000000000;\\n        bool negativeY = uint128 (y) >= 0x80000000000000000000000000000000;\\n\\n        if (negativeX) {\\n          if (negativeY) return absoluteX > absoluteY ? -1 : int8 (1);\\n          else return -1; \\n        } else {\\n          if (negativeY) return 1;\\n          else return absoluteX > absoluteY ? int8 (1) : -1;\\n        }\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Test whether x equals y.  NaN, infinity, and -infinity are not equal to\\n   * anything. \\n   *\\n   * @param x quadruple precision number\\n   * @param y quadruple precision number\\n   * @return true if x equals to y, false otherwise\\n   */\\n  function eq (bytes16 x, bytes16 y) internal pure returns (bool) {\\n    unchecked {\\n      if (x == y) {\\n        return uint128 (x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF <\\n          0x7FFF0000000000000000000000000000;\\n      } else return false;\\n    }\\n  }\\n\\n  /**\\n   * Calculate x + y.  Special values behave in the following way:\\n   *\\n   * NaN + x = NaN for any x.\\n   * Infinity + x = Infinity for any finite x.\\n   * -Infinity + x = -Infinity for any finite x.\\n   * Infinity + Infinity = Infinity.\\n   * -Infinity + -Infinity = -Infinity.\\n   * Infinity + -Infinity = -Infinity + Infinity = NaN.\\n   *\\n   * @param x quadruple precision number\\n   * @param y quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function add (bytes16 x, bytes16 y) internal pure returns (bytes16) {\\n    unchecked {\\n      uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\\n      uint256 yExponent = uint128 (y) >> 112 & 0x7FFF;\\n\\n      if (xExponent == 0x7FFF) {\\n        if (yExponent == 0x7FFF) { \\n          if (x == y) return x;\\n          else return NaN;\\n        } else return x; \\n      } else if (yExponent == 0x7FFF) return y;\\n      else {\\n        bool xSign = uint128 (x) >= 0x80000000000000000000000000000000;\\n        uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (xExponent == 0) xExponent = 1;\\n        else xSignifier |= 0x10000000000000000000000000000;\\n\\n        bool ySign = uint128 (y) >= 0x80000000000000000000000000000000;\\n        uint256 ySignifier = uint128 (y) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (yExponent == 0) yExponent = 1;\\n        else ySignifier |= 0x10000000000000000000000000000;\\n\\n        if (xSignifier == 0) return y == NEGATIVE_ZERO ? POSITIVE_ZERO : y;\\n        else if (ySignifier == 0) return x == NEGATIVE_ZERO ? POSITIVE_ZERO : x;\\n        else {\\n          int256 delta = int256 (xExponent) - int256 (yExponent);\\n  \\n          if (xSign == ySign) {\\n            if (delta > 112) return x;\\n            else if (delta > 0) ySignifier >>= uint256 (delta);\\n            else if (delta < -112) return y;\\n            else if (delta < 0) {\\n              xSignifier >>= uint256 (-delta);\\n              xExponent = yExponent;\\n            }\\n  \\n            xSignifier += ySignifier;\\n  \\n            if (xSignifier >= 0x20000000000000000000000000000) {\\n              xSignifier >>= 1;\\n              xExponent += 1;\\n            }\\n  \\n            if (xExponent == 0x7FFF)\\n              return xSign ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\\n            else {\\n              if (xSignifier < 0x10000000000000000000000000000) xExponent = 0;\\n              else xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n  \\n              return bytes16 (uint128 (\\n                  (xSign ? 0x80000000000000000000000000000000 : 0) |\\n                  (xExponent << 112) |\\n                  xSignifier)); \\n            }\\n          } else {\\n            if (delta > 0) {\\n              xSignifier <<= 1;\\n              xExponent -= 1;\\n            } else if (delta < 0) {\\n              ySignifier <<= 1;\\n              xExponent = yExponent - 1;\\n            }\\n\\n            if (delta > 112) ySignifier = 1;\\n            else if (delta > 1) ySignifier = (ySignifier - 1 >> uint256 (delta - 1)) + 1;\\n            else if (delta < -112) xSignifier = 1;\\n            else if (delta < -1) xSignifier = (xSignifier - 1 >> uint256 (-delta - 1)) + 1;\\n\\n            if (xSignifier >= ySignifier) xSignifier -= ySignifier;\\n            else {\\n              xSignifier = ySignifier - xSignifier;\\n              xSign = ySign;\\n            }\\n\\n            if (xSignifier == 0)\\n              return POSITIVE_ZERO;\\n\\n            uint256 msb = mostSignificantBit (xSignifier);\\n\\n            if (msb == 113) {\\n              xSignifier = xSignifier >> 1 & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n              xExponent += 1;\\n            } else if (msb < 112) {\\n              uint256 shift = 112 - msb;\\n              if (xExponent > shift) {\\n                xSignifier = xSignifier << shift & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n                xExponent -= shift;\\n              } else {\\n                xSignifier <<= xExponent - 1;\\n                xExponent = 0;\\n              }\\n            } else xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n            if (xExponent == 0x7FFF)\\n              return xSign ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\\n            else return bytes16 (uint128 (\\n                (xSign ? 0x80000000000000000000000000000000 : 0) |\\n                (xExponent << 112) |\\n                xSignifier));\\n          }\\n        }\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate x - y.  Special values behave in the following way:\\n   *\\n   * NaN - x = NaN for any x.\\n   * Infinity - x = Infinity for any finite x.\\n   * -Infinity - x = -Infinity for any finite x.\\n   * Infinity - -Infinity = Infinity.\\n   * -Infinity - Infinity = -Infinity.\\n   * Infinity - Infinity = -Infinity - -Infinity = NaN.\\n   *\\n   * @param x quadruple precision number\\n   * @param y quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function sub (bytes16 x, bytes16 y) internal pure returns (bytes16) {\\n    unchecked {\\n      return add (x, y ^ 0x80000000000000000000000000000000);\\n    }\\n  }\\n\\n  /**\\n   * Calculate x * y.  Special values behave in the following way:\\n   *\\n   * NaN * x = NaN for any x.\\n   * Infinity * x = Infinity for any finite positive x.\\n   * Infinity * x = -Infinity for any finite negative x.\\n   * -Infinity * x = -Infinity for any finite positive x.\\n   * -Infinity * x = Infinity for any finite negative x.\\n   * Infinity * 0 = NaN.\\n   * -Infinity * 0 = NaN.\\n   * Infinity * Infinity = Infinity.\\n   * Infinity * -Infinity = -Infinity.\\n   * -Infinity * Infinity = -Infinity.\\n   * -Infinity * -Infinity = Infinity.\\n   *\\n   * @param x quadruple precision number\\n   * @param y quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function mul (bytes16 x, bytes16 y) internal pure returns (bytes16) {\\n    unchecked {\\n      uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\\n      uint256 yExponent = uint128 (y) >> 112 & 0x7FFF;\\n\\n      if (xExponent == 0x7FFF) {\\n        if (yExponent == 0x7FFF) {\\n          if (x == y) return x ^ y & 0x80000000000000000000000000000000;\\n          else if (x ^ y == 0x80000000000000000000000000000000) return x | y;\\n          else return NaN;\\n        } else {\\n          if (y & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) return NaN;\\n          else return x ^ y & 0x80000000000000000000000000000000;\\n        }\\n      } else if (yExponent == 0x7FFF) {\\n          if (x & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) return NaN;\\n          else return y ^ x & 0x80000000000000000000000000000000;\\n      } else {\\n        uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (xExponent == 0) xExponent = 1;\\n        else xSignifier |= 0x10000000000000000000000000000;\\n\\n        uint256 ySignifier = uint128 (y) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (yExponent == 0) yExponent = 1;\\n        else ySignifier |= 0x10000000000000000000000000000;\\n\\n        xSignifier *= ySignifier;\\n        if (xSignifier == 0)\\n          return (x ^ y) & 0x80000000000000000000000000000000 > 0 ?\\n              NEGATIVE_ZERO : POSITIVE_ZERO;\\n\\n        xExponent += yExponent;\\n\\n        uint256 msb =\\n          xSignifier >= 0x200000000000000000000000000000000000000000000000000000000 ? 225 :\\n          xSignifier >= 0x100000000000000000000000000000000000000000000000000000000 ? 224 :\\n          mostSignificantBit (xSignifier);\\n\\n        if (xExponent + msb < 16496) { // Underflow\\n          xExponent = 0;\\n          xSignifier = 0;\\n        } else if (xExponent + msb < 16608) { // Subnormal\\n          if (xExponent < 16496)\\n            xSignifier >>= 16496 - xExponent;\\n          else if (xExponent > 16496)\\n            xSignifier <<= xExponent - 16496;\\n          xExponent = 0;\\n        } else if (xExponent + msb > 49373) {\\n          xExponent = 0x7FFF;\\n          xSignifier = 0;\\n        } else {\\n          if (msb > 112)\\n            xSignifier >>= msb - 112;\\n          else if (msb < 112)\\n            xSignifier <<= 112 - msb;\\n\\n          xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n          xExponent = xExponent + msb - 16607;\\n        }\\n\\n        return bytes16 (uint128 (uint128 ((x ^ y) & 0x80000000000000000000000000000000) |\\n            xExponent << 112 | xSignifier));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate x / y.  Special values behave in the following way:\\n   *\\n   * NaN / x = NaN for any x.\\n   * x / NaN = NaN for any x.\\n   * Infinity / x = Infinity for any finite non-negative x.\\n   * Infinity / x = -Infinity for any finite negative x including -0.\\n   * -Infinity / x = -Infinity for any finite non-negative x.\\n   * -Infinity / x = Infinity for any finite negative x including -0.\\n   * x / Infinity = 0 for any finite non-negative x.\\n   * x / -Infinity = -0 for any finite non-negative x.\\n   * x / Infinity = -0 for any finite non-negative x including -0.\\n   * x / -Infinity = 0 for any finite non-negative x including -0.\\n   * \\n   * Infinity / Infinity = NaN.\\n   * Infinity / -Infinity = -NaN.\\n   * -Infinity / Infinity = -NaN.\\n   * -Infinity / -Infinity = NaN.\\n   *\\n   * Division by zero behaves in the following way:\\n   *\\n   * x / 0 = Infinity for any finite positive x.\\n   * x / -0 = -Infinity for any finite positive x.\\n   * x / 0 = -Infinity for any finite negative x.\\n   * x / -0 = Infinity for any finite negative x.\\n   * 0 / 0 = NaN.\\n   * 0 / -0 = NaN.\\n   * -0 / 0 = NaN.\\n   * -0 / -0 = NaN.\\n   *\\n   * @param x quadruple precision number\\n   * @param y quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function div (bytes16 x, bytes16 y) internal pure returns (bytes16) {\\n    unchecked {\\n      uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\\n      uint256 yExponent = uint128 (y) >> 112 & 0x7FFF;\\n\\n      if (xExponent == 0x7FFF) {\\n        if (yExponent == 0x7FFF) return NaN;\\n        else return x ^ y & 0x80000000000000000000000000000000;\\n      } else if (yExponent == 0x7FFF) {\\n        if (y & 0x0000FFFFFFFFFFFFFFFFFFFFFFFFFFFF != 0) return NaN;\\n        else return POSITIVE_ZERO | (x ^ y) & 0x80000000000000000000000000000000;\\n      } else if (y & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) {\\n        if (x & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) return NaN;\\n        else return POSITIVE_INFINITY | (x ^ y) & 0x80000000000000000000000000000000;\\n      } else {\\n        uint256 ySignifier = uint128 (y) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (yExponent == 0) yExponent = 1;\\n        else ySignifier |= 0x10000000000000000000000000000;\\n\\n        uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (xExponent == 0) {\\n          if (xSignifier != 0) {\\n            uint shift = 226 - mostSignificantBit (xSignifier);\\n\\n            xSignifier <<= shift;\\n\\n            xExponent = 1;\\n            yExponent += shift - 114;\\n          }\\n        }\\n        else {\\n          xSignifier = (xSignifier | 0x10000000000000000000000000000) << 114;\\n        }\\n\\n        xSignifier = xSignifier / ySignifier;\\n        if (xSignifier == 0)\\n          return (x ^ y) & 0x80000000000000000000000000000000 > 0 ?\\n              NEGATIVE_ZERO : POSITIVE_ZERO;\\n\\n        assert (xSignifier >= 0x1000000000000000000000000000);\\n\\n        uint256 msb =\\n          xSignifier >= 0x80000000000000000000000000000 ? mostSignificantBit (xSignifier) :\\n          xSignifier >= 0x40000000000000000000000000000 ? 114 :\\n          xSignifier >= 0x20000000000000000000000000000 ? 113 : 112;\\n\\n        if (xExponent + msb > yExponent + 16497) { // Overflow\\n          xExponent = 0x7FFF;\\n          xSignifier = 0;\\n        } else if (xExponent + msb + 16380  < yExponent) { // Underflow\\n          xExponent = 0;\\n          xSignifier = 0;\\n        } else if (xExponent + msb + 16268  < yExponent) { // Subnormal\\n          if (xExponent + 16380 > yExponent)\\n            xSignifier <<= xExponent + 16380 - yExponent;\\n          else if (xExponent + 16380 < yExponent)\\n            xSignifier >>= yExponent - xExponent - 16380;\\n\\n          xExponent = 0;\\n        } else { // Normal\\n          if (msb > 112)\\n            xSignifier >>= msb - 112;\\n\\n          xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n          xExponent = xExponent + msb + 16269 - yExponent;\\n        }\\n\\n        return bytes16 (uint128 (uint128 ((x ^ y) & 0x80000000000000000000000000000000) |\\n            xExponent << 112 | xSignifier));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate -x.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function neg (bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      return x ^ 0x80000000000000000000000000000000;\\n    }\\n  }\\n\\n  /**\\n   * Calculate |x|.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function abs (bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      return x & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n    }\\n  }\\n\\n  /**\\n   * Calculate square root of x.  Return NaN on negative x excluding -0.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function sqrt (bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      if (uint128 (x) >  0x80000000000000000000000000000000) return NaN;\\n      else {\\n        uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\\n        if (xExponent == 0x7FFF) return x;\\n        else {\\n          uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n          if (xExponent == 0) xExponent = 1;\\n          else xSignifier |= 0x10000000000000000000000000000;\\n\\n          if (xSignifier == 0) return POSITIVE_ZERO;\\n\\n          bool oddExponent = xExponent & 0x1 == 0;\\n          xExponent = xExponent + 16383 >> 1;\\n\\n          if (oddExponent) {\\n            if (xSignifier >= 0x10000000000000000000000000000)\\n              xSignifier <<= 113;\\n            else {\\n              uint256 msb = mostSignificantBit (xSignifier);\\n              uint256 shift = (226 - msb) & 0xFE;\\n              xSignifier <<= shift;\\n              xExponent -= shift - 112 >> 1;\\n            }\\n          } else {\\n            if (xSignifier >= 0x10000000000000000000000000000)\\n              xSignifier <<= 112;\\n            else {\\n              uint256 msb = mostSignificantBit (xSignifier);\\n              uint256 shift = (225 - msb) & 0xFE;\\n              xSignifier <<= shift;\\n              xExponent -= shift - 112 >> 1;\\n            }\\n          }\\n\\n          uint256 r = 0x10000000000000000000000000000;\\n          r = (r + xSignifier / r) >> 1;\\n          r = (r + xSignifier / r) >> 1;\\n          r = (r + xSignifier / r) >> 1;\\n          r = (r + xSignifier / r) >> 1;\\n          r = (r + xSignifier / r) >> 1;\\n          r = (r + xSignifier / r) >> 1;\\n          r = (r + xSignifier / r) >> 1; // Seven iterations should be enough\\n          uint256 r1 = xSignifier / r;\\n          if (r1 < r) r = r1;\\n\\n          return bytes16 (uint128 (xExponent << 112 | r & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF));\\n        }\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate binary logarithm of x.  Return NaN on negative x excluding -0.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function log_2 (bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      if (uint128 (x) > 0x80000000000000000000000000000000) return NaN;\\n      else if (x == 0x3FFF0000000000000000000000000000) return POSITIVE_ZERO; \\n      else {\\n        uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\\n        if (xExponent == 0x7FFF) return x;\\n        else {\\n          uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n          if (xExponent == 0) xExponent = 1;\\n          else xSignifier |= 0x10000000000000000000000000000;\\n\\n          if (xSignifier == 0) return NEGATIVE_INFINITY;\\n\\n          bool resultNegative;\\n          uint256 resultExponent = 16495;\\n          uint256 resultSignifier;\\n\\n          if (xExponent >= 0x3FFF) {\\n            resultNegative = false;\\n            resultSignifier = xExponent - 0x3FFF;\\n            xSignifier <<= 15;\\n          } else {\\n            resultNegative = true;\\n            if (xSignifier >= 0x10000000000000000000000000000) {\\n              resultSignifier = 0x3FFE - xExponent;\\n              xSignifier <<= 15;\\n            } else {\\n              uint256 msb = mostSignificantBit (xSignifier);\\n              resultSignifier = 16493 - msb;\\n              xSignifier <<= 127 - msb;\\n            }\\n          }\\n\\n          if (xSignifier == 0x80000000000000000000000000000000) {\\n            if (resultNegative) resultSignifier += 1;\\n            uint256 shift = 112 - mostSignificantBit (resultSignifier);\\n            resultSignifier <<= shift;\\n            resultExponent -= shift;\\n          } else {\\n            uint256 bb = resultNegative ? 1 : 0;\\n            while (resultSignifier < 0x10000000000000000000000000000) {\\n              resultSignifier <<= 1;\\n              resultExponent -= 1;\\n  \\n              xSignifier *= xSignifier;\\n              uint256 b = xSignifier >> 255;\\n              resultSignifier += b ^ bb;\\n              xSignifier >>= 127 + b;\\n            }\\n          }\\n\\n          return bytes16 (uint128 ((resultNegative ? 0x80000000000000000000000000000000 : 0) |\\n              resultExponent << 112 | resultSignifier & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF));\\n        }\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate natural logarithm of x.  Return NaN on negative x excluding -0.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function ln (bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      return mul (log_2 (x), 0x3FFE62E42FEFA39EF35793C7673007E5);\\n    }\\n  }\\n\\n  /**\\n   * Calculate 2^x.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function pow_2 (bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      bool xNegative = uint128 (x) > 0x80000000000000000000000000000000;\\n      uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\\n      uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      if (xExponent == 0x7FFF && xSignifier != 0) return NaN;\\n      else if (xExponent > 16397)\\n        return xNegative ? POSITIVE_ZERO : POSITIVE_INFINITY;\\n      else if (xExponent < 16255)\\n        return 0x3FFF0000000000000000000000000000;\\n      else {\\n        if (xExponent == 0) xExponent = 1;\\n        else xSignifier |= 0x10000000000000000000000000000;\\n\\n        if (xExponent > 16367)\\n          xSignifier <<= xExponent - 16367;\\n        else if (xExponent < 16367)\\n          xSignifier >>= 16367 - xExponent;\\n\\n        if (xNegative && xSignifier > 0x406E00000000000000000000000000000000)\\n          return POSITIVE_ZERO;\\n\\n        if (!xNegative && xSignifier > 0x3FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\\n          return POSITIVE_INFINITY;\\n\\n        uint256 resultExponent = xSignifier >> 128;\\n        xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (xNegative && xSignifier != 0) {\\n          xSignifier = ~xSignifier;\\n          resultExponent += 1;\\n        }\\n\\n        uint256 resultSignifier = 0x80000000000000000000000000000000;\\n        if (xSignifier & 0x80000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x16A09E667F3BCC908B2FB1366EA957D3E >> 128;\\n        if (xSignifier & 0x40000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1306FE0A31B7152DE8D5A46305C85EDEC >> 128;\\n        if (xSignifier & 0x20000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1172B83C7D517ADCDF7C8C50EB14A791F >> 128;\\n        if (xSignifier & 0x10000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10B5586CF9890F6298B92B71842A98363 >> 128;\\n        if (xSignifier & 0x8000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1059B0D31585743AE7C548EB68CA417FD >> 128;\\n        if (xSignifier & 0x4000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x102C9A3E778060EE6F7CACA4F7A29BDE8 >> 128;\\n        if (xSignifier & 0x2000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10163DA9FB33356D84A66AE336DCDFA3F >> 128;\\n        if (xSignifier & 0x1000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100B1AFA5ABCBED6129AB13EC11DC9543 >> 128;\\n        if (xSignifier & 0x800000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10058C86DA1C09EA1FF19D294CF2F679B >> 128;\\n        if (xSignifier & 0x400000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1002C605E2E8CEC506D21BFC89A23A00F >> 128;\\n        if (xSignifier & 0x200000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100162F3904051FA128BCA9C55C31E5DF >> 128;\\n        if (xSignifier & 0x100000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000B175EFFDC76BA38E31671CA939725 >> 128;\\n        if (xSignifier & 0x80000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100058BA01FB9F96D6CACD4B180917C3D >> 128;\\n        if (xSignifier & 0x40000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10002C5CC37DA9491D0985C348C68E7B3 >> 128;\\n        if (xSignifier & 0x20000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000162E525EE054754457D5995292026 >> 128;\\n        if (xSignifier & 0x10000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000B17255775C040618BF4A4ADE83FC >> 128;\\n        if (xSignifier & 0x8000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000058B91B5BC9AE2EED81E9B7D4CFAB >> 128;\\n        if (xSignifier & 0x4000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100002C5C89D5EC6CA4D7C8ACC017B7C9 >> 128;\\n        if (xSignifier & 0x2000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000162E43F4F831060E02D839A9D16D >> 128;\\n        if (xSignifier & 0x1000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000B1721BCFC99D9F890EA06911763 >> 128;\\n        if (xSignifier & 0x800000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000058B90CF1E6D97F9CA14DBCC1628 >> 128;\\n        if (xSignifier & 0x400000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000002C5C863B73F016468F6BAC5CA2B >> 128;\\n        if (xSignifier & 0x200000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000162E430E5A18F6119E3C02282A5 >> 128;\\n        if (xSignifier & 0x100000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000B1721835514B86E6D96EFD1BFE >> 128;\\n        if (xSignifier & 0x80000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000058B90C0B48C6BE5DF846C5B2EF >> 128;\\n        if (xSignifier & 0x40000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000002C5C8601CC6B9E94213C72737A >> 128;\\n        if (xSignifier & 0x20000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000162E42FFF037DF38AA2B219F06 >> 128;\\n        if (xSignifier & 0x10000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000B17217FBA9C739AA5819F44F9 >> 128;\\n        if (xSignifier & 0x8000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000058B90BFCDEE5ACD3C1CEDC823 >> 128;\\n        if (xSignifier & 0x4000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000002C5C85FE31F35A6A30DA1BE50 >> 128;\\n        if (xSignifier & 0x2000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000162E42FF0999CE3541B9FFFCF >> 128;\\n        if (xSignifier & 0x1000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000B17217F80F4EF5AADDA45554 >> 128;\\n        if (xSignifier & 0x800000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000058B90BFBF8479BD5A81B51AD >> 128;\\n        if (xSignifier & 0x400000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000002C5C85FDF84BD62AE30A74CC >> 128;\\n        if (xSignifier & 0x200000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000162E42FEFB2FED257559BDAA >> 128;\\n        if (xSignifier & 0x100000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000B17217F7D5A7716BBA4A9AE >> 128;\\n        if (xSignifier & 0x80000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000058B90BFBE9DDBAC5E109CCE >> 128;\\n        if (xSignifier & 0x40000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000002C5C85FDF4B15DE6F17EB0D >> 128;\\n        if (xSignifier & 0x20000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000162E42FEFA494F1478FDE05 >> 128;\\n        if (xSignifier & 0x10000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000B17217F7D20CF927C8E94C >> 128;\\n        if (xSignifier & 0x8000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000058B90BFBE8F71CB4E4B33D >> 128;\\n        if (xSignifier & 0x4000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000002C5C85FDF477B662B26945 >> 128;\\n        if (xSignifier & 0x2000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000162E42FEFA3AE53369388C >> 128;\\n        if (xSignifier & 0x1000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000B17217F7D1D351A389D40 >> 128;\\n        if (xSignifier & 0x800000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000058B90BFBE8E8B2D3D4EDE >> 128;\\n        if (xSignifier & 0x400000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000002C5C85FDF4741BEA6E77E >> 128;\\n        if (xSignifier & 0x200000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000162E42FEFA39FE95583C2 >> 128;\\n        if (xSignifier & 0x100000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000B17217F7D1CFB72B45E1 >> 128;\\n        if (xSignifier & 0x80000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000058B90BFBE8E7CC35C3F0 >> 128;\\n        if (xSignifier & 0x40000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000002C5C85FDF473E242EA38 >> 128;\\n        if (xSignifier & 0x20000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000162E42FEFA39F02B772C >> 128;\\n        if (xSignifier & 0x10000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000B17217F7D1CF7D83C1A >> 128;\\n        if (xSignifier & 0x8000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000058B90BFBE8E7BDCBE2E >> 128;\\n        if (xSignifier & 0x4000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000002C5C85FDF473DEA871F >> 128;\\n        if (xSignifier & 0x2000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000162E42FEFA39EF44D91 >> 128;\\n        if (xSignifier & 0x1000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000B17217F7D1CF79E949 >> 128;\\n        if (xSignifier & 0x800000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000058B90BFBE8E7BCE544 >> 128;\\n        if (xSignifier & 0x400000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000002C5C85FDF473DE6ECA >> 128;\\n        if (xSignifier & 0x200000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000162E42FEFA39EF366F >> 128;\\n        if (xSignifier & 0x100000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000B17217F7D1CF79AFA >> 128;\\n        if (xSignifier & 0x80000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000058B90BFBE8E7BCD6D >> 128;\\n        if (xSignifier & 0x40000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000002C5C85FDF473DE6B2 >> 128;\\n        if (xSignifier & 0x20000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000162E42FEFA39EF358 >> 128;\\n        if (xSignifier & 0x10000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000B17217F7D1CF79AB >> 128;\\n        if (xSignifier & 0x8000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000058B90BFBE8E7BCD5 >> 128;\\n        if (xSignifier & 0x4000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000002C5C85FDF473DE6A >> 128;\\n        if (xSignifier & 0x2000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000162E42FEFA39EF34 >> 128;\\n        if (xSignifier & 0x1000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000B17217F7D1CF799 >> 128;\\n        if (xSignifier & 0x800000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000058B90BFBE8E7BCC >> 128;\\n        if (xSignifier & 0x400000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000002C5C85FDF473DE5 >> 128;\\n        if (xSignifier & 0x200000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000162E42FEFA39EF2 >> 128;\\n        if (xSignifier & 0x100000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000B17217F7D1CF78 >> 128;\\n        if (xSignifier & 0x80000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000058B90BFBE8E7BB >> 128;\\n        if (xSignifier & 0x40000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000002C5C85FDF473DD >> 128;\\n        if (xSignifier & 0x20000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000162E42FEFA39EE >> 128;\\n        if (xSignifier & 0x10000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000B17217F7D1CF6 >> 128;\\n        if (xSignifier & 0x8000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000058B90BFBE8E7A >> 128;\\n        if (xSignifier & 0x4000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000002C5C85FDF473C >> 128;\\n        if (xSignifier & 0x2000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000162E42FEFA39D >> 128;\\n        if (xSignifier & 0x1000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000B17217F7D1CE >> 128;\\n        if (xSignifier & 0x800000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000058B90BFBE8E6 >> 128;\\n        if (xSignifier & 0x400000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000002C5C85FDF472 >> 128;\\n        if (xSignifier & 0x200000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000162E42FEFA38 >> 128;\\n        if (xSignifier & 0x100000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000B17217F7D1B >> 128;\\n        if (xSignifier & 0x80000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000058B90BFBE8D >> 128;\\n        if (xSignifier & 0x40000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000002C5C85FDF46 >> 128;\\n        if (xSignifier & 0x20000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000162E42FEFA2 >> 128;\\n        if (xSignifier & 0x10000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000B17217F7D0 >> 128;\\n        if (xSignifier & 0x8000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000058B90BFBE7 >> 128;\\n        if (xSignifier & 0x4000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000002C5C85FDF3 >> 128;\\n        if (xSignifier & 0x2000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000162E42FEF9 >> 128;\\n        if (xSignifier & 0x1000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000B17217F7C >> 128;\\n        if (xSignifier & 0x800000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000058B90BFBD >> 128;\\n        if (xSignifier & 0x400000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000002C5C85FDE >> 128;\\n        if (xSignifier & 0x200000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000162E42FEE >> 128;\\n        if (xSignifier & 0x100000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000B17217F6 >> 128;\\n        if (xSignifier & 0x80000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000058B90BFA >> 128;\\n        if (xSignifier & 0x40000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000002C5C85FC >> 128;\\n        if (xSignifier & 0x20000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000162E42FD >> 128;\\n        if (xSignifier & 0x10000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000B17217E >> 128;\\n        if (xSignifier & 0x8000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000058B90BE >> 128;\\n        if (xSignifier & 0x4000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000002C5C85E >> 128;\\n        if (xSignifier & 0x2000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000162E42E >> 128;\\n        if (xSignifier & 0x1000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000B17216 >> 128;\\n        if (xSignifier & 0x800000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000058B90A >> 128;\\n        if (xSignifier & 0x400000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000002C5C84 >> 128;\\n        if (xSignifier & 0x200000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000162E41 >> 128;\\n        if (xSignifier & 0x100000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000000B1720 >> 128;\\n        if (xSignifier & 0x80000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000058B8F >> 128;\\n        if (xSignifier & 0x40000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000002C5C7 >> 128;\\n        if (xSignifier & 0x20000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000000162E3 >> 128;\\n        if (xSignifier & 0x10000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000000B171 >> 128;\\n        if (xSignifier & 0x8000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000000058B8 >> 128;\\n        if (xSignifier & 0x4000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000002C5B >> 128;\\n        if (xSignifier & 0x2000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000000162D >> 128;\\n        if (xSignifier & 0x1000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000B16 >> 128;\\n        if (xSignifier & 0x800 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000000058A >> 128;\\n        if (xSignifier & 0x400 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000000002C4 >> 128;\\n        if (xSignifier & 0x200 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000161 >> 128;\\n        if (xSignifier & 0x100 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000000000B0 >> 128;\\n        if (xSignifier & 0x80 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000057 >> 128;\\n        if (xSignifier & 0x40 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000000002B >> 128;\\n        if (xSignifier & 0x20 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000015 >> 128;\\n        if (xSignifier & 0x10 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000000000A >> 128;\\n        if (xSignifier & 0x8 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000004 >> 128;\\n        if (xSignifier & 0x4 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000001 >> 128;\\n\\n        if (!xNegative) {\\n          resultSignifier = resultSignifier >> 15 & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n          resultExponent += 0x3FFF;\\n        } else if (resultExponent <= 0x3FFE) {\\n          resultSignifier = resultSignifier >> 15 & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n          resultExponent = 0x3FFF - resultExponent;\\n        } else {\\n          resultSignifier = resultSignifier >> resultExponent - 16367;\\n          resultExponent = 0;\\n        }\\n\\n        return bytes16 (uint128 (resultExponent << 112 | resultSignifier));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate e^x.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function exp (bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      return pow_2 (mul (x, 0x3FFF71547652B82FE1777D0FFDA0D23A));\\n    }\\n  }\\n\\n  /**\\n   * Get index of the most significant non-zero bit in binary representation of\\n   * x.  Reverts if x is zero.\\n   *\\n   * @return index of the most significant non-zero bit in binary representation\\n   *         of x\\n   */\\n  function mostSignificantBit (uint256 x) private pure returns (uint256) {\\n    unchecked {\\n      require (x > 0);\\n\\n      uint256 result = 0;\\n\\n      if (x >= 0x100000000000000000000000000000000) { x >>= 128; result += 128; }\\n      if (x >= 0x10000000000000000) { x >>= 64; result += 64; }\\n      if (x >= 0x100000000) { x >>= 32; result += 32; }\\n      if (x >= 0x10000) { x >>= 16; result += 16; }\\n      if (x >= 0x100) { x >>= 8; result += 8; }\\n      if (x >= 0x10) { x >>= 4; result += 4; }\\n      if (x >= 0x4) { x >>= 2; result += 2; }\\n      if (x >= 0x2) result += 1; // No need to shift x anymore\\n\\n      return result;\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0x9694a9f6fcadd4fa917efa674de42a74b8fbab8d68924f771ea5cc5e1a301434\",\"license\":\"BSD-4-Clause\"},\"contracts/implementation/PoolKeeper.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.6;\\n\\nimport \\\"../interfaces/IPoolKeeper.sol\\\";\\nimport \\\"../interfaces/IOracleWrapper.sol\\\";\\nimport \\\"../interfaces/IPoolFactory.sol\\\";\\nimport \\\"../interfaces/ILeveragedPool.sol\\\";\\nimport \\\"../interfaces/IERC20DecimalsWrapper.sol\\\";\\nimport \\\"../interfaces/IERC20DecimalsWrapper.sol\\\";\\nimport \\\"./PoolSwapLibrary.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/proxy/Clones.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"abdk-libraries-solidity/ABDKMathQuad.sol\\\";\\nimport \\\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol\\\";\\n\\n/// @title The manager contract for multiple markets and the pools in them\\ncontract PoolKeeper is IPoolKeeper, Ownable {\\n    /* Constants */\\n    uint256 public constant BASE_TIP = 5; // 5% base tip\\n    uint256 public constant TIP_DELTA_PER_BLOCK = 5; // 5% increase per block\\n    uint256 public constant BLOCK_TIME = 13; /* in seconds */\\n    uint256 public constant MAX_DECIMALS = 18;\\n\\n    // #### Global variables\\n    /**\\n     * @notice Format: Pool address => last executionPrice\\n     */\\n    mapping(address => int256) public executionPrice;\\n\\n    IPoolFactory public factory;\\n    bytes16 constant fixedPoint = 0x403abc16d674ec800000000000000000; // 1 ether\\n\\n    // #### Functions\\n    constructor(address _factory) {\\n        require(_factory != address(0), \\\"Factory cannot be 0 address\\\");\\n        factory = IPoolFactory(_factory);\\n    }\\n\\n    /**\\n     * @notice When a pool is created, this function is called by the factory to initiate price trackings\\n     * @param _poolAddress The address of the newly-created pools\\n     */\\n    function newPool(address _poolAddress) external override onlyFactory {\\n        address oracleWrapper = ILeveragedPool(_poolAddress).oracleWrapper();\\n        int256 firstPrice = IOracleWrapper(oracleWrapper).getPrice();\\n        int256 startingPrice = ABDKMathQuad.toInt(ABDKMathQuad.mul(ABDKMathQuad.fromInt(firstPrice), fixedPoint));\\n        emit PoolAdded(_poolAddress, firstPrice);\\n        executionPrice[_poolAddress] = startingPrice;\\n    }\\n\\n    // Keeper network\\n    /**\\n     * @notice Check if upkeep is required\\n     * @param _pool The address of the pool to upkeep\\n     * @return upkeepNeeded Whether or not upkeep is needed for this single pool\\n     */\\n    function checkUpkeepSinglePool(address _pool) public view override returns (bool) {\\n        if (!factory.isValidPool(_pool)) {\\n            return false;\\n        }\\n\\n        // The update interval has passed\\n        return ILeveragedPool(_pool).intervalPassed();\\n    }\\n\\n    /**\\n     * @notice Checks multiple pools if any of them need updating\\n     * @param _pools The array of pools to check\\n     * @return upkeepNeeded Whether or not at least one pool needs upkeeping\\n     */\\n    function checkUpkeepMultiplePools(address[] calldata _pools) external view override returns (bool) {\\n        for (uint256 i = 0; i < _pools.length; i++) {\\n            if (checkUpkeepSinglePool(_pools[i])) {\\n                // One has been found that requires upkeeping\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    /**\\n     * @notice Called by keepers to perform an update on a single pool\\n     * @param _pool The pool code to perform the update for\\n     */\\n    function performUpkeepSinglePool(address _pool) public override {\\n        uint256 startGas = gasleft();\\n\\n        // validate the pool, check that the interval time has passed\\n        if (!checkUpkeepSinglePool(_pool)) {\\n            return;\\n        }\\n        ILeveragedPool pool = ILeveragedPool(_pool);\\n        int256 latestPrice = IOracleWrapper(pool.oracleWrapper()).getPrice();\\n        // Start a new round\\n        int256 lastExecutionPrice = executionPrice[_pool];\\n        executionPrice[_pool] = ABDKMathQuad.toInt(ABDKMathQuad.mul(ABDKMathQuad.fromInt(latestPrice), fixedPoint));\\n\\n        uint256 savedPreviousUpdatedTimestamp = pool.lastPriceTimestamp();\\n        uint256 updateInterval = pool.updateInterval();\\n\\n        // This allows us to still batch multiple calls to executePriceChange, even if some are invalid\\n        // Without reverting the entire transaction\\n        try ILeveragedPool(pool).poolUpkeep(lastExecutionPrice, executionPrice[_pool]) {\\n            // If poolUpkeep is successful, refund the keeper for their gas costs\\n            uint256 gasSpent = startGas - gasleft();\\n\\n            // TODO: poll gas price oracle (or BASEFEE)\\n            // _gasPrice = 10 gwei = 10000000000 wei\\n            uint256 _gasPrice = 10 gwei;\\n\\n            payKeeper(_pool, _gasPrice, gasSpent, savedPreviousUpdatedTimestamp, updateInterval);\\n        } catch Error(string memory reason) {\\n            // If poolUpkeep fails for any other reason, emit event\\n            emit PoolUpkeepError(_pool, reason);\\n        }\\n    }\\n\\n    /**\\n     * @notice Called by keepers to perform an update on multiple pools\\n     * @param pools pool codes to perform the update for\\n     */\\n    function performUpkeepMultiplePools(address[] calldata pools) external override {\\n        for (uint256 i = 0; i < pools.length; i++) {\\n            performUpkeepSinglePool(pools[i]);\\n        }\\n    }\\n\\n    /**\\n     * @notice Pay keeper for upkeep\\n     * @param _pool Address of the given pool\\n     * @param _gasPrice Price of a single gas unit (in ETH)\\n     * @param _gasSpent Number of gas units spent\\n     * @param _savedPreviousUpdatedTimestamp Last timestamp when the pool's price execution happened\\n     * @param _updateInterval Pool interval of the given pool\\n     */\\n    function payKeeper(\\n        address _pool,\\n        uint256 _gasPrice,\\n        uint256 _gasSpent,\\n        uint256 _savedPreviousUpdatedTimestamp,\\n        uint256 _updateInterval\\n    ) internal {\\n        uint256 reward = keeperReward(_pool, _gasPrice, _gasSpent, _savedPreviousUpdatedTimestamp, _updateInterval);\\n        if (ILeveragedPool(_pool).payKeeperFromBalances(msg.sender, reward)) {\\n            emit KeeperPaid(_pool, msg.sender, reward);\\n        } else {\\n            // Usually occurs if pool just started and does not have any funds\\n            emit KeeperPaymentError(_pool, msg.sender, reward);\\n        }\\n    }\\n\\n    /**\\n     * @notice Payment keeper receives for performing upkeep on a given pool\\n     * @param _pool Address of the given pool\\n     * @param _gasPrice Price of a single gas unit (in ETH)\\n     * @param _gasSpent Number of gas units spent\\n     * @param _savedPreviousUpdatedTimestamp Last timestamp when the pool's price execution happened\\n     * @param _poolInterval Pool interval of the given pool\\n     * @return Number of settlement tokens to give to the keeper for work performed\\n     */\\n    function keeperReward(\\n        address _pool,\\n        uint256 _gasPrice,\\n        uint256 _gasSpent,\\n        uint256 _savedPreviousUpdatedTimestamp,\\n        uint256 _poolInterval\\n    ) public view returns (uint256) {\\n        // keeper gas cost in wei. WAD formatted\\n        uint256 _keeperGas = keeperGas(_pool, _gasPrice, _gasSpent);\\n\\n        // tip percent in wad units\\n        bytes16 _tipPercent = ABDKMathQuad.mul(\\n            ABDKMathQuad.fromUInt(keeperTip(_savedPreviousUpdatedTimestamp, _poolInterval)),\\n            fixedPoint\\n        );\\n        // amount of settlement tokens to give to the keeper\\n        _tipPercent = ABDKMathQuad.div(_tipPercent, ABDKMathQuad.fromUInt(100));\\n        int256 wadRewardValue = ABDKMathQuad.toInt(\\n            ABDKMathQuad.add(\\n                ABDKMathQuad.fromUInt(_keeperGas),\\n                ABDKMathQuad.div((ABDKMathQuad.mul(ABDKMathQuad.fromUInt(_keeperGas), _tipPercent)), fixedPoint)\\n            )\\n        );\\n        uint256 decimals = IERC20DecimalsWrapper(ILeveragedPool(_pool).quoteToken()).decimals();\\n        uint256 deWadifiedReward = PoolSwapLibrary.fromWad(uint256(wadRewardValue), decimals);\\n        // _keeperGas + _keeperGas * percentTip\\n        return deWadifiedReward;\\n    }\\n\\n    /**\\n     * @notice Compensation a keeper will receive for their gas expenditure\\n     * @param _pool Address of the given pool\\n     * @param _gasPrice Price of a single gas unit (in ETH)\\n     * @param _gasSpent Number of gas units spent\\n     * @return Keeper's gas compensation\\n     */\\n    function keeperGas(\\n        address _pool,\\n        uint256 _gasPrice,\\n        uint256 _gasSpent\\n    ) public view returns (uint256) {\\n        int256 settlementTokenPrice = IOracleWrapper(ILeveragedPool(_pool).settlementEthOracle()).getPrice();\\n\\n        if (settlementTokenPrice <= 0) {\\n            return 0;\\n        } else {\\n            /* safe due to explicit bounds check above */\\n            /* (wei * Settlement / ETH) / fixed point (10^18) = amount in settlement */\\n            bytes16 _weiSpent = ABDKMathQuad.fromUInt(_gasPrice * _gasSpent);\\n            bytes16 _settlementTokenPrice = ABDKMathQuad.fromUInt(uint256(settlementTokenPrice));\\n            return\\n                ABDKMathQuad.toUInt(ABDKMathQuad.div(ABDKMathQuad.mul(_weiSpent, _settlementTokenPrice), fixedPoint));\\n        }\\n    }\\n\\n    /**\\n     * @notice Tip a keeper will receive for successfully updating the specified pool\\n     * @param _savedPreviousUpdatedTimestamp Last timestamp when the pool's price execution happened\\n     * @param _poolInterval Pool interval of the given pool\\n     * @return Percent of the `keeperGas` cost to add to payment, as a percent\\n     */\\n    function keeperTip(uint256 _savedPreviousUpdatedTimestamp, uint256 _poolInterval) public view returns (uint256) {\\n        /* the number of blocks that have elapsed since the given pool's updateInterval passed */\\n        uint256 elapsedBlocks = (block.timestamp - (_savedPreviousUpdatedTimestamp + _poolInterval)) / BLOCK_TIME;\\n\\n        return BASE_TIP + TIP_DELTA_PER_BLOCK * elapsedBlocks;\\n    }\\n\\n    function setFactory(address _factory) external override onlyOwner {\\n        factory = IPoolFactory(_factory);\\n    }\\n\\n    modifier onlyFactory() {\\n        require(msg.sender == address(factory), \\\"Caller not factory\\\");\\n        _;\\n    }\\n}\\n\",\"keccak256\":\"0xab5175f2def8fae4026399080373df35c22b3894d6a23ce88b0daadef82b9cd9\",\"license\":\"MIT\"},\"contracts/implementation/PoolSwapLibrary.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.6;\\n\\nimport \\\"abdk-libraries-solidity/ABDKMathQuad.sol\\\";\\n\\n/// @title Library for various useful (mostly) mathematical functions\\nlibrary PoolSwapLibrary {\\n    bytes16 public constant one = 0x3fff0000000000000000000000000000;\\n    bytes16 public constant zero = 0x00000000000000000000000000000000;\\n    uint256 public constant MAX_DECIMALS = 18;\\n\\n    struct PriceChangeData {\\n        int256 oldPrice;\\n        int256 newPrice;\\n        uint256 longBalance;\\n        uint256 shortBalance;\\n        bytes16 leverageAmount;\\n        bytes16 fee;\\n    }\\n\\n    /**\\n     * @notice Calculates the ratio between two numbers\\n     * @dev Rounds any overflow towards 0. If either parameter is zero, the ratio is 0\\n     * @param _numerator The \\\"parts per\\\" side of the equation. If this is zero, the ratio is zero\\n     * @param _denominator The \\\"per part\\\" side of the equation. If this is zero, the ratio is zero\\n     * @return the ratio, as an ABDKMathQuad number (IEEE 754 quadruple precision floating point)\\n     */\\n    function getRatio(uint256 _numerator, uint256 _denominator) public pure returns (bytes16) {\\n        // Catch the divide by zero error.\\n        if (_denominator == 0) {\\n            return 0;\\n        }\\n        return ABDKMathQuad.div(ABDKMathQuad.fromUInt(_numerator), ABDKMathQuad.fromUInt(_denominator));\\n    }\\n\\n    /**\\n     * @notice Gets the short and long balances after the keeper rewards have been paid out\\n     *         Keeper rewards are paid proportionally to the short and long pool\\n     * @dev Assumes shortBalance + longBalance >= reward\\n     * @param reward Amount of keeper reward\\n     * @param shortBalance Short balance of the pool\\n     * @param longBalance Long balance of the pool\\n     * @return shortBalanceAfterFees Short balance of the pool after the keeper reward has been paid\\n     * @return longBalanceAfterFees Long balance of the pool after the keeper reward has been paid\\n     */\\n    function getBalancesAfterFees(\\n        uint256 reward,\\n        uint256 shortBalance,\\n        uint256 longBalance\\n    ) public pure returns (uint256, uint256) {\\n        bytes16 ratioShort = getRatio(shortBalance, shortBalance + longBalance);\\n\\n        uint256 shortFees = convertDecimalToUInt(multiplyDecimalByUInt(ratioShort, reward));\\n\\n        uint256 shortBalanceAfterFees = shortBalance - shortFees;\\n        uint256 longBalanceAfterFees = longBalance - (reward - shortFees);\\n\\n        // Return shortBalance and longBalance after rewards are paid out\\n        return (shortBalanceAfterFees, longBalanceAfterFees);\\n    }\\n\\n    /**\\n     * @notice Gets the amount of tokens a user is entitled to according to the ratio\\n     * @dev This is useful for getting the amount of pool tokens to mint, and the amount of quote tokens to remit when minting and burning. Can also be used to provide the user with an estimate of their commit results.\\n     * @param ratio The ratio to calculate. Use the getRatio function to calculate this\\n     * @param amountIn The amount of tokens the user is providing. This can be quote tokens or pool tokens.\\n     * @return The amount of tokens to mint/remit to the user.\\n     */\\n    function getAmountOut(bytes16 ratio, uint256 amountIn) public pure returns (uint256) {\\n        require(amountIn > 0, \\\"Invalid amount\\\");\\n        if (ABDKMathQuad.cmp(ratio, 0) == 0 || ABDKMathQuad.cmp(ratio, bytes16(\\\"0x1\\\")) == 0) {\\n            return amountIn;\\n        }\\n        return ABDKMathQuad.toUInt(ABDKMathQuad.mul(ratio, ABDKMathQuad.fromUInt(amountIn)));\\n    }\\n\\n    /**\\n     * @notice Compares two decimal numbers\\n     * @param x The first number to compare\\n     * @param y The second number to compare\\n     * @return -1 if x < y, 0 if x = y, or 1 if x > y\\n     */\\n    function compareDecimals(bytes16 x, bytes16 y) public pure returns (int8) {\\n        return ABDKMathQuad.cmp(x, y);\\n    }\\n\\n    /**\\n     * @notice Converts an integer value to a compatible decimal value\\n     * @param amount The amount to convert\\n     * @return The amount as a IEEE754 quadruple precision number\\n     */\\n    function convertUIntToDecimal(uint256 amount) external pure returns (bytes16) {\\n        return ABDKMathQuad.fromUInt(amount);\\n    }\\n\\n    /**\\n     * @notice Converts a raw decimal value to a more readable uint256 value\\n     * @param ratio The value to convert\\n     * @return The converted value\\n     */\\n    function convertDecimalToUInt(bytes16 ratio) public pure returns (uint256) {\\n        return ABDKMathQuad.toUInt(ratio);\\n    }\\n\\n    /**\\n     * @notice Multiplies a decimal and an unsigned integer\\n     * @param a The first term\\n     * @param b The second term\\n     * @return The product of a*b as a decimal\\n     */\\n    function multiplyDecimalByUInt(bytes16 a, uint256 b) public pure returns (bytes16) {\\n        return ABDKMathQuad.mul(a, ABDKMathQuad.fromUInt(b));\\n    }\\n\\n    /**\\n     * @notice Divides two integers\\n     * @param a The dividend\\n     * @param b The divisor\\n     * @return The quotient\\n     */\\n    function divInt(int256 a, int256 b) public pure returns (bytes16) {\\n        return ABDKMathQuad.div(ABDKMathQuad.fromInt(a), ABDKMathQuad.fromInt(b));\\n    }\\n\\n    /**\\n     * @notice Calculates the loss multiplier to apply to the losing pool. Includes the power leverage\\n     * @param ratio The ratio of new price to old price\\n     * @param direction The direction of the change. -1 if it's decreased, 0 if it hasn't changed, and 1 if it's increased\\n     * @param leverage The amount of leverage to apply\\n     * @return The multiplier\\n     */\\n    function getLossMultiplier(\\n        bytes16 ratio,\\n        int8 direction,\\n        bytes16 leverage\\n    ) public pure returns (bytes16) {\\n        // If decreased:  2 ^ (leverage * log2[(1 * new/old) + [(0 * 1) / new/old]])\\n        //              = 2 ^ (leverage * log2[(new/old)])\\n        // If increased:  2 ^ (leverage * log2[(0 * new/old) + [(1 * 1) / new/old]])\\n        //              = 2 ^ (leverage * log2([1 / new/old]))\\n        //              = 2 ^ (leverage * log2([old/new]))\\n        return\\n            ABDKMathQuad.pow_2(\\n                ABDKMathQuad.mul(\\n                    leverage,\\n                    ABDKMathQuad.log_2(\\n                        ABDKMathQuad.add(\\n                            ABDKMathQuad.mul(direction < 0 ? one : zero, ratio),\\n                            ABDKMathQuad.div(ABDKMathQuad.mul(direction >= 0 ? one : zero, one), ratio)\\n                        )\\n                    )\\n                )\\n            );\\n    }\\n\\n    /**\\n     * @notice Calculates the amount to take from the losing pool\\n     * @param lossMultiplier The multiplier to use\\n     * @param balance The balance of the losing pool\\n     */\\n    function getLossAmount(bytes16 lossMultiplier, uint256 balance) public pure returns (uint256) {\\n        return\\n            ABDKMathQuad.toUInt(\\n                ABDKMathQuad.mul(ABDKMathQuad.sub(one, lossMultiplier), ABDKMathQuad.fromUInt(balance))\\n            );\\n    }\\n\\n    /**\\n     * @notice Calculates the effect of a price change. This involves calculating how many funds to transfer from the losing pool to the other.\\n     * @dev This function should be called by the LeveragedPool.\\n     * @param priceChange The struct containing necessary data to calculate price change\\n     */\\n    function calculatePriceChange(PriceChangeData memory priceChange)\\n        public\\n        pure\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        uint256 shortBalance = priceChange.shortBalance;\\n        uint256 longBalance = priceChange.longBalance;\\n        bytes16 leverageAmount = priceChange.leverageAmount;\\n        int256 oldPrice = priceChange.oldPrice;\\n        int256 newPrice = priceChange.newPrice;\\n        bytes16 fee = priceChange.fee;\\n\\n        // Calculate fees from long and short sides\\n        uint256 longFeeAmount = convertDecimalToUInt(multiplyDecimalByUInt(fee, longBalance));\\n        uint256 shortFeeAmount = convertDecimalToUInt(multiplyDecimalByUInt(fee, shortBalance));\\n        uint256 totalFeeAmount = 0;\\n\\n        // fee is enforced to be < 1. Therefore, shortFeeAmount < shortBalance, and longFeeAmount < longBalance\\n        shortBalance = shortBalance - shortFeeAmount;\\n        totalFeeAmount = totalFeeAmount + shortFeeAmount;\\n        longBalance = longBalance - longFeeAmount;\\n        totalFeeAmount = totalFeeAmount + longFeeAmount;\\n\\n        // Use the ratio to determine if the price increased or decreased and therefore which direction\\n        // the funds should be transferred towards.\\n\\n        bytes16 ratio = divInt(newPrice, oldPrice);\\n        int8 direction = compareDecimals(ratio, PoolSwapLibrary.one);\\n        // Take into account the leverage\\n        bytes16 lossMultiplier = getLossMultiplier(ratio, direction, leverageAmount);\\n\\n        if (direction >= 0 && shortBalance > 0) {\\n            // Move funds from short to long pair\\n            uint256 lossAmount = getLossAmount(lossMultiplier, shortBalance);\\n            shortBalance = shortBalance - lossAmount;\\n            longBalance = longBalance + lossAmount;\\n        } else if (direction < 0 && longBalance > 0) {\\n            // Move funds from long to short pair\\n            uint256 lossAmount = getLossAmount(lossMultiplier, longBalance);\\n            shortBalance = shortBalance + lossAmount;\\n            longBalance = longBalance - lossAmount;\\n        }\\n\\n        return (longBalance, shortBalance, totalFeeAmount);\\n    }\\n\\n    /**\\n     * @notice Returns true if the function is being called BEFORE the frontRunningInterval starts,\\n     *         which is allowed for uncommitment.\\n     * @dev If you try to uncommit AFTER the frontRunningInterval, it should revert.\\n     */\\n    function isBeforeFrontRunningInterval(\\n        uint256 lastPriceTimestamp,\\n        uint256 updateInterval,\\n        uint256 frontRunningInterval\\n    ) external view returns (bool) {\\n        return lastPriceTimestamp + updateInterval - frontRunningInterval > block.timestamp;\\n    }\\n\\n    /**\\n     * @notice Gets the number of pool tokens to be minted based on existing tokens\\n     * @param tokenSupply Total supply of pool tokens\\n     * @param amountIn Commitment amount of collateral tokens going into the pool\\n     * @param balance Balance of the pool (no. of underlying collateral tokens in pool)\\n     * @param inverseShadowbalance Balance the shadow pool at time of mint\\n     * @return Number of pool tokens to be minted\\n     */\\n    function getMintAmount(\\n        uint256 tokenSupply,\\n        uint256 amountIn,\\n        uint256 balance,\\n        uint256 inverseShadowbalance\\n    ) external pure returns (uint256) {\\n        return\\n            getAmountOut(\\n                // ratio = (totalSupply + inverseShadowBalance) / balance\\n                getRatio(tokenSupply + inverseShadowbalance, balance),\\n                amountIn\\n            );\\n    }\\n\\n    /**\\n     * @notice Converts from a WAD to normal value\\n     * @return Converted non-WAD value\\n     */\\n    function fromWad(uint256 _wadValue, uint256 _decimals) external pure returns (uint256) {\\n        uint256 scaler = uint256(10**(MAX_DECIMALS - _decimals));\\n        return _wadValue / scaler;\\n    }\\n}\\n\",\"keccak256\":\"0x0f48cbc49eb58245afee232308d11d892cc4e9f174beefd6e036f9807951f9d9\",\"license\":\"MIT\"},\"contracts/interfaces/IERC20DecimalsWrapper.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.6;\\n\\n/// @title The decimals interface for extending the ERC20 interface\\ninterface IERC20DecimalsWrapper {\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x9b40e1f0143035fdfbed603ba540e0498bdfa20bdff4f0795c8f5d673d84797a\",\"license\":\"MIT\"},\"contracts/interfaces/ILeveragedPool.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.6;\\n\\n/// @title The pool controller contract interface\\ninterface ILeveragedPool {\\n    // Initialisation parameters for new market\\n    struct Initialization {\\n        address _owner; // Owner of the contract\\n        address _keeper; // The address of the PoolKeeper contract\\n        address _oracleWrapper; // The oracle wrapper for the derivative price feed\\n        address _settlementEthOracle; // The oracle wrapper for the SettlementToken/ETH price feed\\n        address _longToken; // Address of the long pool token\\n        address _shortToken; // Address of the short pool token\\n        address _poolCommitter; // Address of the PoolCommitter contract\\n        string _poolName; // The pool identification name\\n        uint32 _frontRunningInterval; // The minimum number of seconds that must elapse before a commit is forced to wait until the next interval\\n        uint32 _updateInterval; // The minimum number of seconds that must elapse before a commit can be executed\\n        bytes16 _fee; // The fund movement fee. This amount is extracted from the deposited asset with every update and sent to the fee address\\n        uint16 _leverageAmount; // The amount of exposure to price movements for the pool\\n        address _feeAddress; // The address that the fund movement fee is sent to\\n        address _quoteToken; //  The digital asset that the pool accepts. Must have a decimals() function\\n    }\\n\\n    // #### Events\\n    /**\\n     * @notice Creates a notification when the pool is setup and ready for use\\n     * @param longToken The address of the LONG pair token\\n     * @param shortToken The address of the SHORT pair token\\n     * @param quoteToken The address of the digital asset that the pool accepts\\n     * @param poolName The pool code for the pool\\n     */\\n    event PoolInitialized(address indexed longToken, address indexed shortToken, address quoteToken, string poolName);\\n\\n    /**\\n     * @notice Creates a notification when the pool's upkeep succeeds\\n     * @param startPrice Price prior to price change execution\\n     * @param endPrice Price during price change execution\\n     */\\n    event CompletedUpkeep(int256 indexed startPrice, int256 indexed endPrice);\\n\\n    /**\\n     * @notice Creates a notification when the pool's price execution fails\\n     * @param startPrice Price prior to price change execution\\n     * @param endPrice Price during price change execution\\n     */\\n    event PriceChangeError(int256 indexed startPrice, int256 indexed endPrice);\\n\\n    /**\\n     * @notice Represents change in fee receiver's address\\n     * @param oldAddress Previous address\\n     * @param newAddress Address after change\\n     */\\n    event FeeAddressUpdated(address indexed oldAddress, address indexed newAddress);\\n\\n    /**\\n     * @notice Represents change in keeper's address\\n     * @param oldAddress Previous address\\n     * @param newAddress Address after change\\n     */\\n    event KeeperAddressChanged(address indexed oldAddress, address indexed newAddress);\\n\\n    /**\\n     * @notice Represents change in governance address\\n     * @param oldAddress Previous address\\n     * @param newAddress Address after change\\n     */\\n    event GovernanceAddressChanged(address indexed oldAddress, address indexed newAddress);\\n\\n    function leverageAmount() external view returns (bytes16);\\n\\n    function poolCommitter() external view returns (address);\\n\\n    function quoteToken() external view returns (address);\\n\\n    function oracleWrapper() external view returns (address);\\n\\n    function lastPriceTimestamp() external view returns (uint256);\\n\\n    function poolName() external view returns (string calldata);\\n\\n    function updateInterval() external view returns (uint32);\\n\\n    function shortBalance() external view returns (uint256);\\n\\n    function longBalance() external view returns (uint256);\\n\\n    function frontRunningInterval() external view returns (uint32);\\n\\n    function poolTokens() external view returns (address[2] memory);\\n\\n    function settlementEthOracle() external view returns (address);\\n\\n    // #### Functions\\n    /**\\n     * @notice Configures the pool on deployment. The pools are EIP 1167 clones.\\n     * @dev This should only be able to be run once to prevent abuse of the pool. Use of Openzeppelin Initializable or similar is recommended\\n     * @param initialization The struct Initialization containing initialization data\\n     */\\n    function initialize(Initialization calldata initialization) external;\\n\\n    function poolUpkeep(int256 _oldPrice, int256 _newPrice) external;\\n\\n    function quoteTokenTransferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external;\\n\\n    function payKeeperFromBalances(address to, uint256 amount) external returns (bool);\\n\\n    function quoteTokenTransfer(address to, uint256 amount) external;\\n\\n    function setNewPoolBalances(uint256 _longBalance, uint256 _shortBalance) external;\\n\\n    function getOraclePrice() external view returns (int256);\\n\\n    function intervalPassed() external view returns (bool);\\n\\n    function setKeeper(address _keeper) external;\\n\\n    function transferGovernance(address _governance) external;\\n\\n    function updateFeeAddress(address account) external;\\n\\n    function mintTokens(\\n        uint256 token,\\n        uint256 amount,\\n        address burner\\n    ) external;\\n\\n    function burnTokens(\\n        uint256 token,\\n        uint256 amount,\\n        address burner\\n    ) external;\\n}\\n\",\"keccak256\":\"0x02486bf29ca0cfd631cb05c56b451b00786c5151ed2830ac93f0227e5c435a75\",\"license\":\"MIT\"},\"contracts/interfaces/IOracleWrapper.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.6;\\n\\n/// @title The oracle wrapper contract interface\\ninterface IOracleWrapper {\\n    function oracle() external view returns (address);\\n\\n    // #### Functions\\n    /**\\n     * @notice Sets the oracle for a given market\\n     * @dev Should be secured, ideally only allowing the PoolKeeper to access\\n     * @param _oracle The oracle to set for the market\\n     */\\n    function setOracle(address _oracle) external;\\n\\n    /**\\n     * @notice Returns the current price for the asset in question\\n     * @return The latest price\\n     */\\n    function getPrice() external view returns (int256);\\n\\n    /**\\n     * @notice Converts from a WAD to normal value\\n     * @return Converted non-WAD value\\n     */\\n    function fromWad(int256 wad) external view returns (int256);\\n}\\n\",\"keccak256\":\"0xf1c77aed418b9a295b557c93a643c7ff0d449ff84213effc6bd108faa68a4a74\",\"license\":\"MIT\"},\"contracts/interfaces/IPoolFactory.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.6;\\n\\n/// @title The contract factory for the keeper and pool contracts. Utilizes minimal clones to keep gas costs low\\ninterface IPoolFactory {\\n    struct PoolDeployment {\\n        string poolName; // The name to identify a pool by\\n        uint32 frontRunningInterval; // The minimum number of seconds that must elapse before a commit can be executed. Must be smaller than or equal to the update interval to prevent deadlock\\n        uint32 updateInterval; // The minimum number of seconds that must elapse before a price change\\n        uint16 leverageAmount; // The amount of exposure to price movements for the pool\\n        address quoteToken; // The digital asset that the pool accepts\\n        address oracleWrapper; // The IOracleWrapper implementation for fetching price feed data\\n        address settlementEthOracle; // The oracle to fetch the price of Ether in terms of the settlement token\\n    }\\n\\n    // #### Events\\n    /**\\n     * @notice Creates a notification when a pool is deployed\\n     * @param pool Address of the new pool\\n     * @param ticker Ticker of the neew pool\\n     */\\n    event DeployPool(address indexed pool, string ticker);\\n\\n    // #### Getters for Globals\\n    function pools(uint256 id) external view returns (address);\\n\\n    function numPools() external view returns (uint256);\\n\\n    function isValidPool(address _pool) external view returns (bool);\\n\\n    // #### Functions\\n    function deployPool(PoolDeployment calldata deploymentParameters) external returns (address);\\n\\n    function setPoolKeeper(address _poolKeeper) external;\\n\\n    function setMaxLeverage(uint16 newMaxLeverage) external;\\n\\n    function setFeeReceiver(address _feeReceiver) external;\\n\\n    function setFee(bytes16 _fee) external;\\n\\n    function setPoolCommitterDeployer(address _poolCommitterDeployer) external;\\n}\\n\",\"keccak256\":\"0x866bbc84aee7088cb0d9e022e35ceb5a95d66e68c7042eb4d5844232300d448f\",\"license\":\"MIT\"},\"contracts/interfaces/IPoolKeeper.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.6;\\n\\n/// @title The manager contract interface for multiple markets and the pools in them\\ninterface IPoolKeeper {\\n    // #### Events\\n    /**\\n     * @notice Creates a notification when a pool is created\\n     * @param poolAddress The pool address of the newly created pool\\n     * @param firstPrice The price of the market oracle when the pool was created\\n     */\\n    event PoolAdded(address indexed poolAddress, int256 indexed firstPrice);\\n\\n    /**\\n     * @notice Creates a notification when a keeper is paid for doing upkeep for a pool\\n     * @param _pool Address of pool being upkept\\n     * @param keeper Keeper to be rewarded for upkeeping\\n     * @param reward Keeper's reward (in settlement tokens)\\n     */\\n    event KeeperPaid(address indexed _pool, address indexed keeper, uint256 reward);\\n\\n    /**\\n     * @notice Creates a notification when a keeper's payment for upkeeping a pool failed\\n     * @param _pool Address of pool being upkept\\n     * @param keeper Keeper to be rewarded for upkeeping\\n     * @param expectedReward Keeper's expected reward (in settlement tokens); not actually transferred\\n     */\\n    event KeeperPaymentError(address indexed _pool, address indexed keeper, uint256 expectedReward);\\n\\n    /**\\n     * @notice Creates a notification of a failed pool update\\n     * @param pool The pool that failed to update\\n     * @param reason The reason for the error\\n     */\\n    event PoolUpkeepError(address indexed pool, string reason);\\n\\n    // #### Functions\\n    function newPool(address _poolAddress) external;\\n\\n    function setFactory(address _factory) external;\\n\\n    function checkUpkeepSinglePool(address pool) external view returns (bool);\\n\\n    function checkUpkeepMultiplePools(address[] calldata pools) external view returns (bool);\\n\\n    function performUpkeepSinglePool(address pool) external;\\n\\n    function performUpkeepMultiplePools(address[] calldata pools) external;\\n}\\n\",\"keccak256\":\"0x46f7a8201c5075cd4785f16d466d4d94f969d981b869262ce77ad73713461924\",\"license\":\"MIT\"}},\"version\":1}",
    "bytecode": "0x60806040523480156200001157600080fd5b5060405162003828380380620038288339818101604052810190620000379190620001f5565b620000576200004b6200011260201b60201c565b6200011a60201b60201c565b600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff161415620000ca576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401620000c1906200024e565b60405180910390fd5b80600260006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050620002fd565b600033905090565b60008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050816000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508173ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a35050565b600081519050620001ef81620002e3565b92915050565b6000602082840312156200020e576200020d620002b5565b5b60006200021e84828501620001de565b91505092915050565b600062000236601b8362000270565b91506200024382620002ba565b602082019050919050565b60006020820190508181036000830152620002698162000227565b9050919050565b600082825260208201905092915050565b60006200028e8262000295565b9050919050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b600080fd5b7f466163746f72792063616e6e6f74206265203020616464726573730000000000600082015250565b620002ee8162000281565b8114620002fa57600080fd5b50565b61351b806200030d6000396000f3fe608060405234801561001057600080fd5b50600436106101165760003560e01c8063aea8acb1116100a2578063cdd9e13711610071578063cdd9e137146102cf578063ce1dcdfc146102ff578063f2fde38b1461032f578063f93019101461034b578063fcab9e981461036957610116565b8063aea8acb114610233578063b3fbb7c414610251578063b9c6536514610281578063c45a0155146102b157610116565b8063715018a6116100e9578063715018a6146101a15780638da5cb5b146101ab57806391a60782146101c95780639f9a3d95146101e5578063a40d6b801461020357610116565b80630417cf8e1461011b578063225739b1146101395780633c5c7fb3146101695780635bb4780814610185575b600080fd5b610123610385565b6040516101309190612f21565b60405180910390f35b610153600480360381019061014e9190612a4f565b61038a565b6040516101609190612e25565b60405180910390f35b610183600480360381019061017e9190612a4f565b6104ca565b005b61019f600480360381019061019a9190612a4f565b61071d565b005b6101a96107dd565b005b6101b3610865565b6040516101c09190612de1565b60405180910390f35b6101e360048036038101906101de9190612a4f565b61088e565b005b6101ed610cd2565b6040516101fa9190612f21565b60405180910390f35b61021d60048036038101906102189190612aa9565b610cd7565b60405161022a9190612f21565b60405180910390f35b61023b610e49565b6040516102489190612f21565b60405180910390f35b61026b60048036038101906102669190612afc565b610e4e565b6040516102789190612f21565b60405180910390f35b61029b60048036038101906102969190612c4b565b611090565b6040516102a89190612f21565b60405180910390f35b6102b96110da565b6040516102c69190612e40565b60405180910390f35b6102e960048036038101906102e49190612a4f565b611100565b6040516102f69190612e5b565b60405180910390f35b61031960048036038101906103149190612b77565b611118565b6040516103269190612e25565b60405180910390f35b61034960048036038101906103449190612a4f565b611189565b005b610353611281565b6040516103609190612f21565b60405180910390f35b610383600480360381019061037e9190612b77565b611286565b005b601281565b6000600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16635ab78ee1836040518263ffffffff1660e01b81526004016103e79190612de1565b60206040518083038186803b1580156103ff57600080fd5b505afa158015610413573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104379190612bc4565b61044457600090506104c5565b8173ffffffffffffffffffffffffffffffffffffffff16637bbf10336040518163ffffffff1660e01b815260040160206040518083038186803b15801561048a57600080fd5b505afa15801561049e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104c29190612bc4565b90505b919050565b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161461055a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161055190612f01565b60405180910390fd5b60008173ffffffffffffffffffffffffffffffffffffffff1663b9ed8abf6040518163ffffffff1660e01b815260040160206040518083038186803b1580156105a257600080fd5b505afa1580156105b6573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105da9190612a7c565b905060008173ffffffffffffffffffffffffffffffffffffffff166398d5fdca6040518163ffffffff1660e01b815260040160206040518083038186803b15801561062457600080fd5b505afa158015610638573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061065c9190612bf1565b9050600061068d61068861066f846112dc565b6f403abc16d674ec80000000000000000060801b61138a565b61181f565b9050818473ffffffffffffffffffffffffffffffffffffffff167fe950cb32f7a787627d713d7365623fef2d762ef8fcf813b865a04350852deb9b60405160405180910390a380600160008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000208190555050505050565b61072561197f565b73ffffffffffffffffffffffffffffffffffffffff16610743610865565b73ffffffffffffffffffffffffffffffffffffffff1614610799576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161079090612ee1565b60405180910390fd5b80600260006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050565b6107e561197f565b73ffffffffffffffffffffffffffffffffffffffff16610803610865565b73ffffffffffffffffffffffffffffffffffffffff1614610859576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161085090612ee1565b60405180910390fd5b6108636000611987565b565b60008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b60005a905061089c8261038a565b6108a65750610ccf565b600082905060008173ffffffffffffffffffffffffffffffffffffffff1663b9ed8abf6040518163ffffffff1660e01b815260040160206040518083038186803b1580156108f357600080fd5b505afa158015610907573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061092b9190612a7c565b73ffffffffffffffffffffffffffffffffffffffff166398d5fdca6040518163ffffffff1660e01b815260040160206040518083038186803b15801561097057600080fd5b505afa158015610984573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109a89190612bf1565b90506000600160008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020549050610a1b610a166109fd846112dc565b6f403abc16d674ec80000000000000000060801b61138a565b61181f565b600160008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000208190555060008373ffffffffffffffffffffffffffffffffffffffff16637de93f936040518163ffffffff1660e01b815260040160206040518083038186803b158015610aa657600080fd5b505afa158015610aba573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ade9190612c1e565b905060008473ffffffffffffffffffffffffffffffffffffffff1663fd2c80ae6040518163ffffffff1660e01b815260040160206040518083038186803b158015610b2857600080fd5b505afa158015610b3c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b609190612c8b565b63ffffffff1690508473ffffffffffffffffffffffffffffffffffffffff1663f633a74084600160008b73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020546040518363ffffffff1660e01b8152600401610be2929190612e76565b600060405180830381600087803b158015610bfc57600080fd5b505af1925050508015610c0d575060015b610c9e57610c196132cb565b806308c379a01415610c8d5750610c2e6133c5565b80610c395750610c8f565b8773ffffffffffffffffffffffffffffffffffffffff167f8a47468bf96478429d382ed6385d9c77fba8b89540cd88199b1b51d5723b11fa82604051610c7f9190612e9f565b60405180910390a250610c99565b505b3d6000803e3d6000fd5b610cc8565b60005a87610cac919061306c565b905060006402540be4009050610cc58982848787611a4b565b50505b5050505050505b50565b600581565b6000808473ffffffffffffffffffffffffffffffffffffffff16638226f3966040518163ffffffff1660e01b815260040160206040518083038186803b158015610d2057600080fd5b505afa158015610d34573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d589190612a7c565b73ffffffffffffffffffffffffffffffffffffffff166398d5fdca6040518163ffffffff1660e01b815260040160206040518083038186803b158015610d9d57600080fd5b505afa158015610db1573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610dd59190612bf1565b905060008113610de9576000915050610e42565b6000610dff8486610dfa9190613012565b611bc6565b90506000610e0c83611bc6565b9050610e3c610e37610e1e848461138a565b6f403abc16d674ec80000000000000000060801b611c44565b61210d565b93505050505b9392505050565b600581565b600080610e5c878787610cd7565b90506000610e8e610e75610e708787611090565b611bc6565b6f403abc16d674ec80000000000000000060801b61138a565b9050610ea381610e9e6064611bc6565b611c44565b90506000610eee610ee9610eb685611bc6565b610ee4610ecb610ec588611bc6565b8761138a565b6f403abc16d674ec80000000000000000060801b611c44565b61220b565b61181f565b905060008973ffffffffffffffffffffffffffffffffffffffff1663217a4b706040518163ffffffff1660e01b815260040160206040518083038186803b158015610f3857600080fd5b505afa158015610f4c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f709190612a7c565b73ffffffffffffffffffffffffffffffffffffffff1663313ce5676040518163ffffffff1660e01b815260040160206040518083038186803b158015610fb557600080fd5b505afa158015610fc9573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610fed9190612cb8565b60ff1690506000733f4a6959e5D34E24a192B8AbF9AA7cc451a1986463bf36f0e984846040518363ffffffff1660e01b815260040161102d929190612f3c565b60206040518083038186803b15801561104557600080fd5b505af4158015611059573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061107d9190612c1e565b9050809550505050505095945050505050565b600080600d83856110a19190612f8b565b426110ac919061306c565b6110b69190612fe1565b90508060056110c59190613012565b60056110d19190612f8b565b91505092915050565b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b60016020528060005260406000206000915090505481565b600080600090505b8383905081101561117d5761115b8484838181106111415761114061326d565b5b90506020020160208101906111569190612a4f565b61038a565b1561116a576001915050611183565b808061117590613197565b915050611120565b50600090505b92915050565b61119161197f565b73ffffffffffffffffffffffffffffffffffffffff166111af610865565b73ffffffffffffffffffffffffffffffffffffffff1614611205576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016111fc90612ee1565b60405180910390fd5b600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff161415611275576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161126c90612ec1565b60405180910390fd5b61127e81611987565b50565b600d81565b60005b828290508110156112d7576112c48383838181106112aa576112a961326d565b5b90506020020160208101906112bf9190612a4f565b61088e565b80806112cf90613197565b915050611289565b505050565b6000808214156112f257600060801b9050611385565b60008083136113045782600003611306565b825b9050600061131382612870565b9050607081101561132c578060700382901b9150611340565b607081111561133f576070810382901c91505b5b607081613fff01901b6dffffffffffffffffffffffffffff8316179150600084121561137c576f80000000000000000000000000000000821791505b8160801b925050505b919050565b600080617fff60708560801c6fffffffffffffffffffffffffffffffff16901c166fffffffffffffffffffffffffffffffff1690506000617fff60708560801c6fffffffffffffffffffffffffffffffff16901c166fffffffffffffffffffffffffffffffff169050617fff82141561152157617fff8114156114af57836fffffffffffffffffffffffffffffffff1916856fffffffffffffffffffffffffffffffff19161415611456576f8000000000000000000000000000000060801b8416851892505050611819565b6f8000000000000000000000000000000060801b8486186fffffffffffffffffffffffffffffffff191614156114925783851792505050611819565b6f7fff800000000000000000000000000060801b92505050611819565b600060801b6f7fffffffffffffffffffffffffffffff60801b85166fffffffffffffffffffffffffffffffff19161415611500576f7fff800000000000000000000000000060801b92505050611819565b6f8000000000000000000000000000000060801b8416851892505050611819565b617fff81141561159d57600060801b6f7fffffffffffffffffffffffffffffff60801b86166fffffffffffffffffffffffffffffffff1916141561157c576f7fff800000000000000000000000000060801b92505050611819565b6f8000000000000000000000000000000060801b8516841892505050611819565b60006dffffffffffffffffffffffffffff8660801c166fffffffffffffffffffffffffffffffff16905060008314156115d957600192506115ee565b6e010000000000000000000000000000811790505b60006dffffffffffffffffffffffffffff8660801c166fffffffffffffffffffffffffffffffff169050600083141561162a576001925061163f565b6e010000000000000000000000000000811790505b808202915060008214156116ac57600060801b6f8000000000000000000000000000000060801b878918166fffffffffffffffffffffffffffffffff19161161168c57600060801b6116a1565b6f8000000000000000000000000000000060801b5b945050505050611819565b828401935060007c0200000000000000000000000000000000000000000000000000000000831015611713577c010000000000000000000000000000000000000000000000000000000083101561170b5761170683612870565b61170e565b60e05b611716565b60e15b905061407081860110156117315760009450600092506117d9565b6140e081860110156117755761407085101561175657846140700383901c925061176c565b61407085111561176b57614070850383901b92505b5b600094506117d8565b61c0dd818601111561178f57617fff9450600092506117d7565b60708111156117a6576070810383901c92506117ba565b60708110156117b9578060700383901b92505b5b6dffffffffffffffffffffffffffff831692506140df8186010394505b5b5b82607086901b6f8000000000000000000000000000000060801b898b181660801c6fffffffffffffffffffffffffffffffff16171760801b955050505050505b92915050565b600080617fff60708460801c6fffffffffffffffffffffffffffffffff16901c166fffffffffffffffffffffffffffffffff1690506140fe81111561186357600080fd5b613fff81101561187757600091505061197a565b60006e0100000000000000000000000000006dffffffffffffffffffffffffffff8560801c6fffffffffffffffffffffffffffffffff161617905061406f8210156118cb578161406f0381901c90506118e1565b61406f8211156118e05761406f820381901b90505b5b6f800000000000000000000000000000008460801c6fffffffffffffffffffffffffffffffff1610611947577f800000000000000000000000000000000000000000000000000000000000000081111561193a57600080fd5b806000039250505061197a565b7f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff81111561197457600080fd5b80925050505b919050565b600033905090565b60008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050816000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508173ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a35050565b6000611a5a8686868686610e4e565b90508573ffffffffffffffffffffffffffffffffffffffff16636dc2b27133836040518363ffffffff1660e01b8152600401611a97929190612dfc565b602060405180830381600087803b158015611ab157600080fd5b505af1158015611ac5573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ae99190612bc4565b15611b58573373ffffffffffffffffffffffffffffffffffffffff168673ffffffffffffffffffffffffffffffffffffffff167ff03012dd4aab142682aa01439f94e975e2ec77ef558352323bc05f382f74b08283604051611b4b9190612f21565b60405180910390a3611bbe565b3373ffffffffffffffffffffffffffffffffffffffff168673ffffffffffffffffffffffffffffffffffffffff167f08b35d4c86707ba44cdcc5efaa79b8a307e6c7f789f1eb86ca1ff1e9bde0569783604051611bb59190612f21565b60405180910390a35b505050505050565b600080821415611bdc57600060801b9050611c3f565b60008290506000611bec82612870565b90506070811015611c05578060700382901b9150611c19565b6070811115611c18576070810382901c91505b5b607081613fff01901b6dffffffffffffffffffffffffffff83161791508160801b925050505b919050565b600080617fff60708560801c6fffffffffffffffffffffffffffffffff16901c166fffffffffffffffffffffffffffffffff1690506000617fff60708560801c6fffffffffffffffffffffffffffffffff16901c166fffffffffffffffffffffffffffffffff169050617fff821415611cff57617fff811415611cde576f7fff800000000000000000000000000060801b92505050612107565b6f8000000000000000000000000000000060801b8416851892505050612107565b617fff811415611d7e57600060801b6dffffffffffffffffffffffffffff60801b85166fffffffffffffffffffffffffffffffff191614611d57576f7fff800000000000000000000000000060801b92505050612107565b6f8000000000000000000000000000000060801b84861816600060801b1792505050612107565b600060801b6f7fffffffffffffffffffffffffffffff60801b85166fffffffffffffffffffffffffffffffff19161415611e3957600060801b6f7fffffffffffffffffffffffffffffff60801b86166fffffffffffffffffffffffffffffffff19161415611e03576f7fff800000000000000000000000000060801b92505050612107565b6f8000000000000000000000000000000060801b848618166f7fff000000000000000000000000000060801b1792505050612107565b60006dffffffffffffffffffffffffffff8560801c166fffffffffffffffffffffffffffffffff1690506000821415611e755760019150611e8a565b6e010000000000000000000000000000811790505b60006dffffffffffffffffffffffffffff8760801c166fffffffffffffffffffffffffffffffff1690506000841415611eee5760008114611ee9576000611ed082612870565b60e20390508082901b9150600194506072810384019350505b611f07565b60726e0100000000000000000000000000008217901b90505b818181611f1757611f1661323e565b5b0490506000811415611f8257600060801b6f8000000000000000000000000000000060801b878918166fffffffffffffffffffffffffffffffff191611611f6257600060801b611f77565b6f8000000000000000000000000000000060801b5b945050505050612107565b6d1000000000000000000000000000811015611fa157611fa06131e0565b5b60006e080000000000000000000000000000821015612002576e040000000000000000000000000000821015611ff7576e020000000000000000000000000000821015611fef576070611ff2565b60715b611ffa565b60725b60ff1661200c565b61200b82612870565b5b90506140718401818601111561202a57617fff9450600091506120c7565b83613ffc8287010110156120455760009450600091506120c6565b83613f8c8287010110156120935783613ffc860111156120705783613ffc86010382901b915061208a565b83613ffc8601101561208957613ffc8585030382901c91505b5b600094506120c5565b60708111156120a6576070810382901c91505b6dffffffffffffffffffffffffffff8216915083613f8d828701010394505b5b5b81607086901b6f8000000000000000000000000000000060801b898b181660801c6fffffffffffffffffffffffffffffffff16171760801b955050505050505b92915050565b600080617fff60708460801c6fffffffffffffffffffffffffffffffff16901c166fffffffffffffffffffffffffffffffff169050613fff811015612156576000915050612206565b6f800000000000000000000000000000008360801c6fffffffffffffffffffffffffffffffff161061218757600080fd5b6140fe81111561219657600080fd5b60006e0100000000000000000000000000006dffffffffffffffffffffffffffff8560801c6fffffffffffffffffffffffffffffffff161617905061406f8210156121ea578161406f0381901c9050612200565b61406f8211156121ff5761406f820381901b90505b5b80925050505b919050565b600080617fff60708560801c6fffffffffffffffffffffffffffffffff16901c166fffffffffffffffffffffffffffffffff1690506000617fff60708560801c6fffffffffffffffffffffffffffffffff16901c166fffffffffffffffffffffffffffffffff169050617fff8214156122e757617fff8114156122dd57836fffffffffffffffffffffffffffffffff1916856fffffffffffffffffffffffffffffffff191614156122c057849250505061286a565b6f7fff800000000000000000000000000060801b9250505061286a565b849250505061286a565b617fff8114156122fb57839250505061286a565b60006f800000000000000000000000000000008660801c6fffffffffffffffffffffffffffffffff161015905060006dffffffffffffffffffffffffffff8760801c166fffffffffffffffffffffffffffffffff16905060008414156123645760019350612379565b6e010000000000000000000000000000811790505b60006f800000000000000000000000000000008760801c6fffffffffffffffffffffffffffffffff161015905060006dffffffffffffffffffffffffffff8860801c166fffffffffffffffffffffffffffffffff16905060008514156123e257600194506123f7565b6e010000000000000000000000000000811790505b6000831415612459576f8000000000000000000000000000000060801b6fffffffffffffffffffffffffffffffff1916886fffffffffffffffffffffffffffffffff191614612446578761244c565b600060801b5b965050505050505061286a565b60008114156124bb576f8000000000000000000000000000000060801b6fffffffffffffffffffffffffffffffff1916896fffffffffffffffffffffffffffffffff1916146124a857886124ae565b600060801b5b965050505050505061286a565b6000858703905082151585151514156126395760708113156124e6578997505050505050505061286a565b60008113156124fa578082901c9150612548565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff90811215612531578897505050505050505061286a565b6000811215612547578060000384901c93508596505b5b81840193506e020000000000000000000000000000841061257157600184901c93506001870196505b617fff8714156125bc5784612599576f7fff000000000000000000000000000060801b6125ae565b6fffff000000000000000000000000000060801b5b97505050505050505061286a565b6e0100000000000000000000000000008410156125dc57600096506125f0565b6dffffffffffffffffffffffffffff841693505b83607088901b86612602576000612614565b6f800000000000000000000000000000005b6fffffffffffffffffffffffffffffffff16171760801b97505050505050505061286a565b600081131561265457600184901b935060018703965061266c565b600081121561266b57600182901b91506001860396505b5b607081131561267e5760019150612708565b600181131561269a57600180820360018403901c019150612707565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff908112156126cb5760019350612706565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff81121561270557600180826000030360018603901c0193505b5b5b5b818410612719578184039350612722565b83820393508294505b600084141561273e57600060801b97505050505050505061286a565b600061274985612870565b90506071811415612776576dffffffffffffffffffffffffffff600186901c1694506001880197506127d8565b60708110156127c3576000816070039050808911156127af576dffffffffffffffffffffffffffff8187901b16955080890398506127bd565b6001890386901b9550600098505b506127d7565b6dffffffffffffffffffffffffffff851694505b5b617fff8814156128245785612800576f7fff000000000000000000000000000060801b612815565b6fffff000000000000000000000000000060801b5b9850505050505050505061286a565b84607089901b87612836576000612848565b6f800000000000000000000000000000005b6fffffffffffffffffffffffffffffffff16171760801b985050505050505050505b92915050565b600080821161287e57600080fd5b600070010000000000000000000000000000000083106128a657608083901c92506080810190505b6801000000000000000083106128c457604083901c92506040810190505b64010000000083106128de57602083901c92506020810190505b6201000083106128f657601083901c92506010810190505b610100831061290d57600883901c92506008810190505b6010831061292357600483901c92506004810190505b6004831061293957600283901c92506002810190505b60028310612948576001810190505b80915050919050565b6000813590506129608161345b565b92915050565b6000815190506129758161345b565b92915050565b60008083601f840112612991576129906132f2565b5b8235905067ffffffffffffffff8111156129ae576129ad6132ed565b5b6020830191508360208202830111156129ca576129c96132f7565b5b9250929050565b6000815190506129e081613472565b92915050565b6000815190506129f581613489565b92915050565b600081359050612a0a816134a0565b92915050565b600081519050612a1f816134a0565b92915050565b600081519050612a34816134b7565b92915050565b600081519050612a49816134ce565b92915050565b600060208284031215612a6557612a64613301565b5b6000612a7384828501612951565b91505092915050565b600060208284031215612a9257612a91613301565b5b6000612aa084828501612966565b91505092915050565b600080600060608486031215612ac257612ac1613301565b5b6000612ad086828701612951565b9350506020612ae1868287016129fb565b9250506040612af2868287016129fb565b9150509250925092565b600080600080600060a08688031215612b1857612b17613301565b5b6000612b2688828901612951565b9550506020612b37888289016129fb565b9450506040612b48888289016129fb565b9350506060612b59888289016129fb565b9250506080612b6a888289016129fb565b9150509295509295909350565b60008060208385031215612b8e57612b8d613301565b5b600083013567ffffffffffffffff811115612bac57612bab6132fc565b5b612bb88582860161297b565b92509250509250929050565b600060208284031215612bda57612bd9613301565b5b6000612be8848285016129d1565b91505092915050565b600060208284031215612c0757612c06613301565b5b6000612c15848285016129e6565b91505092915050565b600060208284031215612c3457612c33613301565b5b6000612c4284828501612a10565b91505092915050565b60008060408385031215612c6257612c61613301565b5b6000612c70858286016129fb565b9250506020612c81858286016129fb565b9150509250929050565b600060208284031215612ca157612ca0613301565b5b6000612caf84828501612a25565b91505092915050565b600060208284031215612cce57612ccd613301565b5b6000612cdc84828501612a3a565b91505092915050565b612cee816130a0565b82525050565b612cfd816130b2565b82525050565b612d0c8161310f565b82525050565b612d1b816130be565b82525050565b6000612d2c82612f6f565b612d368185612f7a565b9350612d46818560208601613133565b612d4f81613306565b840191505092915050565b6000612d67602683612f7a565b9150612d7282613324565b604082019050919050565b6000612d8a602083612f7a565b9150612d9582613373565b602082019050919050565b6000612dad601283612f7a565b9150612db88261339c565b602082019050919050565b612dcc816130e8565b82525050565b612ddb816130e8565b82525050565b6000602082019050612df66000830184612ce5565b92915050565b6000604082019050612e116000830185612ce5565b612e1e6020830184612dc3565b9392505050565b6000602082019050612e3a6000830184612cf4565b92915050565b6000602082019050612e556000830184612d03565b92915050565b6000602082019050612e706000830184612d12565b92915050565b6000604082019050612e8b6000830185612d12565b612e986020830184612d12565b9392505050565b60006020820190508181036000830152612eb98184612d21565b905092915050565b60006020820190508181036000830152612eda81612d5a565b9050919050565b60006020820190508181036000830152612efa81612d7d565b9050919050565b60006020820190508181036000830152612f1a81612da0565b9050919050565b6000602082019050612f366000830184612dc3565b92915050565b6000604082019050612f516000830185612dd2565b612f5e6020830184612dd2565b9392505050565b6000604051905090565b600081519050919050565b600082825260208201905092915050565b6000612f96826130e8565b9150612fa1836130e8565b9250827fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff03821115612fd657612fd561320f565b5b828201905092915050565b6000612fec826130e8565b9150612ff7836130e8565b9250826130075761300661323e565b5b828204905092915050565b600061301d826130e8565b9150613028836130e8565b9250817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff04831182151516156130615761306061320f565b5b828202905092915050565b6000613077826130e8565b9150613082836130e8565b9250828210156130955761309461320f565b5b828203905092915050565b60006130ab826130c8565b9050919050565b60008115159050919050565b6000819050919050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000819050919050565b600063ffffffff82169050919050565b600060ff82169050919050565b600061311a82613121565b9050919050565b600061312c826130c8565b9050919050565b60005b83811015613151578082015181840152602081019050613136565b83811115613160576000848401525b50505050565b61316f82613306565b810181811067ffffffffffffffff8211171561318e5761318d61329c565b5b80604052505050565b60006131a2826130e8565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8214156131d5576131d461320f565b5b600182019050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052600160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600060033d11156132ea5760046000803e6132e7600051613317565b90505b90565b600080fd5b600080fd5b600080fd5b600080fd5b600080fd5b6000601f19601f8301169050919050565b60008160e01c9050919050565b7f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160008201527f6464726573730000000000000000000000000000000000000000000000000000602082015250565b7f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572600082015250565b7f43616c6c6572206e6f7420666163746f72790000000000000000000000000000600082015250565b600060443d10156133d557613458565b6133dd612f65565b60043d036004823e80513d602482011167ffffffffffffffff82111715613405575050613458565b808201805167ffffffffffffffff8111156134235750505050613458565b80602083010160043d038501811115613440575050505050613458565b61344f82602001850186613166565b82955050505050505b90565b613464816130a0565b811461346f57600080fd5b50565b61347b816130b2565b811461348657600080fd5b50565b613492816130be565b811461349d57600080fd5b50565b6134a9816130e8565b81146134b457600080fd5b50565b6134c0816130f2565b81146134cb57600080fd5b50565b6134d781613102565b81146134e257600080fd5b5056fea2646970667358221220cd1d1892c23aba169f2ce9ec0b60540260ee9095770d13be4b33462ff7dbc7b064736f6c63430008060033",
    "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106101165760003560e01c8063aea8acb1116100a2578063cdd9e13711610071578063cdd9e137146102cf578063ce1dcdfc146102ff578063f2fde38b1461032f578063f93019101461034b578063fcab9e981461036957610116565b8063aea8acb114610233578063b3fbb7c414610251578063b9c6536514610281578063c45a0155146102b157610116565b8063715018a6116100e9578063715018a6146101a15780638da5cb5b146101ab57806391a60782146101c95780639f9a3d95146101e5578063a40d6b801461020357610116565b80630417cf8e1461011b578063225739b1146101395780633c5c7fb3146101695780635bb4780814610185575b600080fd5b610123610385565b6040516101309190612f21565b60405180910390f35b610153600480360381019061014e9190612a4f565b61038a565b6040516101609190612e25565b60405180910390f35b610183600480360381019061017e9190612a4f565b6104ca565b005b61019f600480360381019061019a9190612a4f565b61071d565b005b6101a96107dd565b005b6101b3610865565b6040516101c09190612de1565b60405180910390f35b6101e360048036038101906101de9190612a4f565b61088e565b005b6101ed610cd2565b6040516101fa9190612f21565b60405180910390f35b61021d60048036038101906102189190612aa9565b610cd7565b60405161022a9190612f21565b60405180910390f35b61023b610e49565b6040516102489190612f21565b60405180910390f35b61026b60048036038101906102669190612afc565b610e4e565b6040516102789190612f21565b60405180910390f35b61029b60048036038101906102969190612c4b565b611090565b6040516102a89190612f21565b60405180910390f35b6102b96110da565b6040516102c69190612e40565b60405180910390f35b6102e960048036038101906102e49190612a4f565b611100565b6040516102f69190612e5b565b60405180910390f35b61031960048036038101906103149190612b77565b611118565b6040516103269190612e25565b60405180910390f35b61034960048036038101906103449190612a4f565b611189565b005b610353611281565b6040516103609190612f21565b60405180910390f35b610383600480360381019061037e9190612b77565b611286565b005b601281565b6000600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16635ab78ee1836040518263ffffffff1660e01b81526004016103e79190612de1565b60206040518083038186803b1580156103ff57600080fd5b505afa158015610413573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104379190612bc4565b61044457600090506104c5565b8173ffffffffffffffffffffffffffffffffffffffff16637bbf10336040518163ffffffff1660e01b815260040160206040518083038186803b15801561048a57600080fd5b505afa15801561049e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104c29190612bc4565b90505b919050565b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161461055a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161055190612f01565b60405180910390fd5b60008173ffffffffffffffffffffffffffffffffffffffff1663b9ed8abf6040518163ffffffff1660e01b815260040160206040518083038186803b1580156105a257600080fd5b505afa1580156105b6573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105da9190612a7c565b905060008173ffffffffffffffffffffffffffffffffffffffff166398d5fdca6040518163ffffffff1660e01b815260040160206040518083038186803b15801561062457600080fd5b505afa158015610638573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061065c9190612bf1565b9050600061068d61068861066f846112dc565b6f403abc16d674ec80000000000000000060801b61138a565b61181f565b9050818473ffffffffffffffffffffffffffffffffffffffff167fe950cb32f7a787627d713d7365623fef2d762ef8fcf813b865a04350852deb9b60405160405180910390a380600160008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000208190555050505050565b61072561197f565b73ffffffffffffffffffffffffffffffffffffffff16610743610865565b73ffffffffffffffffffffffffffffffffffffffff1614610799576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161079090612ee1565b60405180910390fd5b80600260006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050565b6107e561197f565b73ffffffffffffffffffffffffffffffffffffffff16610803610865565b73ffffffffffffffffffffffffffffffffffffffff1614610859576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161085090612ee1565b60405180910390fd5b6108636000611987565b565b60008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b60005a905061089c8261038a565b6108a65750610ccf565b600082905060008173ffffffffffffffffffffffffffffffffffffffff1663b9ed8abf6040518163ffffffff1660e01b815260040160206040518083038186803b1580156108f357600080fd5b505afa158015610907573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061092b9190612a7c565b73ffffffffffffffffffffffffffffffffffffffff166398d5fdca6040518163ffffffff1660e01b815260040160206040518083038186803b15801561097057600080fd5b505afa158015610984573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109a89190612bf1565b90506000600160008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020549050610a1b610a166109fd846112dc565b6f403abc16d674ec80000000000000000060801b61138a565b61181f565b600160008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000208190555060008373ffffffffffffffffffffffffffffffffffffffff16637de93f936040518163ffffffff1660e01b815260040160206040518083038186803b158015610aa657600080fd5b505afa158015610aba573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ade9190612c1e565b905060008473ffffffffffffffffffffffffffffffffffffffff1663fd2c80ae6040518163ffffffff1660e01b815260040160206040518083038186803b158015610b2857600080fd5b505afa158015610b3c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b609190612c8b565b63ffffffff1690508473ffffffffffffffffffffffffffffffffffffffff1663f633a74084600160008b73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020546040518363ffffffff1660e01b8152600401610be2929190612e76565b600060405180830381600087803b158015610bfc57600080fd5b505af1925050508015610c0d575060015b610c9e57610c196132cb565b806308c379a01415610c8d5750610c2e6133c5565b80610c395750610c8f565b8773ffffffffffffffffffffffffffffffffffffffff167f8a47468bf96478429d382ed6385d9c77fba8b89540cd88199b1b51d5723b11fa82604051610c7f9190612e9f565b60405180910390a250610c99565b505b3d6000803e3d6000fd5b610cc8565b60005a87610cac919061306c565b905060006402540be4009050610cc58982848787611a4b565b50505b5050505050505b50565b600581565b6000808473ffffffffffffffffffffffffffffffffffffffff16638226f3966040518163ffffffff1660e01b815260040160206040518083038186803b158015610d2057600080fd5b505afa158015610d34573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d589190612a7c565b73ffffffffffffffffffffffffffffffffffffffff166398d5fdca6040518163ffffffff1660e01b815260040160206040518083038186803b158015610d9d57600080fd5b505afa158015610db1573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610dd59190612bf1565b905060008113610de9576000915050610e42565b6000610dff8486610dfa9190613012565b611bc6565b90506000610e0c83611bc6565b9050610e3c610e37610e1e848461138a565b6f403abc16d674ec80000000000000000060801b611c44565b61210d565b93505050505b9392505050565b600581565b600080610e5c878787610cd7565b90506000610e8e610e75610e708787611090565b611bc6565b6f403abc16d674ec80000000000000000060801b61138a565b9050610ea381610e9e6064611bc6565b611c44565b90506000610eee610ee9610eb685611bc6565b610ee4610ecb610ec588611bc6565b8761138a565b6f403abc16d674ec80000000000000000060801b611c44565b61220b565b61181f565b905060008973ffffffffffffffffffffffffffffffffffffffff1663217a4b706040518163ffffffff1660e01b815260040160206040518083038186803b158015610f3857600080fd5b505afa158015610f4c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f709190612a7c565b73ffffffffffffffffffffffffffffffffffffffff1663313ce5676040518163ffffffff1660e01b815260040160206040518083038186803b158015610fb557600080fd5b505afa158015610fc9573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610fed9190612cb8565b60ff169050600073__$dc3b4b0a367edd91a2d74c73e2da54c142$__63bf36f0e984846040518363ffffffff1660e01b815260040161102d929190612f3c565b60206040518083038186803b15801561104557600080fd5b505af4158015611059573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061107d9190612c1e565b9050809550505050505095945050505050565b600080600d83856110a19190612f8b565b426110ac919061306c565b6110b69190612fe1565b90508060056110c59190613012565b60056110d19190612f8b565b91505092915050565b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b60016020528060005260406000206000915090505481565b600080600090505b8383905081101561117d5761115b8484838181106111415761114061326d565b5b90506020020160208101906111569190612a4f565b61038a565b1561116a576001915050611183565b808061117590613197565b915050611120565b50600090505b92915050565b61119161197f565b73ffffffffffffffffffffffffffffffffffffffff166111af610865565b73ffffffffffffffffffffffffffffffffffffffff1614611205576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016111fc90612ee1565b60405180910390fd5b600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff161415611275576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161126c90612ec1565b60405180910390fd5b61127e81611987565b50565b600d81565b60005b828290508110156112d7576112c48383838181106112aa576112a961326d565b5b90506020020160208101906112bf9190612a4f565b61088e565b80806112cf90613197565b915050611289565b505050565b6000808214156112f257600060801b9050611385565b60008083136113045782600003611306565b825b9050600061131382612870565b9050607081101561132c578060700382901b9150611340565b607081111561133f576070810382901c91505b5b607081613fff01901b6dffffffffffffffffffffffffffff8316179150600084121561137c576f80000000000000000000000000000000821791505b8160801b925050505b919050565b600080617fff60708560801c6fffffffffffffffffffffffffffffffff16901c166fffffffffffffffffffffffffffffffff1690506000617fff60708560801c6fffffffffffffffffffffffffffffffff16901c166fffffffffffffffffffffffffffffffff169050617fff82141561152157617fff8114156114af57836fffffffffffffffffffffffffffffffff1916856fffffffffffffffffffffffffffffffff19161415611456576f8000000000000000000000000000000060801b8416851892505050611819565b6f8000000000000000000000000000000060801b8486186fffffffffffffffffffffffffffffffff191614156114925783851792505050611819565b6f7fff800000000000000000000000000060801b92505050611819565b600060801b6f7fffffffffffffffffffffffffffffff60801b85166fffffffffffffffffffffffffffffffff19161415611500576f7fff800000000000000000000000000060801b92505050611819565b6f8000000000000000000000000000000060801b8416851892505050611819565b617fff81141561159d57600060801b6f7fffffffffffffffffffffffffffffff60801b86166fffffffffffffffffffffffffffffffff1916141561157c576f7fff800000000000000000000000000060801b92505050611819565b6f8000000000000000000000000000000060801b8516841892505050611819565b60006dffffffffffffffffffffffffffff8660801c166fffffffffffffffffffffffffffffffff16905060008314156115d957600192506115ee565b6e010000000000000000000000000000811790505b60006dffffffffffffffffffffffffffff8660801c166fffffffffffffffffffffffffffffffff169050600083141561162a576001925061163f565b6e010000000000000000000000000000811790505b808202915060008214156116ac57600060801b6f8000000000000000000000000000000060801b878918166fffffffffffffffffffffffffffffffff19161161168c57600060801b6116a1565b6f8000000000000000000000000000000060801b5b945050505050611819565b828401935060007c0200000000000000000000000000000000000000000000000000000000831015611713577c010000000000000000000000000000000000000000000000000000000083101561170b5761170683612870565b61170e565b60e05b611716565b60e15b905061407081860110156117315760009450600092506117d9565b6140e081860110156117755761407085101561175657846140700383901c925061176c565b61407085111561176b57614070850383901b92505b5b600094506117d8565b61c0dd818601111561178f57617fff9450600092506117d7565b60708111156117a6576070810383901c92506117ba565b60708110156117b9578060700383901b92505b5b6dffffffffffffffffffffffffffff831692506140df8186010394505b5b5b82607086901b6f8000000000000000000000000000000060801b898b181660801c6fffffffffffffffffffffffffffffffff16171760801b955050505050505b92915050565b600080617fff60708460801c6fffffffffffffffffffffffffffffffff16901c166fffffffffffffffffffffffffffffffff1690506140fe81111561186357600080fd5b613fff81101561187757600091505061197a565b60006e0100000000000000000000000000006dffffffffffffffffffffffffffff8560801c6fffffffffffffffffffffffffffffffff161617905061406f8210156118cb578161406f0381901c90506118e1565b61406f8211156118e05761406f820381901b90505b5b6f800000000000000000000000000000008460801c6fffffffffffffffffffffffffffffffff1610611947577f800000000000000000000000000000000000000000000000000000000000000081111561193a57600080fd5b806000039250505061197a565b7f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff81111561197457600080fd5b80925050505b919050565b600033905090565b60008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050816000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508173ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a35050565b6000611a5a8686868686610e4e565b90508573ffffffffffffffffffffffffffffffffffffffff16636dc2b27133836040518363ffffffff1660e01b8152600401611a97929190612dfc565b602060405180830381600087803b158015611ab157600080fd5b505af1158015611ac5573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ae99190612bc4565b15611b58573373ffffffffffffffffffffffffffffffffffffffff168673ffffffffffffffffffffffffffffffffffffffff167ff03012dd4aab142682aa01439f94e975e2ec77ef558352323bc05f382f74b08283604051611b4b9190612f21565b60405180910390a3611bbe565b3373ffffffffffffffffffffffffffffffffffffffff168673ffffffffffffffffffffffffffffffffffffffff167f08b35d4c86707ba44cdcc5efaa79b8a307e6c7f789f1eb86ca1ff1e9bde0569783604051611bb59190612f21565b60405180910390a35b505050505050565b600080821415611bdc57600060801b9050611c3f565b60008290506000611bec82612870565b90506070811015611c05578060700382901b9150611c19565b6070811115611c18576070810382901c91505b5b607081613fff01901b6dffffffffffffffffffffffffffff83161791508160801b925050505b919050565b600080617fff60708560801c6fffffffffffffffffffffffffffffffff16901c166fffffffffffffffffffffffffffffffff1690506000617fff60708560801c6fffffffffffffffffffffffffffffffff16901c166fffffffffffffffffffffffffffffffff169050617fff821415611cff57617fff811415611cde576f7fff800000000000000000000000000060801b92505050612107565b6f8000000000000000000000000000000060801b8416851892505050612107565b617fff811415611d7e57600060801b6dffffffffffffffffffffffffffff60801b85166fffffffffffffffffffffffffffffffff191614611d57576f7fff800000000000000000000000000060801b92505050612107565b6f8000000000000000000000000000000060801b84861816600060801b1792505050612107565b600060801b6f7fffffffffffffffffffffffffffffff60801b85166fffffffffffffffffffffffffffffffff19161415611e3957600060801b6f7fffffffffffffffffffffffffffffff60801b86166fffffffffffffffffffffffffffffffff19161415611e03576f7fff800000000000000000000000000060801b92505050612107565b6f8000000000000000000000000000000060801b848618166f7fff000000000000000000000000000060801b1792505050612107565b60006dffffffffffffffffffffffffffff8560801c166fffffffffffffffffffffffffffffffff1690506000821415611e755760019150611e8a565b6e010000000000000000000000000000811790505b60006dffffffffffffffffffffffffffff8760801c166fffffffffffffffffffffffffffffffff1690506000841415611eee5760008114611ee9576000611ed082612870565b60e20390508082901b9150600194506072810384019350505b611f07565b60726e0100000000000000000000000000008217901b90505b818181611f1757611f1661323e565b5b0490506000811415611f8257600060801b6f8000000000000000000000000000000060801b878918166fffffffffffffffffffffffffffffffff191611611f6257600060801b611f77565b6f8000000000000000000000000000000060801b5b945050505050612107565b6d1000000000000000000000000000811015611fa157611fa06131e0565b5b60006e080000000000000000000000000000821015612002576e040000000000000000000000000000821015611ff7576e020000000000000000000000000000821015611fef576070611ff2565b60715b611ffa565b60725b60ff1661200c565b61200b82612870565b5b90506140718401818601111561202a57617fff9450600091506120c7565b83613ffc8287010110156120455760009450600091506120c6565b83613f8c8287010110156120935783613ffc860111156120705783613ffc86010382901b915061208a565b83613ffc8601101561208957613ffc8585030382901c91505b5b600094506120c5565b60708111156120a6576070810382901c91505b6dffffffffffffffffffffffffffff8216915083613f8d828701010394505b5b5b81607086901b6f8000000000000000000000000000000060801b898b181660801c6fffffffffffffffffffffffffffffffff16171760801b955050505050505b92915050565b600080617fff60708460801c6fffffffffffffffffffffffffffffffff16901c166fffffffffffffffffffffffffffffffff169050613fff811015612156576000915050612206565b6f800000000000000000000000000000008360801c6fffffffffffffffffffffffffffffffff161061218757600080fd5b6140fe81111561219657600080fd5b60006e0100000000000000000000000000006dffffffffffffffffffffffffffff8560801c6fffffffffffffffffffffffffffffffff161617905061406f8210156121ea578161406f0381901c9050612200565b61406f8211156121ff5761406f820381901b90505b5b80925050505b919050565b600080617fff60708560801c6fffffffffffffffffffffffffffffffff16901c166fffffffffffffffffffffffffffffffff1690506000617fff60708560801c6fffffffffffffffffffffffffffffffff16901c166fffffffffffffffffffffffffffffffff169050617fff8214156122e757617fff8114156122dd57836fffffffffffffffffffffffffffffffff1916856fffffffffffffffffffffffffffffffff191614156122c057849250505061286a565b6f7fff800000000000000000000000000060801b9250505061286a565b849250505061286a565b617fff8114156122fb57839250505061286a565b60006f800000000000000000000000000000008660801c6fffffffffffffffffffffffffffffffff161015905060006dffffffffffffffffffffffffffff8760801c166fffffffffffffffffffffffffffffffff16905060008414156123645760019350612379565b6e010000000000000000000000000000811790505b60006f800000000000000000000000000000008760801c6fffffffffffffffffffffffffffffffff161015905060006dffffffffffffffffffffffffffff8860801c166fffffffffffffffffffffffffffffffff16905060008514156123e257600194506123f7565b6e010000000000000000000000000000811790505b6000831415612459576f8000000000000000000000000000000060801b6fffffffffffffffffffffffffffffffff1916886fffffffffffffffffffffffffffffffff191614612446578761244c565b600060801b5b965050505050505061286a565b60008114156124bb576f8000000000000000000000000000000060801b6fffffffffffffffffffffffffffffffff1916896fffffffffffffffffffffffffffffffff1916146124a857886124ae565b600060801b5b965050505050505061286a565b6000858703905082151585151514156126395760708113156124e6578997505050505050505061286a565b60008113156124fa578082901c9150612548565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff90811215612531578897505050505050505061286a565b6000811215612547578060000384901c93508596505b5b81840193506e020000000000000000000000000000841061257157600184901c93506001870196505b617fff8714156125bc5784612599576f7fff000000000000000000000000000060801b6125ae565b6fffff000000000000000000000000000060801b5b97505050505050505061286a565b6e0100000000000000000000000000008410156125dc57600096506125f0565b6dffffffffffffffffffffffffffff841693505b83607088901b86612602576000612614565b6f800000000000000000000000000000005b6fffffffffffffffffffffffffffffffff16171760801b97505050505050505061286a565b600081131561265457600184901b935060018703965061266c565b600081121561266b57600182901b91506001860396505b5b607081131561267e5760019150612708565b600181131561269a57600180820360018403901c019150612707565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff908112156126cb5760019350612706565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff81121561270557600180826000030360018603901c0193505b5b5b5b818410612719578184039350612722565b83820393508294505b600084141561273e57600060801b97505050505050505061286a565b600061274985612870565b90506071811415612776576dffffffffffffffffffffffffffff600186901c1694506001880197506127d8565b60708110156127c3576000816070039050808911156127af576dffffffffffffffffffffffffffff8187901b16955080890398506127bd565b6001890386901b9550600098505b506127d7565b6dffffffffffffffffffffffffffff851694505b5b617fff8814156128245785612800576f7fff000000000000000000000000000060801b612815565b6fffff000000000000000000000000000060801b5b9850505050505050505061286a565b84607089901b87612836576000612848565b6f800000000000000000000000000000005b6fffffffffffffffffffffffffffffffff16171760801b985050505050505050505b92915050565b600080821161287e57600080fd5b600070010000000000000000000000000000000083106128a657608083901c92506080810190505b6801000000000000000083106128c457604083901c92506040810190505b64010000000083106128de57602083901c92506020810190505b6201000083106128f657601083901c92506010810190505b610100831061290d57600883901c92506008810190505b6010831061292357600483901c92506004810190505b6004831061293957600283901c92506002810190505b60028310612948576001810190505b80915050919050565b6000813590506129608161345b565b92915050565b6000815190506129758161345b565b92915050565b60008083601f840112612991576129906132f2565b5b8235905067ffffffffffffffff8111156129ae576129ad6132ed565b5b6020830191508360208202830111156129ca576129c96132f7565b5b9250929050565b6000815190506129e081613472565b92915050565b6000815190506129f581613489565b92915050565b600081359050612a0a816134a0565b92915050565b600081519050612a1f816134a0565b92915050565b600081519050612a34816134b7565b92915050565b600081519050612a49816134ce565b92915050565b600060208284031215612a6557612a64613301565b5b6000612a7384828501612951565b91505092915050565b600060208284031215612a9257612a91613301565b5b6000612aa084828501612966565b91505092915050565b600080600060608486031215612ac257612ac1613301565b5b6000612ad086828701612951565b9350506020612ae1868287016129fb565b9250506040612af2868287016129fb565b9150509250925092565b600080600080600060a08688031215612b1857612b17613301565b5b6000612b2688828901612951565b9550506020612b37888289016129fb565b9450506040612b48888289016129fb565b9350506060612b59888289016129fb565b9250506080612b6a888289016129fb565b9150509295509295909350565b60008060208385031215612b8e57612b8d613301565b5b600083013567ffffffffffffffff811115612bac57612bab6132fc565b5b612bb88582860161297b565b92509250509250929050565b600060208284031215612bda57612bd9613301565b5b6000612be8848285016129d1565b91505092915050565b600060208284031215612c0757612c06613301565b5b6000612c15848285016129e6565b91505092915050565b600060208284031215612c3457612c33613301565b5b6000612c4284828501612a10565b91505092915050565b60008060408385031215612c6257612c61613301565b5b6000612c70858286016129fb565b9250506020612c81858286016129fb565b9150509250929050565b600060208284031215612ca157612ca0613301565b5b6000612caf84828501612a25565b91505092915050565b600060208284031215612cce57612ccd613301565b5b6000612cdc84828501612a3a565b91505092915050565b612cee816130a0565b82525050565b612cfd816130b2565b82525050565b612d0c8161310f565b82525050565b612d1b816130be565b82525050565b6000612d2c82612f6f565b612d368185612f7a565b9350612d46818560208601613133565b612d4f81613306565b840191505092915050565b6000612d67602683612f7a565b9150612d7282613324565b604082019050919050565b6000612d8a602083612f7a565b9150612d9582613373565b602082019050919050565b6000612dad601283612f7a565b9150612db88261339c565b602082019050919050565b612dcc816130e8565b82525050565b612ddb816130e8565b82525050565b6000602082019050612df66000830184612ce5565b92915050565b6000604082019050612e116000830185612ce5565b612e1e6020830184612dc3565b9392505050565b6000602082019050612e3a6000830184612cf4565b92915050565b6000602082019050612e556000830184612d03565b92915050565b6000602082019050612e706000830184612d12565b92915050565b6000604082019050612e8b6000830185612d12565b612e986020830184612d12565b9392505050565b60006020820190508181036000830152612eb98184612d21565b905092915050565b60006020820190508181036000830152612eda81612d5a565b9050919050565b60006020820190508181036000830152612efa81612d7d565b9050919050565b60006020820190508181036000830152612f1a81612da0565b9050919050565b6000602082019050612f366000830184612dc3565b92915050565b6000604082019050612f516000830185612dd2565b612f5e6020830184612dd2565b9392505050565b6000604051905090565b600081519050919050565b600082825260208201905092915050565b6000612f96826130e8565b9150612fa1836130e8565b9250827fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff03821115612fd657612fd561320f565b5b828201905092915050565b6000612fec826130e8565b9150612ff7836130e8565b9250826130075761300661323e565b5b828204905092915050565b600061301d826130e8565b9150613028836130e8565b9250817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff04831182151516156130615761306061320f565b5b828202905092915050565b6000613077826130e8565b9150613082836130e8565b9250828210156130955761309461320f565b5b828203905092915050565b60006130ab826130c8565b9050919050565b60008115159050919050565b6000819050919050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000819050919050565b600063ffffffff82169050919050565b600060ff82169050919050565b600061311a82613121565b9050919050565b600061312c826130c8565b9050919050565b60005b83811015613151578082015181840152602081019050613136565b83811115613160576000848401525b50505050565b61316f82613306565b810181811067ffffffffffffffff8211171561318e5761318d61329c565b5b80604052505050565b60006131a2826130e8565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8214156131d5576131d461320f565b5b600182019050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052600160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600060033d11156132ea5760046000803e6132e7600051613317565b90505b90565b600080fd5b600080fd5b600080fd5b600080fd5b600080fd5b6000601f19601f8301169050919050565b60008160e01c9050919050565b7f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160008201527f6464726573730000000000000000000000000000000000000000000000000000602082015250565b7f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572600082015250565b7f43616c6c6572206e6f7420666163746f72790000000000000000000000000000600082015250565b600060443d10156133d557613458565b6133dd612f65565b60043d036004823e80513d602482011167ffffffffffffffff82111715613405575050613458565b808201805167ffffffffffffffff8111156134235750505050613458565b80602083010160043d038501811115613440575050505050613458565b61344f82602001850186613166565b82955050505050505b90565b613464816130a0565b811461346f57600080fd5b50565b61347b816130b2565b811461348657600080fd5b50565b613492816130be565b811461349d57600080fd5b50565b6134a9816130e8565b81146134b457600080fd5b50565b6134c0816130f2565b81146134cb57600080fd5b50565b6134d781613102565b81146134e257600080fd5b5056fea2646970667358221220cd1d1892c23aba169f2ce9ec0b60540260ee9095770d13be4b33462ff7dbc7b064736f6c63430008060033",
    "libraries": {
        "PoolSwapLibrary": "0x3f4a6959e5D34E24a192B8AbF9AA7cc451a19864"
    },
    "devdoc": {
        "kind": "dev",
        "methods": {
            "checkUpkeepMultiplePools(address[])": {
                "params": {
                    "_pools": "The array of pools to check"
                },
                "returns": {
                    "_0": "upkeepNeeded Whether or not at least one pool needs upkeeping"
                }
            },
            "checkUpkeepSinglePool(address)": {
                "params": {
                    "_pool": "The address of the pool to upkeep"
                },
                "returns": {
                    "_0": "upkeepNeeded Whether or not upkeep is needed for this single pool"
                }
            },
            "keeperGas(address,uint256,uint256)": {
                "params": {
                    "_gasPrice": "Price of a single gas unit (in ETH)",
                    "_gasSpent": "Number of gas units spent",
                    "_pool": "Address of the given pool"
                },
                "returns": {
                    "_0": "Keeper's gas compensation"
                }
            },
            "keeperReward(address,uint256,uint256,uint256,uint256)": {
                "params": {
                    "_gasPrice": "Price of a single gas unit (in ETH)",
                    "_gasSpent": "Number of gas units spent",
                    "_pool": "Address of the given pool",
                    "_poolInterval": "Pool interval of the given pool",
                    "_savedPreviousUpdatedTimestamp": "Last timestamp when the pool's price execution happened"
                },
                "returns": {
                    "_0": "Number of settlement tokens to give to the keeper for work performed"
                }
            },
            "keeperTip(uint256,uint256)": {
                "params": {
                    "_poolInterval": "Pool interval of the given pool",
                    "_savedPreviousUpdatedTimestamp": "Last timestamp when the pool's price execution happened"
                },
                "returns": {
                    "_0": "Percent of the `keeperGas` cost to add to payment, as a percent"
                }
            },
            "newPool(address)": {
                "params": {
                    "_poolAddress": "The address of the newly-created pools"
                }
            },
            "owner()": {
                "details": "Returns the address of the current owner."
            },
            "performUpkeepMultiplePools(address[])": {
                "params": {
                    "pools": "pool codes to perform the update for"
                }
            },
            "performUpkeepSinglePool(address)": {
                "params": {
                    "_pool": "The pool code to perform the update for"
                }
            },
            "renounceOwnership()": {
                "details": "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."
            },
            "transferOwnership(address)": {
                "details": "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."
            }
        },
        "title": "The manager contract for multiple markets and the pools in them",
        "version": 1
    },
    "userdoc": {
        "events": {
            "KeeperPaid(address,address,uint256)": {
                "notice": "Creates a notification when a keeper is paid for doing upkeep for a pool"
            },
            "KeeperPaymentError(address,address,uint256)": {
                "notice": "Creates a notification when a keeper's payment for upkeeping a pool failed"
            },
            "PoolAdded(address,int256)": {
                "notice": "Creates a notification when a pool is created"
            },
            "PoolUpkeepError(address,string)": {
                "notice": "Creates a notification of a failed pool update"
            }
        },
        "kind": "user",
        "methods": {
            "checkUpkeepMultiplePools(address[])": {
                "notice": "Checks multiple pools if any of them need updating"
            },
            "checkUpkeepSinglePool(address)": {
                "notice": "Check if upkeep is required"
            },
            "executionPrice(address)": {
                "notice": "Format: Pool address => last executionPrice"
            },
            "keeperGas(address,uint256,uint256)": {
                "notice": "Compensation a keeper will receive for their gas expenditure"
            },
            "keeperReward(address,uint256,uint256,uint256,uint256)": {
                "notice": "Payment keeper receives for performing upkeep on a given pool"
            },
            "keeperTip(uint256,uint256)": {
                "notice": "Tip a keeper will receive for successfully updating the specified pool"
            },
            "newPool(address)": {
                "notice": "When a pool is created, this function is called by the factory to initiate price trackings"
            },
            "performUpkeepMultiplePools(address[])": {
                "notice": "Called by keepers to perform an update on multiple pools"
            },
            "performUpkeepSinglePool(address)": {
                "notice": "Called by keepers to perform an update on a single pool"
            }
        },
        "version": 1
    },
    "storageLayout": {
        "storage": [
            {
                "astId": 110,
                "contract": "contracts/implementation/PoolKeeper.sol:PoolKeeper",
                "label": "_owner",
                "offset": 0,
                "slot": "0",
                "type": "t_address"
            },
            {
                "astId": 8485,
                "contract": "contracts/implementation/PoolKeeper.sol:PoolKeeper",
                "label": "executionPrice",
                "offset": 0,
                "slot": "1",
                "type": "t_mapping(t_address,t_int256)"
            },
            {
                "astId": 8488,
                "contract": "contracts/implementation/PoolKeeper.sol:PoolKeeper",
                "label": "factory",
                "offset": 0,
                "slot": "2",
                "type": "t_contract(IPoolFactory)10117"
            }
        ],
        "types": {
            "t_address": {
                "encoding": "inplace",
                "label": "address",
                "numberOfBytes": "20"
            },
            "t_contract(IPoolFactory)10117": {
                "encoding": "inplace",
                "label": "contract IPoolFactory",
                "numberOfBytes": "20"
            },
            "t_int256": {
                "encoding": "inplace",
                "label": "int256",
                "numberOfBytes": "32"
            },
            "t_mapping(t_address,t_int256)": {
                "encoding": "mapping",
                "key": "t_address",
                "label": "mapping(address => int256)",
                "numberOfBytes": "32",
                "value": "t_int256"
            }
        }
    }
}
