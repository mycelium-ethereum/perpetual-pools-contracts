{
  "address": "0xf17b4f778f4314B34fa2E9aE96971A79DC8C963C",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_poolFactoryAddress",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "user",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "poolCommitter",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "updateIntervalId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "newReward",
          "type": "uint256"
        }
      ],
      "name": "PaidClaimRequestUpdate",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "user",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "poolCommitter",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "reward",
          "type": "uint256"
        }
      ],
      "name": "PaidRequestExecution",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "user",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "poolCommitter",
          "type": "address"
        }
      ],
      "name": "RequestWithdrawn",
      "type": "event"
    },
    {
      "stateMutability": "payable",
      "type": "fallback"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint128",
              "name": "updateIntervalId",
              "type": "uint128"
            },
            {
              "internalType": "uint256",
              "name": "reward",
              "type": "uint256"
            }
          ],
          "internalType": "struct IAutoClaim.ClaimRequest",
          "name": "request",
          "type": "tuple"
        },
        {
          "internalType": "uint256",
          "name": "currentUpdateIntervalId",
          "type": "uint256"
        }
      ],
      "name": "checkClaim",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "user",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "poolCommitter",
          "type": "address"
        }
      ],
      "name": "checkUserClaim",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "claimRequests",
      "outputs": [
        {
          "internalType": "uint128",
          "name": "updateIntervalId",
          "type": "uint128"
        },
        {
          "internalType": "uint256",
          "name": "reward",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "user",
          "type": "address"
        }
      ],
      "name": "makePaidClaimRequest",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "args1",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "args2",
          "type": "bytes"
        }
      ],
      "name": "multiPaidClaimMultiplePoolCommitters",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "args",
          "type": "bytes"
        },
        {
          "internalType": "address",
          "name": "poolCommitterAddress",
          "type": "address"
        }
      ],
      "name": "multiPaidClaimSinglePoolCommitter",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "user",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "poolCommitterAddress",
          "type": "address"
        }
      ],
      "name": "paidClaim",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "poolCommitter",
          "type": "address"
        }
      ],
      "name": "withdrawClaimRequest",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "user",
          "type": "address"
        }
      ],
      "name": "withdrawUserClaimRequest",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "stateMutability": "payable",
      "type": "receive"
    }
  ],
  "transactionHash": "0x59482a997daae655e076b3cbc5637d604419898818ddcd77ab009585deb13368",
  "receipt": {
    "to": null,
    "from": "0xfb59B91646cd0890F3E5343384FEb746989B66C7",
    "contractAddress": "0xf17b4f778f4314B34fa2E9aE96971A79DC8C963C",
    "transactionIndex": 0,
    "gasUsed": "18362666",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x045db0e7c7bae370abfd3a3df75d0430491a35f66dbc8d1f92481a51c49a4dc5",
    "transactionHash": "0x59482a997daae655e076b3cbc5637d604419898818ddcd77ab009585deb13368",
    "logs": [],
    "blockNumber": 12184318,
    "cumulativeGasUsed": "8350306",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x615ae0452587d6030bC68fb3A9e205e430c0CF8f"
  ],
  "solcInputHash": "ed877995a3a12fdfd020e943737872e5",
  "metadata": "{\"compiler\":{\"version\":\"0.8.7+commit.e28d00a7\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_poolFactoryAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"poolCommitter\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"updateIntervalId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newReward\",\"type\":\"uint256\"}],\"name\":\"PaidClaimRequestUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"poolCommitter\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"PaidRequestExecution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"poolCommitter\",\"type\":\"address\"}],\"name\":\"RequestWithdrawn\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint128\",\"name\":\"updateIntervalId\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"internalType\":\"struct IAutoClaim.ClaimRequest\",\"name\":\"request\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"currentUpdateIntervalId\",\"type\":\"uint256\"}],\"name\":\"checkClaim\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"poolCommitter\",\"type\":\"address\"}],\"name\":\"checkUserClaim\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"claimRequests\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"updateIntervalId\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"makePaidClaimRequest\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"args1\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"args2\",\"type\":\"bytes\"}],\"name\":\"multiPaidClaimMultiplePoolCommitters\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"args\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"poolCommitterAddress\",\"type\":\"address\"}],\"name\":\"multiPaidClaimSinglePoolCommitter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"poolCommitterAddress\",\"type\":\"address\"}],\"name\":\"paidClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolCommitter\",\"type\":\"address\"}],\"name\":\"withdrawClaimRequest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"withdrawUserClaimRequest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}],\"devdoc\":{\"details\":\"A question I had to ask was \\\"What happens if one requests a second claim before one's pending request from a previous update interval one gets executed on?\\\".      My solution to this was to have the committer instantly claim for themself. They have signified their desire to claim their tokens, after all.\",\"kind\":\"dev\",\"methods\":{\"checkClaim((uint128,uint256),uint256)\":{\"details\":\"A claim request can be executed only if one exists and is from an update interval that has passed.\",\"params\":{\"currentUpdateIntervalId\":\"The current update interval. Used to compare to the update interval of the ClaimRequest.\",\"request\":\"The ClaimRequest object to be checked.\"},\"returns\":{\"_0\":\"true if the given claim request can be executed.\"}},\"checkUserClaim(address,address)\":{\"params\":{\"poolCommitter\":\"The pool committer in which to look for a user's claim request.\",\"user\":\"The user whose claim request will be checked.\"},\"returns\":{\"_0\":\"true if the claim request can be executed.\"}},\"makePaidClaimRequest(address)\":{\"details\":\"Only callable by this contract's associated PoolCommitter instance. This prevents griefing. Consider a permissionless function, where a user can claim that somebody else wants to auto claim when they do not.Emits a `PaidRequestExecution` event on successful claim for pending commit.\",\"params\":{\"user\":\"The user who wants to autoclaim.\"}},\"multiPaidClaimMultiplePoolCommitters(bytes,bytes)\":{\"details\":\"The nth address in args2 should be the address of the PoolCommitter where the nth address in args1 requested an auto claim.\",\"params\":{\"args1\":\"Arguments for the function packed into a bytes array.                        __                       /  |    __ _ _ __ __ _ ___ `| |     _______________________________________________________________________________________________________________________   / _` | '__/ _` / __| | |    |          20 bytes          |          20 bytes         |          20 bytes          |          20 bytes         | ... |  | (_| | | | (_| \\\\__ \\\\_| |_   |      0th user address      |     1st user address      |      3rd user address      |      4th user address     | ... |   \\\\__,_|_|  \\\\__, |___/\\\\___/    \\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e              __/ |             |___/                       ___                      |__ \\\\    __ _ _ __ __ _ ___   ) |    _______________________________________________________________________________________________________________________   / _` | '__/ _` / __| / /    |          20 bytes          |          20 bytes         |          20 bytes          |          20 bytes         | ... |  | (_| | | | (_| \\\\__ \\\\/ /_    |  0th poolCommitter address | 1st poolCommitter address |  3rd poolCommitter address | 4th poolCommitter address | ... |   \\\\__,_|_|  \\\\__, |___/____|    \\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e              __/ |             |___/\"}},\"multiPaidClaimSinglePoolCommitter(bytes,address)\":{\"details\":\"poolCommitterAddress should be the PoolCommitter where all the supplied user addresses requested an auto claim\",\"params\":{\"args\":\"Arguments for the function packed into a bytes array. Generated with L2Encoder.encode  _______________________________________________________________________________________________________________________ |          20 bytes          |          20 bytes         |          20 bytes          |          20 bytes         | ... | |      0th user address      |     1st user address      |      3rd user address      |      4th user address     | ... |  \\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\",\"poolCommitterAddress\":\"The PoolCommitter address within which you would like to claim for the respective user\"}},\"paidClaim(address,address)\":{\"params\":{\"poolCommitterAddress\":\"The PoolCommitter address within which the user's claim will be executed\",\"user\":\"The user who requested an autoclaim.\"}},\"withdrawClaimRequest(address)\":{\"details\":\"Emits a `RequestWithdrawn` event on success\",\"params\":{\"poolCommitter\":\"The PoolCommitter for which the user's commit claim is to be withdrawn.\"}},\"withdrawUserClaimRequest(address)\":{\"details\":\"Only callable by the associated `PoolCommitter` contract\",\"params\":{\"user\":\"The user who will have their claim request withdrawn.\"}}},\"title\":\"The contract to be used for paying to have a keeper claim your commit automatically\",\"version\":1},\"userdoc\":{\"events\":{\"PaidClaimRequestUpdate(address,address,uint256,uint256)\":{\"notice\":\"Creates a notification when an auto-claim request is updated. i.e. When another commit is added and reward is incremented.\"},\"PaidRequestExecution(address,address,uint256)\":{\"notice\":\"Creates a notification when an auto-claim request is executed\"},\"RequestWithdrawn(address,address)\":{\"notice\":\"Creates a notification when an auto-claim request is withdrawn\"}},\"kind\":\"user\",\"methods\":{\"checkUserClaim(address,address)\":{\"notice\":\"Check the validity of a user's claim request for a given pool committer.\"},\"makePaidClaimRequest(address)\":{\"notice\":\"Pay for your commit to be claimed. This means that a willing participant can claim on `user`'s behalf when the current update interval ends. Claims a previously pending and claimable request before creating the requested claim-request.\"},\"multiPaidClaimMultiplePoolCommitters(bytes,bytes)\":{\"notice\":\"Call `paidClaim` for multiple users, across multiple PoolCommitters.\"},\"multiPaidClaimSinglePoolCommitter(bytes,address)\":{\"notice\":\"Call `paidClaim` for multiple users, in a single PoolCommitter.\"},\"paidClaim(address,address)\":{\"notice\":\"Claim on the behalf of a user who has requested to have their commit automatically claimed by a keeper.\"},\"withdrawClaimRequest(address)\":{\"notice\":\"If a user's claim request never gets executed (due to not high enough of a reward), or they change their minds, enable them to withdraw their request.\"},\"withdrawUserClaimRequest(address)\":{\"notice\":\"When the user claims themself through poolCommitter, you want the user to be able to withdraw their request through the poolCommitter as msg.sender\"}},\"notice\":\"The way this works is when a user commits with `PoolCommitter::commit`, they have the option to set the `bool payForClaim` parameter to `true`.         During this function execution, `AutoClaim::payForClaim` is called, and `msg.value` is taken as the reward to whoever claims for requester (by using `AutoClaim::paidClaim`).\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/implementation/AutoClaim.sol\":\"AutoClaim\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) private pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x3b4820cac4f127869f6eb496c1d74fa6ac86ed24071e0f94742e6aef20e7252c\",\"license\":\"MIT\"},\"contracts/implementation/AutoClaim.sol\":{\"content\":\"//SPDX-License-Identifier: CC-BY-NC-ND-4.0\\npragma solidity 0.8.7;\\n\\nimport \\\"../interfaces/IPoolFactory.sol\\\";\\nimport \\\"../interfaces/IPoolCommitter.sol\\\";\\nimport \\\"../interfaces/IAutoClaim.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\n\\nimport \\\"../libraries/CalldataLogic.sol\\\";\\n\\n/// @title The contract to be used for paying to have a keeper claim your commit automatically\\n/// @notice The way this works is when a user commits with `PoolCommitter::commit`, they have the option to set the `bool payForClaim` parameter to `true`.\\n///         During this function execution, `AutoClaim::payForClaim` is called, and `msg.value` is taken as the reward to whoever claims for requester (by using `AutoClaim::paidClaim`).\\n/// @dev A question I had to ask was \\\"What happens if one requests a second claim before one's pending request from a previous update interval one gets executed on?\\\".\\n///      My solution to this was to have the committer instantly claim for themself. They have signified their desire to claim their tokens, after all.\\ncontract AutoClaim is IAutoClaim {\\n    // User => PoolCommitter address => Claim Request\\n    mapping(address => mapping(address => ClaimRequest)) public claimRequests;\\n    IPoolFactory internal immutable poolFactory;\\n\\n    modifier onlyPoolCommitter() {\\n        require(poolFactory.isValidPoolCommitter(msg.sender), \\\"msg.sender not valid PoolCommitter\\\");\\n        _;\\n    }\\n\\n    constructor(address _poolFactoryAddress) {\\n        require(_poolFactoryAddress != address(0), \\\"PoolFactory cannot be null\\\");\\n        poolFactory = IPoolFactory(_poolFactoryAddress);\\n    }\\n\\n    /**\\n     * @notice Pay for your commit to be claimed. This means that a willing participant can claim on `user`'s behalf when the current update interval ends. Claims a previously pending and claimable request before creating the requested claim-request.\\n     * @dev Only callable by this contract's associated PoolCommitter instance. This prevents griefing. Consider a permissionless function, where a user can claim that somebody else wants to auto claim when they do not.\\n     * @dev Emits a `PaidRequestExecution` event on successful claim for pending commit.\\n     * @param user The user who wants to autoclaim.\\n     */\\n    function makePaidClaimRequest(address user) external payable override onlyPoolCommitter {\\n        ClaimRequest storage request = claimRequests[user][msg.sender];\\n        IPoolCommitter poolCommitter = IPoolCommitter(msg.sender);\\n\\n        uint128 requestUpdateIntervalId = request.updateIntervalId;\\n        // Check if a previous claim request is pending...\\n        if (requestUpdateIntervalId > 0) {\\n            // and if it is claimable (the current update interval is greater than the one where the request was made).\\n            if (requestUpdateIntervalId < poolCommitter.updateIntervalId()) {\\n                // If so, this person may as well claim for themself (if allowed). They have signified their want of claim, after all.\\n                // Note that this function is only called by PoolCommitter when a user `commits` and therefore `user` will always equal the original `msg.sender`.\\n                uint256 reward = request.reward;\\n                delete claimRequests[user][msg.sender];\\n                poolCommitter.claim(user);\\n                if (reward > 0) {\\n                    Address.sendValue(payable(user), reward);\\n                }\\n                emit PaidRequestExecution(user, msg.sender, reward);\\n            } else {\\n                // If the claim request is pending but not yet valid (it was made in the current commit), we want to add to the value.\\n                // Note that in context, the user *usually* won't need or want to increment `ClaimRequest.reward` more than once because the first call to `payForClaim` should suffice.\\n                request.reward += msg.value;\\n                emit PaidClaimRequestUpdate(user, msg.sender, request.updateIntervalId, request.reward);\\n                return;\\n            }\\n        }\\n\\n        // If no previous claim requests are pending, we need to make a new one.\\n        requestUpdateIntervalId = poolCommitter.getAppropriateUpdateIntervalId();\\n        request.updateIntervalId = requestUpdateIntervalId;\\n        request.reward = msg.value;\\n        emit PaidClaimRequestUpdate(user, msg.sender, requestUpdateIntervalId, request.reward);\\n    }\\n\\n    /**\\n     * @notice Claim on the behalf of a user who has requested to have their commit automatically claimed by a keeper.\\n     * @param user The user who requested an autoclaim.\\n     * @param poolCommitterAddress The PoolCommitter address within which the user's claim will be executed\\n     */\\n    function paidClaim(address user, address poolCommitterAddress) public override {\\n        require(poolFactory.isValidPoolCommitter(poolCommitterAddress), \\\"Invalid pool committer contract\\\");\\n        IPoolCommitter poolCommitter = IPoolCommitter(poolCommitterAddress);\\n        uint256 currentUpdateIntervalId = poolCommitter.updateIntervalId();\\n        uint256 reward = claim(user, poolCommitterAddress, poolCommitter, currentUpdateIntervalId);\\n        if (reward > 0) {\\n            Address.sendValue(payable(msg.sender), reward);\\n        }\\n    }\\n\\n    /**\\n     * @notice Claim on the behalf of a user who has requested to have their commit automatically claimed by a keeper.\\n     * @dev Does not transfer the reward, but instead returns the reward amount. This is a private function and is used to batch multiple reward transfers into one.\\n     */\\n    function claim(\\n        address user,\\n        address poolCommitterAddress,\\n        IPoolCommitter poolCommitter,\\n        uint256 currentUpdateIntervalId\\n    ) private returns (uint256) {\\n        ClaimRequest memory request = claimRequests[user][poolCommitterAddress];\\n        // Check if a previous claim request has been made, and if it is claimable.\\n        if (checkClaim(request, currentUpdateIntervalId)) {\\n            // Send the reward to msg.sender.\\n            // delete the ClaimRequest from storage\\n            delete claimRequests[user][poolCommitterAddress];\\n            // execute the claim\\n            poolCommitter.claim(user);\\n            emit PaidRequestExecution(user, poolCommitterAddress, request.reward);\\n            return request.reward;\\n        }\\n        return 0;\\n    }\\n\\n    /**\\n     * @notice Call `paidClaim` for multiple users, across multiple PoolCommitters.\\n     * @param args1 Arguments for the function packed into a bytes array.\\n     *                        __\\n     *                       /  |\\n     *    __ _ _ __ __ _ ___ `| |     _______________________________________________________________________________________________________________________\\n     *   / _` | '__/ _` / __| | |    |          20 bytes          |          20 bytes         |          20 bytes          |          20 bytes         | ... |\\n     *  | (_| | | | (_| \\\\__ \\\\_| |_   |      0th user address      |     1st user address      |      3rd user address      |      4th user address     | ... |\\n     *   \\\\__,_|_|  \\\\__, |___/\\\\___/    \\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\n     *              __/ |\\n     *             |___/\\n     *                       ___\\n     *                      |__ \\\\\\n     *    __ _ _ __ __ _ ___   ) |    _______________________________________________________________________________________________________________________\\n     *   / _` | '__/ _` / __| / /    |          20 bytes          |          20 bytes         |          20 bytes          |          20 bytes         | ... |\\n     *  | (_| | | | (_| \\\\__ \\\\/ /_    |  0th poolCommitter address | 1st poolCommitter address |  3rd poolCommitter address | 4th poolCommitter address | ... |\\n     *   \\\\__,_|_|  \\\\__, |___/____|    \\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\n     *              __/ |\\n     *             |___/\\n     *\\n     * @dev The nth address in args2 should be the address of the PoolCommitter where the nth address in args1 requested an auto claim.\\n     */\\n    function multiPaidClaimMultiplePoolCommitters(bytes calldata args1, bytes calldata args2) external override {\\n        require(args1.length % CalldataLogic.ADDRESS_LENGTH == 0, \\\"args must only include addresses\\\");\\n        require(args1.length == args2.length, \\\"args must be same length\\\");\\n        uint256 reward;\\n        uint256 nrUsers = args1.length / CalldataLogic.ADDRESS_LENGTH;\\n        uint256 poolCommittersOffset;\\n        uint256 userOffset;\\n        uint256 currentUpdateIntervalId;\\n\\n        assembly {\\n            poolCommittersOffset := args2.offset\\n            userOffset := args1.offset\\n        }\\n\\n        address user;\\n        address poolCommitterAddress;\\n        for (uint256 i; i < nrUsers; ) {\\n            // Fetch the next addresses\\n            user = CalldataLogic.getAddressAtOffset(userOffset);\\n            poolCommitterAddress = CalldataLogic.getAddressAtOffset(poolCommittersOffset);\\n\\n            // Make sure this PoolCommitter is one which has been deployed by the factory\\n            require(poolFactory.isValidPoolCommitter(poolCommitterAddress), \\\"Invalid pool committer contract\\\");\\n            IPoolCommitter poolCommitter = IPoolCommitter(poolCommitterAddress);\\n\\n            // Get the update interval ID of the pool committer we are using\\n            currentUpdateIntervalId = poolCommitter.updateIntervalId();\\n            reward += claim(user, poolCommitterAddress, poolCommitter, currentUpdateIntervalId);\\n\\n            unchecked {\\n                ++i;\\n                // The offset of the next addresses will be ADDRESS_LENGTH (20) bytes across\\n                userOffset += CalldataLogic.ADDRESS_LENGTH;\\n                poolCommittersOffset += CalldataLogic.ADDRESS_LENGTH;\\n            }\\n        }\\n        if (reward > 0) {\\n            Address.sendValue(payable(msg.sender), reward);\\n        }\\n    }\\n\\n    /**\\n     * @notice Call `paidClaim` for multiple users, in a single PoolCommitter.\\n     * @param args Arguments for the function packed into a bytes array. Generated with L2Encoder.encode\\n     *  _______________________________________________________________________________________________________________________\\n     * |          20 bytes          |          20 bytes         |          20 bytes          |          20 bytes         | ... |\\n     * |      0th user address      |     1st user address      |      3rd user address      |      4th user address     | ... |\\n     *  \\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\n     * @param poolCommitterAddress The PoolCommitter address within which you would like to claim for the respective user\\n     * @dev poolCommitterAddress should be the PoolCommitter where all the supplied user addresses requested an auto claim\\n     */\\n    function multiPaidClaimSinglePoolCommitter(bytes calldata args, address poolCommitterAddress) external override {\\n        require(args.length % CalldataLogic.ADDRESS_LENGTH == 0, \\\"args must only include addresses\\\");\\n\\n        uint256 nrUsers = args.length / CalldataLogic.ADDRESS_LENGTH;\\n        uint256 userOffset;\\n        assembly {\\n            userOffset := args.offset\\n        }\\n\\n        address user;\\n        uint256 reward;\\n        require(poolFactory.isValidPoolCommitter(poolCommitterAddress), \\\"Invalid pool committer contract\\\");\\n        IPoolCommitter poolCommitter = IPoolCommitter(poolCommitterAddress);\\n        uint256 currentUpdateIntervalId = poolCommitter.updateIntervalId();\\n        for (uint256 i; i < nrUsers; ) {\\n            user = CalldataLogic.getAddressAtOffset(userOffset);\\n            reward += claim(user, poolCommitterAddress, poolCommitter, currentUpdateIntervalId);\\n\\n            unchecked {\\n                ++i;\\n                userOffset += CalldataLogic.ADDRESS_LENGTH;\\n            }\\n        }\\n        if (reward > 0) {\\n            Address.sendValue(payable(msg.sender), reward);\\n        }\\n    }\\n\\n    /**\\n     * @notice If a user's claim request never gets executed (due to not high enough of a reward), or they change their minds, enable them to withdraw their request.\\n     * @param poolCommitter The PoolCommitter for which the user's commit claim is to be withdrawn.\\n     * @dev Emits a `RequestWithdrawn` event on success\\n     */\\n    function withdrawClaimRequest(address poolCommitter) external override {\\n        require(poolFactory.isValidPoolCommitter(poolCommitter), \\\"Invalid pool committer contract\\\");\\n        if (claimRequests[msg.sender][poolCommitter].updateIntervalId > 0) {\\n            uint256 reward = claimRequests[msg.sender][poolCommitter].reward;\\n            delete claimRequests[msg.sender][poolCommitter];\\n            if (reward > 0) {\\n                Address.sendValue(payable(msg.sender), reward);\\n            }\\n            emit RequestWithdrawn(msg.sender, poolCommitter);\\n        }\\n    }\\n\\n    /**\\n     * @notice When the user claims themself through poolCommitter, you want the user to be able to withdraw their request through the poolCommitter as msg.sender\\n     * @param user The user who will have their claim request withdrawn.\\n     * @dev Only callable by the associated `PoolCommitter` contract\\n     */\\n\\n    function withdrawUserClaimRequest(address user) public override onlyPoolCommitter {\\n        // msg.sender is the PoolCommitter\\n        uint256 reward = claimRequests[user][msg.sender].reward;\\n        delete claimRequests[user][msg.sender];\\n        if (reward > 0) {\\n            Address.sendValue(payable(user), reward);\\n        }\\n    }\\n\\n    /**\\n     * @notice Check the validity of a user's claim request for a given pool committer.\\n     * @return true if the claim request can be executed.\\n     * @param user The user whose claim request will be checked.\\n     * @param poolCommitter The pool committer in which to look for a user's claim request.\\n     */\\n    function checkUserClaim(address user, address poolCommitter) external view override returns (bool) {\\n        return checkClaim(claimRequests[user][poolCommitter], IPoolCommitter(poolCommitter).updateIntervalId());\\n    }\\n\\n    /**\\n     * @return true if the given claim request can be executed.\\n     * @dev A claim request can be executed only if one exists and is from an update interval that has passed.\\n     * @param request The ClaimRequest object to be checked.\\n     * @param currentUpdateIntervalId The current update interval. Used to compare to the update interval of the ClaimRequest.\\n     */\\n    function checkClaim(ClaimRequest memory request, uint256 currentUpdateIntervalId)\\n        public\\n        pure\\n        override\\n        returns (bool)\\n    {\\n        return request.updateIntervalId > 0 && request.updateIntervalId < currentUpdateIntervalId;\\n    }\\n\\n    function unchecked_inc(uint256 i) private pure returns (uint256) {\\n        unchecked {\\n            return ++i;\\n        }\\n    }\\n\\n    receive() external payable {\\n        revert();\\n    }\\n\\n    fallback() external payable {\\n        revert();\\n    }\\n}\\n\",\"keccak256\":\"0xc2c830643071d108478c4051e5442bdcbd77919de2878e1c640276057388dbaa\",\"license\":\"CC-BY-NC-ND-4.0\"},\"contracts/interfaces/IAutoClaim.sol\":{\"content\":\"//SPDX-License-Identifier: CC-BY-NC-ND-4.0\\npragma solidity 0.8.7;\\n\\ninterface IAutoClaim {\\n    /**\\n     * @notice Creates a notification when an auto-claim request is updated. i.e. When another commit is added and reward is incremented.\\n     * @param user The user whose request got updated\\n     * @param poolCommitter The PoolCommitter instance in which the commits were made\\n     * @param updateIntervalId The update interval ID that the corresponding commitment was allocated for\\n     * @param newReward The new total reward for the auto-claim\\n     */\\n    event PaidClaimRequestUpdate(\\n        address indexed user,\\n        address indexed poolCommitter,\\n        uint256 indexed updateIntervalId,\\n        uint256 newReward\\n    );\\n\\n    /**\\n     * @notice Creates a notification when an auto-claim request is executed\\n     * @param user The user whose request got executed\\n     * @param poolCommitter The PoolCommitter instance in which the original commit was made\\n     * @param reward The reward for the auto-claim\\n     */\\n    event PaidRequestExecution(address indexed user, address indexed poolCommitter, uint256 indexed reward);\\n\\n    /**\\n     * @notice Creates a notification when an auto-claim request is withdrawn\\n     * @param user The user whose request got withdrawn\\n     * @param poolCommitter The PoolCommitter instance in which the original commit was made\\n     */\\n    event RequestWithdrawn(address indexed user, address indexed poolCommitter);\\n\\n    struct ClaimRequest {\\n        uint128 updateIntervalId; // The update interval during which a user requested a claim.\\n        uint256 reward; // The amount of ETH in wei that was given by the user to pay for upkeep\\n    }\\n\\n    /**\\n     * @notice Pay for your commit to be claimed. This means that a willing participant can claim on `user`'s behalf when the current update interval ends.\\n     * @dev Only callable by this contract's associated PoolCommitter instance. This prevents griefing. Consider a permissionless function, where a user can claim that somebody else wants to auto claim when they do not.\\n     * @param user The user who wants to autoclaim.\\n     */\\n    function makePaidClaimRequest(address user) external payable;\\n\\n    /**\\n     * @notice Claim on the behalf of a user who has requests to have their commit automatically claimed by a keeper.\\n     * @param user The user who requested an autoclaim.\\n     * @param poolCommitterAddress The PoolCommitter address within which the user's claim will be executed\\n     */\\n    function paidClaim(address user, address poolCommitterAddress) external;\\n\\n    function multiPaidClaimMultiplePoolCommitters(bytes memory args1, bytes memory args2) external;\\n\\n    /**\\n     * @notice Call `paidClaim` for multiple users, in a single PoolCommitter.\\n     * @param args Arguments for the function packed into a bytes array. Generated with L2Encoder.encode\\n     * -------------------------------------------------------------------------------------------------------------------------\\n     * |          20 bytes          |          20 bytes         |          20 bytes          |          20 bytes         | ... |\\n     * |      0th user address      |     1st user address      |      3rd user address      |      4th user address     | ... |\\n     * -------------------------------------------------------------------------------------------------------------------------\\n     * @param poolCommitterAddress The PoolCommitter address within which you would like to claim for the respective user\\n     * @dev poolCommitterAddress should be the PoolCommitter where the all supplied user addresses requested an auto claim\\n     */\\n    function multiPaidClaimSinglePoolCommitter(bytes calldata args, address poolCommitterAddress) external;\\n\\n    /**\\n     * @notice If a user's claim request never gets executed (due to not high enough of a reward), or they change their minds, enable them to withdraw their request.\\n     * @param poolCommitter The PoolCommitter for which the user's commit claim is to be withdrawn.\\n     */\\n    function withdrawClaimRequest(address poolCommitter) external;\\n\\n    /**\\n     * @notice When the user claims themself through poolCommitter, you want the user to be able to withdraw their request through the poolCommitter as msg.sender\\n     * @param user The user who will have their claim request withdrawn.\\n     */\\n    function withdrawUserClaimRequest(address user) external;\\n\\n    /**\\n     * @notice Check the validity of a user's claim request for a given pool committer.\\n     * @return true if the claim request can be executed.\\n     * @param user The user whose claim request will be checked.\\n     * @param poolCommitter The pool committer in which to look for a user's claim request.\\n     */\\n    function checkUserClaim(address user, address poolCommitter) external view returns (bool);\\n\\n    /**\\n     * @return true if the given claim request can be executed.\\n     * @dev A claim request can be executed only if one exists and is from an update interval that has passed.\\n     * @param request The ClaimRequest object to be checked.\\n     * @param currentUpdateIntervalId The current update interval. Used to compare to the update interval of the ClaimRequest.\\n     */\\n    function checkClaim(ClaimRequest memory request, uint256 currentUpdateIntervalId) external pure returns (bool);\\n}\\n\",\"keccak256\":\"0xd398d4a2773a3886c7372867ecc01c4750762008fb849464131240e7ac0c9be0\",\"license\":\"CC-BY-NC-ND-4.0\"},\"contracts/interfaces/IPoolCommitter.sol\":{\"content\":\"//SPDX-License-Identifier: CC-BY-NC-ND-4.0\\npragma solidity 0.8.7;\\n\\n/// @title The interface for the contract that handles pool commitments\\ninterface IPoolCommitter {\\n    /// Type of commit\\n    enum CommitType {\\n        ShortMint, // Mint short tokens\\n        ShortBurn, // Burn short tokens\\n        LongMint, // Mint long tokens\\n        LongBurn, // Burn long tokens\\n        LongBurnShortMint, // Burn Long tokens, then instantly mint in same upkeep\\n        ShortBurnLongMint // Burn Short tokens, then instantly mint in same upkeep\\n    }\\n\\n    function isMint(CommitType t) external pure returns (bool);\\n\\n    function isBurn(CommitType t) external pure returns (bool);\\n\\n    function isLong(CommitType t) external pure returns (bool);\\n\\n    function isShort(CommitType t) external pure returns (bool);\\n\\n    // Pool balances and supplies\\n    struct BalancesAndSupplies {\\n        uint256 newShortBalance;\\n        uint256 newLongBalance;\\n        uint256 longMintPoolTokens;\\n        uint256 shortMintPoolTokens;\\n        uint256 longBurnInstantMintSettlement;\\n        uint256 shortBurnInstantMintSettlement;\\n        uint256 totalLongBurnPoolTokens;\\n        uint256 totalShortBurnPoolTokens;\\n    }\\n\\n    // User aggregate balance\\n    struct Balance {\\n        uint256 longTokens;\\n        uint256 shortTokens;\\n        uint256 settlementTokens;\\n    }\\n\\n    // Token Prices\\n    struct Prices {\\n        bytes16 longPrice;\\n        bytes16 shortPrice;\\n    }\\n\\n    // Commit information\\n    struct Commit {\\n        uint256 amount;\\n        CommitType commitType;\\n        uint40 created;\\n        address owner;\\n    }\\n\\n    // Commit information\\n    struct TotalCommitment {\\n        uint256 longMintSettlement;\\n        uint256 longBurnPoolTokens;\\n        uint256 shortMintSettlement;\\n        uint256 shortBurnPoolTokens;\\n        uint256 shortBurnLongMintPoolTokens;\\n        uint256 longBurnShortMintPoolTokens;\\n    }\\n\\n    // User updated aggregate balance\\n    struct BalanceUpdate {\\n        uint256 _updateIntervalId;\\n        uint256 _newLongTokensSum;\\n        uint256 _newShortTokensSum;\\n        uint256 _newSettlementTokensSum;\\n        uint256 _longSettlementFee;\\n        uint256 _shortSettlementFee;\\n        uint8 _maxIterations;\\n    }\\n\\n    // Track how much of a user's commitments are being done from their aggregate balance\\n    struct UserCommitment {\\n        uint256 longMintSettlement;\\n        uint256 longBurnPoolTokens;\\n        uint256 shortMintSettlement;\\n        uint256 shortBurnPoolTokens;\\n        uint256 shortBurnLongMintPoolTokens;\\n        uint256 longBurnShortMintPoolTokens;\\n        uint256 updateIntervalId;\\n    }\\n\\n    // Track the relevant data when executing a range of update interval's commitments (stack too deep)\\n    struct CommitmentExecutionTracking {\\n        uint256 longTotalSupply;\\n        uint256 shortTotalSupply;\\n        uint256 longTotalSupplyBefore;\\n        uint256 shortTotalSupplyBefore;\\n        uint256 _updateIntervalId;\\n    }\\n\\n    /**\\n     * @notice Creates a notification when a commit is created\\n     * @param user The user making the commitment\\n     * @param amount Amount of the commit\\n     * @param commitType Type of the commit (Short v Long, Mint v Burn)\\n     * @param appropriateUpdateIntervalId Id of update interval where this commit can be executed as part of upkeep\\n     * @param fromAggregateBalance whether or not to commit from aggregate (unclaimed) balance\\n     * @param payForClaim whether or not to request this commit be claimed automatically\\n     * @param mintingFee Minting fee at time of commit creation\\n     */\\n    event CreateCommit(\\n        address indexed user,\\n        uint256 indexed amount,\\n        CommitType indexed commitType,\\n        uint256 appropriateUpdateIntervalId,\\n        bool fromAggregateBalance,\\n        bool payForClaim,\\n        bytes16 mintingFee\\n    );\\n\\n    /**\\n     * @notice Creates a notification when a user's aggregate balance is updated\\n     */\\n    event AggregateBalanceUpdated(address indexed user);\\n\\n    /**\\n     * @notice Creates a notification when the PoolCommitter's leveragedPool address has been updated.\\n     * @param newPool the address of the new leveraged pool\\n     */\\n    event PoolChanged(address indexed newPool);\\n\\n    /**\\n     * @notice Creates a notification when commits for a given update interval are executed\\n     * @param updateIntervalId Unique identifier for the relevant update interval\\n     * @param burningFee Burning fee at the time of commit execution\\n     */\\n    event ExecutedCommitsForInterval(uint256 indexed updateIntervalId, bytes16 burningFee);\\n\\n    /**\\n     * @notice Creates a notification when a claim is made, depositing pool tokens in user's wallet\\n     */\\n    event Claim(address indexed user);\\n\\n    /*\\n     * @notice Creates a notification when the burningFee is updated\\n     */\\n    event BurningFeeSet(uint256 indexed _burningFee);\\n\\n    /**\\n     * @notice Creates a notification when the mintingFee is updated\\n     */\\n    event MintingFeeSet(uint256 indexed _mintingFee);\\n\\n    /**\\n     * @notice Creates a notification when the changeInterval is updated\\n     */\\n    event ChangeIntervalSet(uint256 indexed _changeInterval);\\n\\n    /**\\n     * @notice Creates a notification when the feeController is updated\\n     */\\n    event FeeControllerSet(address indexed _feeController);\\n\\n    // #### Functions\\n\\n    function initialize(\\n        address _factory,\\n        address _autoClaim,\\n        address _factoryOwner,\\n        address _feeController,\\n        address _invariantCheck,\\n        uint256 mintingFee,\\n        uint256 burningFee,\\n        uint256 _changeInterval\\n    ) external;\\n\\n    function commit(bytes32 args) external payable;\\n\\n    function updateIntervalId() external view returns (uint128);\\n\\n    function pendingMintSettlementAmount() external view returns (uint256);\\n\\n    function pendingShortBurnPoolTokens() external view returns (uint256);\\n\\n    function pendingLongBurnPoolTokens() external view returns (uint256);\\n\\n    function claim(address user) external;\\n\\n    function executeCommitments(\\n        uint256 lastPriceTimestamp,\\n        uint256 updateInterval,\\n        uint256 longBalance,\\n        uint256 shortBalance\\n    )\\n        external\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256\\n        );\\n\\n    function updateAggregateBalance(address user) external;\\n\\n    function getAggregateBalance(address user) external view returns (Balance memory _balance);\\n\\n    function getAppropriateUpdateIntervalId() external view returns (uint128);\\n\\n    function setPool(address _leveragedPool) external;\\n\\n    function setBurningFee(uint256 _burningFee) external;\\n\\n    function setMintingFee(uint256 _mintingFee) external;\\n\\n    function setChangeInterval(uint256 _changeInterval) external;\\n\\n    function setFeeController(address _feeController) external;\\n}\\n\",\"keccak256\":\"0x6e61f689295ef4339452ac1ba5347d1e933d2ef231ca5d1a4a89ef94a506234b\",\"license\":\"CC-BY-NC-ND-4.0\"},\"contracts/interfaces/IPoolFactory.sol\":{\"content\":\"//SPDX-License-Identifier: CC-BY-NC-ND-4.0\\npragma solidity 0.8.7;\\n\\n/// @title The contract factory for the keeper and pool contracts. Utilizes minimal clones to keep gas costs low\\ninterface IPoolFactory {\\n    struct PoolDeployment {\\n        string poolName; // The name to identify a pool by\\n        uint32 frontRunningInterval; // The minimum number of seconds that must elapse before a commit can be executed. Must be smaller than or equal to the update interval to prevent deadlock\\n        uint32 updateInterval; // The minimum number of seconds that must elapse before a price change\\n        uint16 leverageAmount; // The amount of exposure to price movements for the pool\\n        address settlementToken; // The digital asset that the pool accepts\\n        address oracleWrapper; // The IOracleWrapper implementation for fetching price feed data\\n        address settlementEthOracle; // The oracle to fetch the price of Ether in terms of the settlement token\\n        address feeController;\\n        // The fee taken for each mint and burn. Fee value as a decimal multiplied by 10^18. For example, 50% is represented as 0.5 * 10^18\\n        uint256 mintingFee; // The fee amount for mints\\n        uint256 changeInterval; // The interval at which the mintingFee in a market either increases or decreases, as per the logic in `PoolCommitter::updateMintingFee`\\n        uint256 burningFee; // The fee amount for burns\\n    }\\n\\n    // #### Events\\n    /**\\n     * @notice Creates a notification when a pool is deployed\\n     * @param pool Address of the new pool\\n     * @param ticker Ticker of the new pool\\n     */\\n    event DeployPool(address indexed pool, address poolCommitter, string ticker);\\n\\n    /**\\n     * @notice Indicates that the InvariantCheck contract has changed\\n     * @param invariantCheck New InvariantCheck contract\\n     */\\n    event InvariantCheckChanged(address indexed invariantCheck);\\n\\n    /**\\n     * @notice Creates a notification when a PoolCommitter is deployed\\n     * @param poolCommitterAddress Address of new PoolCommitter\\n     * @param settlementToken Address of new settlementToken\\n     * @param pool Address of the pool associated with this PoolCommitter\\n     * @param changeInterval The amount that the `mintingFee` will change each update interval, based on `updateMintingFee`, given as a decimal * 10 ^ 18 (same format as `_mintingFee`)\\n     * @param feeController The address that has control over fee parameters\\n     */\\n    event DeployCommitter(\\n        address poolCommitterAddress,\\n        address settlementToken,\\n        address pool,\\n        uint256 changeInterval,\\n        address feeController\\n    );\\n\\n    /**\\n     * @notice Creates a notification when the pool keeper changes\\n     * @param _poolKeeper Address of the new pool keeper\\n     */\\n    event PoolKeeperChanged(address _poolKeeper);\\n\\n    /**\\n     * @notice Indicates that the maximum allowed leverage has changed\\n     * @param leverage New maximum allowed leverage value\\n     */\\n    event MaxLeverageChanged(uint256 indexed leverage);\\n\\n    /**\\n     * @notice Indicates that the receipient of fees has changed\\n     * @param receiver Address of the new receipient of fees\\n     */\\n    event FeeReceiverChanged(address indexed receiver);\\n\\n    /**\\n     * @notice Indicates that the receipient of fees has changed\\n     * @param fee Address of the new receipient of fees\\n     */\\n    event SecondaryFeeSplitChanged(uint256 indexed fee);\\n\\n    /**\\n     * @notice Indicates that the trading fee has changed\\n     * @param fee New trading fee\\n     */\\n    event FeeChanged(uint256 indexed fee);\\n\\n    /**\\n     * @notice Indicates that the AutoClaim contract has changed\\n     * @param autoClaim New AutoClaim contract\\n     */\\n    event AutoClaimChanged(address indexed autoClaim);\\n\\n    /**\\n     * @notice Indicates that the minting and burning fees have changed\\n     * @param mint Minting fee\\n     * @param burn Burning fee\\n     */\\n    event MintAndBurnFeesChanged(uint256 indexed mint, uint256 indexed burn);\\n\\n    // #### Getters for Globals\\n    function pools(uint256 id) external view returns (address);\\n\\n    function numPools() external view returns (uint256);\\n\\n    function isValidPool(address _pool) external view returns (bool);\\n\\n    function isValidPoolCommitter(address _poolCommitter) external view returns (bool);\\n\\n    function getPoolKeeper() external view returns (address);\\n\\n    // #### Functions\\n    function deployPool(PoolDeployment calldata deploymentParameters) external returns (address);\\n\\n    function setPoolKeeper(address _poolKeeper) external;\\n\\n    function setAutoClaim(address _autoClaim) external;\\n\\n    function setInvariantCheck(address _invariantCheck) external;\\n\\n    function setFeeReceiver(address _feeReceiver) external;\\n\\n    function setFee(uint256 _fee) external;\\n\\n    function setSecondaryFeeSplitPercent(uint256 newFeePercent) external;\\n}\\n\",\"keccak256\":\"0x81fca6af4dececdb8f4bdf446b9e0260de3c0e70df3b0e98e60b7ae5b4d79a04\",\"license\":\"CC-BY-NC-ND-4.0\"},\"contracts/libraries/CalldataLogic.sol\":{\"content\":\"//SPDX-License-Identifier: CC-BY-NC-ND-4.0\\npragma solidity 0.8.7;\\n\\nimport \\\"../interfaces/IPoolCommitter.sol\\\";\\n\\n/// @title CalldataLogic library\\n/// @notice Library to decode calldata, used to optimize calldata size in PerpetualPools for L2 transaction cost reduction\\nlibrary CalldataLogic {\\n    /*\\n     * Calldata when parameter is a tightly packed byte array looks like this:\\n     * -----------------------------------------------------------------------------------------------------\\n     * | function signature | offset of byte array | length of byte array |           bytes array           |\\n     * |      4 bytes       |       32 bytes       |       32 bytes       |  20 * number_of_addresses bytes |\\n     * -----------------------------------------------------------------------------------------------------\\n     *\\n     * If there are two bytes arrays, then it looks like\\n     * ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\\n     * | function signature | offset of 1st byte array | offset of 2nd byte array | length of 1st byte array |        1st bytes array          | length of 2nd byte array |        2nd bytes array          |\\n     * |      4 bytes       |        32 bytes          |        32 bytes          |         32 bytes         |  20 * number_of_addresses bytes |         32 bytes         |  20 * number_of_addresses bytes |\\n     * ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\\n     * and so on...\\n     * Note that the offset indicates where the length is indicated, and the actual array itself starts 32 bytes after that\\n     */\\n    // Length of address = 20\\n    uint16 internal constant ADDRESS_LENGTH = 20;\\n\\n    function getAddressAtOffset(uint256 offset) internal pure returns (address) {\\n        bytes20 addressAtOffset;\\n        assembly {\\n            addressAtOffset := calldataload(offset)\\n        }\\n        return (address(addressAtOffset));\\n    }\\n\\n    /**\\n     * @notice decodes compressed commit params to standard params\\n     * @param args The packed commit args\\n     * @return The amount of settlement or pool tokens to commit\\n     * @return The CommitType\\n     * @return Whether to make the commitment from user's aggregate balance\\n     * @return Whether to pay for an autoclaim or not\\n     */\\n    function decodeCommitParams(bytes32 args)\\n        internal\\n        pure\\n        returns (\\n            uint256,\\n            IPoolCommitter.CommitType,\\n            bool,\\n            bool\\n        )\\n    {\\n        uint256 amount;\\n        IPoolCommitter.CommitType commitType;\\n        bool fromAggregateBalance;\\n        bool payForClaim;\\n\\n        // `amount` is implicitly capped at 128 bits.\\n        assembly {\\n            amount := and(args, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\\n            commitType := and(shr(128, args), 0xFF)\\n            fromAggregateBalance := and(shr(136, args), 0xFF)\\n            payForClaim := and(shr(144, args), 0xFF)\\n        }\\n        return (amount, commitType, fromAggregateBalance, payForClaim);\\n    }\\n}\\n\",\"keccak256\":\"0x9fef7490d395734483ba2e80c0439a24b8198cf13c0c2de2a52941b83456681d\",\"license\":\"CC-BY-NC-ND-4.0\"}},\"version\":1}",
  "bytecode": "0x60a060405234801561001057600080fd5b5060405161157a38038061157a83398101604081905261002f9161009e565b6001600160a01b0381166100895760405162461bcd60e51b815260206004820152601a60248201527f506f6f6c466163746f72792063616e6e6f74206265206e756c6c000000000000604482015260640160405180910390fd5b60601b6001600160601b0319166080526100ce565b6000602082840312156100b057600080fd5b81516001600160a01b03811681146100c757600080fd5b9392505050565b60805160601c61146b61010f6000396000818161021f0152818161035f0152818161059f01528181610790015281816109d60152610d7c015261146b6000f3fe60806040526004361061008a5760003560e01c806382b342a41161005957806382b342a414610130578063883e9e48146101505780638d68dd61146101705780639b42f47e146101d7578063c76ac728146101ea57600080fd5b806307119aeb14610099578063351ea38a146100bb5780634c830642146100f057806355bb0a541461011057600080fd5b3661009457600080fd5b600080fd5b3480156100a557600080fd5b506100b96100b436600461117b565b61020a565b005b3480156100c757600080fd5b506100db6100d63660046112ab565b610314565b60405190151581526020015b60405180910390f35b3480156100fc57600080fd5b506100b961010b36600461117b565b610340565b34801561011c57600080fd5b506100b961012b36600461123f565b6104aa565b34801561013c57600080fd5b506100b961014b3660046111eb565b610702565b34801561015c57600080fd5b506100db61016b366004611196565b6108fe565b34801561017c57600080fd5b506101b861018b366004611196565b6000602081815292815260408082209093529081522080546001909101546001600160801b039091169082565b604080516001600160801b0390931683526020830191909152016100e7565b6100b96101e536600461117b565b6109c1565b3480156101f657600080fd5b506100b9610205366004611196565b610d5d565b6040516359e86a9960e01b81523360048201527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316906359e86a999060240160206040518083038186803b15801561026957600080fd5b505afa15801561027d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102a191906111c9565b6102c65760405162461bcd60e51b81526004016102bd9061137a565b60405180910390fd5b6001600160a01b038116600090815260208181526040808320338452909152812060018101805482546001600160801b031916909255919091558015610310576103108282610ebc565b5050565b81516000906001600160801b031615801590610339575082516001600160801b031682115b9392505050565b6040516359e86a9960e01b81526001600160a01b0382811660048301527f000000000000000000000000000000000000000000000000000000000000000016906359e86a999060240160206040518083038186803b1580156103a157600080fd5b505afa1580156103b5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103d991906111c9565b6103f55760405162461bcd60e51b81526004016102bd90611343565b336000908152602081815260408083206001600160a01b03851684529091529020546001600160801b0316156104a757336000908152602081815260408083206001600160a01b0385168452909152812060018101805482546001600160801b03191690925591909155801561046f5761046f3382610ebc565b6040516001600160a01b0383169033907fbeb52c9358dfd474b9e79cc7bb7c88a2079664f938ff899c7a54bbaa5e54b08a90600090a3505b50565b6104b56014846113f6565b156105025760405162461bcd60e51b815260206004820181905260248201527f61726773206d757374206f6e6c7920696e636c7564652061646472657373657360448201526064016102bd565b8281146105515760405162461bcd60e51b815260206004820152601860248201527f61726773206d7573742062652073616d65206c656e677468000000000000000060448201526064016102bd565b60008061055f6014866113e2565b9050838660008080805b868110156106e457843560601c9250853560601c6040516359e86a9960e01b81526001600160a01b0380831660048301529193507f0000000000000000000000000000000000000000000000000000000000000000909116906359e86a999060240160206040518083038186803b1580156105e357600080fd5b505afa1580156105f7573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061061b91906111c9565b6106375760405162461bcd60e51b81526004016102bd90611343565b6000829050806001600160a01b0316639d03132e6040518163ffffffff1660e01b815260040160206040518083038186803b15801561067557600080fd5b505afa158015610689573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106ad9190611326565b6001600160801b031694506106c484848388610fda565b6106ce908a6113bc565b9850506014958601959490940193600101610569565b5086156106f5576106f53388610ebc565b5050505050505050505050565b61070d6014836113f6565b1561075a5760405162461bcd60e51b815260206004820181905260248201527f61726773206d757374206f6e6c7920696e636c7564652061646472657373657360448201526064016102bd565b60006107676014846113e2565b6040516359e86a9960e01b81526001600160a01b038481166004830152919250859160009182917f000000000000000000000000000000000000000000000000000000000000000016906359e86a999060240160206040518083038186803b1580156107d257600080fd5b505afa1580156107e6573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061080a91906111c9565b6108265760405162461bcd60e51b81526004016102bd90611343565b60008590506000816001600160a01b0316639d03132e6040518163ffffffff1660e01b815260040160206040518083038186803b15801561086657600080fd5b505afa15801561087a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061089e9190611326565b6001600160801b0316905060005b868110156108e257853560601c94506108c785898585610fda565b6108d190856113bc565b6014969096019593506001016108ac565b5082156108f3576108f33384610ebc565b505050505050505050565b6001600160a01b038083166000908152602081815260408083209385168084529382528083208151808301835281546001600160801b03168152600190910154818401528151634e81899760e11b8152915193946103399491939092639d03132e9260048083019392829003018186803b15801561097b57600080fd5b505afa15801561098f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109b39190611326565b6001600160801b0316610314565b6040516359e86a9960e01b81523360048201527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316906359e86a999060240160206040518083038186803b158015610a2057600080fd5b505afa158015610a34573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a5891906111c9565b610a745760405162461bcd60e51b81526004016102bd9061137a565b6001600160a01b03811660009081526020818152604080832033808552925290912080549091906001600160801b03168015610c8857816001600160a01b0316639d03132e6040518163ffffffff1660e01b815260040160206040518083038186803b158015610ae357600080fd5b505afa158015610af7573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b1b9190611326565b6001600160801b0316816001600160801b03161015610c15576001838101546001600160a01b0386811660008181526020818152604080832033845290915280822080546001600160801b0319168155909501559251630f41a04d60e11b81526004810193909352909190841690631e83409a90602401600060405180830381600087803b158015610bac57600080fd5b505af1158015610bc0573d6000803e3d6000fd5b505050506000811115610bd757610bd78582610ebc565b604051819033906001600160a01b038816907ffc1ef6f920271c53bdf1b6aa6a98b1cd7baa573c736975d7eb1f85b2f0c3d7f390600090a450610c88565b34836001016000828254610c2991906113bc565b9091555050825460018401546040519081526001600160801b039091169033906001600160a01b038716907f2bce56202c21201c15ed96641bc5306fdd7bdd656deb133d0677f3b3879b883b906020015b60405180910390a450505050565b816001600160a01b031663d4c4e2836040518163ffffffff1660e01b815260040160206040518083038186803b158015610cc157600080fd5b505afa158015610cd5573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610cf99190611326565b83546001600160801b0319166001600160801b038216908117855534600186018190556040519081529192509033906001600160a01b038716907f2bce56202c21201c15ed96641bc5306fdd7bdd656deb133d0677f3b3879b883b90602001610c7a565b6040516359e86a9960e01b81526001600160a01b0382811660048301527f000000000000000000000000000000000000000000000000000000000000000016906359e86a999060240160206040518083038186803b158015610dbe57600080fd5b505afa158015610dd2573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610df691906111c9565b610e125760405162461bcd60e51b81526004016102bd90611343565b60008190506000816001600160a01b0316639d03132e6040518163ffffffff1660e01b815260040160206040518083038186803b158015610e5257600080fd5b505afa158015610e66573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e8a9190611326565b6001600160801b031690506000610ea385858585610fda565b90508015610eb557610eb53382610ebc565b5050505050565b80471015610f0c5760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a20696e73756666696369656e742062616c616e636500000060448201526064016102bd565b6000826001600160a01b03168260405160006040518083038185875af1925050503d8060008114610f59576040519150601f19603f3d011682016040523d82523d6000602084013e610f5e565b606091505b5050905080610fd55760405162461bcd60e51b815260206004820152603a60248201527f416464726573733a20756e61626c6520746f2073656e642076616c75652c207260448201527f6563697069656e74206d6179206861766520726576657274656400000000000060648201526084016102bd565b505050565b6001600160a01b038085166000908152602081815260408083209387168352928152828220835180850190945280546001600160801b031684526001015490830152906110278184610314565b15611108576001600160a01b038681166000818152602081815260408083208a8616845290915280822080546001600160801b03191681556001019190915551630f41a04d60e11b8152600481019190915290851690631e83409a90602401600060405180830381600087803b1580156110a057600080fd5b505af11580156110b4573d6000803e3d6000fd5b505050508060200151856001600160a01b0316876001600160a01b03167ffc1ef6f920271c53bdf1b6aa6a98b1cd7baa573c736975d7eb1f85b2f0c3d7f360405160405180910390a460200151905061110e565b60009150505b949350505050565b80356001600160a01b038116811461112d57600080fd5b919050565b60008083601f84011261114457600080fd5b50813567ffffffffffffffff81111561115c57600080fd5b60208301915083602082850101111561117457600080fd5b9250929050565b60006020828403121561118d57600080fd5b61033982611116565b600080604083850312156111a957600080fd5b6111b283611116565b91506111c060208401611116565b90509250929050565b6000602082840312156111db57600080fd5b8151801515811461033957600080fd5b60008060006040848603121561120057600080fd5b833567ffffffffffffffff81111561121757600080fd5b61122386828701611132565b9094509250611236905060208501611116565b90509250925092565b6000806000806040858703121561125557600080fd5b843567ffffffffffffffff8082111561126d57600080fd5b61127988838901611132565b9096509450602087013591508082111561129257600080fd5b5061129f87828801611132565b95989497509550505050565b60008082840360608112156112bf57600080fd5b60408112156112cd57600080fd5b506040516040810181811067ffffffffffffffff821117156112ff57634e487b7160e01b600052604160045260246000fd5b604052833561130d81611420565b8152602084810135908201529460409093013593505050565b60006020828403121561133857600080fd5b815161033981611420565b6020808252601f908201527f496e76616c696420706f6f6c20636f6d6d697474657220636f6e747261637400604082015260600190565b60208082526022908201527f6d73672e73656e646572206e6f742076616c696420506f6f6c436f6d6d69747460408201526132b960f11b606082015260800190565b600082198211156113dd57634e487b7160e01b600052601160045260246000fd5b500190565b6000826113f1576113f161140a565b500490565b6000826114055761140561140a565b500690565b634e487b7160e01b600052601260045260246000fd5b6001600160801b03811681146104a757600080fdfea26469706673582212203f80ae0da597c110d31acbd5275cd3e6754400d500373b614cb8ba3fcd1653a564736f6c63430008070033",
  "deployedBytecode": "0x60806040526004361061008a5760003560e01c806382b342a41161005957806382b342a414610130578063883e9e48146101505780638d68dd61146101705780639b42f47e146101d7578063c76ac728146101ea57600080fd5b806307119aeb14610099578063351ea38a146100bb5780634c830642146100f057806355bb0a541461011057600080fd5b3661009457600080fd5b600080fd5b3480156100a557600080fd5b506100b96100b436600461117b565b61020a565b005b3480156100c757600080fd5b506100db6100d63660046112ab565b610314565b60405190151581526020015b60405180910390f35b3480156100fc57600080fd5b506100b961010b36600461117b565b610340565b34801561011c57600080fd5b506100b961012b36600461123f565b6104aa565b34801561013c57600080fd5b506100b961014b3660046111eb565b610702565b34801561015c57600080fd5b506100db61016b366004611196565b6108fe565b34801561017c57600080fd5b506101b861018b366004611196565b6000602081815292815260408082209093529081522080546001909101546001600160801b039091169082565b604080516001600160801b0390931683526020830191909152016100e7565b6100b96101e536600461117b565b6109c1565b3480156101f657600080fd5b506100b9610205366004611196565b610d5d565b6040516359e86a9960e01b81523360048201527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316906359e86a999060240160206040518083038186803b15801561026957600080fd5b505afa15801561027d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102a191906111c9565b6102c65760405162461bcd60e51b81526004016102bd9061137a565b60405180910390fd5b6001600160a01b038116600090815260208181526040808320338452909152812060018101805482546001600160801b031916909255919091558015610310576103108282610ebc565b5050565b81516000906001600160801b031615801590610339575082516001600160801b031682115b9392505050565b6040516359e86a9960e01b81526001600160a01b0382811660048301527f000000000000000000000000000000000000000000000000000000000000000016906359e86a999060240160206040518083038186803b1580156103a157600080fd5b505afa1580156103b5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103d991906111c9565b6103f55760405162461bcd60e51b81526004016102bd90611343565b336000908152602081815260408083206001600160a01b03851684529091529020546001600160801b0316156104a757336000908152602081815260408083206001600160a01b0385168452909152812060018101805482546001600160801b03191690925591909155801561046f5761046f3382610ebc565b6040516001600160a01b0383169033907fbeb52c9358dfd474b9e79cc7bb7c88a2079664f938ff899c7a54bbaa5e54b08a90600090a3505b50565b6104b56014846113f6565b156105025760405162461bcd60e51b815260206004820181905260248201527f61726773206d757374206f6e6c7920696e636c7564652061646472657373657360448201526064016102bd565b8281146105515760405162461bcd60e51b815260206004820152601860248201527f61726773206d7573742062652073616d65206c656e677468000000000000000060448201526064016102bd565b60008061055f6014866113e2565b9050838660008080805b868110156106e457843560601c9250853560601c6040516359e86a9960e01b81526001600160a01b0380831660048301529193507f0000000000000000000000000000000000000000000000000000000000000000909116906359e86a999060240160206040518083038186803b1580156105e357600080fd5b505afa1580156105f7573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061061b91906111c9565b6106375760405162461bcd60e51b81526004016102bd90611343565b6000829050806001600160a01b0316639d03132e6040518163ffffffff1660e01b815260040160206040518083038186803b15801561067557600080fd5b505afa158015610689573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106ad9190611326565b6001600160801b031694506106c484848388610fda565b6106ce908a6113bc565b9850506014958601959490940193600101610569565b5086156106f5576106f53388610ebc565b5050505050505050505050565b61070d6014836113f6565b1561075a5760405162461bcd60e51b815260206004820181905260248201527f61726773206d757374206f6e6c7920696e636c7564652061646472657373657360448201526064016102bd565b60006107676014846113e2565b6040516359e86a9960e01b81526001600160a01b038481166004830152919250859160009182917f000000000000000000000000000000000000000000000000000000000000000016906359e86a999060240160206040518083038186803b1580156107d257600080fd5b505afa1580156107e6573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061080a91906111c9565b6108265760405162461bcd60e51b81526004016102bd90611343565b60008590506000816001600160a01b0316639d03132e6040518163ffffffff1660e01b815260040160206040518083038186803b15801561086657600080fd5b505afa15801561087a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061089e9190611326565b6001600160801b0316905060005b868110156108e257853560601c94506108c785898585610fda565b6108d190856113bc565b6014969096019593506001016108ac565b5082156108f3576108f33384610ebc565b505050505050505050565b6001600160a01b038083166000908152602081815260408083209385168084529382528083208151808301835281546001600160801b03168152600190910154818401528151634e81899760e11b8152915193946103399491939092639d03132e9260048083019392829003018186803b15801561097b57600080fd5b505afa15801561098f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109b39190611326565b6001600160801b0316610314565b6040516359e86a9960e01b81523360048201527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316906359e86a999060240160206040518083038186803b158015610a2057600080fd5b505afa158015610a34573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a5891906111c9565b610a745760405162461bcd60e51b81526004016102bd9061137a565b6001600160a01b03811660009081526020818152604080832033808552925290912080549091906001600160801b03168015610c8857816001600160a01b0316639d03132e6040518163ffffffff1660e01b815260040160206040518083038186803b158015610ae357600080fd5b505afa158015610af7573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b1b9190611326565b6001600160801b0316816001600160801b03161015610c15576001838101546001600160a01b0386811660008181526020818152604080832033845290915280822080546001600160801b0319168155909501559251630f41a04d60e11b81526004810193909352909190841690631e83409a90602401600060405180830381600087803b158015610bac57600080fd5b505af1158015610bc0573d6000803e3d6000fd5b505050506000811115610bd757610bd78582610ebc565b604051819033906001600160a01b038816907ffc1ef6f920271c53bdf1b6aa6a98b1cd7baa573c736975d7eb1f85b2f0c3d7f390600090a450610c88565b34836001016000828254610c2991906113bc565b9091555050825460018401546040519081526001600160801b039091169033906001600160a01b038716907f2bce56202c21201c15ed96641bc5306fdd7bdd656deb133d0677f3b3879b883b906020015b60405180910390a450505050565b816001600160a01b031663d4c4e2836040518163ffffffff1660e01b815260040160206040518083038186803b158015610cc157600080fd5b505afa158015610cd5573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610cf99190611326565b83546001600160801b0319166001600160801b038216908117855534600186018190556040519081529192509033906001600160a01b038716907f2bce56202c21201c15ed96641bc5306fdd7bdd656deb133d0677f3b3879b883b90602001610c7a565b6040516359e86a9960e01b81526001600160a01b0382811660048301527f000000000000000000000000000000000000000000000000000000000000000016906359e86a999060240160206040518083038186803b158015610dbe57600080fd5b505afa158015610dd2573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610df691906111c9565b610e125760405162461bcd60e51b81526004016102bd90611343565b60008190506000816001600160a01b0316639d03132e6040518163ffffffff1660e01b815260040160206040518083038186803b158015610e5257600080fd5b505afa158015610e66573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e8a9190611326565b6001600160801b031690506000610ea385858585610fda565b90508015610eb557610eb53382610ebc565b5050505050565b80471015610f0c5760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a20696e73756666696369656e742062616c616e636500000060448201526064016102bd565b6000826001600160a01b03168260405160006040518083038185875af1925050503d8060008114610f59576040519150601f19603f3d011682016040523d82523d6000602084013e610f5e565b606091505b5050905080610fd55760405162461bcd60e51b815260206004820152603a60248201527f416464726573733a20756e61626c6520746f2073656e642076616c75652c207260448201527f6563697069656e74206d6179206861766520726576657274656400000000000060648201526084016102bd565b505050565b6001600160a01b038085166000908152602081815260408083209387168352928152828220835180850190945280546001600160801b031684526001015490830152906110278184610314565b15611108576001600160a01b038681166000818152602081815260408083208a8616845290915280822080546001600160801b03191681556001019190915551630f41a04d60e11b8152600481019190915290851690631e83409a90602401600060405180830381600087803b1580156110a057600080fd5b505af11580156110b4573d6000803e3d6000fd5b505050508060200151856001600160a01b0316876001600160a01b03167ffc1ef6f920271c53bdf1b6aa6a98b1cd7baa573c736975d7eb1f85b2f0c3d7f360405160405180910390a460200151905061110e565b60009150505b949350505050565b80356001600160a01b038116811461112d57600080fd5b919050565b60008083601f84011261114457600080fd5b50813567ffffffffffffffff81111561115c57600080fd5b60208301915083602082850101111561117457600080fd5b9250929050565b60006020828403121561118d57600080fd5b61033982611116565b600080604083850312156111a957600080fd5b6111b283611116565b91506111c060208401611116565b90509250929050565b6000602082840312156111db57600080fd5b8151801515811461033957600080fd5b60008060006040848603121561120057600080fd5b833567ffffffffffffffff81111561121757600080fd5b61122386828701611132565b9094509250611236905060208501611116565b90509250925092565b6000806000806040858703121561125557600080fd5b843567ffffffffffffffff8082111561126d57600080fd5b61127988838901611132565b9096509450602087013591508082111561129257600080fd5b5061129f87828801611132565b95989497509550505050565b60008082840360608112156112bf57600080fd5b60408112156112cd57600080fd5b506040516040810181811067ffffffffffffffff821117156112ff57634e487b7160e01b600052604160045260246000fd5b604052833561130d81611420565b8152602084810135908201529460409093013593505050565b60006020828403121561133857600080fd5b815161033981611420565b6020808252601f908201527f496e76616c696420706f6f6c20636f6d6d697474657220636f6e747261637400604082015260600190565b60208082526022908201527f6d73672e73656e646572206e6f742076616c696420506f6f6c436f6d6d69747460408201526132b960f11b606082015260800190565b600082198211156113dd57634e487b7160e01b600052601160045260246000fd5b500190565b6000826113f1576113f161140a565b500490565b6000826114055761140561140a565b500690565b634e487b7160e01b600052601260045260246000fd5b6001600160801b03811681146104a757600080fdfea26469706673582212203f80ae0da597c110d31acbd5275cd3e6754400d500373b614cb8ba3fcd1653a564736f6c63430008070033",
  "devdoc": {
    "details": "A question I had to ask was \"What happens if one requests a second claim before one's pending request from a previous update interval one gets executed on?\".      My solution to this was to have the committer instantly claim for themself. They have signified their desire to claim their tokens, after all.",
    "kind": "dev",
    "methods": {
      "checkClaim((uint128,uint256),uint256)": {
        "details": "A claim request can be executed only if one exists and is from an update interval that has passed.",
        "params": {
          "currentUpdateIntervalId": "The current update interval. Used to compare to the update interval of the ClaimRequest.",
          "request": "The ClaimRequest object to be checked."
        },
        "returns": {
          "_0": "true if the given claim request can be executed."
        }
      },
      "checkUserClaim(address,address)": {
        "params": {
          "poolCommitter": "The pool committer in which to look for a user's claim request.",
          "user": "The user whose claim request will be checked."
        },
        "returns": {
          "_0": "true if the claim request can be executed."
        }
      },
      "makePaidClaimRequest(address)": {
        "details": "Only callable by this contract's associated PoolCommitter instance. This prevents griefing. Consider a permissionless function, where a user can claim that somebody else wants to auto claim when they do not.Emits a `PaidRequestExecution` event on successful claim for pending commit.",
        "params": {
          "user": "The user who wants to autoclaim."
        }
      },
      "multiPaidClaimMultiplePoolCommitters(bytes,bytes)": {
        "details": "The nth address in args2 should be the address of the PoolCommitter where the nth address in args1 requested an auto claim.",
        "params": {
          "args1": "Arguments for the function packed into a bytes array.                        __                       /  |    __ _ _ __ __ _ ___ `| |     _______________________________________________________________________________________________________________________   / _` | '__/ _` / __| | |    |          20 bytes          |          20 bytes         |          20 bytes          |          20 bytes         | ... |  | (_| | | | (_| \\__ \\_| |_   |      0th user address      |     1st user address      |      3rd user address      |      4th user address     | ... |   \\__,_|_|  \\__, |___/\\___/                  __/ |             |___/                       ___                      |__ \\    __ _ _ __ __ _ ___   ) |    _______________________________________________________________________________________________________________________   / _` | '__/ _` / __| / /    |          20 bytes          |          20 bytes         |          20 bytes          |          20 bytes         | ... |  | (_| | | | (_| \\__ \\/ /_    |  0th poolCommitter address | 1st poolCommitter address |  3rd poolCommitter address | 4th poolCommitter address | ... |   \\__,_|_|  \\__, |___/____|                  __/ |             |___/"
        }
      },
      "multiPaidClaimSinglePoolCommitter(bytes,address)": {
        "details": "poolCommitterAddress should be the PoolCommitter where all the supplied user addresses requested an auto claim",
        "params": {
          "args": "Arguments for the function packed into a bytes array. Generated with L2Encoder.encode  _______________________________________________________________________________________________________________________ |          20 bytes          |          20 bytes         |          20 bytes          |          20 bytes         | ... | |      0th user address      |     1st user address      |      3rd user address      |      4th user address     | ... |  ",
          "poolCommitterAddress": "The PoolCommitter address within which you would like to claim for the respective user"
        }
      },
      "paidClaim(address,address)": {
        "params": {
          "poolCommitterAddress": "The PoolCommitter address within which the user's claim will be executed",
          "user": "The user who requested an autoclaim."
        }
      },
      "withdrawClaimRequest(address)": {
        "details": "Emits a `RequestWithdrawn` event on success",
        "params": {
          "poolCommitter": "The PoolCommitter for which the user's commit claim is to be withdrawn."
        }
      },
      "withdrawUserClaimRequest(address)": {
        "details": "Only callable by the associated `PoolCommitter` contract",
        "params": {
          "user": "The user who will have their claim request withdrawn."
        }
      }
    },
    "title": "The contract to be used for paying to have a keeper claim your commit automatically",
    "version": 1
  },
  "userdoc": {
    "events": {
      "PaidClaimRequestUpdate(address,address,uint256,uint256)": {
        "notice": "Creates a notification when an auto-claim request is updated. i.e. When another commit is added and reward is incremented."
      },
      "PaidRequestExecution(address,address,uint256)": {
        "notice": "Creates a notification when an auto-claim request is executed"
      },
      "RequestWithdrawn(address,address)": {
        "notice": "Creates a notification when an auto-claim request is withdrawn"
      }
    },
    "kind": "user",
    "methods": {
      "checkUserClaim(address,address)": {
        "notice": "Check the validity of a user's claim request for a given pool committer."
      },
      "makePaidClaimRequest(address)": {
        "notice": "Pay for your commit to be claimed. This means that a willing participant can claim on `user`'s behalf when the current update interval ends. Claims a previously pending and claimable request before creating the requested claim-request."
      },
      "multiPaidClaimMultiplePoolCommitters(bytes,bytes)": {
        "notice": "Call `paidClaim` for multiple users, across multiple PoolCommitters."
      },
      "multiPaidClaimSinglePoolCommitter(bytes,address)": {
        "notice": "Call `paidClaim` for multiple users, in a single PoolCommitter."
      },
      "paidClaim(address,address)": {
        "notice": "Claim on the behalf of a user who has requested to have their commit automatically claimed by a keeper."
      },
      "withdrawClaimRequest(address)": {
        "notice": "If a user's claim request never gets executed (due to not high enough of a reward), or they change their minds, enable them to withdraw their request."
      },
      "withdrawUserClaimRequest(address)": {
        "notice": "When the user claims themself through poolCommitter, you want the user to be able to withdraw their request through the poolCommitter as msg.sender"
      }
    },
    "notice": "The way this works is when a user commits with `PoolCommitter::commit`, they have the option to set the `bool payForClaim` parameter to `true`.         During this function execution, `AutoClaim::payForClaim` is called, and `msg.value` is taken as the reward to whoever claims for requester (by using `AutoClaim::paidClaim`).",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 7328,
        "contract": "contracts/implementation/AutoClaim.sol:AutoClaim",
        "label": "claimRequests",
        "offset": 0,
        "slot": "0",
        "type": "t_mapping(t_address,t_mapping(t_address,t_struct(ClaimRequest)14408_storage))"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_mapping(t_address,t_mapping(t_address,t_struct(ClaimRequest)14408_storage))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(address => struct IAutoClaim.ClaimRequest))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_address,t_struct(ClaimRequest)14408_storage)"
      },
      "t_mapping(t_address,t_struct(ClaimRequest)14408_storage)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => struct IAutoClaim.ClaimRequest)",
        "numberOfBytes": "32",
        "value": "t_struct(ClaimRequest)14408_storage"
      },
      "t_struct(ClaimRequest)14408_storage": {
        "encoding": "inplace",
        "label": "struct IAutoClaim.ClaimRequest",
        "members": [
          {
            "astId": 14405,
            "contract": "contracts/implementation/AutoClaim.sol:AutoClaim",
            "label": "updateIntervalId",
            "offset": 0,
            "slot": "0",
            "type": "t_uint128"
          },
          {
            "astId": 14407,
            "contract": "contracts/implementation/AutoClaim.sol:AutoClaim",
            "label": "reward",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_uint128": {
        "encoding": "inplace",
        "label": "uint128",
        "numberOfBytes": "16"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}