{
    "address": "0x542848E66D8f387a78717Be7b39f7259B7782bAe",
    "abi": [
        {
            "inputs": [],
            "name": "MAX_DECIMALS",
            "outputs": [
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                }
            ],
            "stateMutability": "view",
            "type": "function"
        },
        {
            "inputs": [],
            "name": "WAD_PRECISION",
            "outputs": [
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                }
            ],
            "stateMutability": "view",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "components": [
                        {
                            "internalType": "int256",
                            "name": "oldPrice",
                            "type": "int256"
                        },
                        {
                            "internalType": "int256",
                            "name": "newPrice",
                            "type": "int256"
                        },
                        {
                            "internalType": "uint256",
                            "name": "longBalance",
                            "type": "uint256"
                        },
                        {
                            "internalType": "uint256",
                            "name": "shortBalance",
                            "type": "uint256"
                        },
                        {
                            "internalType": "bytes16",
                            "name": "leverageAmount",
                            "type": "bytes16"
                        },
                        {
                            "internalType": "bytes16",
                            "name": "fee",
                            "type": "bytes16"
                        }
                    ],
                    "internalType": "struct PoolSwapLibrary.PriceChangeData",
                    "name": "priceChange",
                    "type": "tuple"
                }
            ],
            "name": "calculatePriceChange",
            "outputs": [
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                }
            ],
            "stateMutability": "pure",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "bytes16",
                    "name": "x",
                    "type": "bytes16"
                },
                {
                    "internalType": "bytes16",
                    "name": "y",
                    "type": "bytes16"
                }
            ],
            "name": "compareDecimals",
            "outputs": [
                {
                    "internalType": "int8",
                    "name": "",
                    "type": "int8"
                }
            ],
            "stateMutability": "pure",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "bytes16",
                    "name": "ratio",
                    "type": "bytes16"
                }
            ],
            "name": "convertDecimalToUInt",
            "outputs": [
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                }
            ],
            "stateMutability": "pure",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "uint256",
                    "name": "amount",
                    "type": "uint256"
                }
            ],
            "name": "convertUIntToDecimal",
            "outputs": [
                {
                    "internalType": "bytes16",
                    "name": "",
                    "type": "bytes16"
                }
            ],
            "stateMutability": "pure",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "int256",
                    "name": "a",
                    "type": "int256"
                },
                {
                    "internalType": "int256",
                    "name": "b",
                    "type": "int256"
                }
            ],
            "name": "divInt",
            "outputs": [
                {
                    "internalType": "bytes16",
                    "name": "",
                    "type": "bytes16"
                }
            ],
            "stateMutability": "pure",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "uint256",
                    "name": "_wadValue",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "_decimals",
                    "type": "uint256"
                }
            ],
            "name": "fromWad",
            "outputs": [
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                }
            ],
            "stateMutability": "pure",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "uint256",
                    "name": "reward",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "shortBalance",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "longBalance",
                    "type": "uint256"
                }
            ],
            "name": "getBalancesAfterFees",
            "outputs": [
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                }
            ],
            "stateMutability": "pure",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "bytes16",
                    "name": "lossMultiplier",
                    "type": "bytes16"
                },
                {
                    "internalType": "uint256",
                    "name": "balance",
                    "type": "uint256"
                }
            ],
            "name": "getLossAmount",
            "outputs": [
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                }
            ],
            "stateMutability": "pure",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "bytes16",
                    "name": "ratio",
                    "type": "bytes16"
                },
                {
                    "internalType": "int8",
                    "name": "direction",
                    "type": "int8"
                },
                {
                    "internalType": "bytes16",
                    "name": "leverage",
                    "type": "bytes16"
                }
            ],
            "name": "getLossMultiplier",
            "outputs": [
                {
                    "internalType": "bytes16",
                    "name": "",
                    "type": "bytes16"
                }
            ],
            "stateMutability": "pure",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "uint256",
                    "name": "tokenSupply",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "amountIn",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "balance",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "shadowBalance",
                    "type": "uint256"
                }
            ],
            "name": "getMintAmount",
            "outputs": [
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                }
            ],
            "stateMutability": "pure",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "uint256",
                    "name": "_numerator",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "_denominator",
                    "type": "uint256"
                }
            ],
            "name": "getRatio",
            "outputs": [
                {
                    "internalType": "bytes16",
                    "name": "",
                    "type": "bytes16"
                }
            ],
            "stateMutability": "pure",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "uint256",
                    "name": "tokenSupply",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "amountIn",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "balance",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "shadowBalance",
                    "type": "uint256"
                }
            ],
            "name": "getWithdrawAmountOnBurn",
            "outputs": [
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                }
            ],
            "stateMutability": "pure",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "uint256",
                    "name": "subjectTime",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "lastPriceTimestamp",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "updateInterval",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "frontRunningInterval",
                    "type": "uint256"
                }
            ],
            "name": "isBeforeFrontRunningInterval",
            "outputs": [
                {
                    "internalType": "bool",
                    "name": "",
                    "type": "bool"
                }
            ],
            "stateMutability": "pure",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "bytes16",
                    "name": "a",
                    "type": "bytes16"
                },
                {
                    "internalType": "uint256",
                    "name": "b",
                    "type": "uint256"
                }
            ],
            "name": "multiplyDecimalByUInt",
            "outputs": [
                {
                    "internalType": "bytes16",
                    "name": "",
                    "type": "bytes16"
                }
            ],
            "stateMutability": "pure",
            "type": "function"
        },
        {
            "inputs": [],
            "name": "one",
            "outputs": [
                {
                    "internalType": "bytes16",
                    "name": "",
                    "type": "bytes16"
                }
            ],
            "stateMutability": "view",
            "type": "function"
        },
        {
            "inputs": [],
            "name": "zero",
            "outputs": [
                {
                    "internalType": "bytes16",
                    "name": "",
                    "type": "bytes16"
                }
            ],
            "stateMutability": "view",
            "type": "function"
        }
    ],
    "transactionHash": "0x229353503808cfbaee7f08baaac58938f68f27481942133aa99ebd7292b420ea",
    "receipt": {
        "to": null,
        "from": "0xfb59B91646cd0890F3E5343384FEb746989B66C7",
        "contractAddress": "0x542848E66D8f387a78717Be7b39f7259B7782bAe",
        "transactionIndex": 0,
        "gasUsed": "89878315",
        "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
        "blockHash": "0x0647d81b23f43a0d4c5d10fd18a168124e7652dc15457e5dcbfaf80b135cf02d",
        "transactionHash": "0x229353503808cfbaee7f08baaac58938f68f27481942133aa99ebd7292b420ea",
        "logs": [],
        "blockNumber": 1009722,
        "cumulativeGasUsed": "70616275",
        "status": 1,
        "byzantium": true
    },
    "args": [],
    "solcInputHash": "8a049347457f9128995616e64e929d97",
    "metadata": "{\"compiler\":{\"version\":\"0.8.7+commit.e28d00a7\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"MAX_DECIMALS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WAD_PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"int256\",\"name\":\"oldPrice\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"newPrice\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"longBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shortBalance\",\"type\":\"uint256\"},{\"internalType\":\"bytes16\",\"name\":\"leverageAmount\",\"type\":\"bytes16\"},{\"internalType\":\"bytes16\",\"name\":\"fee\",\"type\":\"bytes16\"}],\"internalType\":\"struct PoolSwapLibrary.PriceChangeData\",\"name\":\"priceChange\",\"type\":\"tuple\"}],\"name\":\"calculatePriceChange\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"x\",\"type\":\"bytes16\"},{\"internalType\":\"bytes16\",\"name\":\"y\",\"type\":\"bytes16\"}],\"name\":\"compareDecimals\",\"outputs\":[{\"internalType\":\"int8\",\"name\":\"\",\"type\":\"int8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"ratio\",\"type\":\"bytes16\"}],\"name\":\"convertDecimalToUInt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"convertUIntToDecimal\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"a\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"b\",\"type\":\"int256\"}],\"name\":\"divInt\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_wadValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_decimals\",\"type\":\"uint256\"}],\"name\":\"fromWad\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shortBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"longBalance\",\"type\":\"uint256\"}],\"name\":\"getBalancesAfterFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"lossMultiplier\",\"type\":\"bytes16\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"getLossAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"ratio\",\"type\":\"bytes16\"},{\"internalType\":\"int8\",\"name\":\"direction\",\"type\":\"int8\"},{\"internalType\":\"bytes16\",\"name\":\"leverage\",\"type\":\"bytes16\"}],\"name\":\"getLossMultiplier\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shadowBalance\",\"type\":\"uint256\"}],\"name\":\"getMintAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_numerator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_denominator\",\"type\":\"uint256\"}],\"name\":\"getRatio\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shadowBalance\",\"type\":\"uint256\"}],\"name\":\"getWithdrawAmountOnBurn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"subjectTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastPriceTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updateInterval\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"frontRunningInterval\",\"type\":\"uint256\"}],\"name\":\"isBeforeFrontRunningInterval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"a\",\"type\":\"bytes16\"},{\"internalType\":\"uint256\",\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"multiplyDecimalByUInt\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"one\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"zero\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"calculatePriceChange(PoolSwapLibrary.PriceChangeData)\":{\"details\":\"This function should be called by the LeveragedPool.\",\"params\":{\"priceChange\":\"The struct containing necessary data to calculate price change\"}},\"compareDecimals(bytes16,bytes16)\":{\"params\":{\"x\":\"The first number to compare\",\"y\":\"The second number to compare\"},\"returns\":{\"_0\":\"-1 if x < y, 0 if x = y, or 1 if x > y\"}},\"convertDecimalToUInt(bytes16)\":{\"params\":{\"ratio\":\"The value to convert\"},\"returns\":{\"_0\":\"The converted value\"}},\"convertUIntToDecimal(uint256)\":{\"params\":{\"amount\":\"The amount to convert\"},\"returns\":{\"_0\":\"The amount as a IEEE754 quadruple precision number\"}},\"divInt(int256,int256)\":{\"params\":{\"a\":\"The dividend\",\"b\":\"The divisor\"},\"returns\":{\"_0\":\"The quotient\"}},\"fromWad(uint256,uint256)\":{\"returns\":{\"_0\":\"Converted non-WAD value\"}},\"getBalancesAfterFees(uint256,uint256,uint256)\":{\"details\":\"Assumes shortBalance + longBalance >= reward\",\"params\":{\"longBalance\":\"Long balance of the pool\",\"reward\":\"Amount of keeper reward\",\"shortBalance\":\"Short balance of the pool\"},\"returns\":{\"_0\":\"shortBalanceAfterFees Short balance of the pool after the keeper reward has been paid\",\"_1\":\"longBalanceAfterFees Long balance of the pool after the keeper reward has been paid\"}},\"getLossAmount(bytes16,uint256)\":{\"params\":{\"balance\":\"The balance of the losing pool\",\"lossMultiplier\":\"The multiplier to use\"}},\"getLossMultiplier(bytes16,int8,bytes16)\":{\"params\":{\"direction\":\"The direction of the change. -1 if it's decreased, 0 if it hasn't changed, and 1 if it's increased\",\"leverage\":\"The amount of leverage to apply\",\"ratio\":\"The ratio of new price to old price\"},\"returns\":{\"_0\":\"The multiplier\"}},\"getMintAmount(uint256,uint256,uint256,uint256)\":{\"details\":\"Calculated as (tokenSupply + shadowBalance) * amountIn / balance\",\"params\":{\"amountIn\":\"Commitment amount of collateral tokens going into the pool\",\"balance\":\"Balance of the pool (no. of underlying collateral tokens in pool)\",\"shadowBalance\":\"Balance the shadow pool at time of mint\",\"tokenSupply\":\"Total supply of pool tokens\"},\"returns\":{\"_0\":\"Number of pool tokens to be minted\"}},\"getRatio(uint256,uint256)\":{\"details\":\"Rounds any overflow towards 0. If either parameter is zero, the ratio is 0\",\"params\":{\"_denominator\":\"The \\\"per part\\\" side of the equation. If this is zero, the ratio is zero\",\"_numerator\":\"The \\\"parts per\\\" side of the equation. If this is zero, the ratio is zero\"},\"returns\":{\"_0\":\"the ratio, as an ABDKMathQuad number (IEEE 754 quadruple precision floating point)\"}},\"getWithdrawAmountOnBurn(uint256,uint256,uint256,uint256)\":{\"details\":\"Calculates as `balance * amountIn / (tokenSupply + shadowBalance)\",\"params\":{\"amountIn\":\"Commitment amount of collateral tokens going into the pool\",\"balance\":\"Balance of the pool (no. of underlying collateral tokens in pool)\",\"shadowBalance\":\"Balance the shadow pool at time of mint\",\"tokenSupply\":\"Total supply of pool tokens\"},\"returns\":{\"_0\":\"Number of settlement tokens to be withdrawn on a burn\"}},\"isBeforeFrontRunningInterval(uint256,uint256,uint256,uint256)\":{\"details\":\"If you try to uncommit AFTER the frontRunningInterval, it should revert.\",\"params\":{\"frontRunningInterval\":\"The window of time before a price udpate users can not uncommit or have their commit executed from\",\"lastPriceTimestamp\":\"The timestamp of the last price update\",\"subjectTime\":\"The timestamp for which you want to calculate if it was beforeFrontRunningInterval\",\"updateInterval\":\"The interval between price updates\"}},\"multiplyDecimalByUInt(bytes16,uint256)\":{\"params\":{\"a\":\"The first term\",\"b\":\"The second term\"},\"returns\":{\"_0\":\"The product of a*b as a decimal\"}}},\"title\":\"Library for various useful (mostly) mathematical functions\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"calculatePriceChange(PoolSwapLibrary.PriceChangeData)\":{\"notice\":\"Calculates the effect of a price change. This involves calculating how many funds to transfer from the losing pool to the other.\"},\"compareDecimals(bytes16,bytes16)\":{\"notice\":\"Compares two decimal numbers\"},\"convertDecimalToUInt(bytes16)\":{\"notice\":\"Converts a raw decimal value to a more readable uint256 value\"},\"convertUIntToDecimal(uint256)\":{\"notice\":\"Converts an integer value to a compatible decimal value\"},\"divInt(int256,int256)\":{\"notice\":\"Divides two integers\"},\"fromWad(uint256,uint256)\":{\"notice\":\"Converts from a WAD to normal value\"},\"getBalancesAfterFees(uint256,uint256,uint256)\":{\"notice\":\"Gets the short and long balances after the keeper rewards have been paid out         Keeper rewards are paid proportionally to the short and long pool\"},\"getLossAmount(bytes16,uint256)\":{\"notice\":\"Calculates the amount to take from the losing pool\"},\"getLossMultiplier(bytes16,int8,bytes16)\":{\"notice\":\"Calculates the loss multiplier to apply to the losing pool. Includes the power leverage\"},\"getMintAmount(uint256,uint256,uint256,uint256)\":{\"notice\":\"Gets the number of pool tokens to be minted based on existing tokens\"},\"getRatio(uint256,uint256)\":{\"notice\":\"Calculates the ratio between two numbers\"},\"getWithdrawAmountOnBurn(uint256,uint256,uint256,uint256)\":{\"notice\":\"Gets the number of settlement tokens to be withdrawn based on a pool token burn amount\"},\"isBeforeFrontRunningInterval(uint256,uint256,uint256,uint256)\":{\"notice\":\"Returns true if the given timestamp is BEFORE the frontRunningInterval starts,         which is allowed for uncommitment.\"},\"multiplyDecimalByUInt(bytes16,uint256)\":{\"notice\":\"Multiplies a decimal and an unsigned integer\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/implementation/PoolSwapLibrary.sol\":\"PoolSwapLibrary\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"abdk-libraries-solidity/ABDKMathQuad.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-4-Clause\\n/*\\n * ABDK Math Quad Smart Contract Library.  Copyright \\u00a9 2019 by ABDK Consulting.\\n * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\\n */\\npragma solidity ^0.8.0;\\n\\n/**\\n * Smart contract library of mathematical functions operating with IEEE 754\\n * quadruple-precision binary floating-point numbers (quadruple precision\\n * numbers).  As long as quadruple precision numbers are 16-bytes long, they are\\n * represented by bytes16 type.\\n */\\nlibrary ABDKMathQuad {\\n  /*\\n   * 0.\\n   */\\n  bytes16 private constant POSITIVE_ZERO = 0x00000000000000000000000000000000;\\n\\n  /*\\n   * -0.\\n   */\\n  bytes16 private constant NEGATIVE_ZERO = 0x80000000000000000000000000000000;\\n\\n  /*\\n   * +Infinity.\\n   */\\n  bytes16 private constant POSITIVE_INFINITY = 0x7FFF0000000000000000000000000000;\\n\\n  /*\\n   * -Infinity.\\n   */\\n  bytes16 private constant NEGATIVE_INFINITY = 0xFFFF0000000000000000000000000000;\\n\\n  /*\\n   * Canonical NaN value.\\n   */\\n  bytes16 private constant NaN = 0x7FFF8000000000000000000000000000;\\n\\n  /**\\n   * Convert signed 256-bit integer number into quadruple precision number.\\n   *\\n   * @param x signed 256-bit integer number\\n   * @return quadruple precision number\\n   */\\n  function fromInt (int256 x) internal pure returns (bytes16) {\\n    unchecked {\\n      if (x == 0) return bytes16 (0);\\n      else {\\n        // We rely on overflow behavior here\\n        uint256 result = uint256 (x > 0 ? x : -x);\\n\\n        uint256 msb = mostSignificantBit (result);\\n        if (msb < 112) result <<= 112 - msb;\\n        else if (msb > 112) result >>= msb - 112;\\n\\n        result = result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF | 16383 + msb << 112;\\n        if (x < 0) result |= 0x80000000000000000000000000000000;\\n\\n        return bytes16 (uint128 (result));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert quadruple precision number into signed 256-bit integer number\\n   * rounding towards zero.  Revert on overflow.\\n   *\\n   * @param x quadruple precision number\\n   * @return signed 256-bit integer number\\n   */\\n  function toInt (bytes16 x) internal pure returns (int256) {\\n    unchecked {\\n      uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\\n\\n      require (exponent <= 16638); // Overflow\\n      if (exponent < 16383) return 0; // Underflow\\n\\n      uint256 result = uint256 (uint128 (x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF |\\n        0x10000000000000000000000000000;\\n\\n      if (exponent < 16495) result >>= 16495 - exponent;\\n      else if (exponent > 16495) result <<= exponent - 16495;\\n\\n      if (uint128 (x) >= 0x80000000000000000000000000000000) { // Negative\\n        require (result <= 0x8000000000000000000000000000000000000000000000000000000000000000);\\n        return -int256 (result); // We rely on overflow behavior here\\n      } else {\\n        require (result <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n        return int256 (result);\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert unsigned 256-bit integer number into quadruple precision number.\\n   *\\n   * @param x unsigned 256-bit integer number\\n   * @return quadruple precision number\\n   */\\n  function fromUInt (uint256 x) internal pure returns (bytes16) {\\n    unchecked {\\n      if (x == 0) return bytes16 (0);\\n      else {\\n        uint256 result = x;\\n\\n        uint256 msb = mostSignificantBit (result);\\n        if (msb < 112) result <<= 112 - msb;\\n        else if (msb > 112) result >>= msb - 112;\\n\\n        result = result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF | 16383 + msb << 112;\\n\\n        return bytes16 (uint128 (result));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert quadruple precision number into unsigned 256-bit integer number\\n   * rounding towards zero.  Revert on underflow.  Note, that negative floating\\n   * point numbers in range (-1.0 .. 0.0) may be converted to unsigned integer\\n   * without error, because they are rounded to zero.\\n   *\\n   * @param x quadruple precision number\\n   * @return unsigned 256-bit integer number\\n   */\\n  function toUInt (bytes16 x) internal pure returns (uint256) {\\n    unchecked {\\n      uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\\n\\n      if (exponent < 16383) return 0; // Underflow\\n\\n      require (uint128 (x) < 0x80000000000000000000000000000000); // Negative\\n\\n      require (exponent <= 16638); // Overflow\\n      uint256 result = uint256 (uint128 (x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF |\\n        0x10000000000000000000000000000;\\n\\n      if (exponent < 16495) result >>= 16495 - exponent;\\n      else if (exponent > 16495) result <<= exponent - 16495;\\n\\n      return result;\\n    }\\n  }\\n\\n  /**\\n   * Convert signed 128.128 bit fixed point number into quadruple precision\\n   * number.\\n   *\\n   * @param x signed 128.128 bit fixed point number\\n   * @return quadruple precision number\\n   */\\n  function from128x128 (int256 x) internal pure returns (bytes16) {\\n    unchecked {\\n      if (x == 0) return bytes16 (0);\\n      else {\\n        // We rely on overflow behavior here\\n        uint256 result = uint256 (x > 0 ? x : -x);\\n\\n        uint256 msb = mostSignificantBit (result);\\n        if (msb < 112) result <<= 112 - msb;\\n        else if (msb > 112) result >>= msb - 112;\\n\\n        result = result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF | 16255 + msb << 112;\\n        if (x < 0) result |= 0x80000000000000000000000000000000;\\n\\n        return bytes16 (uint128 (result));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert quadruple precision number into signed 128.128 bit fixed point\\n   * number.  Revert on overflow.\\n   *\\n   * @param x quadruple precision number\\n   * @return signed 128.128 bit fixed point number\\n   */\\n  function to128x128 (bytes16 x) internal pure returns (int256) {\\n    unchecked {\\n      uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\\n\\n      require (exponent <= 16510); // Overflow\\n      if (exponent < 16255) return 0; // Underflow\\n\\n      uint256 result = uint256 (uint128 (x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF |\\n        0x10000000000000000000000000000;\\n\\n      if (exponent < 16367) result >>= 16367 - exponent;\\n      else if (exponent > 16367) result <<= exponent - 16367;\\n\\n      if (uint128 (x) >= 0x80000000000000000000000000000000) { // Negative\\n        require (result <= 0x8000000000000000000000000000000000000000000000000000000000000000);\\n        return -int256 (result); // We rely on overflow behavior here\\n      } else {\\n        require (result <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n        return int256 (result);\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert signed 64.64 bit fixed point number into quadruple precision\\n   * number.\\n   *\\n   * @param x signed 64.64 bit fixed point number\\n   * @return quadruple precision number\\n   */\\n  function from64x64 (int128 x) internal pure returns (bytes16) {\\n    unchecked {\\n      if (x == 0) return bytes16 (0);\\n      else {\\n        // We rely on overflow behavior here\\n        uint256 result = uint128 (x > 0 ? x : -x);\\n\\n        uint256 msb = mostSignificantBit (result);\\n        if (msb < 112) result <<= 112 - msb;\\n        else if (msb > 112) result >>= msb - 112;\\n\\n        result = result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF | 16319 + msb << 112;\\n        if (x < 0) result |= 0x80000000000000000000000000000000;\\n\\n        return bytes16 (uint128 (result));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert quadruple precision number into signed 64.64 bit fixed point\\n   * number.  Revert on overflow.\\n   *\\n   * @param x quadruple precision number\\n   * @return signed 64.64 bit fixed point number\\n   */\\n  function to64x64 (bytes16 x) internal pure returns (int128) {\\n    unchecked {\\n      uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\\n\\n      require (exponent <= 16446); // Overflow\\n      if (exponent < 16319) return 0; // Underflow\\n\\n      uint256 result = uint256 (uint128 (x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF |\\n        0x10000000000000000000000000000;\\n\\n      if (exponent < 16431) result >>= 16431 - exponent;\\n      else if (exponent > 16431) result <<= exponent - 16431;\\n\\n      if (uint128 (x) >= 0x80000000000000000000000000000000) { // Negative\\n        require (result <= 0x80000000000000000000000000000000);\\n        return -int128 (int256 (result)); // We rely on overflow behavior here\\n      } else {\\n        require (result <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n        return int128 (int256 (result));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert octuple precision number into quadruple precision number.\\n   *\\n   * @param x octuple precision number\\n   * @return quadruple precision number\\n   */\\n  function fromOctuple (bytes32 x) internal pure returns (bytes16) {\\n    unchecked {\\n      bool negative = x & 0x8000000000000000000000000000000000000000000000000000000000000000 > 0;\\n\\n      uint256 exponent = uint256 (x) >> 236 & 0x7FFFF;\\n      uint256 significand = uint256 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      if (exponent == 0x7FFFF) {\\n        if (significand > 0) return NaN;\\n        else return negative ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\\n      }\\n\\n      if (exponent > 278526)\\n        return negative ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\\n      else if (exponent < 245649)\\n        return negative ? NEGATIVE_ZERO : POSITIVE_ZERO;\\n      else if (exponent < 245761) {\\n        significand = (significand | 0x100000000000000000000000000000000000000000000000000000000000) >> 245885 - exponent;\\n        exponent = 0;\\n      } else {\\n        significand >>= 124;\\n        exponent -= 245760;\\n      }\\n\\n      uint128 result = uint128 (significand | exponent << 112);\\n      if (negative) result |= 0x80000000000000000000000000000000;\\n\\n      return bytes16 (result);\\n    }\\n  }\\n\\n  /**\\n   * Convert quadruple precision number into octuple precision number.\\n   *\\n   * @param x quadruple precision number\\n   * @return octuple precision number\\n   */\\n  function toOctuple (bytes16 x) internal pure returns (bytes32) {\\n    unchecked {\\n      uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\\n\\n      uint256 result = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      if (exponent == 0x7FFF) exponent = 0x7FFFF; // Infinity or NaN\\n      else if (exponent == 0) {\\n        if (result > 0) {\\n          uint256 msb = mostSignificantBit (result);\\n          result = result << 236 - msb & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n          exponent = 245649 + msb;\\n        }\\n      } else {\\n        result <<= 124;\\n        exponent += 245760;\\n      }\\n\\n      result |= exponent << 236;\\n      if (uint128 (x) >= 0x80000000000000000000000000000000)\\n        result |= 0x8000000000000000000000000000000000000000000000000000000000000000;\\n\\n      return bytes32 (result);\\n    }\\n  }\\n\\n  /**\\n   * Convert double precision number into quadruple precision number.\\n   *\\n   * @param x double precision number\\n   * @return quadruple precision number\\n   */\\n  function fromDouble (bytes8 x) internal pure returns (bytes16) {\\n    unchecked {\\n      uint256 exponent = uint64 (x) >> 52 & 0x7FF;\\n\\n      uint256 result = uint64 (x) & 0xFFFFFFFFFFFFF;\\n\\n      if (exponent == 0x7FF) exponent = 0x7FFF; // Infinity or NaN\\n      else if (exponent == 0) {\\n        if (result > 0) {\\n          uint256 msb = mostSignificantBit (result);\\n          result = result << 112 - msb & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n          exponent = 15309 + msb;\\n        }\\n      } else {\\n        result <<= 60;\\n        exponent += 15360;\\n      }\\n\\n      result |= exponent << 112;\\n      if (x & 0x8000000000000000 > 0)\\n        result |= 0x80000000000000000000000000000000;\\n\\n      return bytes16 (uint128 (result));\\n    }\\n  }\\n\\n  /**\\n   * Convert quadruple precision number into double precision number.\\n   *\\n   * @param x quadruple precision number\\n   * @return double precision number\\n   */\\n  function toDouble (bytes16 x) internal pure returns (bytes8) {\\n    unchecked {\\n      bool negative = uint128 (x) >= 0x80000000000000000000000000000000;\\n\\n      uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\\n      uint256 significand = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      if (exponent == 0x7FFF) {\\n        if (significand > 0) return 0x7FF8000000000000; // NaN\\n        else return negative ?\\n            bytes8 (0xFFF0000000000000) : // -Infinity\\n            bytes8 (0x7FF0000000000000); // Infinity\\n      }\\n\\n      if (exponent > 17406)\\n        return negative ?\\n            bytes8 (0xFFF0000000000000) : // -Infinity\\n            bytes8 (0x7FF0000000000000); // Infinity\\n      else if (exponent < 15309)\\n        return negative ?\\n            bytes8 (0x8000000000000000) : // -0\\n            bytes8 (0x0000000000000000); // 0\\n      else if (exponent < 15361) {\\n        significand = (significand | 0x10000000000000000000000000000) >> 15421 - exponent;\\n        exponent = 0;\\n      } else {\\n        significand >>= 60;\\n        exponent -= 15360;\\n      }\\n\\n      uint64 result = uint64 (significand | exponent << 52);\\n      if (negative) result |= 0x8000000000000000;\\n\\n      return bytes8 (result);\\n    }\\n  }\\n\\n  /**\\n   * Test whether given quadruple precision number is NaN.\\n   *\\n   * @param x quadruple precision number\\n   * @return true if x is NaN, false otherwise\\n   */\\n  function isNaN (bytes16 x) internal pure returns (bool) {\\n    unchecked {\\n      return uint128 (x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF >\\n        0x7FFF0000000000000000000000000000;\\n    }\\n  }\\n\\n  /**\\n   * Test whether given quadruple precision number is positive or negative\\n   * infinity.\\n   *\\n   * @param x quadruple precision number\\n   * @return true if x is positive or negative infinity, false otherwise\\n   */\\n  function isInfinity (bytes16 x) internal pure returns (bool) {\\n    unchecked {\\n      return uint128 (x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF ==\\n        0x7FFF0000000000000000000000000000;\\n    }\\n  }\\n\\n  /**\\n   * Calculate sign of x, i.e. -1 if x is negative, 0 if x if zero, and 1 if x\\n   * is positive.  Note that sign (-0) is zero.  Revert if x is NaN. \\n   *\\n   * @param x quadruple precision number\\n   * @return sign of x\\n   */\\n  function sign (bytes16 x) internal pure returns (int8) {\\n    unchecked {\\n      uint128 absoluteX = uint128 (x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      require (absoluteX <= 0x7FFF0000000000000000000000000000); // Not NaN\\n\\n      if (absoluteX == 0) return 0;\\n      else if (uint128 (x) >= 0x80000000000000000000000000000000) return -1;\\n      else return 1;\\n    }\\n  }\\n\\n  /**\\n   * Calculate sign (x - y).  Revert if either argument is NaN, or both\\n   * arguments are infinities of the same sign. \\n   *\\n   * @param x quadruple precision number\\n   * @param y quadruple precision number\\n   * @return sign (x - y)\\n   */\\n  function cmp (bytes16 x, bytes16 y) internal pure returns (int8) {\\n    unchecked {\\n      uint128 absoluteX = uint128 (x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      require (absoluteX <= 0x7FFF0000000000000000000000000000); // Not NaN\\n\\n      uint128 absoluteY = uint128 (y) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      require (absoluteY <= 0x7FFF0000000000000000000000000000); // Not NaN\\n\\n      // Not infinities of the same sign\\n      require (x != y || absoluteX < 0x7FFF0000000000000000000000000000);\\n\\n      if (x == y) return 0;\\n      else {\\n        bool negativeX = uint128 (x) >= 0x80000000000000000000000000000000;\\n        bool negativeY = uint128 (y) >= 0x80000000000000000000000000000000;\\n\\n        if (negativeX) {\\n          if (negativeY) return absoluteX > absoluteY ? -1 : int8 (1);\\n          else return -1; \\n        } else {\\n          if (negativeY) return 1;\\n          else return absoluteX > absoluteY ? int8 (1) : -1;\\n        }\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Test whether x equals y.  NaN, infinity, and -infinity are not equal to\\n   * anything. \\n   *\\n   * @param x quadruple precision number\\n   * @param y quadruple precision number\\n   * @return true if x equals to y, false otherwise\\n   */\\n  function eq (bytes16 x, bytes16 y) internal pure returns (bool) {\\n    unchecked {\\n      if (x == y) {\\n        return uint128 (x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF <\\n          0x7FFF0000000000000000000000000000;\\n      } else return false;\\n    }\\n  }\\n\\n  /**\\n   * Calculate x + y.  Special values behave in the following way:\\n   *\\n   * NaN + x = NaN for any x.\\n   * Infinity + x = Infinity for any finite x.\\n   * -Infinity + x = -Infinity for any finite x.\\n   * Infinity + Infinity = Infinity.\\n   * -Infinity + -Infinity = -Infinity.\\n   * Infinity + -Infinity = -Infinity + Infinity = NaN.\\n   *\\n   * @param x quadruple precision number\\n   * @param y quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function add (bytes16 x, bytes16 y) internal pure returns (bytes16) {\\n    unchecked {\\n      uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\\n      uint256 yExponent = uint128 (y) >> 112 & 0x7FFF;\\n\\n      if (xExponent == 0x7FFF) {\\n        if (yExponent == 0x7FFF) { \\n          if (x == y) return x;\\n          else return NaN;\\n        } else return x; \\n      } else if (yExponent == 0x7FFF) return y;\\n      else {\\n        bool xSign = uint128 (x) >= 0x80000000000000000000000000000000;\\n        uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (xExponent == 0) xExponent = 1;\\n        else xSignifier |= 0x10000000000000000000000000000;\\n\\n        bool ySign = uint128 (y) >= 0x80000000000000000000000000000000;\\n        uint256 ySignifier = uint128 (y) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (yExponent == 0) yExponent = 1;\\n        else ySignifier |= 0x10000000000000000000000000000;\\n\\n        if (xSignifier == 0) return y == NEGATIVE_ZERO ? POSITIVE_ZERO : y;\\n        else if (ySignifier == 0) return x == NEGATIVE_ZERO ? POSITIVE_ZERO : x;\\n        else {\\n          int256 delta = int256 (xExponent) - int256 (yExponent);\\n  \\n          if (xSign == ySign) {\\n            if (delta > 112) return x;\\n            else if (delta > 0) ySignifier >>= uint256 (delta);\\n            else if (delta < -112) return y;\\n            else if (delta < 0) {\\n              xSignifier >>= uint256 (-delta);\\n              xExponent = yExponent;\\n            }\\n  \\n            xSignifier += ySignifier;\\n  \\n            if (xSignifier >= 0x20000000000000000000000000000) {\\n              xSignifier >>= 1;\\n              xExponent += 1;\\n            }\\n  \\n            if (xExponent == 0x7FFF)\\n              return xSign ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\\n            else {\\n              if (xSignifier < 0x10000000000000000000000000000) xExponent = 0;\\n              else xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n  \\n              return bytes16 (uint128 (\\n                  (xSign ? 0x80000000000000000000000000000000 : 0) |\\n                  (xExponent << 112) |\\n                  xSignifier)); \\n            }\\n          } else {\\n            if (delta > 0) {\\n              xSignifier <<= 1;\\n              xExponent -= 1;\\n            } else if (delta < 0) {\\n              ySignifier <<= 1;\\n              xExponent = yExponent - 1;\\n            }\\n\\n            if (delta > 112) ySignifier = 1;\\n            else if (delta > 1) ySignifier = (ySignifier - 1 >> uint256 (delta - 1)) + 1;\\n            else if (delta < -112) xSignifier = 1;\\n            else if (delta < -1) xSignifier = (xSignifier - 1 >> uint256 (-delta - 1)) + 1;\\n\\n            if (xSignifier >= ySignifier) xSignifier -= ySignifier;\\n            else {\\n              xSignifier = ySignifier - xSignifier;\\n              xSign = ySign;\\n            }\\n\\n            if (xSignifier == 0)\\n              return POSITIVE_ZERO;\\n\\n            uint256 msb = mostSignificantBit (xSignifier);\\n\\n            if (msb == 113) {\\n              xSignifier = xSignifier >> 1 & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n              xExponent += 1;\\n            } else if (msb < 112) {\\n              uint256 shift = 112 - msb;\\n              if (xExponent > shift) {\\n                xSignifier = xSignifier << shift & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n                xExponent -= shift;\\n              } else {\\n                xSignifier <<= xExponent - 1;\\n                xExponent = 0;\\n              }\\n            } else xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n            if (xExponent == 0x7FFF)\\n              return xSign ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\\n            else return bytes16 (uint128 (\\n                (xSign ? 0x80000000000000000000000000000000 : 0) |\\n                (xExponent << 112) |\\n                xSignifier));\\n          }\\n        }\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate x - y.  Special values behave in the following way:\\n   *\\n   * NaN - x = NaN for any x.\\n   * Infinity - x = Infinity for any finite x.\\n   * -Infinity - x = -Infinity for any finite x.\\n   * Infinity - -Infinity = Infinity.\\n   * -Infinity - Infinity = -Infinity.\\n   * Infinity - Infinity = -Infinity - -Infinity = NaN.\\n   *\\n   * @param x quadruple precision number\\n   * @param y quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function sub (bytes16 x, bytes16 y) internal pure returns (bytes16) {\\n    unchecked {\\n      return add (x, y ^ 0x80000000000000000000000000000000);\\n    }\\n  }\\n\\n  /**\\n   * Calculate x * y.  Special values behave in the following way:\\n   *\\n   * NaN * x = NaN for any x.\\n   * Infinity * x = Infinity for any finite positive x.\\n   * Infinity * x = -Infinity for any finite negative x.\\n   * -Infinity * x = -Infinity for any finite positive x.\\n   * -Infinity * x = Infinity for any finite negative x.\\n   * Infinity * 0 = NaN.\\n   * -Infinity * 0 = NaN.\\n   * Infinity * Infinity = Infinity.\\n   * Infinity * -Infinity = -Infinity.\\n   * -Infinity * Infinity = -Infinity.\\n   * -Infinity * -Infinity = Infinity.\\n   *\\n   * @param x quadruple precision number\\n   * @param y quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function mul (bytes16 x, bytes16 y) internal pure returns (bytes16) {\\n    unchecked {\\n      uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\\n      uint256 yExponent = uint128 (y) >> 112 & 0x7FFF;\\n\\n      if (xExponent == 0x7FFF) {\\n        if (yExponent == 0x7FFF) {\\n          if (x == y) return x ^ y & 0x80000000000000000000000000000000;\\n          else if (x ^ y == 0x80000000000000000000000000000000) return x | y;\\n          else return NaN;\\n        } else {\\n          if (y & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) return NaN;\\n          else return x ^ y & 0x80000000000000000000000000000000;\\n        }\\n      } else if (yExponent == 0x7FFF) {\\n          if (x & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) return NaN;\\n          else return y ^ x & 0x80000000000000000000000000000000;\\n      } else {\\n        uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (xExponent == 0) xExponent = 1;\\n        else xSignifier |= 0x10000000000000000000000000000;\\n\\n        uint256 ySignifier = uint128 (y) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (yExponent == 0) yExponent = 1;\\n        else ySignifier |= 0x10000000000000000000000000000;\\n\\n        xSignifier *= ySignifier;\\n        if (xSignifier == 0)\\n          return (x ^ y) & 0x80000000000000000000000000000000 > 0 ?\\n              NEGATIVE_ZERO : POSITIVE_ZERO;\\n\\n        xExponent += yExponent;\\n\\n        uint256 msb =\\n          xSignifier >= 0x200000000000000000000000000000000000000000000000000000000 ? 225 :\\n          xSignifier >= 0x100000000000000000000000000000000000000000000000000000000 ? 224 :\\n          mostSignificantBit (xSignifier);\\n\\n        if (xExponent + msb < 16496) { // Underflow\\n          xExponent = 0;\\n          xSignifier = 0;\\n        } else if (xExponent + msb < 16608) { // Subnormal\\n          if (xExponent < 16496)\\n            xSignifier >>= 16496 - xExponent;\\n          else if (xExponent > 16496)\\n            xSignifier <<= xExponent - 16496;\\n          xExponent = 0;\\n        } else if (xExponent + msb > 49373) {\\n          xExponent = 0x7FFF;\\n          xSignifier = 0;\\n        } else {\\n          if (msb > 112)\\n            xSignifier >>= msb - 112;\\n          else if (msb < 112)\\n            xSignifier <<= 112 - msb;\\n\\n          xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n          xExponent = xExponent + msb - 16607;\\n        }\\n\\n        return bytes16 (uint128 (uint128 ((x ^ y) & 0x80000000000000000000000000000000) |\\n            xExponent << 112 | xSignifier));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate x / y.  Special values behave in the following way:\\n   *\\n   * NaN / x = NaN for any x.\\n   * x / NaN = NaN for any x.\\n   * Infinity / x = Infinity for any finite non-negative x.\\n   * Infinity / x = -Infinity for any finite negative x including -0.\\n   * -Infinity / x = -Infinity for any finite non-negative x.\\n   * -Infinity / x = Infinity for any finite negative x including -0.\\n   * x / Infinity = 0 for any finite non-negative x.\\n   * x / -Infinity = -0 for any finite non-negative x.\\n   * x / Infinity = -0 for any finite non-negative x including -0.\\n   * x / -Infinity = 0 for any finite non-negative x including -0.\\n   * \\n   * Infinity / Infinity = NaN.\\n   * Infinity / -Infinity = -NaN.\\n   * -Infinity / Infinity = -NaN.\\n   * -Infinity / -Infinity = NaN.\\n   *\\n   * Division by zero behaves in the following way:\\n   *\\n   * x / 0 = Infinity for any finite positive x.\\n   * x / -0 = -Infinity for any finite positive x.\\n   * x / 0 = -Infinity for any finite negative x.\\n   * x / -0 = Infinity for any finite negative x.\\n   * 0 / 0 = NaN.\\n   * 0 / -0 = NaN.\\n   * -0 / 0 = NaN.\\n   * -0 / -0 = NaN.\\n   *\\n   * @param x quadruple precision number\\n   * @param y quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function div (bytes16 x, bytes16 y) internal pure returns (bytes16) {\\n    unchecked {\\n      uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\\n      uint256 yExponent = uint128 (y) >> 112 & 0x7FFF;\\n\\n      if (xExponent == 0x7FFF) {\\n        if (yExponent == 0x7FFF) return NaN;\\n        else return x ^ y & 0x80000000000000000000000000000000;\\n      } else if (yExponent == 0x7FFF) {\\n        if (y & 0x0000FFFFFFFFFFFFFFFFFFFFFFFFFFFF != 0) return NaN;\\n        else return POSITIVE_ZERO | (x ^ y) & 0x80000000000000000000000000000000;\\n      } else if (y & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) {\\n        if (x & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) return NaN;\\n        else return POSITIVE_INFINITY | (x ^ y) & 0x80000000000000000000000000000000;\\n      } else {\\n        uint256 ySignifier = uint128 (y) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (yExponent == 0) yExponent = 1;\\n        else ySignifier |= 0x10000000000000000000000000000;\\n\\n        uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (xExponent == 0) {\\n          if (xSignifier != 0) {\\n            uint shift = 226 - mostSignificantBit (xSignifier);\\n\\n            xSignifier <<= shift;\\n\\n            xExponent = 1;\\n            yExponent += shift - 114;\\n          }\\n        }\\n        else {\\n          xSignifier = (xSignifier | 0x10000000000000000000000000000) << 114;\\n        }\\n\\n        xSignifier = xSignifier / ySignifier;\\n        if (xSignifier == 0)\\n          return (x ^ y) & 0x80000000000000000000000000000000 > 0 ?\\n              NEGATIVE_ZERO : POSITIVE_ZERO;\\n\\n        assert (xSignifier >= 0x1000000000000000000000000000);\\n\\n        uint256 msb =\\n          xSignifier >= 0x80000000000000000000000000000 ? mostSignificantBit (xSignifier) :\\n          xSignifier >= 0x40000000000000000000000000000 ? 114 :\\n          xSignifier >= 0x20000000000000000000000000000 ? 113 : 112;\\n\\n        if (xExponent + msb > yExponent + 16497) { // Overflow\\n          xExponent = 0x7FFF;\\n          xSignifier = 0;\\n        } else if (xExponent + msb + 16380  < yExponent) { // Underflow\\n          xExponent = 0;\\n          xSignifier = 0;\\n        } else if (xExponent + msb + 16268  < yExponent) { // Subnormal\\n          if (xExponent + 16380 > yExponent)\\n            xSignifier <<= xExponent + 16380 - yExponent;\\n          else if (xExponent + 16380 < yExponent)\\n            xSignifier >>= yExponent - xExponent - 16380;\\n\\n          xExponent = 0;\\n        } else { // Normal\\n          if (msb > 112)\\n            xSignifier >>= msb - 112;\\n\\n          xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n          xExponent = xExponent + msb + 16269 - yExponent;\\n        }\\n\\n        return bytes16 (uint128 (uint128 ((x ^ y) & 0x80000000000000000000000000000000) |\\n            xExponent << 112 | xSignifier));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate -x.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function neg (bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      return x ^ 0x80000000000000000000000000000000;\\n    }\\n  }\\n\\n  /**\\n   * Calculate |x|.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function abs (bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      return x & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n    }\\n  }\\n\\n  /**\\n   * Calculate square root of x.  Return NaN on negative x excluding -0.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function sqrt (bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      if (uint128 (x) >  0x80000000000000000000000000000000) return NaN;\\n      else {\\n        uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\\n        if (xExponent == 0x7FFF) return x;\\n        else {\\n          uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n          if (xExponent == 0) xExponent = 1;\\n          else xSignifier |= 0x10000000000000000000000000000;\\n\\n          if (xSignifier == 0) return POSITIVE_ZERO;\\n\\n          bool oddExponent = xExponent & 0x1 == 0;\\n          xExponent = xExponent + 16383 >> 1;\\n\\n          if (oddExponent) {\\n            if (xSignifier >= 0x10000000000000000000000000000)\\n              xSignifier <<= 113;\\n            else {\\n              uint256 msb = mostSignificantBit (xSignifier);\\n              uint256 shift = (226 - msb) & 0xFE;\\n              xSignifier <<= shift;\\n              xExponent -= shift - 112 >> 1;\\n            }\\n          } else {\\n            if (xSignifier >= 0x10000000000000000000000000000)\\n              xSignifier <<= 112;\\n            else {\\n              uint256 msb = mostSignificantBit (xSignifier);\\n              uint256 shift = (225 - msb) & 0xFE;\\n              xSignifier <<= shift;\\n              xExponent -= shift - 112 >> 1;\\n            }\\n          }\\n\\n          uint256 r = 0x10000000000000000000000000000;\\n          r = (r + xSignifier / r) >> 1;\\n          r = (r + xSignifier / r) >> 1;\\n          r = (r + xSignifier / r) >> 1;\\n          r = (r + xSignifier / r) >> 1;\\n          r = (r + xSignifier / r) >> 1;\\n          r = (r + xSignifier / r) >> 1;\\n          r = (r + xSignifier / r) >> 1; // Seven iterations should be enough\\n          uint256 r1 = xSignifier / r;\\n          if (r1 < r) r = r1;\\n\\n          return bytes16 (uint128 (xExponent << 112 | r & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF));\\n        }\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate binary logarithm of x.  Return NaN on negative x excluding -0.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function log_2 (bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      if (uint128 (x) > 0x80000000000000000000000000000000) return NaN;\\n      else if (x == 0x3FFF0000000000000000000000000000) return POSITIVE_ZERO; \\n      else {\\n        uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\\n        if (xExponent == 0x7FFF) return x;\\n        else {\\n          uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n          if (xExponent == 0) xExponent = 1;\\n          else xSignifier |= 0x10000000000000000000000000000;\\n\\n          if (xSignifier == 0) return NEGATIVE_INFINITY;\\n\\n          bool resultNegative;\\n          uint256 resultExponent = 16495;\\n          uint256 resultSignifier;\\n\\n          if (xExponent >= 0x3FFF) {\\n            resultNegative = false;\\n            resultSignifier = xExponent - 0x3FFF;\\n            xSignifier <<= 15;\\n          } else {\\n            resultNegative = true;\\n            if (xSignifier >= 0x10000000000000000000000000000) {\\n              resultSignifier = 0x3FFE - xExponent;\\n              xSignifier <<= 15;\\n            } else {\\n              uint256 msb = mostSignificantBit (xSignifier);\\n              resultSignifier = 16493 - msb;\\n              xSignifier <<= 127 - msb;\\n            }\\n          }\\n\\n          if (xSignifier == 0x80000000000000000000000000000000) {\\n            if (resultNegative) resultSignifier += 1;\\n            uint256 shift = 112 - mostSignificantBit (resultSignifier);\\n            resultSignifier <<= shift;\\n            resultExponent -= shift;\\n          } else {\\n            uint256 bb = resultNegative ? 1 : 0;\\n            while (resultSignifier < 0x10000000000000000000000000000) {\\n              resultSignifier <<= 1;\\n              resultExponent -= 1;\\n  \\n              xSignifier *= xSignifier;\\n              uint256 b = xSignifier >> 255;\\n              resultSignifier += b ^ bb;\\n              xSignifier >>= 127 + b;\\n            }\\n          }\\n\\n          return bytes16 (uint128 ((resultNegative ? 0x80000000000000000000000000000000 : 0) |\\n              resultExponent << 112 | resultSignifier & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF));\\n        }\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate natural logarithm of x.  Return NaN on negative x excluding -0.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function ln (bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      return mul (log_2 (x), 0x3FFE62E42FEFA39EF35793C7673007E5);\\n    }\\n  }\\n\\n  /**\\n   * Calculate 2^x.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function pow_2 (bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      bool xNegative = uint128 (x) > 0x80000000000000000000000000000000;\\n      uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\\n      uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      if (xExponent == 0x7FFF && xSignifier != 0) return NaN;\\n      else if (xExponent > 16397)\\n        return xNegative ? POSITIVE_ZERO : POSITIVE_INFINITY;\\n      else if (xExponent < 16255)\\n        return 0x3FFF0000000000000000000000000000;\\n      else {\\n        if (xExponent == 0) xExponent = 1;\\n        else xSignifier |= 0x10000000000000000000000000000;\\n\\n        if (xExponent > 16367)\\n          xSignifier <<= xExponent - 16367;\\n        else if (xExponent < 16367)\\n          xSignifier >>= 16367 - xExponent;\\n\\n        if (xNegative && xSignifier > 0x406E00000000000000000000000000000000)\\n          return POSITIVE_ZERO;\\n\\n        if (!xNegative && xSignifier > 0x3FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\\n          return POSITIVE_INFINITY;\\n\\n        uint256 resultExponent = xSignifier >> 128;\\n        xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (xNegative && xSignifier != 0) {\\n          xSignifier = ~xSignifier;\\n          resultExponent += 1;\\n        }\\n\\n        uint256 resultSignifier = 0x80000000000000000000000000000000;\\n        if (xSignifier & 0x80000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x16A09E667F3BCC908B2FB1366EA957D3E >> 128;\\n        if (xSignifier & 0x40000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1306FE0A31B7152DE8D5A46305C85EDEC >> 128;\\n        if (xSignifier & 0x20000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1172B83C7D517ADCDF7C8C50EB14A791F >> 128;\\n        if (xSignifier & 0x10000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10B5586CF9890F6298B92B71842A98363 >> 128;\\n        if (xSignifier & 0x8000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1059B0D31585743AE7C548EB68CA417FD >> 128;\\n        if (xSignifier & 0x4000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x102C9A3E778060EE6F7CACA4F7A29BDE8 >> 128;\\n        if (xSignifier & 0x2000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10163DA9FB33356D84A66AE336DCDFA3F >> 128;\\n        if (xSignifier & 0x1000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100B1AFA5ABCBED6129AB13EC11DC9543 >> 128;\\n        if (xSignifier & 0x800000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10058C86DA1C09EA1FF19D294CF2F679B >> 128;\\n        if (xSignifier & 0x400000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1002C605E2E8CEC506D21BFC89A23A00F >> 128;\\n        if (xSignifier & 0x200000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100162F3904051FA128BCA9C55C31E5DF >> 128;\\n        if (xSignifier & 0x100000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000B175EFFDC76BA38E31671CA939725 >> 128;\\n        if (xSignifier & 0x80000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100058BA01FB9F96D6CACD4B180917C3D >> 128;\\n        if (xSignifier & 0x40000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10002C5CC37DA9491D0985C348C68E7B3 >> 128;\\n        if (xSignifier & 0x20000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000162E525EE054754457D5995292026 >> 128;\\n        if (xSignifier & 0x10000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000B17255775C040618BF4A4ADE83FC >> 128;\\n        if (xSignifier & 0x8000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000058B91B5BC9AE2EED81E9B7D4CFAB >> 128;\\n        if (xSignifier & 0x4000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100002C5C89D5EC6CA4D7C8ACC017B7C9 >> 128;\\n        if (xSignifier & 0x2000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000162E43F4F831060E02D839A9D16D >> 128;\\n        if (xSignifier & 0x1000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000B1721BCFC99D9F890EA06911763 >> 128;\\n        if (xSignifier & 0x800000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000058B90CF1E6D97F9CA14DBCC1628 >> 128;\\n        if (xSignifier & 0x400000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000002C5C863B73F016468F6BAC5CA2B >> 128;\\n        if (xSignifier & 0x200000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000162E430E5A18F6119E3C02282A5 >> 128;\\n        if (xSignifier & 0x100000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000B1721835514B86E6D96EFD1BFE >> 128;\\n        if (xSignifier & 0x80000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000058B90C0B48C6BE5DF846C5B2EF >> 128;\\n        if (xSignifier & 0x40000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000002C5C8601CC6B9E94213C72737A >> 128;\\n        if (xSignifier & 0x20000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000162E42FFF037DF38AA2B219F06 >> 128;\\n        if (xSignifier & 0x10000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000B17217FBA9C739AA5819F44F9 >> 128;\\n        if (xSignifier & 0x8000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000058B90BFCDEE5ACD3C1CEDC823 >> 128;\\n        if (xSignifier & 0x4000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000002C5C85FE31F35A6A30DA1BE50 >> 128;\\n        if (xSignifier & 0x2000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000162E42FF0999CE3541B9FFFCF >> 128;\\n        if (xSignifier & 0x1000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000B17217F80F4EF5AADDA45554 >> 128;\\n        if (xSignifier & 0x800000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000058B90BFBF8479BD5A81B51AD >> 128;\\n        if (xSignifier & 0x400000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000002C5C85FDF84BD62AE30A74CC >> 128;\\n        if (xSignifier & 0x200000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000162E42FEFB2FED257559BDAA >> 128;\\n        if (xSignifier & 0x100000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000B17217F7D5A7716BBA4A9AE >> 128;\\n        if (xSignifier & 0x80000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000058B90BFBE9DDBAC5E109CCE >> 128;\\n        if (xSignifier & 0x40000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000002C5C85FDF4B15DE6F17EB0D >> 128;\\n        if (xSignifier & 0x20000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000162E42FEFA494F1478FDE05 >> 128;\\n        if (xSignifier & 0x10000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000B17217F7D20CF927C8E94C >> 128;\\n        if (xSignifier & 0x8000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000058B90BFBE8F71CB4E4B33D >> 128;\\n        if (xSignifier & 0x4000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000002C5C85FDF477B662B26945 >> 128;\\n        if (xSignifier & 0x2000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000162E42FEFA3AE53369388C >> 128;\\n        if (xSignifier & 0x1000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000B17217F7D1D351A389D40 >> 128;\\n        if (xSignifier & 0x800000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000058B90BFBE8E8B2D3D4EDE >> 128;\\n        if (xSignifier & 0x400000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000002C5C85FDF4741BEA6E77E >> 128;\\n        if (xSignifier & 0x200000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000162E42FEFA39FE95583C2 >> 128;\\n        if (xSignifier & 0x100000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000B17217F7D1CFB72B45E1 >> 128;\\n        if (xSignifier & 0x80000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000058B90BFBE8E7CC35C3F0 >> 128;\\n        if (xSignifier & 0x40000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000002C5C85FDF473E242EA38 >> 128;\\n        if (xSignifier & 0x20000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000162E42FEFA39F02B772C >> 128;\\n        if (xSignifier & 0x10000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000B17217F7D1CF7D83C1A >> 128;\\n        if (xSignifier & 0x8000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000058B90BFBE8E7BDCBE2E >> 128;\\n        if (xSignifier & 0x4000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000002C5C85FDF473DEA871F >> 128;\\n        if (xSignifier & 0x2000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000162E42FEFA39EF44D91 >> 128;\\n        if (xSignifier & 0x1000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000B17217F7D1CF79E949 >> 128;\\n        if (xSignifier & 0x800000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000058B90BFBE8E7BCE544 >> 128;\\n        if (xSignifier & 0x400000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000002C5C85FDF473DE6ECA >> 128;\\n        if (xSignifier & 0x200000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000162E42FEFA39EF366F >> 128;\\n        if (xSignifier & 0x100000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000B17217F7D1CF79AFA >> 128;\\n        if (xSignifier & 0x80000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000058B90BFBE8E7BCD6D >> 128;\\n        if (xSignifier & 0x40000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000002C5C85FDF473DE6B2 >> 128;\\n        if (xSignifier & 0x20000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000162E42FEFA39EF358 >> 128;\\n        if (xSignifier & 0x10000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000B17217F7D1CF79AB >> 128;\\n        if (xSignifier & 0x8000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000058B90BFBE8E7BCD5 >> 128;\\n        if (xSignifier & 0x4000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000002C5C85FDF473DE6A >> 128;\\n        if (xSignifier & 0x2000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000162E42FEFA39EF34 >> 128;\\n        if (xSignifier & 0x1000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000B17217F7D1CF799 >> 128;\\n        if (xSignifier & 0x800000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000058B90BFBE8E7BCC >> 128;\\n        if (xSignifier & 0x400000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000002C5C85FDF473DE5 >> 128;\\n        if (xSignifier & 0x200000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000162E42FEFA39EF2 >> 128;\\n        if (xSignifier & 0x100000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000B17217F7D1CF78 >> 128;\\n        if (xSignifier & 0x80000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000058B90BFBE8E7BB >> 128;\\n        if (xSignifier & 0x40000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000002C5C85FDF473DD >> 128;\\n        if (xSignifier & 0x20000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000162E42FEFA39EE >> 128;\\n        if (xSignifier & 0x10000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000B17217F7D1CF6 >> 128;\\n        if (xSignifier & 0x8000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000058B90BFBE8E7A >> 128;\\n        if (xSignifier & 0x4000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000002C5C85FDF473C >> 128;\\n        if (xSignifier & 0x2000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000162E42FEFA39D >> 128;\\n        if (xSignifier & 0x1000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000B17217F7D1CE >> 128;\\n        if (xSignifier & 0x800000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000058B90BFBE8E6 >> 128;\\n        if (xSignifier & 0x400000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000002C5C85FDF472 >> 128;\\n        if (xSignifier & 0x200000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000162E42FEFA38 >> 128;\\n        if (xSignifier & 0x100000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000B17217F7D1B >> 128;\\n        if (xSignifier & 0x80000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000058B90BFBE8D >> 128;\\n        if (xSignifier & 0x40000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000002C5C85FDF46 >> 128;\\n        if (xSignifier & 0x20000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000162E42FEFA2 >> 128;\\n        if (xSignifier & 0x10000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000B17217F7D0 >> 128;\\n        if (xSignifier & 0x8000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000058B90BFBE7 >> 128;\\n        if (xSignifier & 0x4000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000002C5C85FDF3 >> 128;\\n        if (xSignifier & 0x2000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000162E42FEF9 >> 128;\\n        if (xSignifier & 0x1000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000B17217F7C >> 128;\\n        if (xSignifier & 0x800000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000058B90BFBD >> 128;\\n        if (xSignifier & 0x400000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000002C5C85FDE >> 128;\\n        if (xSignifier & 0x200000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000162E42FEE >> 128;\\n        if (xSignifier & 0x100000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000B17217F6 >> 128;\\n        if (xSignifier & 0x80000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000058B90BFA >> 128;\\n        if (xSignifier & 0x40000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000002C5C85FC >> 128;\\n        if (xSignifier & 0x20000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000162E42FD >> 128;\\n        if (xSignifier & 0x10000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000B17217E >> 128;\\n        if (xSignifier & 0x8000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000058B90BE >> 128;\\n        if (xSignifier & 0x4000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000002C5C85E >> 128;\\n        if (xSignifier & 0x2000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000162E42E >> 128;\\n        if (xSignifier & 0x1000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000B17216 >> 128;\\n        if (xSignifier & 0x800000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000058B90A >> 128;\\n        if (xSignifier & 0x400000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000002C5C84 >> 128;\\n        if (xSignifier & 0x200000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000162E41 >> 128;\\n        if (xSignifier & 0x100000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000000B1720 >> 128;\\n        if (xSignifier & 0x80000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000058B8F >> 128;\\n        if (xSignifier & 0x40000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000002C5C7 >> 128;\\n        if (xSignifier & 0x20000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000000162E3 >> 128;\\n        if (xSignifier & 0x10000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000000B171 >> 128;\\n        if (xSignifier & 0x8000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000000058B8 >> 128;\\n        if (xSignifier & 0x4000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000002C5B >> 128;\\n        if (xSignifier & 0x2000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000000162D >> 128;\\n        if (xSignifier & 0x1000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000B16 >> 128;\\n        if (xSignifier & 0x800 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000000058A >> 128;\\n        if (xSignifier & 0x400 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000000002C4 >> 128;\\n        if (xSignifier & 0x200 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000161 >> 128;\\n        if (xSignifier & 0x100 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000000000B0 >> 128;\\n        if (xSignifier & 0x80 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000057 >> 128;\\n        if (xSignifier & 0x40 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000000002B >> 128;\\n        if (xSignifier & 0x20 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000015 >> 128;\\n        if (xSignifier & 0x10 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000000000A >> 128;\\n        if (xSignifier & 0x8 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000004 >> 128;\\n        if (xSignifier & 0x4 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000001 >> 128;\\n\\n        if (!xNegative) {\\n          resultSignifier = resultSignifier >> 15 & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n          resultExponent += 0x3FFF;\\n        } else if (resultExponent <= 0x3FFE) {\\n          resultSignifier = resultSignifier >> 15 & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n          resultExponent = 0x3FFF - resultExponent;\\n        } else {\\n          resultSignifier = resultSignifier >> resultExponent - 16367;\\n          resultExponent = 0;\\n        }\\n\\n        return bytes16 (uint128 (resultExponent << 112 | resultSignifier));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate e^x.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function exp (bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      return pow_2 (mul (x, 0x3FFF71547652B82FE1777D0FFDA0D23A));\\n    }\\n  }\\n\\n  /**\\n   * Get index of the most significant non-zero bit in binary representation of\\n   * x.  Reverts if x is zero.\\n   *\\n   * @return index of the most significant non-zero bit in binary representation\\n   *         of x\\n   */\\n  function mostSignificantBit (uint256 x) private pure returns (uint256) {\\n    unchecked {\\n      require (x > 0);\\n\\n      uint256 result = 0;\\n\\n      if (x >= 0x100000000000000000000000000000000) { x >>= 128; result += 128; }\\n      if (x >= 0x10000000000000000) { x >>= 64; result += 64; }\\n      if (x >= 0x100000000) { x >>= 32; result += 32; }\\n      if (x >= 0x10000) { x >>= 16; result += 16; }\\n      if (x >= 0x100) { x >>= 8; result += 8; }\\n      if (x >= 0x10) { x >>= 4; result += 4; }\\n      if (x >= 0x4) { x >>= 2; result += 2; }\\n      if (x >= 0x2) result += 1; // No need to shift x anymore\\n\\n      return result;\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0x9694a9f6fcadd4fa917efa674de42a74b8fbab8d68924f771ea5cc5e1a301434\",\"license\":\"BSD-4-Clause\"},\"contracts/implementation/PoolSwapLibrary.sol\":{\"content\":\"//SPDX-License-Identifier: CC-BY-NC-ND-4.0\\npragma solidity 0.8.7;\\n\\nimport \\\"abdk-libraries-solidity/ABDKMathQuad.sol\\\";\\n\\n/// @title Library for various useful (mostly) mathematical functions\\nlibrary PoolSwapLibrary {\\n    bytes16 public constant one = 0x3fff0000000000000000000000000000;\\n    bytes16 public constant zero = 0x00000000000000000000000000000000;\\n\\n    /* ABDKMathQuad defines this but it's private */\\n    bytes16 private constant NEGATIVE_ZERO = 0x80000000000000000000000000000000;\\n    uint256 public constant MAX_DECIMALS = 18;\\n\\n    uint256 public constant WAD_PRECISION = 10**18;\\n\\n    struct PriceChangeData {\\n        int256 oldPrice;\\n        int256 newPrice;\\n        uint256 longBalance;\\n        uint256 shortBalance;\\n        bytes16 leverageAmount;\\n        bytes16 fee;\\n    }\\n\\n    /**\\n     * @notice Calculates the ratio between two numbers\\n     * @dev Rounds any overflow towards 0. If either parameter is zero, the ratio is 0\\n     * @param _numerator The \\\"parts per\\\" side of the equation. If this is zero, the ratio is zero\\n     * @param _denominator The \\\"per part\\\" side of the equation. If this is zero, the ratio is zero\\n     * @return the ratio, as an ABDKMathQuad number (IEEE 754 quadruple precision floating point)\\n     */\\n    function getRatio(uint256 _numerator, uint256 _denominator) public pure returns (bytes16) {\\n        // Catch the divide by zero error.\\n        if (_denominator == 0) {\\n            return 0;\\n        }\\n        return ABDKMathQuad.div(ABDKMathQuad.fromUInt(_numerator), ABDKMathQuad.fromUInt(_denominator));\\n    }\\n\\n    /**\\n     * @notice Gets the short and long balances after the keeper rewards have been paid out\\n     *         Keeper rewards are paid proportionally to the short and long pool\\n     * @dev Assumes shortBalance + longBalance >= reward\\n     * @param reward Amount of keeper reward\\n     * @param shortBalance Short balance of the pool\\n     * @param longBalance Long balance of the pool\\n     * @return shortBalanceAfterFees Short balance of the pool after the keeper reward has been paid\\n     * @return longBalanceAfterFees Long balance of the pool after the keeper reward has been paid\\n     */\\n    function getBalancesAfterFees(\\n        uint256 reward,\\n        uint256 shortBalance,\\n        uint256 longBalance\\n    ) external pure returns (uint256, uint256) {\\n        bytes16 ratioShort = getRatio(shortBalance, shortBalance + longBalance);\\n\\n        uint256 shortFees = convertDecimalToUInt(multiplyDecimalByUInt(ratioShort, reward));\\n\\n        uint256 shortBalanceAfterFees = shortBalance - shortFees;\\n        uint256 longBalanceAfterFees = longBalance - (reward - shortFees);\\n\\n        // Return shortBalance and longBalance after rewards are paid out\\n        return (shortBalanceAfterFees, longBalanceAfterFees);\\n    }\\n\\n    /**\\n     * @notice Compares two decimal numbers\\n     * @param x The first number to compare\\n     * @param y The second number to compare\\n     * @return -1 if x < y, 0 if x = y, or 1 if x > y\\n     */\\n    function compareDecimals(bytes16 x, bytes16 y) public pure returns (int8) {\\n        return ABDKMathQuad.cmp(x, y);\\n    }\\n\\n    /**\\n     * @notice Converts an integer value to a compatible decimal value\\n     * @param amount The amount to convert\\n     * @return The amount as a IEEE754 quadruple precision number\\n     */\\n    function convertUIntToDecimal(uint256 amount) external pure returns (bytes16) {\\n        return ABDKMathQuad.fromUInt(amount);\\n    }\\n\\n    /**\\n     * @notice Converts a raw decimal value to a more readable uint256 value\\n     * @param ratio The value to convert\\n     * @return The converted value\\n     */\\n    function convertDecimalToUInt(bytes16 ratio) public pure returns (uint256) {\\n        return ABDKMathQuad.toUInt(ratio);\\n    }\\n\\n    /**\\n     * @notice Multiplies a decimal and an unsigned integer\\n     * @param a The first term\\n     * @param b The second term\\n     * @return The product of a*b as a decimal\\n     */\\n    function multiplyDecimalByUInt(bytes16 a, uint256 b) public pure returns (bytes16) {\\n        return ABDKMathQuad.mul(a, ABDKMathQuad.fromUInt(b));\\n    }\\n\\n    /**\\n     * @notice Divides two integers\\n     * @param a The dividend\\n     * @param b The divisor\\n     * @return The quotient\\n     */\\n    function divInt(int256 a, int256 b) public pure returns (bytes16) {\\n        return ABDKMathQuad.div(ABDKMathQuad.fromInt(a), ABDKMathQuad.fromInt(b));\\n    }\\n\\n    /**\\n     * @notice Calculates the loss multiplier to apply to the losing pool. Includes the power leverage\\n     * @param ratio The ratio of new price to old price\\n     * @param direction The direction of the change. -1 if it's decreased, 0 if it hasn't changed, and 1 if it's increased\\n     * @param leverage The amount of leverage to apply\\n     * @return The multiplier\\n     */\\n    function getLossMultiplier(\\n        bytes16 ratio,\\n        int8 direction,\\n        bytes16 leverage\\n    ) public pure returns (bytes16) {\\n        // If decreased:  2 ^ (leverage * log2[(1 * new/old) + [(0 * 1) / new/old]])\\n        //              = 2 ^ (leverage * log2[(new/old)])\\n        // If increased:  2 ^ (leverage * log2[(0 * new/old) + [(1 * 1) / new/old]])\\n        //              = 2 ^ (leverage * log2([1 / new/old]))\\n        //              = 2 ^ (leverage * log2([old/new]))\\n        return\\n            ABDKMathQuad.pow_2(\\n                ABDKMathQuad.mul(leverage, ABDKMathQuad.log_2(direction < 0 ? ratio : ABDKMathQuad.div(one, ratio)))\\n            );\\n    }\\n\\n    /**\\n     * @notice Calculates the amount to take from the losing pool\\n     * @param lossMultiplier The multiplier to use\\n     * @param balance The balance of the losing pool\\n     */\\n    function getLossAmount(bytes16 lossMultiplier, uint256 balance) public pure returns (uint256) {\\n        return\\n            ABDKMathQuad.toUInt(\\n                ABDKMathQuad.mul(ABDKMathQuad.sub(one, lossMultiplier), ABDKMathQuad.fromUInt(balance))\\n            );\\n    }\\n\\n    /**\\n     * @notice Calculates the effect of a price change. This involves calculating how many funds to transfer from the losing pool to the other.\\n     * @dev This function should be called by the LeveragedPool.\\n     * @param priceChange The struct containing necessary data to calculate price change\\n     */\\n    function calculatePriceChange(PriceChangeData memory priceChange)\\n        external\\n        pure\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        uint256 shortBalance = priceChange.shortBalance;\\n        uint256 longBalance = priceChange.longBalance;\\n        bytes16 leverageAmount = priceChange.leverageAmount;\\n        int256 oldPrice = priceChange.oldPrice;\\n        int256 newPrice = priceChange.newPrice;\\n        bytes16 fee = priceChange.fee;\\n\\n        // Calculate fees from long and short sides\\n        uint256 longFeeAmount = convertDecimalToUInt(multiplyDecimalByUInt(fee, longBalance)) /\\n            PoolSwapLibrary.WAD_PRECISION;\\n        uint256 shortFeeAmount = convertDecimalToUInt(multiplyDecimalByUInt(fee, shortBalance)) /\\n            PoolSwapLibrary.WAD_PRECISION;\\n\\n        shortBalance = shortBalance - shortFeeAmount;\\n        longBalance = longBalance - longFeeAmount;\\n        uint256 totalFeeAmount = shortFeeAmount + longFeeAmount;\\n\\n        // Use the ratio to determine if the price increased or decreased and therefore which direction\\n        // the funds should be transferred towards.\\n\\n        bytes16 ratio = divInt(newPrice, oldPrice);\\n        int8 direction = compareDecimals(ratio, PoolSwapLibrary.one);\\n        // Take into account the leverage\\n        bytes16 lossMultiplier = getLossMultiplier(ratio, direction, leverageAmount);\\n\\n        if (direction >= 0 && shortBalance > 0) {\\n            // Move funds from short to long pair\\n            uint256 lossAmount = getLossAmount(lossMultiplier, shortBalance);\\n            shortBalance = shortBalance - lossAmount;\\n            longBalance = longBalance + lossAmount;\\n        } else if (direction < 0 && longBalance > 0) {\\n            // Move funds from long to short pair\\n            uint256 lossAmount = getLossAmount(lossMultiplier, longBalance);\\n            shortBalance = shortBalance + lossAmount;\\n            longBalance = longBalance - lossAmount;\\n        }\\n\\n        return (longBalance, shortBalance, totalFeeAmount);\\n    }\\n\\n    /**\\n     * @notice Returns true if the given timestamp is BEFORE the frontRunningInterval starts,\\n     *         which is allowed for uncommitment.\\n     * @dev If you try to uncommit AFTER the frontRunningInterval, it should revert.\\n     * @param subjectTime The timestamp for which you want to calculate if it was beforeFrontRunningInterval\\n     * @param lastPriceTimestamp The timestamp of the last price update\\n     * @param updateInterval The interval between price updates\\n     * @param frontRunningInterval The window of time before a price udpate users can not uncommit or have their commit executed from\\n     */\\n    function isBeforeFrontRunningInterval(\\n        uint256 subjectTime,\\n        uint256 lastPriceTimestamp,\\n        uint256 updateInterval,\\n        uint256 frontRunningInterval\\n    ) external pure returns (bool) {\\n        return lastPriceTimestamp + updateInterval - frontRunningInterval > subjectTime;\\n    }\\n\\n    /**\\n     * @notice Gets the number of settlement tokens to be withdrawn based on a pool token burn amount\\n     * @dev Calculates as `balance * amountIn / (tokenSupply + shadowBalance)\\n     * @param tokenSupply Total supply of pool tokens\\n     * @param amountIn Commitment amount of collateral tokens going into the pool\\n     * @param balance Balance of the pool (no. of underlying collateral tokens in pool)\\n     * @param shadowBalance Balance the shadow pool at time of mint\\n     * @return Number of settlement tokens to be withdrawn on a burn\\n     */\\n    function getWithdrawAmountOnBurn(\\n        uint256 tokenSupply,\\n        uint256 amountIn,\\n        uint256 balance,\\n        uint256 shadowBalance\\n    ) external pure returns (uint256) {\\n        require(amountIn > 0, \\\"Invalid amount\\\");\\n\\n        // Catch the divide by zero error.\\n        if (balance == 0 || tokenSupply + shadowBalance == 0) {\\n            return amountIn;\\n        }\\n        bytes16 numerator = ABDKMathQuad.mul(ABDKMathQuad.fromUInt(balance), ABDKMathQuad.fromUInt(amountIn));\\n        return ABDKMathQuad.toUInt(ABDKMathQuad.div(numerator, ABDKMathQuad.fromUInt(tokenSupply + shadowBalance)));\\n    }\\n\\n    /**\\n     * @notice Gets the number of pool tokens to be minted based on existing tokens\\n     * @dev Calculated as (tokenSupply + shadowBalance) * amountIn / balance\\n     * @param tokenSupply Total supply of pool tokens\\n     * @param amountIn Commitment amount of collateral tokens going into the pool\\n     * @param balance Balance of the pool (no. of underlying collateral tokens in pool)\\n     * @param shadowBalance Balance the shadow pool at time of mint\\n     * @return Number of pool tokens to be minted\\n     */\\n    function getMintAmount(\\n        uint256 tokenSupply,\\n        uint256 amountIn,\\n        uint256 balance,\\n        uint256 shadowBalance\\n    ) external pure returns (uint256) {\\n        require(amountIn > 0, \\\"Invalid amount\\\");\\n\\n        // Catch the divide by zero error.\\n        if (balance == 0 || tokenSupply + shadowBalance == 0) {\\n            return amountIn;\\n        }\\n\\n        bytes16 numerator = ABDKMathQuad.mul(\\n            ABDKMathQuad.fromUInt(tokenSupply + shadowBalance),\\n            ABDKMathQuad.fromUInt(amountIn)\\n        );\\n        return ABDKMathQuad.toUInt(ABDKMathQuad.div(numerator, ABDKMathQuad.fromUInt(balance)));\\n    }\\n\\n    /**\\n     * @notice Converts from a WAD to normal value\\n     * @return Converted non-WAD value\\n     */\\n    function fromWad(uint256 _wadValue, uint256 _decimals) external pure returns (uint256) {\\n        uint256 scaler = 10**(MAX_DECIMALS - _decimals);\\n        return _wadValue / scaler;\\n    }\\n}\\n\",\"keccak256\":\"0xdb371bc69356883d7f54cdf065df2c999d71ebeab16ecd5d19276a9a7be1de85\",\"license\":\"CC-BY-NC-ND-4.0\"}},\"version\":1}",
    "bytecode": "0x612bc461003a600b82828239805160001a60731461002d57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600436106101205760003560e01c8063ab41556f116100ac578063c3ff80911161007b578063c3ff809114610265578063cff7000114610278578063dc35bc131461028b578063debb52df146102b3578063dfdbe4da146102c657600080fd5b8063ab41556f14610224578063aeb64d7d14610237578063bc1b392d1461024a578063bf36f0e91461025257600080fd5b8063664808a8116100f3578063664808a8146101a557806381a799db146101b4578063901717d1146101d7578063a481c1b4146101e3578063a818c0d21461021157600080fd5b80630417cf8e146101255780631842c9d814610140578063202f125714610166578063422051e714610192575b600080fd5b61012d601281565b6040519081526020015b60405180910390f35b61015361014e36600461283c565b6102d9565b60405160009190910b8152602001610137565b6101796101743660046128e4565b6102ee565b6040516001600160801b03199091168152602001610137565b6101796101a03660046128ba565b61030a565b61012d670de0b6b3a764000081565b6101c76101c23660046129de565b61031e565b6040519015158152602001610137565b610179613fff60f01b81565b6101f66101f1366004612906565b610342565b60408051938452602084019290925290820152606001610137565b61012d61021f3660046128ba565b6104a6565b61012d6102323660046129de565b6104cb565b61012d610245366004612821565b61056e565b610179600081565b61012d6102603660046128e4565b610579565b61017961027336600461286f565b61059e565b6101796102863660046128e4565b6105d4565b61029e6102993660046129b2565b6105f8565b60408051928352602083019190915201610137565b61012d6102c13660046129de565b610651565b6101796102d4366004612999565b6106d7565b60006102e583836106e2565b90505b92915050565b60006102e56102fc84610809565b61030584610809565b61089c565b60006102e58361031984610b53565b610bb7565b6000848261032c8587612a10565b6103369190612b35565b1190505b949350505050565b6060810151604082015160808301518351602085015160a08601516000958695869591949093919290919086670de0b6b3a7640000610384610245848961030a565b61038e9190612a28565b90506000670de0b6b3a76400006103a8610245858b61030a565b6103b29190612a28565b90506103be8189612b35565b97506103ca8288612b35565b965060006103d88383612a10565b905060006103e686886102ee565b905060006103f982613fff60f01b6102d9565b9050600061040883838c61059e565b905060008260000b1215801561041e575060008c115b1561044f57600061042f828e6104a6565b905061043b818e612b35565b9c50610447818d612a10565b9b505061048f565b60008260000b128015610462575060008b115b1561048f576000610473828d6104a6565b905061047f818e612a10565b9c5061048b818d612b35565b9b50505b50989e999d50909b50979950505050505050505050565b60006102e56104c66104bd613fff60f01b86610e12565b61031985610b53565b610e24565b60008084116105125760405162461bcd60e51b815260206004820152600e60248201526d125b9d985b1a5908185b5bdd5b9d60921b60448201526064015b60405180910390fd5b82158061052657506105248286612a10565b155b1561053257508261033a565b60006105526105496105448589612a10565b610b53565b61031987610b53565b90506105646104c68261030587610b53565b9695505050505050565b60006102e882610e24565b600080610587836012612b35565b61059290600a612a8d565b905061033a8185612a28565b600061033a6105cf8361031960008760000b126105c9576105c4613fff60f01b8961089c565b610ea8565b87610ea8565b611058565b6000816105e3575060006102e8565b6102e56105ef84610b53565b61030584610b53565b6000808061060a856102868682612a10565b9050600061061b610245838961030a565b905060006106298288612b35565b90506000610637838a612b35565b6106419088612b35565b9199919850909650505050505050565b60008084116106935760405162461bcd60e51b815260206004820152600e60248201526d125b9d985b1a5908185b5bdd5b9d60921b6044820152606401610509565b8215806106a757506106a58286612a10565b155b156106b357508261033a565b60006106c161054985610b53565b90506105646104c682610305610544878b612a10565b60006102e882610b53565b600060016001607f1b03608084901c16617fff60701b81111561070457600080fd5b60016001607f1b03608084901c16617fff60701b81111561072457600080fd5b6001600160801b031985811690851614158061074d5750617fff60701b826001600160801b0316105b61075657600080fd5b6001600160801b03198581169085161415610776576000925050506102e8565b6001607f1b608086811c82118015929187901c9190911015906107c85780156107b957826001600160801b0316846001600160801b0316116107b95760016107bd565b6000195b9450505050506102e8565b80156107db5760019450505050506102e8565b826001600160801b0316846001600160801b0316116107fc576000196107bd565b60019450505050506102e8565b60008161081857506000919050565b600080831361082a578260000361082c565b825b90506000610839826123ab565b90506070811015610852578060700382901b9150610865565b6070811115610865576070810382901c91505b6001600160701b03909116613fff820160701b1790600084121561088d576001607f1b821791505b5060801b92915050565b919050565b6000617fff60f084811c8216919084901c8116908214156108e25780617fff14156108d1575061ffff60ef1b91506102e89050565b505050600160ff1b811682186102e8565b80617fff1415610926576dffffffffffffffffffffffffffff60801b841615610915575061ffff60ef1b91506102e89050565b505050808218600160ff1b166102e8565b600160801b600160ff1b03841661097057600160801b600160ff1b038516610958575061ffff60ef1b91506102e89050565b505050808218600160ff1b16617fff60f01b176102e8565b6001600160701b03608085901c168161098c5760019150610993565b600160701b175b6001600160701b03608087901c16836109d25780156109cd5760006109b7826123ab565b6001955060e20393840160711901939190911b90505b6109dc565b600160701b1760721b5b8181816109eb576109eb612b78565b04905080610a1757600160ff1b87871816610a075760006107bd565b600160ff1b9450505050506102e8565b6001606c1b811015610a2b57610a2b612b4c565b6000600160731b821015610a6a57600160721b821015610a5f57600160711b821015610a58576070610a62565b6071610a62565b60725b60ff16610a73565b610a73826123ab565b905083614071018186011115610a9157617fff945060009150610b24565b83818601613ffc011015610aac576000945060009150610b24565b83818601613f8c011015610af9578385613ffc011115610ad7578385613ffc010382901b9150610af0565b8385613ffc011015610af057613ffc8585030382901c91505b60009450610b24565b6070811115610b0c576070810382901c91505b6001600160701b038216915083818601613f8d010394505b81607086901b888a186001607f1b60801b1660801c6001600160801b0316171760801b955050505050506102e8565b600081610b6257506000919050565b816000610b6e826123ab565b90506070811015610b87578060700382901b9150610b9a565b6070811115610b9a576070810382901c91505b613fff0160701b6001600160701b03919091161760801b92915050565b6000617fff60f084811c8216919084901c811690821415610c565780617fff1415610c35576001600160801b03198581169085161415610c0257505050600160ff1b811682186102e8565b600160ff1b6001600160801b0319868618161415610c25575050508181176102e8565b5061ffff60ef1b91506102e89050565b600160801b600160ff1b0384166108d1575061ffff60ef1b91506102e89050565b80617fff1415610c9257600160801b600160ff1b038516610c81575061ffff60ef1b91506102e89050565b505050600160ff1b821681186102e8565b6001600160701b03608086901c1682610cae5760019250610cb5565b600160701b175b6001600160701b03608086901c1682610cd15760019250610cd8565b600160701b175b9081029081610cf557600160ff1b87871816610a075760006107bd565b928201926000600160e11b831015610d2857600160e01b831015610d2157610d1c836123ab565b610d2b565b60e0610d2b565b60e15b90506140708186011015610d46576000945060009250610de3565b6140e08186011015610d8957614070851015610d6b57846140700383901c9250610d80565b614070851115610d8057614070850383901b92505b60009450610de3565b61c0dd8186011115610da357617fff945060009250610de3565b6070811115610dba576070810383901c9250610dcd565b6070811015610dcd578060700383901b92505b6001600160701b03831692506140df8186010394505b82607086901b888a186001607f1b60801b1660801c6001600160801b0316171760801b955050505050506102e8565b60006102e583600160ff1b8418612449565b6000617fff60f083901c16613fff811015610e425750600092915050565b6001607f1b608084901c10610e5657600080fd5b6140fe811115610e6557600080fd5b600160701b6001600160701b03608085901c161761406f821015610e8f5761406f8290031c610ea1565b61406f821115610ea15761406e1982011b5b9392505050565b60006001607f1b608083901c1115610ec6575061ffff60ef1b919050565b613fff60f01b6001600160801b031983161415610ee557506000919050565b617fff60f083901c811690811415610efe575090919050565b6001600160701b03608084901c1681610f1a5760019150610f21565b600160701b175b80610f3757506001600160f01b03199392505050565b600061406f81613fff8510610f5d5750600f9290921b9160009150613ffe198401610f9c565b60019250600160701b8410610f7f5784613ffe039050600f84901b9350610f9c565b6000610f8a856123ab565b607f8190039590951b9461406d039150505b836001607f1b1415610fd0578215610fb2576001015b6000610fbd826123ab565b60700392839003929190911b905061101e565b600083610fde576000610fe1565b60015b60ff1690505b600160701b82101561101c5793800260ff81901c607f81019190911c94600019939093019260019290921b9082180190610fe7565b505b806001600160701b0316607083901b8461103957600061103f565b6001607f1b5b6001600160801b0316171760801b979650505050505050565b60006001607f1b608083901c90811190617fff60f085901c8116916001600160701b0316908214801561108a57508015155b1561109e575061ffff60ef1b949350505050565b61400d8211156110c457826110b857617fff60f01b6110bb565b60005b95945050505050565b613f7f8210156110dd5750613fff60f01b949350505050565b816110eb57600191506110f2565b600160701b175b613fef82111561110857613fee1982011b61111a565b613fef82101561111a57613fef8290031c5b82801561112b575061203760811b81115b1561113b57506000949350505050565b8215801561115a5750713fffffffffffffffffffffffffffffffffff81115b1561116e5750617fff60f01b949350505050565b6001600160801b0381169060801c83801561118857508115155b15611194579019906001015b6001607f1b828116156111b85770016a09e667f3bcc908b2fb1366ea957d3e0260801c5b6001607e1b8316156111db577001306fe0a31b7152de8d5a46305c85edec0260801c5b6001607d1b8316156111fe577001172b83c7d517adcdf7c8c50eb14a791f0260801c5b6001607c1b8316156112215770010b5586cf9890f6298b92b71842a983630260801c5b6001607b1b831615611244577001059b0d31585743ae7c548eb68ca417fd0260801c5b6001607a1b83161561126757700102c9a3e778060ee6f7caca4f7a29bde80260801c5b600160791b83161561128a5770010163da9fb33356d84a66ae336dcdfa3f0260801c5b600160781b8316156112ad57700100b1afa5abcbed6129ab13ec11dc95430260801c5b600160771b8316156112d05770010058c86da1c09ea1ff19d294cf2f679b0260801c5b600160761b8316156112f3577001002c605e2e8cec506d21bfc89a23a00f0260801c5b600160751b83161561131657700100162f3904051fa128bca9c55c31e5df0260801c5b600160741b831615611339577001000b175effdc76ba38e31671ca9397250260801c5b600160731b83161561135c57700100058ba01fb9f96d6cacd4b180917c3d0260801c5b600160721b83161561137f5770010002c5cc37da9491d0985c348c68e7b30260801c5b600160711b8316156113a2577001000162e525ee054754457d59952920260260801c5b600160701b8316156113c55770010000b17255775c040618bf4a4ade83fc0260801c5b6001606f1b8316156113e8577001000058b91b5bc9ae2eed81e9b7d4cfab0260801c5b6001606e1b83161561140b57700100002c5c89d5ec6ca4d7c8acc017b7c90260801c5b6001606d1b83161561142e5770010000162e43f4f831060e02d839a9d16d0260801c5b6001606c1b83161561145157700100000b1721bcfc99d9f890ea069117630260801c5b6001606b1b8316156114745770010000058b90cf1e6d97f9ca14dbcc16280260801c5b6001606a1b831615611497577001000002c5c863b73f016468f6bac5ca2b0260801c5b600160691b8316156114ba57700100000162e430e5a18f6119e3c02282a50260801c5b600160681b8316156114dd577001000000b1721835514b86e6d96efd1bfe0260801c5b600160671b83161561150057700100000058b90c0b48c6be5df846c5b2ef0260801c5b600160661b8316156115235770010000002c5c8601cc6b9e94213c72737a0260801c5b600160651b831615611546577001000000162e42fff037df38aa2b219f060260801c5b600160641b8316156115695770010000000b17217fba9c739aa5819f44f90260801c5b600160631b83161561158c577001000000058b90bfcdee5acd3c1cedc8230260801c5b600160621b8316156115af57700100000002c5c85fe31f35a6a30da1be500260801c5b600160611b8316156115d25770010000000162e42ff0999ce3541b9fffcf0260801c5b600160601b8316156115f557700100000000b17217f80f4ef5aadda455540260801c5b6001605f1b8316156116185770010000000058b90bfbf8479bd5a81b51ad0260801c5b6001605e1b83161561163b577001000000002c5c85fdf84bd62ae30a74cc0260801c5b6001605d1b83161561165e57700100000000162e42fefb2fed257559bdaa0260801c5b6001605c1b831615611681577001000000000b17217f7d5a7716bba4a9ae0260801c5b6001605b1b8316156116a457700100000000058b90bfbe9ddbac5e109cce0260801c5b6001605a1b8316156116c75770010000000002c5c85fdf4b15de6f17eb0d0260801c5b600160591b8316156116ea577001000000000162e42fefa494f1478fde050260801c5b600160581b83161561170d5770010000000000b17217f7d20cf927c8e94c0260801c5b600160571b831615611730577001000000000058b90bfbe8f71cb4e4b33d0260801c5b600160561b83161561175357700100000000002c5c85fdf477b662b269450260801c5b600160551b8316156117765770010000000000162e42fefa3ae53369388c0260801c5b600160541b83161561179957700100000000000b17217f7d1d351a389d400260801c5b600160531b8316156117bc5770010000000000058b90bfbe8e8b2d3d4ede0260801c5b600160521b8316156117df577001000000000002c5c85fdf4741bea6e77e0260801c5b600160511b83161561180257700100000000000162e42fefa39fe95583c20260801c5b600160501b831615611825577001000000000000b17217f7d1cfb72b45e10260801c5b698000000000000000000083161561184e57700100000000000058b90bfbe8e7cc35c3f00260801c5b69400000000000000000008316156118775770010000000000002c5c85fdf473e242ea380260801c5b69200000000000000000008316156118a0577001000000000000162e42fefa39f02b772c0260801c5b69100000000000000000008316156118c95770010000000000000b17217f7d1cf7d83c1a0260801c5b69080000000000000000008316156118f2577001000000000000058b90bfbe8e7bdcbe2e0260801c5b690400000000000000000083161561191b57700100000000000002c5c85fdf473dea871f0260801c5b69020000000000000000008316156119445770010000000000000162e42fefa39ef44d910260801c5b690100000000000000000083161561196d57700100000000000000b17217f7d1cf79e9490260801c5b688000000000000000008316156119955770010000000000000058b90bfbe8e7bce5440260801c5b684000000000000000008316156119bd577001000000000000002c5c85fdf473de6eca0260801c5b682000000000000000008316156119e557700100000000000000162e42fefa39ef366f0260801c5b68100000000000000000831615611a0d577001000000000000000b17217f7d1cf79afa0260801c5b68080000000000000000831615611a3557700100000000000000058b90bfbe8e7bcd6d0260801c5b68040000000000000000831615611a5d5770010000000000000002c5c85fdf473de6b20260801c5b68020000000000000000831615611a85577001000000000000000162e42fefa39ef3580260801c5b600160401b831615611aa85770010000000000000000b17217f7d1cf79ab0260801c5b678000000000000000831615611acf577001000000000000000058b90bfbe8e7bcd50260801c5b674000000000000000831615611af657700100000000000000002c5c85fdf473de6a0260801c5b672000000000000000831615611b1d5770010000000000000000162e42fefa39ef340260801c5b671000000000000000831615611b4457700100000000000000000b17217f7d1cf7990260801c5b670800000000000000831615611b6b5770010000000000000000058b90bfbe8e7bcc0260801c5b670400000000000000831615611b92577001000000000000000002c5c85fdf473de50260801c5b670200000000000000831615611bb957700100000000000000000162e42fefa39ef20260801c5b670100000000000000831615611be0577001000000000000000000b17217f7d1cf780260801c5b6680000000000000831615611c0657700100000000000000000058b90bfbe8e7bb0260801c5b6640000000000000831615611c2c5770010000000000000000002c5c85fdf473dd0260801c5b6620000000000000831615611c52577001000000000000000000162e42fefa39ee0260801c5b6610000000000000831615611c785770010000000000000000000b17217f7d1cf60260801c5b6608000000000000831615611c9e577001000000000000000000058b90bfbe8e7a0260801c5b6604000000000000831615611cc457700100000000000000000002c5c85fdf473c0260801c5b6602000000000000831615611cea5770010000000000000000000162e42fefa39d0260801c5b6601000000000000831615611d1057700100000000000000000000b17217f7d1ce0260801c5b65800000000000831615611d355770010000000000000000000058b90bfbe8e60260801c5b65400000000000831615611d5a577001000000000000000000002c5c85fdf4720260801c5b65200000000000831615611d7f57700100000000000000000000162e42fefa380260801c5b65100000000000831615611da4577001000000000000000000000b17217f7d1b0260801c5b65080000000000831615611dc957700100000000000000000000058b90bfbe8d0260801c5b65040000000000831615611dee5770010000000000000000000002c5c85fdf460260801c5b65020000000000831615611e13577001000000000000000000000162e42fefa20260801c5b65010000000000831615611e385770010000000000000000000000b17217f7d00260801c5b648000000000831615611e5c577001000000000000000000000058b90bfbe70260801c5b644000000000831615611e8057700100000000000000000000002c5c85fdf30260801c5b642000000000831615611ea45770010000000000000000000000162e42fef90260801c5b641000000000831615611ec857700100000000000000000000000b17217f7c0260801c5b640800000000831615611eec5770010000000000000000000000058b90bfbd0260801c5b640400000000831615611f10577001000000000000000000000002c5c85fde0260801c5b640200000000831615611f3457700100000000000000000000000162e42fee0260801c5b640100000000831615611f58577001000000000000000000000000b17217f60260801c5b6380000000831615611f7b57700100000000000000000000000058b90bfa0260801c5b6340000000831615611f9e5770010000000000000000000000002c5c85fc0260801c5b6320000000831615611fc1577001000000000000000000000000162e42fd0260801c5b6310000000831615611fe45770010000000000000000000000000b17217e0260801c5b6308000000831615612007577001000000000000000000000000058b90be0260801c5b630400000083161561202a57700100000000000000000000000002c5c85e0260801c5b630200000083161561204d5770010000000000000000000000000162e42e0260801c5b630100000083161561207057700100000000000000000000000000b172160260801c5b628000008316156120925770010000000000000000000000000058b90a0260801c5b624000008316156120b4577001000000000000000000000000002c5c840260801c5b622000008316156120d657700100000000000000000000000000162e410260801c5b621000008316156120f8577001000000000000000000000000000b17200260801c5b6208000083161561211a57700100000000000000000000000000058b8f0260801c5b6204000083161561213c5770010000000000000000000000000002c5c70260801c5b6202000083161561215e577001000000000000000000000000000162e30260801c5b620100008316156121805770010000000000000000000000000000b1710260801c5b6180008316156121a1577001000000000000000000000000000058b80260801c5b6140008316156121c257700100000000000000000000000000002c5b0260801c5b6120008316156121e35770010000000000000000000000000000162d0260801c5b61100083161561220457700100000000000000000000000000000b160260801c5b6108008316156122255770010000000000000000000000000000058a0260801c5b610400831615612246577001000000000000000000000000000002c40260801c5b610200831615612267577001000000000000000000000000000001610260801c5b610100831615612288577001000000000000000000000000000000b00260801c5b60808316156122a8577001000000000000000000000000000000570260801c5b60408316156122c85770010000000000000000000000000000002b0260801c5b60208316156122e8577001000000000000000000000000000000150260801c5b60108316156123085770010000000000000000000000000000000a0260801c5b6008831615612328577001000000000000000000000000000000040260801c5b6004831615612348577001000000000000000000000000000000010260801c5b8461236957600f81901c6001600160701b03169050613fff82019150612398565b613ffe821161238e57600f81901c6001600160701b0316905081613fff039150612398565b600091613fee19011c5b60709190911b1760801b95945050505050565b60008082116123b957600080fd5b6000600160801b83106123ce57608092831c92015b600160401b83106123e157604092831c92015b64010000000083106123f557602092831c92015b62010000831061240757601092831c92015b610100831061241857600892831c92015b6010831061242857600492831c92015b6004831061243857600292831c92015b600283106102e85760010192915050565b6000617fff60f084811c8216919084901c8116908214156124975780617fff141561248d576001600160801b03198581169085161415610c255784925050506102e8565b84925050506102e8565b80617fff14156124ab5783925050506102e8565b6001607f1b608086901c90811015906001600160701b0316836124d157600193506124d8565b600160701b175b6001607f1b608087901c90811015906001600160701b0316846124fe5760019450612505565b600160701b175b82612535576001600160801b03198816600160ff1b146125255787612528565b60005b96505050505050506102e8565b80612555576001600160801b03198916600160ff1b146125255788612528565b848603841515831515141561266057607081131561257c57899750505050505050506102e8565b600081131561258e5790811c906125bd565b606f198112156125a757889750505050505050506102e8565b60008112156125bd578060000384901c93508596505b92810192600160711b84106125d8576001968701969390931c925b86617fff141561260a57846125f257617fff60f01b6125fc565b6001600160f01b03195b9750505050505050506102e8565b600160701b84101561261f576000965061262c565b6001600160701b03841693505b83607088901b8661263e576000612644565b6001607f1b5b6001600160801b0316171760801b9750505050505050506102e8565b600081131561267b57600184901b9350600187039650612692565b600081121561269257600182901b91506001860396505b60708113156126a457600191506126f1565b60018113156126c1576001810360018303901c60010191506126f1565b606f198112156126d457600193506126f1565b6000198112156126f1576001816000030360018503901c60010193505b81841061270257818403935061270b565b83820393508294505b836127215750600096506102e895505050505050565b600061272c856123ab565b9050806071141561275257600185901c6001600160701b031694506001880197506127a1565b607081101561279457607081900380891115612781578086901b6001600160701b03169550808903985061278e565b600098600019019590951b945b506127a1565b6001600160701b03851694505b87617fff14156127d457856127bb57617fff60f01b6127c5565b6001600160f01b03195b985050505050505050506102e8565b84607089901b876127e65760006127ec565b6001607f1b5b6001600160801b0316171760801b985050505050505050506102e8565b80356001600160801b03198116811461089757600080fd5b60006020828403121561283357600080fd5b6102e582612809565b6000806040838503121561284f57600080fd5b61285883612809565b915061286660208401612809565b90509250929050565b60008060006060848603121561288457600080fd5b61288d84612809565b925060208401358060000b81146128a357600080fd5b91506128b160408501612809565b90509250925092565b600080604083850312156128cd57600080fd5b6128d683612809565b946020939093013593505050565b600080604083850312156128f757600080fd5b50508035926020909101359150565b600060c0828403121561291857600080fd5b60405160c0810181811067ffffffffffffffff8211171561294957634e487b7160e01b600052604160045260246000fd5b80604052508235815260208301356020820152604083013560408201526060830135606082015261297c60808401612809565b608082015261298d60a08401612809565b60a08201529392505050565b6000602082840312156129ab57600080fd5b5035919050565b6000806000606084860312156129c757600080fd5b505081359360208301359350604090920135919050565b600080600080608085870312156129f457600080fd5b5050823594602084013594506040840135936060013592509050565b60008219821115612a2357612a23612b62565b500190565b600082612a4557634e487b7160e01b600052601260045260246000fd5b500490565b600181815b80851115612a85578160001904821115612a6b57612a6b612b62565b80851615612a7857918102915b93841c9390800290612a4f565b509250929050565b60006102e58383600082612aa3575060016102e8565b81612ab0575060006102e8565b8160018114612ac65760028114612ad057612aec565b60019150506102e8565b60ff841115612ae157612ae1612b62565b50506001821b6102e8565b5060208310610133831016604e8410600b8410161715612b0f575081810a6102e8565b612b198383612a4a565b8060001904821115612b2d57612b2d612b62565b029392505050565b600082821015612b4757612b47612b62565b500390565b634e487b7160e01b600052600160045260246000fd5b634e487b7160e01b600052601160045260246000fd5b634e487b7160e01b600052601260045260246000fdfea2646970667358221220845f01656cb9dc2a918a5fe83c181fe04f67dcb6c12ef43fcdf3158624a365aa64736f6c63430008070033",
    "deployedBytecode": "0x73000000000000000000000000000000000000000030146080604052600436106101205760003560e01c8063ab41556f116100ac578063c3ff80911161007b578063c3ff809114610265578063cff7000114610278578063dc35bc131461028b578063debb52df146102b3578063dfdbe4da146102c657600080fd5b8063ab41556f14610224578063aeb64d7d14610237578063bc1b392d1461024a578063bf36f0e91461025257600080fd5b8063664808a8116100f3578063664808a8146101a557806381a799db146101b4578063901717d1146101d7578063a481c1b4146101e3578063a818c0d21461021157600080fd5b80630417cf8e146101255780631842c9d814610140578063202f125714610166578063422051e714610192575b600080fd5b61012d601281565b6040519081526020015b60405180910390f35b61015361014e36600461283c565b6102d9565b60405160009190910b8152602001610137565b6101796101743660046128e4565b6102ee565b6040516001600160801b03199091168152602001610137565b6101796101a03660046128ba565b61030a565b61012d670de0b6b3a764000081565b6101c76101c23660046129de565b61031e565b6040519015158152602001610137565b610179613fff60f01b81565b6101f66101f1366004612906565b610342565b60408051938452602084019290925290820152606001610137565b61012d61021f3660046128ba565b6104a6565b61012d6102323660046129de565b6104cb565b61012d610245366004612821565b61056e565b610179600081565b61012d6102603660046128e4565b610579565b61017961027336600461286f565b61059e565b6101796102863660046128e4565b6105d4565b61029e6102993660046129b2565b6105f8565b60408051928352602083019190915201610137565b61012d6102c13660046129de565b610651565b6101796102d4366004612999565b6106d7565b60006102e583836106e2565b90505b92915050565b60006102e56102fc84610809565b61030584610809565b61089c565b60006102e58361031984610b53565b610bb7565b6000848261032c8587612a10565b6103369190612b35565b1190505b949350505050565b6060810151604082015160808301518351602085015160a08601516000958695869591949093919290919086670de0b6b3a7640000610384610245848961030a565b61038e9190612a28565b90506000670de0b6b3a76400006103a8610245858b61030a565b6103b29190612a28565b90506103be8189612b35565b97506103ca8288612b35565b965060006103d88383612a10565b905060006103e686886102ee565b905060006103f982613fff60f01b6102d9565b9050600061040883838c61059e565b905060008260000b1215801561041e575060008c115b1561044f57600061042f828e6104a6565b905061043b818e612b35565b9c50610447818d612a10565b9b505061048f565b60008260000b128015610462575060008b115b1561048f576000610473828d6104a6565b905061047f818e612a10565b9c5061048b818d612b35565b9b50505b50989e999d50909b50979950505050505050505050565b60006102e56104c66104bd613fff60f01b86610e12565b61031985610b53565b610e24565b60008084116105125760405162461bcd60e51b815260206004820152600e60248201526d125b9d985b1a5908185b5bdd5b9d60921b60448201526064015b60405180910390fd5b82158061052657506105248286612a10565b155b1561053257508261033a565b60006105526105496105448589612a10565b610b53565b61031987610b53565b90506105646104c68261030587610b53565b9695505050505050565b60006102e882610e24565b600080610587836012612b35565b61059290600a612a8d565b905061033a8185612a28565b600061033a6105cf8361031960008760000b126105c9576105c4613fff60f01b8961089c565b610ea8565b87610ea8565b611058565b6000816105e3575060006102e8565b6102e56105ef84610b53565b61030584610b53565b6000808061060a856102868682612a10565b9050600061061b610245838961030a565b905060006106298288612b35565b90506000610637838a612b35565b6106419088612b35565b9199919850909650505050505050565b60008084116106935760405162461bcd60e51b815260206004820152600e60248201526d125b9d985b1a5908185b5bdd5b9d60921b6044820152606401610509565b8215806106a757506106a58286612a10565b155b156106b357508261033a565b60006106c161054985610b53565b90506105646104c682610305610544878b612a10565b60006102e882610b53565b600060016001607f1b03608084901c16617fff60701b81111561070457600080fd5b60016001607f1b03608084901c16617fff60701b81111561072457600080fd5b6001600160801b031985811690851614158061074d5750617fff60701b826001600160801b0316105b61075657600080fd5b6001600160801b03198581169085161415610776576000925050506102e8565b6001607f1b608086811c82118015929187901c9190911015906107c85780156107b957826001600160801b0316846001600160801b0316116107b95760016107bd565b6000195b9450505050506102e8565b80156107db5760019450505050506102e8565b826001600160801b0316846001600160801b0316116107fc576000196107bd565b60019450505050506102e8565b60008161081857506000919050565b600080831361082a578260000361082c565b825b90506000610839826123ab565b90506070811015610852578060700382901b9150610865565b6070811115610865576070810382901c91505b6001600160701b03909116613fff820160701b1790600084121561088d576001607f1b821791505b5060801b92915050565b919050565b6000617fff60f084811c8216919084901c8116908214156108e25780617fff14156108d1575061ffff60ef1b91506102e89050565b505050600160ff1b811682186102e8565b80617fff1415610926576dffffffffffffffffffffffffffff60801b841615610915575061ffff60ef1b91506102e89050565b505050808218600160ff1b166102e8565b600160801b600160ff1b03841661097057600160801b600160ff1b038516610958575061ffff60ef1b91506102e89050565b505050808218600160ff1b16617fff60f01b176102e8565b6001600160701b03608085901c168161098c5760019150610993565b600160701b175b6001600160701b03608087901c16836109d25780156109cd5760006109b7826123ab565b6001955060e20393840160711901939190911b90505b6109dc565b600160701b1760721b5b8181816109eb576109eb612b78565b04905080610a1757600160ff1b87871816610a075760006107bd565b600160ff1b9450505050506102e8565b6001606c1b811015610a2b57610a2b612b4c565b6000600160731b821015610a6a57600160721b821015610a5f57600160711b821015610a58576070610a62565b6071610a62565b60725b60ff16610a73565b610a73826123ab565b905083614071018186011115610a9157617fff945060009150610b24565b83818601613ffc011015610aac576000945060009150610b24565b83818601613f8c011015610af9578385613ffc011115610ad7578385613ffc010382901b9150610af0565b8385613ffc011015610af057613ffc8585030382901c91505b60009450610b24565b6070811115610b0c576070810382901c91505b6001600160701b038216915083818601613f8d010394505b81607086901b888a186001607f1b60801b1660801c6001600160801b0316171760801b955050505050506102e8565b600081610b6257506000919050565b816000610b6e826123ab565b90506070811015610b87578060700382901b9150610b9a565b6070811115610b9a576070810382901c91505b613fff0160701b6001600160701b03919091161760801b92915050565b6000617fff60f084811c8216919084901c811690821415610c565780617fff1415610c35576001600160801b03198581169085161415610c0257505050600160ff1b811682186102e8565b600160ff1b6001600160801b0319868618161415610c25575050508181176102e8565b5061ffff60ef1b91506102e89050565b600160801b600160ff1b0384166108d1575061ffff60ef1b91506102e89050565b80617fff1415610c9257600160801b600160ff1b038516610c81575061ffff60ef1b91506102e89050565b505050600160ff1b821681186102e8565b6001600160701b03608086901c1682610cae5760019250610cb5565b600160701b175b6001600160701b03608086901c1682610cd15760019250610cd8565b600160701b175b9081029081610cf557600160ff1b87871816610a075760006107bd565b928201926000600160e11b831015610d2857600160e01b831015610d2157610d1c836123ab565b610d2b565b60e0610d2b565b60e15b90506140708186011015610d46576000945060009250610de3565b6140e08186011015610d8957614070851015610d6b57846140700383901c9250610d80565b614070851115610d8057614070850383901b92505b60009450610de3565b61c0dd8186011115610da357617fff945060009250610de3565b6070811115610dba576070810383901c9250610dcd565b6070811015610dcd578060700383901b92505b6001600160701b03831692506140df8186010394505b82607086901b888a186001607f1b60801b1660801c6001600160801b0316171760801b955050505050506102e8565b60006102e583600160ff1b8418612449565b6000617fff60f083901c16613fff811015610e425750600092915050565b6001607f1b608084901c10610e5657600080fd5b6140fe811115610e6557600080fd5b600160701b6001600160701b03608085901c161761406f821015610e8f5761406f8290031c610ea1565b61406f821115610ea15761406e1982011b5b9392505050565b60006001607f1b608083901c1115610ec6575061ffff60ef1b919050565b613fff60f01b6001600160801b031983161415610ee557506000919050565b617fff60f083901c811690811415610efe575090919050565b6001600160701b03608084901c1681610f1a5760019150610f21565b600160701b175b80610f3757506001600160f01b03199392505050565b600061406f81613fff8510610f5d5750600f9290921b9160009150613ffe198401610f9c565b60019250600160701b8410610f7f5784613ffe039050600f84901b9350610f9c565b6000610f8a856123ab565b607f8190039590951b9461406d039150505b836001607f1b1415610fd0578215610fb2576001015b6000610fbd826123ab565b60700392839003929190911b905061101e565b600083610fde576000610fe1565b60015b60ff1690505b600160701b82101561101c5793800260ff81901c607f81019190911c94600019939093019260019290921b9082180190610fe7565b505b806001600160701b0316607083901b8461103957600061103f565b6001607f1b5b6001600160801b0316171760801b979650505050505050565b60006001607f1b608083901c90811190617fff60f085901c8116916001600160701b0316908214801561108a57508015155b1561109e575061ffff60ef1b949350505050565b61400d8211156110c457826110b857617fff60f01b6110bb565b60005b95945050505050565b613f7f8210156110dd5750613fff60f01b949350505050565b816110eb57600191506110f2565b600160701b175b613fef82111561110857613fee1982011b61111a565b613fef82101561111a57613fef8290031c5b82801561112b575061203760811b81115b1561113b57506000949350505050565b8215801561115a5750713fffffffffffffffffffffffffffffffffff81115b1561116e5750617fff60f01b949350505050565b6001600160801b0381169060801c83801561118857508115155b15611194579019906001015b6001607f1b828116156111b85770016a09e667f3bcc908b2fb1366ea957d3e0260801c5b6001607e1b8316156111db577001306fe0a31b7152de8d5a46305c85edec0260801c5b6001607d1b8316156111fe577001172b83c7d517adcdf7c8c50eb14a791f0260801c5b6001607c1b8316156112215770010b5586cf9890f6298b92b71842a983630260801c5b6001607b1b831615611244577001059b0d31585743ae7c548eb68ca417fd0260801c5b6001607a1b83161561126757700102c9a3e778060ee6f7caca4f7a29bde80260801c5b600160791b83161561128a5770010163da9fb33356d84a66ae336dcdfa3f0260801c5b600160781b8316156112ad57700100b1afa5abcbed6129ab13ec11dc95430260801c5b600160771b8316156112d05770010058c86da1c09ea1ff19d294cf2f679b0260801c5b600160761b8316156112f3577001002c605e2e8cec506d21bfc89a23a00f0260801c5b600160751b83161561131657700100162f3904051fa128bca9c55c31e5df0260801c5b600160741b831615611339577001000b175effdc76ba38e31671ca9397250260801c5b600160731b83161561135c57700100058ba01fb9f96d6cacd4b180917c3d0260801c5b600160721b83161561137f5770010002c5cc37da9491d0985c348c68e7b30260801c5b600160711b8316156113a2577001000162e525ee054754457d59952920260260801c5b600160701b8316156113c55770010000b17255775c040618bf4a4ade83fc0260801c5b6001606f1b8316156113e8577001000058b91b5bc9ae2eed81e9b7d4cfab0260801c5b6001606e1b83161561140b57700100002c5c89d5ec6ca4d7c8acc017b7c90260801c5b6001606d1b83161561142e5770010000162e43f4f831060e02d839a9d16d0260801c5b6001606c1b83161561145157700100000b1721bcfc99d9f890ea069117630260801c5b6001606b1b8316156114745770010000058b90cf1e6d97f9ca14dbcc16280260801c5b6001606a1b831615611497577001000002c5c863b73f016468f6bac5ca2b0260801c5b600160691b8316156114ba57700100000162e430e5a18f6119e3c02282a50260801c5b600160681b8316156114dd577001000000b1721835514b86e6d96efd1bfe0260801c5b600160671b83161561150057700100000058b90c0b48c6be5df846c5b2ef0260801c5b600160661b8316156115235770010000002c5c8601cc6b9e94213c72737a0260801c5b600160651b831615611546577001000000162e42fff037df38aa2b219f060260801c5b600160641b8316156115695770010000000b17217fba9c739aa5819f44f90260801c5b600160631b83161561158c577001000000058b90bfcdee5acd3c1cedc8230260801c5b600160621b8316156115af57700100000002c5c85fe31f35a6a30da1be500260801c5b600160611b8316156115d25770010000000162e42ff0999ce3541b9fffcf0260801c5b600160601b8316156115f557700100000000b17217f80f4ef5aadda455540260801c5b6001605f1b8316156116185770010000000058b90bfbf8479bd5a81b51ad0260801c5b6001605e1b83161561163b577001000000002c5c85fdf84bd62ae30a74cc0260801c5b6001605d1b83161561165e57700100000000162e42fefb2fed257559bdaa0260801c5b6001605c1b831615611681577001000000000b17217f7d5a7716bba4a9ae0260801c5b6001605b1b8316156116a457700100000000058b90bfbe9ddbac5e109cce0260801c5b6001605a1b8316156116c75770010000000002c5c85fdf4b15de6f17eb0d0260801c5b600160591b8316156116ea577001000000000162e42fefa494f1478fde050260801c5b600160581b83161561170d5770010000000000b17217f7d20cf927c8e94c0260801c5b600160571b831615611730577001000000000058b90bfbe8f71cb4e4b33d0260801c5b600160561b83161561175357700100000000002c5c85fdf477b662b269450260801c5b600160551b8316156117765770010000000000162e42fefa3ae53369388c0260801c5b600160541b83161561179957700100000000000b17217f7d1d351a389d400260801c5b600160531b8316156117bc5770010000000000058b90bfbe8e8b2d3d4ede0260801c5b600160521b8316156117df577001000000000002c5c85fdf4741bea6e77e0260801c5b600160511b83161561180257700100000000000162e42fefa39fe95583c20260801c5b600160501b831615611825577001000000000000b17217f7d1cfb72b45e10260801c5b698000000000000000000083161561184e57700100000000000058b90bfbe8e7cc35c3f00260801c5b69400000000000000000008316156118775770010000000000002c5c85fdf473e242ea380260801c5b69200000000000000000008316156118a0577001000000000000162e42fefa39f02b772c0260801c5b69100000000000000000008316156118c95770010000000000000b17217f7d1cf7d83c1a0260801c5b69080000000000000000008316156118f2577001000000000000058b90bfbe8e7bdcbe2e0260801c5b690400000000000000000083161561191b57700100000000000002c5c85fdf473dea871f0260801c5b69020000000000000000008316156119445770010000000000000162e42fefa39ef44d910260801c5b690100000000000000000083161561196d57700100000000000000b17217f7d1cf79e9490260801c5b688000000000000000008316156119955770010000000000000058b90bfbe8e7bce5440260801c5b684000000000000000008316156119bd577001000000000000002c5c85fdf473de6eca0260801c5b682000000000000000008316156119e557700100000000000000162e42fefa39ef366f0260801c5b68100000000000000000831615611a0d577001000000000000000b17217f7d1cf79afa0260801c5b68080000000000000000831615611a3557700100000000000000058b90bfbe8e7bcd6d0260801c5b68040000000000000000831615611a5d5770010000000000000002c5c85fdf473de6b20260801c5b68020000000000000000831615611a85577001000000000000000162e42fefa39ef3580260801c5b600160401b831615611aa85770010000000000000000b17217f7d1cf79ab0260801c5b678000000000000000831615611acf577001000000000000000058b90bfbe8e7bcd50260801c5b674000000000000000831615611af657700100000000000000002c5c85fdf473de6a0260801c5b672000000000000000831615611b1d5770010000000000000000162e42fefa39ef340260801c5b671000000000000000831615611b4457700100000000000000000b17217f7d1cf7990260801c5b670800000000000000831615611b6b5770010000000000000000058b90bfbe8e7bcc0260801c5b670400000000000000831615611b92577001000000000000000002c5c85fdf473de50260801c5b670200000000000000831615611bb957700100000000000000000162e42fefa39ef20260801c5b670100000000000000831615611be0577001000000000000000000b17217f7d1cf780260801c5b6680000000000000831615611c0657700100000000000000000058b90bfbe8e7bb0260801c5b6640000000000000831615611c2c5770010000000000000000002c5c85fdf473dd0260801c5b6620000000000000831615611c52577001000000000000000000162e42fefa39ee0260801c5b6610000000000000831615611c785770010000000000000000000b17217f7d1cf60260801c5b6608000000000000831615611c9e577001000000000000000000058b90bfbe8e7a0260801c5b6604000000000000831615611cc457700100000000000000000002c5c85fdf473c0260801c5b6602000000000000831615611cea5770010000000000000000000162e42fefa39d0260801c5b6601000000000000831615611d1057700100000000000000000000b17217f7d1ce0260801c5b65800000000000831615611d355770010000000000000000000058b90bfbe8e60260801c5b65400000000000831615611d5a577001000000000000000000002c5c85fdf4720260801c5b65200000000000831615611d7f57700100000000000000000000162e42fefa380260801c5b65100000000000831615611da4577001000000000000000000000b17217f7d1b0260801c5b65080000000000831615611dc957700100000000000000000000058b90bfbe8d0260801c5b65040000000000831615611dee5770010000000000000000000002c5c85fdf460260801c5b65020000000000831615611e13577001000000000000000000000162e42fefa20260801c5b65010000000000831615611e385770010000000000000000000000b17217f7d00260801c5b648000000000831615611e5c577001000000000000000000000058b90bfbe70260801c5b644000000000831615611e8057700100000000000000000000002c5c85fdf30260801c5b642000000000831615611ea45770010000000000000000000000162e42fef90260801c5b641000000000831615611ec857700100000000000000000000000b17217f7c0260801c5b640800000000831615611eec5770010000000000000000000000058b90bfbd0260801c5b640400000000831615611f10577001000000000000000000000002c5c85fde0260801c5b640200000000831615611f3457700100000000000000000000000162e42fee0260801c5b640100000000831615611f58577001000000000000000000000000b17217f60260801c5b6380000000831615611f7b57700100000000000000000000000058b90bfa0260801c5b6340000000831615611f9e5770010000000000000000000000002c5c85fc0260801c5b6320000000831615611fc1577001000000000000000000000000162e42fd0260801c5b6310000000831615611fe45770010000000000000000000000000b17217e0260801c5b6308000000831615612007577001000000000000000000000000058b90be0260801c5b630400000083161561202a57700100000000000000000000000002c5c85e0260801c5b630200000083161561204d5770010000000000000000000000000162e42e0260801c5b630100000083161561207057700100000000000000000000000000b172160260801c5b628000008316156120925770010000000000000000000000000058b90a0260801c5b624000008316156120b4577001000000000000000000000000002c5c840260801c5b622000008316156120d657700100000000000000000000000000162e410260801c5b621000008316156120f8577001000000000000000000000000000b17200260801c5b6208000083161561211a57700100000000000000000000000000058b8f0260801c5b6204000083161561213c5770010000000000000000000000000002c5c70260801c5b6202000083161561215e577001000000000000000000000000000162e30260801c5b620100008316156121805770010000000000000000000000000000b1710260801c5b6180008316156121a1577001000000000000000000000000000058b80260801c5b6140008316156121c257700100000000000000000000000000002c5b0260801c5b6120008316156121e35770010000000000000000000000000000162d0260801c5b61100083161561220457700100000000000000000000000000000b160260801c5b6108008316156122255770010000000000000000000000000000058a0260801c5b610400831615612246577001000000000000000000000000000002c40260801c5b610200831615612267577001000000000000000000000000000001610260801c5b610100831615612288577001000000000000000000000000000000b00260801c5b60808316156122a8577001000000000000000000000000000000570260801c5b60408316156122c85770010000000000000000000000000000002b0260801c5b60208316156122e8577001000000000000000000000000000000150260801c5b60108316156123085770010000000000000000000000000000000a0260801c5b6008831615612328577001000000000000000000000000000000040260801c5b6004831615612348577001000000000000000000000000000000010260801c5b8461236957600f81901c6001600160701b03169050613fff82019150612398565b613ffe821161238e57600f81901c6001600160701b0316905081613fff039150612398565b600091613fee19011c5b60709190911b1760801b95945050505050565b60008082116123b957600080fd5b6000600160801b83106123ce57608092831c92015b600160401b83106123e157604092831c92015b64010000000083106123f557602092831c92015b62010000831061240757601092831c92015b610100831061241857600892831c92015b6010831061242857600492831c92015b6004831061243857600292831c92015b600283106102e85760010192915050565b6000617fff60f084811c8216919084901c8116908214156124975780617fff141561248d576001600160801b03198581169085161415610c255784925050506102e8565b84925050506102e8565b80617fff14156124ab5783925050506102e8565b6001607f1b608086901c90811015906001600160701b0316836124d157600193506124d8565b600160701b175b6001607f1b608087901c90811015906001600160701b0316846124fe5760019450612505565b600160701b175b82612535576001600160801b03198816600160ff1b146125255787612528565b60005b96505050505050506102e8565b80612555576001600160801b03198916600160ff1b146125255788612528565b848603841515831515141561266057607081131561257c57899750505050505050506102e8565b600081131561258e5790811c906125bd565b606f198112156125a757889750505050505050506102e8565b60008112156125bd578060000384901c93508596505b92810192600160711b84106125d8576001968701969390931c925b86617fff141561260a57846125f257617fff60f01b6125fc565b6001600160f01b03195b9750505050505050506102e8565b600160701b84101561261f576000965061262c565b6001600160701b03841693505b83607088901b8661263e576000612644565b6001607f1b5b6001600160801b0316171760801b9750505050505050506102e8565b600081131561267b57600184901b9350600187039650612692565b600081121561269257600182901b91506001860396505b60708113156126a457600191506126f1565b60018113156126c1576001810360018303901c60010191506126f1565b606f198112156126d457600193506126f1565b6000198112156126f1576001816000030360018503901c60010193505b81841061270257818403935061270b565b83820393508294505b836127215750600096506102e895505050505050565b600061272c856123ab565b9050806071141561275257600185901c6001600160701b031694506001880197506127a1565b607081101561279457607081900380891115612781578086901b6001600160701b03169550808903985061278e565b600098600019019590951b945b506127a1565b6001600160701b03851694505b87617fff14156127d457856127bb57617fff60f01b6127c5565b6001600160f01b03195b985050505050505050506102e8565b84607089901b876127e65760006127ec565b6001607f1b5b6001600160801b0316171760801b985050505050505050506102e8565b80356001600160801b03198116811461089757600080fd5b60006020828403121561283357600080fd5b6102e582612809565b6000806040838503121561284f57600080fd5b61285883612809565b915061286660208401612809565b90509250929050565b60008060006060848603121561288457600080fd5b61288d84612809565b925060208401358060000b81146128a357600080fd5b91506128b160408501612809565b90509250925092565b600080604083850312156128cd57600080fd5b6128d683612809565b946020939093013593505050565b600080604083850312156128f757600080fd5b50508035926020909101359150565b600060c0828403121561291857600080fd5b60405160c0810181811067ffffffffffffffff8211171561294957634e487b7160e01b600052604160045260246000fd5b80604052508235815260208301356020820152604083013560408201526060830135606082015261297c60808401612809565b608082015261298d60a08401612809565b60a08201529392505050565b6000602082840312156129ab57600080fd5b5035919050565b6000806000606084860312156129c757600080fd5b505081359360208301359350604090920135919050565b600080600080608085870312156129f457600080fd5b5050823594602084013594506040840135936060013592509050565b60008219821115612a2357612a23612b62565b500190565b600082612a4557634e487b7160e01b600052601260045260246000fd5b500490565b600181815b80851115612a85578160001904821115612a6b57612a6b612b62565b80851615612a7857918102915b93841c9390800290612a4f565b509250929050565b60006102e58383600082612aa3575060016102e8565b81612ab0575060006102e8565b8160018114612ac65760028114612ad057612aec565b60019150506102e8565b60ff841115612ae157612ae1612b62565b50506001821b6102e8565b5060208310610133831016604e8410600b8410161715612b0f575081810a6102e8565b612b198383612a4a565b8060001904821115612b2d57612b2d612b62565b029392505050565b600082821015612b4757612b47612b62565b500390565b634e487b7160e01b600052600160045260246000fd5b634e487b7160e01b600052601160045260246000fd5b634e487b7160e01b600052601260045260246000fdfea2646970667358221220845f01656cb9dc2a918a5fe83c181fe04f67dcb6c12ef43fcdf3158624a365aa64736f6c63430008070033",
    "devdoc": {
        "kind": "dev",
        "methods": {
            "calculatePriceChange(PoolSwapLibrary.PriceChangeData)": {
                "details": "This function should be called by the LeveragedPool.",
                "params": {
                    "priceChange": "The struct containing necessary data to calculate price change"
                }
            },
            "compareDecimals(bytes16,bytes16)": {
                "params": {
                    "x": "The first number to compare",
                    "y": "The second number to compare"
                },
                "returns": {
                    "_0": "-1 if x < y, 0 if x = y, or 1 if x > y"
                }
            },
            "convertDecimalToUInt(bytes16)": {
                "params": {
                    "ratio": "The value to convert"
                },
                "returns": {
                    "_0": "The converted value"
                }
            },
            "convertUIntToDecimal(uint256)": {
                "params": {
                    "amount": "The amount to convert"
                },
                "returns": {
                    "_0": "The amount as a IEEE754 quadruple precision number"
                }
            },
            "divInt(int256,int256)": {
                "params": {
                    "a": "The dividend",
                    "b": "The divisor"
                },
                "returns": {
                    "_0": "The quotient"
                }
            },
            "fromWad(uint256,uint256)": {
                "returns": {
                    "_0": "Converted non-WAD value"
                }
            },
            "getBalancesAfterFees(uint256,uint256,uint256)": {
                "details": "Assumes shortBalance + longBalance >= reward",
                "params": {
                    "longBalance": "Long balance of the pool",
                    "reward": "Amount of keeper reward",
                    "shortBalance": "Short balance of the pool"
                },
                "returns": {
                    "_0": "shortBalanceAfterFees Short balance of the pool after the keeper reward has been paid",
                    "_1": "longBalanceAfterFees Long balance of the pool after the keeper reward has been paid"
                }
            },
            "getLossAmount(bytes16,uint256)": {
                "params": {
                    "balance": "The balance of the losing pool",
                    "lossMultiplier": "The multiplier to use"
                }
            },
            "getLossMultiplier(bytes16,int8,bytes16)": {
                "params": {
                    "direction": "The direction of the change. -1 if it's decreased, 0 if it hasn't changed, and 1 if it's increased",
                    "leverage": "The amount of leverage to apply",
                    "ratio": "The ratio of new price to old price"
                },
                "returns": {
                    "_0": "The multiplier"
                }
            },
            "getMintAmount(uint256,uint256,uint256,uint256)": {
                "details": "Calculated as (tokenSupply + shadowBalance) * amountIn / balance",
                "params": {
                    "amountIn": "Commitment amount of collateral tokens going into the pool",
                    "balance": "Balance of the pool (no. of underlying collateral tokens in pool)",
                    "shadowBalance": "Balance the shadow pool at time of mint",
                    "tokenSupply": "Total supply of pool tokens"
                },
                "returns": {
                    "_0": "Number of pool tokens to be minted"
                }
            },
            "getRatio(uint256,uint256)": {
                "details": "Rounds any overflow towards 0. If either parameter is zero, the ratio is 0",
                "params": {
                    "_denominator": "The \"per part\" side of the equation. If this is zero, the ratio is zero",
                    "_numerator": "The \"parts per\" side of the equation. If this is zero, the ratio is zero"
                },
                "returns": {
                    "_0": "the ratio, as an ABDKMathQuad number (IEEE 754 quadruple precision floating point)"
                }
            },
            "getWithdrawAmountOnBurn(uint256,uint256,uint256,uint256)": {
                "details": "Calculates as `balance * amountIn / (tokenSupply + shadowBalance)",
                "params": {
                    "amountIn": "Commitment amount of collateral tokens going into the pool",
                    "balance": "Balance of the pool (no. of underlying collateral tokens in pool)",
                    "shadowBalance": "Balance the shadow pool at time of mint",
                    "tokenSupply": "Total supply of pool tokens"
                },
                "returns": {
                    "_0": "Number of settlement tokens to be withdrawn on a burn"
                }
            },
            "isBeforeFrontRunningInterval(uint256,uint256,uint256,uint256)": {
                "details": "If you try to uncommit AFTER the frontRunningInterval, it should revert.",
                "params": {
                    "frontRunningInterval": "The window of time before a price udpate users can not uncommit or have their commit executed from",
                    "lastPriceTimestamp": "The timestamp of the last price update",
                    "subjectTime": "The timestamp for which you want to calculate if it was beforeFrontRunningInterval",
                    "updateInterval": "The interval between price updates"
                }
            },
            "multiplyDecimalByUInt(bytes16,uint256)": {
                "params": {
                    "a": "The first term",
                    "b": "The second term"
                },
                "returns": {
                    "_0": "The product of a*b as a decimal"
                }
            }
        },
        "title": "Library for various useful (mostly) mathematical functions",
        "version": 1
    },
    "userdoc": {
        "kind": "user",
        "methods": {
            "calculatePriceChange(PoolSwapLibrary.PriceChangeData)": {
                "notice": "Calculates the effect of a price change. This involves calculating how many funds to transfer from the losing pool to the other."
            },
            "compareDecimals(bytes16,bytes16)": {
                "notice": "Compares two decimal numbers"
            },
            "convertDecimalToUInt(bytes16)": {
                "notice": "Converts a raw decimal value to a more readable uint256 value"
            },
            "convertUIntToDecimal(uint256)": {
                "notice": "Converts an integer value to a compatible decimal value"
            },
            "divInt(int256,int256)": {
                "notice": "Divides two integers"
            },
            "fromWad(uint256,uint256)": {
                "notice": "Converts from a WAD to normal value"
            },
            "getBalancesAfterFees(uint256,uint256,uint256)": {
                "notice": "Gets the short and long balances after the keeper rewards have been paid out         Keeper rewards are paid proportionally to the short and long pool"
            },
            "getLossAmount(bytes16,uint256)": {
                "notice": "Calculates the amount to take from the losing pool"
            },
            "getLossMultiplier(bytes16,int8,bytes16)": {
                "notice": "Calculates the loss multiplier to apply to the losing pool. Includes the power leverage"
            },
            "getMintAmount(uint256,uint256,uint256,uint256)": {
                "notice": "Gets the number of pool tokens to be minted based on existing tokens"
            },
            "getRatio(uint256,uint256)": {
                "notice": "Calculates the ratio between two numbers"
            },
            "getWithdrawAmountOnBurn(uint256,uint256,uint256,uint256)": {
                "notice": "Gets the number of settlement tokens to be withdrawn based on a pool token burn amount"
            },
            "isBeforeFrontRunningInterval(uint256,uint256,uint256,uint256)": {
                "notice": "Returns true if the given timestamp is BEFORE the frontRunningInterval starts,         which is allowed for uncommitment."
            },
            "multiplyDecimalByUInt(bytes16,uint256)": {
                "notice": "Multiplies a decimal and an unsigned integer"
            }
        },
        "version": 1
    },
    "storageLayout": {
        "storage": [],
        "types": null
    }
}
