{
  "address": "0x33582761879e0eDAcC25D156585c6Ccc0d20f85A",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_keeper",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "pool",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "string",
          "name": "reason",
          "type": "string"
        }
      ],
      "name": "PoolUpkeepError",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "BASE_TIP",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "BLOCK_TIME",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "FIXED_GAS_OVERHEAD",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "FIXED_POINT",
      "outputs": [
        {
          "internalType": "bytes16",
          "name": "",
          "type": "bytes16"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "MAX_TIP",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "TIP_DELTA_PER_BLOCK",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "keeper",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_gasPrice",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_gasSpent",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_settlementTokenPrice",
          "type": "uint256"
        }
      ],
      "name": "keeperGas",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_pool",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_gasPrice",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_gasSpent",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_savedPreviousUpdatedTimestamp",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_poolInterval",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_settlementTokenPrice",
          "type": "uint256"
        }
      ],
      "name": "keeperReward",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_savedPreviousUpdatedTimestamp",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_poolInterval",
          "type": "uint256"
        }
      ],
      "name": "keeperTip",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_keeper",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_pool",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_gasPrice",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_gasSpent",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_savedPreviousUpdatedTimestamp",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_updateInterval",
          "type": "uint256"
        }
      ],
      "name": "payKeeper",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x2d32a38d5a0c61d3626f9a15b4bfdd070bcf4b73e91588b26c8b1f4abc7eedbd",
  "receipt": {
    "to": null,
    "from": "0xCC97EB5651e05D5a0Ae8bcD2813B9DFDaD6F92a5",
    "contractAddress": "0x33582761879e0eDAcC25D156585c6Ccc0d20f85A",
    "transactionIndex": 0,
    "gasUsed": "16557880",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x1261bc453fe2a9298de01b85e4205ba34d461c6c809d4b20b2a81e39d95555cf",
    "transactionHash": "0x2d32a38d5a0c61d3626f9a15b4bfdd070bcf4b73e91588b26c8b1f4abc7eedbd",
    "logs": [],
    "blockNumber": 13387579,
    "cumulativeGasUsed": "7445280",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x051afD0b39ACF4Cc52c76a479aD802d0B82A8249"
  ],
  "solcInputHash": "4b024dc169a046e6527f075e446ec886",
  "metadata": "{\"compiler\":{\"version\":\"0.8.7+commit.e28d00a7\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_keeper\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"reason\",\"type\":\"string\"}],\"name\":\"PoolUpkeepError\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BASE_TIP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BLOCK_TIME\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FIXED_GAS_OVERHEAD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FIXED_POINT\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_TIP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TIP_DELTA_PER_BLOCK\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"keeper\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_gasPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_gasSpent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_settlementTokenPrice\",\"type\":\"uint256\"}],\"name\":\"keeperGas\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_gasPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_gasSpent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_savedPreviousUpdatedTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_poolInterval\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_settlementTokenPrice\",\"type\":\"uint256\"}],\"name\":\"keeperReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_savedPreviousUpdatedTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_poolInterval\",\"type\":\"uint256\"}],\"name\":\"keeperTip\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_keeper\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_gasPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_gasSpent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_savedPreviousUpdatedTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_updateInterval\",\"type\":\"uint256\"}],\"name\":\"payKeeper\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"keeperGas(uint256,uint256,uint256)\":{\"details\":\"Adds a constant to `_gasSpent` when calculating actual gas usage\",\"params\":{\"_gasPrice\":\"Price of a single gas unit (in ETH (wei))\",\"_gasSpent\":\"Number of gas units spent\"},\"returns\":{\"_0\":\"Keeper's gas compensation\"}},\"keeperReward(address,uint256,uint256,uint256,uint256,uint256)\":{\"params\":{\"_gasPrice\":\"Price of a single gas unit (in ETH (wei))\",\"_gasSpent\":\"Number of gas units spent\",\"_poolInterval\":\"Pool interval of the given pool\",\"_savedPreviousUpdatedTimestamp\":\"Last timestamp when the pool's price execution happened\"},\"returns\":{\"_0\":\"Number of settlement tokens to give to the keeper for work performed\"}},\"keeperTip(uint256,uint256)\":{\"params\":{\"_poolInterval\":\"Pool interval of the given pool\",\"_savedPreviousUpdatedTimestamp\":\"Last timestamp when the pool's price execution happened\"},\"returns\":{\"_0\":\"Percent of the `keeperGas` cost to add to payment, as a percent\"}},\"payKeeper(address,address,uint256,uint256,uint256,uint256)\":{\"params\":{\"_gasPrice\":\"Price of a single gas unit (in ETH (wei))\",\"_gasSpent\":\"Number of gas units spent\",\"_keeper\":\"Address of the EOA upkeeping the pool. This is required since the function is called externally\",\"_pool\":\"Address of the given pool\",\"_savedPreviousUpdatedTimestamp\":\"Last timestamp when the pool's price execution happened\",\"_updateInterval\":\"Pool interval of the given pool\"}}},\"title\":\"The contract for calculating and executing keeper reward payments\",\"version\":1},\"userdoc\":{\"events\":{\"PoolUpkeepError(address,string)\":{\"notice\":\"Creates a notification of a failed pool update\"}},\"kind\":\"user\",\"methods\":{\"FIXED_GAS_OVERHEAD()\":{\"notice\":\"Captures fixed gas overhead for performing upkeep that's unreachable by `gasleft()` due to our approach to error handling in that code\"},\"keeperGas(uint256,uint256,uint256)\":{\"notice\":\"Compensation a keeper will receive for their gas expenditure\"},\"keeperReward(address,uint256,uint256,uint256,uint256,uint256)\":{\"notice\":\"Payment keeper receives for performing upkeep on a given pool\"},\"keeperTip(uint256,uint256)\":{\"notice\":\"Tip a keeper will receive for successfully updating the specified pool\"},\"payKeeper(address,address,uint256,uint256,uint256,uint256)\":{\"notice\":\"Pay keeper for upkeep\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/implementation/KeeperRewards.sol\":\"KeeperRewards\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"abdk-libraries-solidity/ABDKMathQuad.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-4-Clause\\n/*\\n * ABDK Math Quad Smart Contract Library.  Copyright \\u00a9 2019 by ABDK Consulting.\\n * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\\n */\\npragma solidity ^0.8.0;\\n\\n/**\\n * Smart contract library of mathematical functions operating with IEEE 754\\n * quadruple-precision binary floating-point numbers (quadruple precision\\n * numbers).  As long as quadruple precision numbers are 16-bytes long, they are\\n * represented by bytes16 type.\\n */\\nlibrary ABDKMathQuad {\\n  /*\\n   * 0.\\n   */\\n  bytes16 private constant POSITIVE_ZERO = 0x00000000000000000000000000000000;\\n\\n  /*\\n   * -0.\\n   */\\n  bytes16 private constant NEGATIVE_ZERO = 0x80000000000000000000000000000000;\\n\\n  /*\\n   * +Infinity.\\n   */\\n  bytes16 private constant POSITIVE_INFINITY = 0x7FFF0000000000000000000000000000;\\n\\n  /*\\n   * -Infinity.\\n   */\\n  bytes16 private constant NEGATIVE_INFINITY = 0xFFFF0000000000000000000000000000;\\n\\n  /*\\n   * Canonical NaN value.\\n   */\\n  bytes16 private constant NaN = 0x7FFF8000000000000000000000000000;\\n\\n  /**\\n   * Convert signed 256-bit integer number into quadruple precision number.\\n   *\\n   * @param x signed 256-bit integer number\\n   * @return quadruple precision number\\n   */\\n  function fromInt (int256 x) internal pure returns (bytes16) {\\n    unchecked {\\n      if (x == 0) return bytes16 (0);\\n      else {\\n        // We rely on overflow behavior here\\n        uint256 result = uint256 (x > 0 ? x : -x);\\n\\n        uint256 msb = mostSignificantBit (result);\\n        if (msb < 112) result <<= 112 - msb;\\n        else if (msb > 112) result >>= msb - 112;\\n\\n        result = result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF | 16383 + msb << 112;\\n        if (x < 0) result |= 0x80000000000000000000000000000000;\\n\\n        return bytes16 (uint128 (result));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert quadruple precision number into signed 256-bit integer number\\n   * rounding towards zero.  Revert on overflow.\\n   *\\n   * @param x quadruple precision number\\n   * @return signed 256-bit integer number\\n   */\\n  function toInt (bytes16 x) internal pure returns (int256) {\\n    unchecked {\\n      uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\\n\\n      require (exponent <= 16638); // Overflow\\n      if (exponent < 16383) return 0; // Underflow\\n\\n      uint256 result = uint256 (uint128 (x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF |\\n        0x10000000000000000000000000000;\\n\\n      if (exponent < 16495) result >>= 16495 - exponent;\\n      else if (exponent > 16495) result <<= exponent - 16495;\\n\\n      if (uint128 (x) >= 0x80000000000000000000000000000000) { // Negative\\n        require (result <= 0x8000000000000000000000000000000000000000000000000000000000000000);\\n        return -int256 (result); // We rely on overflow behavior here\\n      } else {\\n        require (result <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n        return int256 (result);\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert unsigned 256-bit integer number into quadruple precision number.\\n   *\\n   * @param x unsigned 256-bit integer number\\n   * @return quadruple precision number\\n   */\\n  function fromUInt (uint256 x) internal pure returns (bytes16) {\\n    unchecked {\\n      if (x == 0) return bytes16 (0);\\n      else {\\n        uint256 result = x;\\n\\n        uint256 msb = mostSignificantBit (result);\\n        if (msb < 112) result <<= 112 - msb;\\n        else if (msb > 112) result >>= msb - 112;\\n\\n        result = result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF | 16383 + msb << 112;\\n\\n        return bytes16 (uint128 (result));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert quadruple precision number into unsigned 256-bit integer number\\n   * rounding towards zero.  Revert on underflow.  Note, that negative floating\\n   * point numbers in range (-1.0 .. 0.0) may be converted to unsigned integer\\n   * without error, because they are rounded to zero.\\n   *\\n   * @param x quadruple precision number\\n   * @return unsigned 256-bit integer number\\n   */\\n  function toUInt (bytes16 x) internal pure returns (uint256) {\\n    unchecked {\\n      uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\\n\\n      if (exponent < 16383) return 0; // Underflow\\n\\n      require (uint128 (x) < 0x80000000000000000000000000000000); // Negative\\n\\n      require (exponent <= 16638); // Overflow\\n      uint256 result = uint256 (uint128 (x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF |\\n        0x10000000000000000000000000000;\\n\\n      if (exponent < 16495) result >>= 16495 - exponent;\\n      else if (exponent > 16495) result <<= exponent - 16495;\\n\\n      return result;\\n    }\\n  }\\n\\n  /**\\n   * Convert signed 128.128 bit fixed point number into quadruple precision\\n   * number.\\n   *\\n   * @param x signed 128.128 bit fixed point number\\n   * @return quadruple precision number\\n   */\\n  function from128x128 (int256 x) internal pure returns (bytes16) {\\n    unchecked {\\n      if (x == 0) return bytes16 (0);\\n      else {\\n        // We rely on overflow behavior here\\n        uint256 result = uint256 (x > 0 ? x : -x);\\n\\n        uint256 msb = mostSignificantBit (result);\\n        if (msb < 112) result <<= 112 - msb;\\n        else if (msb > 112) result >>= msb - 112;\\n\\n        result = result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF | 16255 + msb << 112;\\n        if (x < 0) result |= 0x80000000000000000000000000000000;\\n\\n        return bytes16 (uint128 (result));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert quadruple precision number into signed 128.128 bit fixed point\\n   * number.  Revert on overflow.\\n   *\\n   * @param x quadruple precision number\\n   * @return signed 128.128 bit fixed point number\\n   */\\n  function to128x128 (bytes16 x) internal pure returns (int256) {\\n    unchecked {\\n      uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\\n\\n      require (exponent <= 16510); // Overflow\\n      if (exponent < 16255) return 0; // Underflow\\n\\n      uint256 result = uint256 (uint128 (x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF |\\n        0x10000000000000000000000000000;\\n\\n      if (exponent < 16367) result >>= 16367 - exponent;\\n      else if (exponent > 16367) result <<= exponent - 16367;\\n\\n      if (uint128 (x) >= 0x80000000000000000000000000000000) { // Negative\\n        require (result <= 0x8000000000000000000000000000000000000000000000000000000000000000);\\n        return -int256 (result); // We rely on overflow behavior here\\n      } else {\\n        require (result <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n        return int256 (result);\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert signed 64.64 bit fixed point number into quadruple precision\\n   * number.\\n   *\\n   * @param x signed 64.64 bit fixed point number\\n   * @return quadruple precision number\\n   */\\n  function from64x64 (int128 x) internal pure returns (bytes16) {\\n    unchecked {\\n      if (x == 0) return bytes16 (0);\\n      else {\\n        // We rely on overflow behavior here\\n        uint256 result = uint128 (x > 0 ? x : -x);\\n\\n        uint256 msb = mostSignificantBit (result);\\n        if (msb < 112) result <<= 112 - msb;\\n        else if (msb > 112) result >>= msb - 112;\\n\\n        result = result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF | 16319 + msb << 112;\\n        if (x < 0) result |= 0x80000000000000000000000000000000;\\n\\n        return bytes16 (uint128 (result));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert quadruple precision number into signed 64.64 bit fixed point\\n   * number.  Revert on overflow.\\n   *\\n   * @param x quadruple precision number\\n   * @return signed 64.64 bit fixed point number\\n   */\\n  function to64x64 (bytes16 x) internal pure returns (int128) {\\n    unchecked {\\n      uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\\n\\n      require (exponent <= 16446); // Overflow\\n      if (exponent < 16319) return 0; // Underflow\\n\\n      uint256 result = uint256 (uint128 (x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF |\\n        0x10000000000000000000000000000;\\n\\n      if (exponent < 16431) result >>= 16431 - exponent;\\n      else if (exponent > 16431) result <<= exponent - 16431;\\n\\n      if (uint128 (x) >= 0x80000000000000000000000000000000) { // Negative\\n        require (result <= 0x80000000000000000000000000000000);\\n        return -int128 (int256 (result)); // We rely on overflow behavior here\\n      } else {\\n        require (result <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n        return int128 (int256 (result));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert octuple precision number into quadruple precision number.\\n   *\\n   * @param x octuple precision number\\n   * @return quadruple precision number\\n   */\\n  function fromOctuple (bytes32 x) internal pure returns (bytes16) {\\n    unchecked {\\n      bool negative = x & 0x8000000000000000000000000000000000000000000000000000000000000000 > 0;\\n\\n      uint256 exponent = uint256 (x) >> 236 & 0x7FFFF;\\n      uint256 significand = uint256 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      if (exponent == 0x7FFFF) {\\n        if (significand > 0) return NaN;\\n        else return negative ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\\n      }\\n\\n      if (exponent > 278526)\\n        return negative ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\\n      else if (exponent < 245649)\\n        return negative ? NEGATIVE_ZERO : POSITIVE_ZERO;\\n      else if (exponent < 245761) {\\n        significand = (significand | 0x100000000000000000000000000000000000000000000000000000000000) >> 245885 - exponent;\\n        exponent = 0;\\n      } else {\\n        significand >>= 124;\\n        exponent -= 245760;\\n      }\\n\\n      uint128 result = uint128 (significand | exponent << 112);\\n      if (negative) result |= 0x80000000000000000000000000000000;\\n\\n      return bytes16 (result);\\n    }\\n  }\\n\\n  /**\\n   * Convert quadruple precision number into octuple precision number.\\n   *\\n   * @param x quadruple precision number\\n   * @return octuple precision number\\n   */\\n  function toOctuple (bytes16 x) internal pure returns (bytes32) {\\n    unchecked {\\n      uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\\n\\n      uint256 result = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      if (exponent == 0x7FFF) exponent = 0x7FFFF; // Infinity or NaN\\n      else if (exponent == 0) {\\n        if (result > 0) {\\n          uint256 msb = mostSignificantBit (result);\\n          result = result << 236 - msb & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n          exponent = 245649 + msb;\\n        }\\n      } else {\\n        result <<= 124;\\n        exponent += 245760;\\n      }\\n\\n      result |= exponent << 236;\\n      if (uint128 (x) >= 0x80000000000000000000000000000000)\\n        result |= 0x8000000000000000000000000000000000000000000000000000000000000000;\\n\\n      return bytes32 (result);\\n    }\\n  }\\n\\n  /**\\n   * Convert double precision number into quadruple precision number.\\n   *\\n   * @param x double precision number\\n   * @return quadruple precision number\\n   */\\n  function fromDouble (bytes8 x) internal pure returns (bytes16) {\\n    unchecked {\\n      uint256 exponent = uint64 (x) >> 52 & 0x7FF;\\n\\n      uint256 result = uint64 (x) & 0xFFFFFFFFFFFFF;\\n\\n      if (exponent == 0x7FF) exponent = 0x7FFF; // Infinity or NaN\\n      else if (exponent == 0) {\\n        if (result > 0) {\\n          uint256 msb = mostSignificantBit (result);\\n          result = result << 112 - msb & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n          exponent = 15309 + msb;\\n        }\\n      } else {\\n        result <<= 60;\\n        exponent += 15360;\\n      }\\n\\n      result |= exponent << 112;\\n      if (x & 0x8000000000000000 > 0)\\n        result |= 0x80000000000000000000000000000000;\\n\\n      return bytes16 (uint128 (result));\\n    }\\n  }\\n\\n  /**\\n   * Convert quadruple precision number into double precision number.\\n   *\\n   * @param x quadruple precision number\\n   * @return double precision number\\n   */\\n  function toDouble (bytes16 x) internal pure returns (bytes8) {\\n    unchecked {\\n      bool negative = uint128 (x) >= 0x80000000000000000000000000000000;\\n\\n      uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\\n      uint256 significand = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      if (exponent == 0x7FFF) {\\n        if (significand > 0) return 0x7FF8000000000000; // NaN\\n        else return negative ?\\n            bytes8 (0xFFF0000000000000) : // -Infinity\\n            bytes8 (0x7FF0000000000000); // Infinity\\n      }\\n\\n      if (exponent > 17406)\\n        return negative ?\\n            bytes8 (0xFFF0000000000000) : // -Infinity\\n            bytes8 (0x7FF0000000000000); // Infinity\\n      else if (exponent < 15309)\\n        return negative ?\\n            bytes8 (0x8000000000000000) : // -0\\n            bytes8 (0x0000000000000000); // 0\\n      else if (exponent < 15361) {\\n        significand = (significand | 0x10000000000000000000000000000) >> 15421 - exponent;\\n        exponent = 0;\\n      } else {\\n        significand >>= 60;\\n        exponent -= 15360;\\n      }\\n\\n      uint64 result = uint64 (significand | exponent << 52);\\n      if (negative) result |= 0x8000000000000000;\\n\\n      return bytes8 (result);\\n    }\\n  }\\n\\n  /**\\n   * Test whether given quadruple precision number is NaN.\\n   *\\n   * @param x quadruple precision number\\n   * @return true if x is NaN, false otherwise\\n   */\\n  function isNaN (bytes16 x) internal pure returns (bool) {\\n    unchecked {\\n      return uint128 (x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF >\\n        0x7FFF0000000000000000000000000000;\\n    }\\n  }\\n\\n  /**\\n   * Test whether given quadruple precision number is positive or negative\\n   * infinity.\\n   *\\n   * @param x quadruple precision number\\n   * @return true if x is positive or negative infinity, false otherwise\\n   */\\n  function isInfinity (bytes16 x) internal pure returns (bool) {\\n    unchecked {\\n      return uint128 (x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF ==\\n        0x7FFF0000000000000000000000000000;\\n    }\\n  }\\n\\n  /**\\n   * Calculate sign of x, i.e. -1 if x is negative, 0 if x if zero, and 1 if x\\n   * is positive.  Note that sign (-0) is zero.  Revert if x is NaN. \\n   *\\n   * @param x quadruple precision number\\n   * @return sign of x\\n   */\\n  function sign (bytes16 x) internal pure returns (int8) {\\n    unchecked {\\n      uint128 absoluteX = uint128 (x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      require (absoluteX <= 0x7FFF0000000000000000000000000000); // Not NaN\\n\\n      if (absoluteX == 0) return 0;\\n      else if (uint128 (x) >= 0x80000000000000000000000000000000) return -1;\\n      else return 1;\\n    }\\n  }\\n\\n  /**\\n   * Calculate sign (x - y).  Revert if either argument is NaN, or both\\n   * arguments are infinities of the same sign. \\n   *\\n   * @param x quadruple precision number\\n   * @param y quadruple precision number\\n   * @return sign (x - y)\\n   */\\n  function cmp (bytes16 x, bytes16 y) internal pure returns (int8) {\\n    unchecked {\\n      uint128 absoluteX = uint128 (x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      require (absoluteX <= 0x7FFF0000000000000000000000000000); // Not NaN\\n\\n      uint128 absoluteY = uint128 (y) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      require (absoluteY <= 0x7FFF0000000000000000000000000000); // Not NaN\\n\\n      // Not infinities of the same sign\\n      require (x != y || absoluteX < 0x7FFF0000000000000000000000000000);\\n\\n      if (x == y) return 0;\\n      else {\\n        bool negativeX = uint128 (x) >= 0x80000000000000000000000000000000;\\n        bool negativeY = uint128 (y) >= 0x80000000000000000000000000000000;\\n\\n        if (negativeX) {\\n          if (negativeY) return absoluteX > absoluteY ? -1 : int8 (1);\\n          else return -1; \\n        } else {\\n          if (negativeY) return 1;\\n          else return absoluteX > absoluteY ? int8 (1) : -1;\\n        }\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Test whether x equals y.  NaN, infinity, and -infinity are not equal to\\n   * anything. \\n   *\\n   * @param x quadruple precision number\\n   * @param y quadruple precision number\\n   * @return true if x equals to y, false otherwise\\n   */\\n  function eq (bytes16 x, bytes16 y) internal pure returns (bool) {\\n    unchecked {\\n      if (x == y) {\\n        return uint128 (x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF <\\n          0x7FFF0000000000000000000000000000;\\n      } else return false;\\n    }\\n  }\\n\\n  /**\\n   * Calculate x + y.  Special values behave in the following way:\\n   *\\n   * NaN + x = NaN for any x.\\n   * Infinity + x = Infinity for any finite x.\\n   * -Infinity + x = -Infinity for any finite x.\\n   * Infinity + Infinity = Infinity.\\n   * -Infinity + -Infinity = -Infinity.\\n   * Infinity + -Infinity = -Infinity + Infinity = NaN.\\n   *\\n   * @param x quadruple precision number\\n   * @param y quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function add (bytes16 x, bytes16 y) internal pure returns (bytes16) {\\n    unchecked {\\n      uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\\n      uint256 yExponent = uint128 (y) >> 112 & 0x7FFF;\\n\\n      if (xExponent == 0x7FFF) {\\n        if (yExponent == 0x7FFF) { \\n          if (x == y) return x;\\n          else return NaN;\\n        } else return x; \\n      } else if (yExponent == 0x7FFF) return y;\\n      else {\\n        bool xSign = uint128 (x) >= 0x80000000000000000000000000000000;\\n        uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (xExponent == 0) xExponent = 1;\\n        else xSignifier |= 0x10000000000000000000000000000;\\n\\n        bool ySign = uint128 (y) >= 0x80000000000000000000000000000000;\\n        uint256 ySignifier = uint128 (y) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (yExponent == 0) yExponent = 1;\\n        else ySignifier |= 0x10000000000000000000000000000;\\n\\n        if (xSignifier == 0) return y == NEGATIVE_ZERO ? POSITIVE_ZERO : y;\\n        else if (ySignifier == 0) return x == NEGATIVE_ZERO ? POSITIVE_ZERO : x;\\n        else {\\n          int256 delta = int256 (xExponent) - int256 (yExponent);\\n  \\n          if (xSign == ySign) {\\n            if (delta > 112) return x;\\n            else if (delta > 0) ySignifier >>= uint256 (delta);\\n            else if (delta < -112) return y;\\n            else if (delta < 0) {\\n              xSignifier >>= uint256 (-delta);\\n              xExponent = yExponent;\\n            }\\n  \\n            xSignifier += ySignifier;\\n  \\n            if (xSignifier >= 0x20000000000000000000000000000) {\\n              xSignifier >>= 1;\\n              xExponent += 1;\\n            }\\n  \\n            if (xExponent == 0x7FFF)\\n              return xSign ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\\n            else {\\n              if (xSignifier < 0x10000000000000000000000000000) xExponent = 0;\\n              else xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n  \\n              return bytes16 (uint128 (\\n                  (xSign ? 0x80000000000000000000000000000000 : 0) |\\n                  (xExponent << 112) |\\n                  xSignifier)); \\n            }\\n          } else {\\n            if (delta > 0) {\\n              xSignifier <<= 1;\\n              xExponent -= 1;\\n            } else if (delta < 0) {\\n              ySignifier <<= 1;\\n              xExponent = yExponent - 1;\\n            }\\n\\n            if (delta > 112) ySignifier = 1;\\n            else if (delta > 1) ySignifier = (ySignifier - 1 >> uint256 (delta - 1)) + 1;\\n            else if (delta < -112) xSignifier = 1;\\n            else if (delta < -1) xSignifier = (xSignifier - 1 >> uint256 (-delta - 1)) + 1;\\n\\n            if (xSignifier >= ySignifier) xSignifier -= ySignifier;\\n            else {\\n              xSignifier = ySignifier - xSignifier;\\n              xSign = ySign;\\n            }\\n\\n            if (xSignifier == 0)\\n              return POSITIVE_ZERO;\\n\\n            uint256 msb = mostSignificantBit (xSignifier);\\n\\n            if (msb == 113) {\\n              xSignifier = xSignifier >> 1 & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n              xExponent += 1;\\n            } else if (msb < 112) {\\n              uint256 shift = 112 - msb;\\n              if (xExponent > shift) {\\n                xSignifier = xSignifier << shift & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n                xExponent -= shift;\\n              } else {\\n                xSignifier <<= xExponent - 1;\\n                xExponent = 0;\\n              }\\n            } else xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n            if (xExponent == 0x7FFF)\\n              return xSign ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\\n            else return bytes16 (uint128 (\\n                (xSign ? 0x80000000000000000000000000000000 : 0) |\\n                (xExponent << 112) |\\n                xSignifier));\\n          }\\n        }\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate x - y.  Special values behave in the following way:\\n   *\\n   * NaN - x = NaN for any x.\\n   * Infinity - x = Infinity for any finite x.\\n   * -Infinity - x = -Infinity for any finite x.\\n   * Infinity - -Infinity = Infinity.\\n   * -Infinity - Infinity = -Infinity.\\n   * Infinity - Infinity = -Infinity - -Infinity = NaN.\\n   *\\n   * @param x quadruple precision number\\n   * @param y quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function sub (bytes16 x, bytes16 y) internal pure returns (bytes16) {\\n    unchecked {\\n      return add (x, y ^ 0x80000000000000000000000000000000);\\n    }\\n  }\\n\\n  /**\\n   * Calculate x * y.  Special values behave in the following way:\\n   *\\n   * NaN * x = NaN for any x.\\n   * Infinity * x = Infinity for any finite positive x.\\n   * Infinity * x = -Infinity for any finite negative x.\\n   * -Infinity * x = -Infinity for any finite positive x.\\n   * -Infinity * x = Infinity for any finite negative x.\\n   * Infinity * 0 = NaN.\\n   * -Infinity * 0 = NaN.\\n   * Infinity * Infinity = Infinity.\\n   * Infinity * -Infinity = -Infinity.\\n   * -Infinity * Infinity = -Infinity.\\n   * -Infinity * -Infinity = Infinity.\\n   *\\n   * @param x quadruple precision number\\n   * @param y quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function mul (bytes16 x, bytes16 y) internal pure returns (bytes16) {\\n    unchecked {\\n      uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\\n      uint256 yExponent = uint128 (y) >> 112 & 0x7FFF;\\n\\n      if (xExponent == 0x7FFF) {\\n        if (yExponent == 0x7FFF) {\\n          if (x == y) return x ^ y & 0x80000000000000000000000000000000;\\n          else if (x ^ y == 0x80000000000000000000000000000000) return x | y;\\n          else return NaN;\\n        } else {\\n          if (y & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) return NaN;\\n          else return x ^ y & 0x80000000000000000000000000000000;\\n        }\\n      } else if (yExponent == 0x7FFF) {\\n          if (x & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) return NaN;\\n          else return y ^ x & 0x80000000000000000000000000000000;\\n      } else {\\n        uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (xExponent == 0) xExponent = 1;\\n        else xSignifier |= 0x10000000000000000000000000000;\\n\\n        uint256 ySignifier = uint128 (y) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (yExponent == 0) yExponent = 1;\\n        else ySignifier |= 0x10000000000000000000000000000;\\n\\n        xSignifier *= ySignifier;\\n        if (xSignifier == 0)\\n          return (x ^ y) & 0x80000000000000000000000000000000 > 0 ?\\n              NEGATIVE_ZERO : POSITIVE_ZERO;\\n\\n        xExponent += yExponent;\\n\\n        uint256 msb =\\n          xSignifier >= 0x200000000000000000000000000000000000000000000000000000000 ? 225 :\\n          xSignifier >= 0x100000000000000000000000000000000000000000000000000000000 ? 224 :\\n          mostSignificantBit (xSignifier);\\n\\n        if (xExponent + msb < 16496) { // Underflow\\n          xExponent = 0;\\n          xSignifier = 0;\\n        } else if (xExponent + msb < 16608) { // Subnormal\\n          if (xExponent < 16496)\\n            xSignifier >>= 16496 - xExponent;\\n          else if (xExponent > 16496)\\n            xSignifier <<= xExponent - 16496;\\n          xExponent = 0;\\n        } else if (xExponent + msb > 49373) {\\n          xExponent = 0x7FFF;\\n          xSignifier = 0;\\n        } else {\\n          if (msb > 112)\\n            xSignifier >>= msb - 112;\\n          else if (msb < 112)\\n            xSignifier <<= 112 - msb;\\n\\n          xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n          xExponent = xExponent + msb - 16607;\\n        }\\n\\n        return bytes16 (uint128 (uint128 ((x ^ y) & 0x80000000000000000000000000000000) |\\n            xExponent << 112 | xSignifier));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate x / y.  Special values behave in the following way:\\n   *\\n   * NaN / x = NaN for any x.\\n   * x / NaN = NaN for any x.\\n   * Infinity / x = Infinity for any finite non-negative x.\\n   * Infinity / x = -Infinity for any finite negative x including -0.\\n   * -Infinity / x = -Infinity for any finite non-negative x.\\n   * -Infinity / x = Infinity for any finite negative x including -0.\\n   * x / Infinity = 0 for any finite non-negative x.\\n   * x / -Infinity = -0 for any finite non-negative x.\\n   * x / Infinity = -0 for any finite non-negative x including -0.\\n   * x / -Infinity = 0 for any finite non-negative x including -0.\\n   * \\n   * Infinity / Infinity = NaN.\\n   * Infinity / -Infinity = -NaN.\\n   * -Infinity / Infinity = -NaN.\\n   * -Infinity / -Infinity = NaN.\\n   *\\n   * Division by zero behaves in the following way:\\n   *\\n   * x / 0 = Infinity for any finite positive x.\\n   * x / -0 = -Infinity for any finite positive x.\\n   * x / 0 = -Infinity for any finite negative x.\\n   * x / -0 = Infinity for any finite negative x.\\n   * 0 / 0 = NaN.\\n   * 0 / -0 = NaN.\\n   * -0 / 0 = NaN.\\n   * -0 / -0 = NaN.\\n   *\\n   * @param x quadruple precision number\\n   * @param y quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function div (bytes16 x, bytes16 y) internal pure returns (bytes16) {\\n    unchecked {\\n      uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\\n      uint256 yExponent = uint128 (y) >> 112 & 0x7FFF;\\n\\n      if (xExponent == 0x7FFF) {\\n        if (yExponent == 0x7FFF) return NaN;\\n        else return x ^ y & 0x80000000000000000000000000000000;\\n      } else if (yExponent == 0x7FFF) {\\n        if (y & 0x0000FFFFFFFFFFFFFFFFFFFFFFFFFFFF != 0) return NaN;\\n        else return POSITIVE_ZERO | (x ^ y) & 0x80000000000000000000000000000000;\\n      } else if (y & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) {\\n        if (x & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) return NaN;\\n        else return POSITIVE_INFINITY | (x ^ y) & 0x80000000000000000000000000000000;\\n      } else {\\n        uint256 ySignifier = uint128 (y) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (yExponent == 0) yExponent = 1;\\n        else ySignifier |= 0x10000000000000000000000000000;\\n\\n        uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (xExponent == 0) {\\n          if (xSignifier != 0) {\\n            uint shift = 226 - mostSignificantBit (xSignifier);\\n\\n            xSignifier <<= shift;\\n\\n            xExponent = 1;\\n            yExponent += shift - 114;\\n          }\\n        }\\n        else {\\n          xSignifier = (xSignifier | 0x10000000000000000000000000000) << 114;\\n        }\\n\\n        xSignifier = xSignifier / ySignifier;\\n        if (xSignifier == 0)\\n          return (x ^ y) & 0x80000000000000000000000000000000 > 0 ?\\n              NEGATIVE_ZERO : POSITIVE_ZERO;\\n\\n        assert (xSignifier >= 0x1000000000000000000000000000);\\n\\n        uint256 msb =\\n          xSignifier >= 0x80000000000000000000000000000 ? mostSignificantBit (xSignifier) :\\n          xSignifier >= 0x40000000000000000000000000000 ? 114 :\\n          xSignifier >= 0x20000000000000000000000000000 ? 113 : 112;\\n\\n        if (xExponent + msb > yExponent + 16497) { // Overflow\\n          xExponent = 0x7FFF;\\n          xSignifier = 0;\\n        } else if (xExponent + msb + 16380  < yExponent) { // Underflow\\n          xExponent = 0;\\n          xSignifier = 0;\\n        } else if (xExponent + msb + 16268  < yExponent) { // Subnormal\\n          if (xExponent + 16380 > yExponent)\\n            xSignifier <<= xExponent + 16380 - yExponent;\\n          else if (xExponent + 16380 < yExponent)\\n            xSignifier >>= yExponent - xExponent - 16380;\\n\\n          xExponent = 0;\\n        } else { // Normal\\n          if (msb > 112)\\n            xSignifier >>= msb - 112;\\n\\n          xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n          xExponent = xExponent + msb + 16269 - yExponent;\\n        }\\n\\n        return bytes16 (uint128 (uint128 ((x ^ y) & 0x80000000000000000000000000000000) |\\n            xExponent << 112 | xSignifier));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate -x.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function neg (bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      return x ^ 0x80000000000000000000000000000000;\\n    }\\n  }\\n\\n  /**\\n   * Calculate |x|.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function abs (bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      return x & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n    }\\n  }\\n\\n  /**\\n   * Calculate square root of x.  Return NaN on negative x excluding -0.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function sqrt (bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      if (uint128 (x) >  0x80000000000000000000000000000000) return NaN;\\n      else {\\n        uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\\n        if (xExponent == 0x7FFF) return x;\\n        else {\\n          uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n          if (xExponent == 0) xExponent = 1;\\n          else xSignifier |= 0x10000000000000000000000000000;\\n\\n          if (xSignifier == 0) return POSITIVE_ZERO;\\n\\n          bool oddExponent = xExponent & 0x1 == 0;\\n          xExponent = xExponent + 16383 >> 1;\\n\\n          if (oddExponent) {\\n            if (xSignifier >= 0x10000000000000000000000000000)\\n              xSignifier <<= 113;\\n            else {\\n              uint256 msb = mostSignificantBit (xSignifier);\\n              uint256 shift = (226 - msb) & 0xFE;\\n              xSignifier <<= shift;\\n              xExponent -= shift - 112 >> 1;\\n            }\\n          } else {\\n            if (xSignifier >= 0x10000000000000000000000000000)\\n              xSignifier <<= 112;\\n            else {\\n              uint256 msb = mostSignificantBit (xSignifier);\\n              uint256 shift = (225 - msb) & 0xFE;\\n              xSignifier <<= shift;\\n              xExponent -= shift - 112 >> 1;\\n            }\\n          }\\n\\n          uint256 r = 0x10000000000000000000000000000;\\n          r = (r + xSignifier / r) >> 1;\\n          r = (r + xSignifier / r) >> 1;\\n          r = (r + xSignifier / r) >> 1;\\n          r = (r + xSignifier / r) >> 1;\\n          r = (r + xSignifier / r) >> 1;\\n          r = (r + xSignifier / r) >> 1;\\n          r = (r + xSignifier / r) >> 1; // Seven iterations should be enough\\n          uint256 r1 = xSignifier / r;\\n          if (r1 < r) r = r1;\\n\\n          return bytes16 (uint128 (xExponent << 112 | r & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF));\\n        }\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate binary logarithm of x.  Return NaN on negative x excluding -0.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function log_2 (bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      if (uint128 (x) > 0x80000000000000000000000000000000) return NaN;\\n      else if (x == 0x3FFF0000000000000000000000000000) return POSITIVE_ZERO; \\n      else {\\n        uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\\n        if (xExponent == 0x7FFF) return x;\\n        else {\\n          uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n          if (xExponent == 0) xExponent = 1;\\n          else xSignifier |= 0x10000000000000000000000000000;\\n\\n          if (xSignifier == 0) return NEGATIVE_INFINITY;\\n\\n          bool resultNegative;\\n          uint256 resultExponent = 16495;\\n          uint256 resultSignifier;\\n\\n          if (xExponent >= 0x3FFF) {\\n            resultNegative = false;\\n            resultSignifier = xExponent - 0x3FFF;\\n            xSignifier <<= 15;\\n          } else {\\n            resultNegative = true;\\n            if (xSignifier >= 0x10000000000000000000000000000) {\\n              resultSignifier = 0x3FFE - xExponent;\\n              xSignifier <<= 15;\\n            } else {\\n              uint256 msb = mostSignificantBit (xSignifier);\\n              resultSignifier = 16493 - msb;\\n              xSignifier <<= 127 - msb;\\n            }\\n          }\\n\\n          if (xSignifier == 0x80000000000000000000000000000000) {\\n            if (resultNegative) resultSignifier += 1;\\n            uint256 shift = 112 - mostSignificantBit (resultSignifier);\\n            resultSignifier <<= shift;\\n            resultExponent -= shift;\\n          } else {\\n            uint256 bb = resultNegative ? 1 : 0;\\n            while (resultSignifier < 0x10000000000000000000000000000) {\\n              resultSignifier <<= 1;\\n              resultExponent -= 1;\\n  \\n              xSignifier *= xSignifier;\\n              uint256 b = xSignifier >> 255;\\n              resultSignifier += b ^ bb;\\n              xSignifier >>= 127 + b;\\n            }\\n          }\\n\\n          return bytes16 (uint128 ((resultNegative ? 0x80000000000000000000000000000000 : 0) |\\n              resultExponent << 112 | resultSignifier & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF));\\n        }\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate natural logarithm of x.  Return NaN on negative x excluding -0.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function ln (bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      return mul (log_2 (x), 0x3FFE62E42FEFA39EF35793C7673007E5);\\n    }\\n  }\\n\\n  /**\\n   * Calculate 2^x.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function pow_2 (bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      bool xNegative = uint128 (x) > 0x80000000000000000000000000000000;\\n      uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\\n      uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      if (xExponent == 0x7FFF && xSignifier != 0) return NaN;\\n      else if (xExponent > 16397)\\n        return xNegative ? POSITIVE_ZERO : POSITIVE_INFINITY;\\n      else if (xExponent < 16255)\\n        return 0x3FFF0000000000000000000000000000;\\n      else {\\n        if (xExponent == 0) xExponent = 1;\\n        else xSignifier |= 0x10000000000000000000000000000;\\n\\n        if (xExponent > 16367)\\n          xSignifier <<= xExponent - 16367;\\n        else if (xExponent < 16367)\\n          xSignifier >>= 16367 - xExponent;\\n\\n        if (xNegative && xSignifier > 0x406E00000000000000000000000000000000)\\n          return POSITIVE_ZERO;\\n\\n        if (!xNegative && xSignifier > 0x3FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\\n          return POSITIVE_INFINITY;\\n\\n        uint256 resultExponent = xSignifier >> 128;\\n        xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (xNegative && xSignifier != 0) {\\n          xSignifier = ~xSignifier;\\n          resultExponent += 1;\\n        }\\n\\n        uint256 resultSignifier = 0x80000000000000000000000000000000;\\n        if (xSignifier & 0x80000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x16A09E667F3BCC908B2FB1366EA957D3E >> 128;\\n        if (xSignifier & 0x40000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1306FE0A31B7152DE8D5A46305C85EDEC >> 128;\\n        if (xSignifier & 0x20000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1172B83C7D517ADCDF7C8C50EB14A791F >> 128;\\n        if (xSignifier & 0x10000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10B5586CF9890F6298B92B71842A98363 >> 128;\\n        if (xSignifier & 0x8000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1059B0D31585743AE7C548EB68CA417FD >> 128;\\n        if (xSignifier & 0x4000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x102C9A3E778060EE6F7CACA4F7A29BDE8 >> 128;\\n        if (xSignifier & 0x2000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10163DA9FB33356D84A66AE336DCDFA3F >> 128;\\n        if (xSignifier & 0x1000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100B1AFA5ABCBED6129AB13EC11DC9543 >> 128;\\n        if (xSignifier & 0x800000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10058C86DA1C09EA1FF19D294CF2F679B >> 128;\\n        if (xSignifier & 0x400000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1002C605E2E8CEC506D21BFC89A23A00F >> 128;\\n        if (xSignifier & 0x200000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100162F3904051FA128BCA9C55C31E5DF >> 128;\\n        if (xSignifier & 0x100000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000B175EFFDC76BA38E31671CA939725 >> 128;\\n        if (xSignifier & 0x80000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100058BA01FB9F96D6CACD4B180917C3D >> 128;\\n        if (xSignifier & 0x40000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10002C5CC37DA9491D0985C348C68E7B3 >> 128;\\n        if (xSignifier & 0x20000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000162E525EE054754457D5995292026 >> 128;\\n        if (xSignifier & 0x10000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000B17255775C040618BF4A4ADE83FC >> 128;\\n        if (xSignifier & 0x8000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000058B91B5BC9AE2EED81E9B7D4CFAB >> 128;\\n        if (xSignifier & 0x4000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100002C5C89D5EC6CA4D7C8ACC017B7C9 >> 128;\\n        if (xSignifier & 0x2000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000162E43F4F831060E02D839A9D16D >> 128;\\n        if (xSignifier & 0x1000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000B1721BCFC99D9F890EA06911763 >> 128;\\n        if (xSignifier & 0x800000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000058B90CF1E6D97F9CA14DBCC1628 >> 128;\\n        if (xSignifier & 0x400000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000002C5C863B73F016468F6BAC5CA2B >> 128;\\n        if (xSignifier & 0x200000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000162E430E5A18F6119E3C02282A5 >> 128;\\n        if (xSignifier & 0x100000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000B1721835514B86E6D96EFD1BFE >> 128;\\n        if (xSignifier & 0x80000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000058B90C0B48C6BE5DF846C5B2EF >> 128;\\n        if (xSignifier & 0x40000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000002C5C8601CC6B9E94213C72737A >> 128;\\n        if (xSignifier & 0x20000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000162E42FFF037DF38AA2B219F06 >> 128;\\n        if (xSignifier & 0x10000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000B17217FBA9C739AA5819F44F9 >> 128;\\n        if (xSignifier & 0x8000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000058B90BFCDEE5ACD3C1CEDC823 >> 128;\\n        if (xSignifier & 0x4000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000002C5C85FE31F35A6A30DA1BE50 >> 128;\\n        if (xSignifier & 0x2000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000162E42FF0999CE3541B9FFFCF >> 128;\\n        if (xSignifier & 0x1000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000B17217F80F4EF5AADDA45554 >> 128;\\n        if (xSignifier & 0x800000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000058B90BFBF8479BD5A81B51AD >> 128;\\n        if (xSignifier & 0x400000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000002C5C85FDF84BD62AE30A74CC >> 128;\\n        if (xSignifier & 0x200000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000162E42FEFB2FED257559BDAA >> 128;\\n        if (xSignifier & 0x100000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000B17217F7D5A7716BBA4A9AE >> 128;\\n        if (xSignifier & 0x80000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000058B90BFBE9DDBAC5E109CCE >> 128;\\n        if (xSignifier & 0x40000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000002C5C85FDF4B15DE6F17EB0D >> 128;\\n        if (xSignifier & 0x20000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000162E42FEFA494F1478FDE05 >> 128;\\n        if (xSignifier & 0x10000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000B17217F7D20CF927C8E94C >> 128;\\n        if (xSignifier & 0x8000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000058B90BFBE8F71CB4E4B33D >> 128;\\n        if (xSignifier & 0x4000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000002C5C85FDF477B662B26945 >> 128;\\n        if (xSignifier & 0x2000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000162E42FEFA3AE53369388C >> 128;\\n        if (xSignifier & 0x1000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000B17217F7D1D351A389D40 >> 128;\\n        if (xSignifier & 0x800000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000058B90BFBE8E8B2D3D4EDE >> 128;\\n        if (xSignifier & 0x400000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000002C5C85FDF4741BEA6E77E >> 128;\\n        if (xSignifier & 0x200000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000162E42FEFA39FE95583C2 >> 128;\\n        if (xSignifier & 0x100000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000B17217F7D1CFB72B45E1 >> 128;\\n        if (xSignifier & 0x80000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000058B90BFBE8E7CC35C3F0 >> 128;\\n        if (xSignifier & 0x40000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000002C5C85FDF473E242EA38 >> 128;\\n        if (xSignifier & 0x20000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000162E42FEFA39F02B772C >> 128;\\n        if (xSignifier & 0x10000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000B17217F7D1CF7D83C1A >> 128;\\n        if (xSignifier & 0x8000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000058B90BFBE8E7BDCBE2E >> 128;\\n        if (xSignifier & 0x4000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000002C5C85FDF473DEA871F >> 128;\\n        if (xSignifier & 0x2000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000162E42FEFA39EF44D91 >> 128;\\n        if (xSignifier & 0x1000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000B17217F7D1CF79E949 >> 128;\\n        if (xSignifier & 0x800000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000058B90BFBE8E7BCE544 >> 128;\\n        if (xSignifier & 0x400000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000002C5C85FDF473DE6ECA >> 128;\\n        if (xSignifier & 0x200000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000162E42FEFA39EF366F >> 128;\\n        if (xSignifier & 0x100000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000B17217F7D1CF79AFA >> 128;\\n        if (xSignifier & 0x80000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000058B90BFBE8E7BCD6D >> 128;\\n        if (xSignifier & 0x40000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000002C5C85FDF473DE6B2 >> 128;\\n        if (xSignifier & 0x20000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000162E42FEFA39EF358 >> 128;\\n        if (xSignifier & 0x10000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000B17217F7D1CF79AB >> 128;\\n        if (xSignifier & 0x8000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000058B90BFBE8E7BCD5 >> 128;\\n        if (xSignifier & 0x4000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000002C5C85FDF473DE6A >> 128;\\n        if (xSignifier & 0x2000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000162E42FEFA39EF34 >> 128;\\n        if (xSignifier & 0x1000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000B17217F7D1CF799 >> 128;\\n        if (xSignifier & 0x800000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000058B90BFBE8E7BCC >> 128;\\n        if (xSignifier & 0x400000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000002C5C85FDF473DE5 >> 128;\\n        if (xSignifier & 0x200000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000162E42FEFA39EF2 >> 128;\\n        if (xSignifier & 0x100000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000B17217F7D1CF78 >> 128;\\n        if (xSignifier & 0x80000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000058B90BFBE8E7BB >> 128;\\n        if (xSignifier & 0x40000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000002C5C85FDF473DD >> 128;\\n        if (xSignifier & 0x20000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000162E42FEFA39EE >> 128;\\n        if (xSignifier & 0x10000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000B17217F7D1CF6 >> 128;\\n        if (xSignifier & 0x8000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000058B90BFBE8E7A >> 128;\\n        if (xSignifier & 0x4000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000002C5C85FDF473C >> 128;\\n        if (xSignifier & 0x2000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000162E42FEFA39D >> 128;\\n        if (xSignifier & 0x1000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000B17217F7D1CE >> 128;\\n        if (xSignifier & 0x800000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000058B90BFBE8E6 >> 128;\\n        if (xSignifier & 0x400000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000002C5C85FDF472 >> 128;\\n        if (xSignifier & 0x200000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000162E42FEFA38 >> 128;\\n        if (xSignifier & 0x100000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000B17217F7D1B >> 128;\\n        if (xSignifier & 0x80000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000058B90BFBE8D >> 128;\\n        if (xSignifier & 0x40000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000002C5C85FDF46 >> 128;\\n        if (xSignifier & 0x20000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000162E42FEFA2 >> 128;\\n        if (xSignifier & 0x10000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000B17217F7D0 >> 128;\\n        if (xSignifier & 0x8000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000058B90BFBE7 >> 128;\\n        if (xSignifier & 0x4000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000002C5C85FDF3 >> 128;\\n        if (xSignifier & 0x2000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000162E42FEF9 >> 128;\\n        if (xSignifier & 0x1000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000B17217F7C >> 128;\\n        if (xSignifier & 0x800000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000058B90BFBD >> 128;\\n        if (xSignifier & 0x400000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000002C5C85FDE >> 128;\\n        if (xSignifier & 0x200000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000162E42FEE >> 128;\\n        if (xSignifier & 0x100000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000B17217F6 >> 128;\\n        if (xSignifier & 0x80000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000058B90BFA >> 128;\\n        if (xSignifier & 0x40000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000002C5C85FC >> 128;\\n        if (xSignifier & 0x20000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000162E42FD >> 128;\\n        if (xSignifier & 0x10000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000B17217E >> 128;\\n        if (xSignifier & 0x8000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000058B90BE >> 128;\\n        if (xSignifier & 0x4000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000002C5C85E >> 128;\\n        if (xSignifier & 0x2000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000162E42E >> 128;\\n        if (xSignifier & 0x1000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000B17216 >> 128;\\n        if (xSignifier & 0x800000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000058B90A >> 128;\\n        if (xSignifier & 0x400000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000002C5C84 >> 128;\\n        if (xSignifier & 0x200000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000162E41 >> 128;\\n        if (xSignifier & 0x100000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000000B1720 >> 128;\\n        if (xSignifier & 0x80000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000058B8F >> 128;\\n        if (xSignifier & 0x40000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000002C5C7 >> 128;\\n        if (xSignifier & 0x20000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000000162E3 >> 128;\\n        if (xSignifier & 0x10000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000000B171 >> 128;\\n        if (xSignifier & 0x8000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000000058B8 >> 128;\\n        if (xSignifier & 0x4000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000002C5B >> 128;\\n        if (xSignifier & 0x2000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000000162D >> 128;\\n        if (xSignifier & 0x1000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000B16 >> 128;\\n        if (xSignifier & 0x800 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000000058A >> 128;\\n        if (xSignifier & 0x400 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000000002C4 >> 128;\\n        if (xSignifier & 0x200 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000161 >> 128;\\n        if (xSignifier & 0x100 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000000000B0 >> 128;\\n        if (xSignifier & 0x80 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000057 >> 128;\\n        if (xSignifier & 0x40 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000000002B >> 128;\\n        if (xSignifier & 0x20 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000015 >> 128;\\n        if (xSignifier & 0x10 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000000000A >> 128;\\n        if (xSignifier & 0x8 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000004 >> 128;\\n        if (xSignifier & 0x4 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000001 >> 128;\\n\\n        if (!xNegative) {\\n          resultSignifier = resultSignifier >> 15 & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n          resultExponent += 0x3FFF;\\n        } else if (resultExponent <= 0x3FFE) {\\n          resultSignifier = resultSignifier >> 15 & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n          resultExponent = 0x3FFF - resultExponent;\\n        } else {\\n          resultSignifier = resultSignifier >> resultExponent - 16367;\\n          resultExponent = 0;\\n        }\\n\\n        return bytes16 (uint128 (resultExponent << 112 | resultSignifier));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate e^x.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function exp (bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      return pow_2 (mul (x, 0x3FFF71547652B82FE1777D0FFDA0D23A));\\n    }\\n  }\\n\\n  /**\\n   * Get index of the most significant non-zero bit in binary representation of\\n   * x.  Reverts if x is zero.\\n   *\\n   * @return index of the most significant non-zero bit in binary representation\\n   *         of x\\n   */\\n  function mostSignificantBit (uint256 x) private pure returns (uint256) {\\n    unchecked {\\n      require (x > 0);\\n\\n      uint256 result = 0;\\n\\n      if (x >= 0x100000000000000000000000000000000) { x >>= 128; result += 128; }\\n      if (x >= 0x10000000000000000) { x >>= 64; result += 64; }\\n      if (x >= 0x100000000) { x >>= 32; result += 32; }\\n      if (x >= 0x10000) { x >>= 16; result += 16; }\\n      if (x >= 0x100) { x >>= 8; result += 8; }\\n      if (x >= 0x10) { x >>= 4; result += 4; }\\n      if (x >= 0x4) { x >>= 2; result += 2; }\\n      if (x >= 0x2) result += 1; // No need to shift x anymore\\n\\n      return result;\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0x9694a9f6fcadd4fa917efa674de42a74b8fbab8d68924f771ea5cc5e1a301434\",\"license\":\"BSD-4-Clause\"},\"contracts/implementation/KeeperRewards.sol\":{\"content\":\"//SPDX-License-Identifier: CC-BY-NC-ND-4.0\\npragma solidity 0.8.7;\\n\\nimport \\\"../interfaces/ILeveragedPool.sol\\\";\\nimport \\\"../interfaces/IKeeperRewards.sol\\\";\\nimport \\\"../interfaces/IOracleWrapper.sol\\\";\\nimport \\\"../interfaces/IERC20DecimalsWrapper.sol\\\";\\n\\nimport \\\"../libraries/PoolSwapLibrary.sol\\\";\\n\\n/// @title The contract for calculating and executing keeper reward payments\\ncontract KeeperRewards is IKeeperRewards {\\n    address public immutable keeper;\\n    /* Constants */\\n    uint256 public constant BASE_TIP = 5; // 5% base tip\\n    uint256 public constant TIP_DELTA_PER_BLOCK = 5; // 5% increase per block\\n    uint256 public constant BLOCK_TIME = 13; /* in seconds */\\n    uint256 public constant MAX_TIP = 100; /* maximum keeper tip */\\n    bytes16 public constant FIXED_POINT = 0x403abc16d674ec800000000000000000; // 1 ether\\n\\n    /// Captures fixed gas overhead for performing upkeep that's unreachable\\n    /// by `gasleft()` due to our approach to error handling in that code\\n    uint256 public constant FIXED_GAS_OVERHEAD = 80195;\\n\\n    constructor(address _keeper) {\\n        require(_keeper != address(0), \\\"PoolKeeper cannot be 0 address\\\");\\n        keeper = _keeper;\\n    }\\n\\n    modifier onlyKeeper() {\\n        require(msg.sender == keeper, \\\"msg.sender not keeper\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @notice Pay keeper for upkeep\\n     * @param _keeper Address of the EOA upkeeping the pool. This is required since the function is called externally\\n     * @param _pool Address of the given pool\\n     * @param _gasPrice Price of a single gas unit (in ETH (wei))\\n     * @param _gasSpent Number of gas units spent\\n     * @param _savedPreviousUpdatedTimestamp Last timestamp when the pool's price execution happened\\n     * @param _updateInterval Pool interval of the given pool\\n     */\\n    function payKeeper(\\n        address _keeper,\\n        address _pool,\\n        uint256 _gasPrice,\\n        uint256 _gasSpent,\\n        uint256 _savedPreviousUpdatedTimestamp,\\n        uint256 _updateInterval\\n    ) external override onlyKeeper returns (uint256) {\\n        try IOracleWrapper(ILeveragedPool(_pool).settlementEthOracle()).poll() {} catch Error(string memory reason) {\\n            emit PoolUpkeepError(_pool, reason);\\n        }\\n        // `IOracleWrapper` is typically implemented such that `getPrice` returns a number with 18 decimal places.\\n        int256 settlementTokenPrice = IOracleWrapper(ILeveragedPool(_pool).settlementEthOracle()).getPrice();\\n\\n        require(settlementTokenPrice >= 0, \\\"settlement price must be >= 0\\\");\\n\\n        uint256 reward = keeperReward(\\n            _pool,\\n            _gasPrice,\\n            _gasSpent,\\n            _savedPreviousUpdatedTimestamp,\\n            _updateInterval,\\n            uint256(settlementTokenPrice)\\n        );\\n        if (ILeveragedPool(_pool).payKeeperFromBalances(_keeper, reward)) {\\n            return reward;\\n        } else {\\n            return 0;\\n        }\\n    }\\n\\n    /**\\n     * @notice Payment keeper receives for performing upkeep on a given pool\\n     * @param _gasPrice Price of a single gas unit (in ETH (wei))\\n     * @param _gasSpent Number of gas units spent\\n     * @param _savedPreviousUpdatedTimestamp Last timestamp when the pool's price execution happened\\n     * @param _poolInterval Pool interval of the given pool\\n     * @return Number of settlement tokens to give to the keeper for work performed\\n     */\\n    function keeperReward(\\n        address _pool,\\n        uint256 _gasPrice,\\n        uint256 _gasSpent,\\n        uint256 _savedPreviousUpdatedTimestamp,\\n        uint256 _poolInterval,\\n        uint256 _settlementTokenPrice\\n    ) public view returns (uint256) {\\n        /**\\n         * Conceptually, we have\\n         *\\n         * Reward = Gas + Tip = Gas + (Base + Premium * Blocks)\\n         *\\n         * Very roughly to scale:\\n         *\\n         * +---------------------------+------+---+---+~~~~~\\n         * | GGGGGGGGGGGGGGGGGGGGGGGGG | BBBB | P | P | ...\\n         * +---------------------------+------+---+---+~~~~~\\n         *\\n         * Under normal circumstances, we don't expect there to be any time\\n         * premium at all. The time premium exists in order to *further*\\n         * incentivise upkeep in the event of lateness.\\n         *\\n         * The base tip exists to act as pure profit for a keeper.\\n         *\\n         * Of course, the gas component acts as compensation for performing\\n         * on-chain computation.\\n         *\\n         */\\n\\n        // keeper gas cost in settlement. WAD formatted\\n        uint256 _keeperGas = keeperGas(_gasPrice, _gasSpent, _settlementTokenPrice);\\n\\n        // tip percent\\n        uint256 _tipPercent = keeperTip(_savedPreviousUpdatedTimestamp, _poolInterval);\\n\\n        // amount of settlement tokens to give to the keeper\\n        // _keeperGas + _keeperGas * percentTip\\n        uint256 wadRewardValue = _keeperGas + ((_keeperGas * _tipPercent) / 100);\\n        uint256 decimals = IERC20DecimalsWrapper(ILeveragedPool(_pool).settlementToken()).decimals();\\n        return PoolSwapLibrary.fromWad(uint256(wadRewardValue), decimals);\\n    }\\n\\n    /**\\n     * @notice Compensation a keeper will receive for their gas expenditure\\n     * @param _gasPrice Price of a single gas unit (in ETH (wei))\\n     * @param _gasSpent Number of gas units spent\\n     * @return Keeper's gas compensation\\n     * @dev Adds a constant to `_gasSpent` when calculating actual gas usage\\n     */\\n    function keeperGas(\\n        uint256 _gasPrice,\\n        uint256 _gasSpent,\\n        uint256 _settlementTokenPrice\\n    ) public pure returns (uint256) {\\n        if (_settlementTokenPrice == 0) {\\n            return 0;\\n        } else {\\n            /* gas spent plus our fixed gas overhead */\\n            uint256 gasUsed = _gasSpent + FIXED_GAS_OVERHEAD;\\n\\n            /* safe due to explicit bounds check for settlementTokenPrice above */\\n            /* (wei * Settlement / ETH) / fixed point (10^18) = amount in settlement */\\n            bytes16 weiSpent = ABDKMathQuad.fromUInt(_gasPrice * gasUsed);\\n            bytes16 settlementTokenPrice = ABDKMathQuad.fromUInt(_settlementTokenPrice);\\n            return ABDKMathQuad.toUInt(ABDKMathQuad.div(ABDKMathQuad.mul(weiSpent, settlementTokenPrice), FIXED_POINT));\\n        }\\n    }\\n\\n    /**\\n     * @notice Tip a keeper will receive for successfully updating the specified pool\\n     * @param _savedPreviousUpdatedTimestamp Last timestamp when the pool's price execution happened\\n     * @param _poolInterval Pool interval of the given pool\\n     * @return Percent of the `keeperGas` cost to add to payment, as a percent\\n     */\\n    function keeperTip(uint256 _savedPreviousUpdatedTimestamp, uint256 _poolInterval) public view returns (uint256) {\\n        /* the number of blocks that have elapsed since the given pool's updateInterval passed */\\n        uint256 elapsedBlocksNumerator = (block.timestamp - (_savedPreviousUpdatedTimestamp + _poolInterval));\\n\\n        uint256 keeperTipAmount = BASE_TIP + (TIP_DELTA_PER_BLOCK * elapsedBlocksNumerator) / BLOCK_TIME;\\n\\n        // In case of network outages or otherwise, we want to cap the tip so that the keeper cost isn't unbounded\\n        if (keeperTipAmount > MAX_TIP) {\\n            return MAX_TIP;\\n        } else {\\n            return keeperTipAmount;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x74e070eebc5b5d1caeccad794e561feacd812ef3a01baed3ea2897966aacedf6\",\"license\":\"CC-BY-NC-ND-4.0\"},\"contracts/interfaces/IERC20DecimalsWrapper.sol\":{\"content\":\"//SPDX-License-Identifier: CC-BY-NC-ND-4.0\\npragma solidity 0.8.7;\\n\\n/// @title The decimals interface for extending the ERC20 interface\\ninterface IERC20DecimalsWrapper {\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x5b719acf06c256045637247185ac0a7f1ba2346ab14cec805a5b7ff2d0f1d83d\",\"license\":\"CC-BY-NC-ND-4.0\"},\"contracts/interfaces/IKeeperRewards.sol\":{\"content\":\"//SPDX-License-Identifier: CC-BY-NC-ND-4.0\\npragma solidity 0.8.7;\\n\\ninterface IKeeperRewards {\\n    /**\\n     * @notice Creates a notification of a failed pool update\\n     * @param pool The pool that failed to update\\n     * @param reason The reason for the error\\n     */\\n    event PoolUpkeepError(address indexed pool, string reason);\\n\\n    function payKeeper(\\n        address _keeper,\\n        address _pool,\\n        uint256 _gasPrice,\\n        uint256 _gasSpent,\\n        uint256 _savedPreviousUpdatedTimestamp,\\n        uint256 _updateInterval\\n    ) external returns (uint256);\\n}\\n\",\"keccak256\":\"0xfe4b2dd1cf019575c213bd8f5e3936ff0275ed14d60679c7019f3513e1839e9f\",\"license\":\"CC-BY-NC-ND-4.0\"},\"contracts/interfaces/ILeveragedPool.sol\":{\"content\":\"//SPDX-License-Identifier: CC-BY-NC-ND-4.0\\npragma solidity 0.8.7;\\n\\n/// @title The pool controller contract interface\\ninterface ILeveragedPool {\\n    // Initialisation parameters for new market\\n    struct Initialization {\\n        address _owner; // Owner of the contract\\n        address _keeper; // The address of the PoolKeeper contract\\n        address _oracleWrapper; // The oracle wrapper for the derivative price feed\\n        address _settlementEthOracle; // The oracle wrapper for the SettlementToken/ETH price feed\\n        address _longToken; // Address of the long pool token\\n        address _shortToken; // Address of the short pool token\\n        address _poolCommitter; // Address of the PoolCommitter contract\\n        address _invariantCheck; // Address of the InvariantCheck contract\\n        string _poolName; // The pool identification name\\n        uint32 _frontRunningInterval; // The minimum number of seconds that must elapse before a commit is forced to wait until the next interval\\n        uint32 _updateInterval; // The minimum number of seconds that must elapse before a commit can be executed\\n        uint16 _leverageAmount; // The amount of exposure to price movements for the pool\\n        uint256 _fee; // The fund movement fee. This amount is extracted from the deposited asset with every update and sent to the fee address. Given as the decimal * 10 ^ 18. For example, 60% fee is 0.6 * 10 ^ 18\\n        address _feeAddress; // The address that the fund movement fee is sent to\\n        address _secondaryFeeAddress; // The address of fee recieved by third party deployers\\n        address _settlementToken; //  The digital asset that the pool accepts. Must have a decimals() function\\n        uint256 _secondaryFeeSplitPercent; // Percent of fees that go to secondary fee address if it exists\\n    }\\n\\n    // #### Events\\n    /**\\n     * @notice Creates a notification when the pool is setup and ready for use\\n     * @param longToken The address of the LONG pair token\\n     * @param shortToken The address of the SHORT pair token\\n     * @param settlementToken The address of the digital asset that the pool accepts\\n     * @param poolName The identification name of the pool\\n     */\\n    event PoolInitialized(\\n        address indexed longToken,\\n        address indexed shortToken,\\n        address settlementToken,\\n        string poolName\\n    );\\n\\n    /**\\n     * @notice Creates a notification when the pool is rebalanced\\n     * @param shortBalanceChange The change of funds in the short side\\n     * @param longBalanceChange The change of funds in the long side\\n     * @param shortFeeAmount Proportional fee taken from short side\\n     * @param longFeeAmount Proportional fee taken from long side\\n     */\\n    event PoolRebalance(\\n        int256 shortBalanceChange,\\n        int256 longBalanceChange,\\n        uint256 shortFeeAmount,\\n        uint256 longFeeAmount\\n    );\\n\\n    /**\\n     * @notice Creates a notification when the pool's price execution fails\\n     * @param startPrice Price prior to price change execution\\n     * @param endPrice Price during price change execution\\n     */\\n    event PriceChangeError(int256 indexed startPrice, int256 indexed endPrice);\\n\\n    /**\\n     * @notice Represents change in fee receiver's address\\n     * @param oldAddress Previous address\\n     * @param newAddress Address after change\\n     */\\n    event FeeAddressUpdated(address indexed oldAddress, address indexed newAddress);\\n\\n    /**\\n     * @notice Represents change in secondary fee receiver's address\\n     * @param oldAddress Previous address\\n     * @param newAddress Address after change\\n     */\\n    event SecondaryFeeAddressUpdated(address indexed oldAddress, address indexed newAddress);\\n\\n    /**\\n     * @notice Represents change in keeper's address\\n     * @param oldAddress Previous address\\n     * @param newAddress Address after change\\n     */\\n    event KeeperAddressChanged(address indexed oldAddress, address indexed newAddress);\\n\\n    /**\\n     * @notice Indicates a payment of fees to the secondary fee address\\n     * @param secondaryFeeAddress The address that got fees paid to it\\n     * @param amount Amount of settlement token paid\\n     */\\n    event SecondaryFeesPaid(address indexed secondaryFeeAddress, uint256 amount);\\n\\n    /**\\n     * @notice Indicates a payment of fees to the primary fee address\\n     * @param feeAddress The address that got fees paid to it\\n     * @param amount Amount of settlement token paid\\n     */\\n    event PrimaryFeesPaid(address indexed feeAddress, uint256 amount);\\n\\n    /**\\n     * @notice Indicates settlement assets have been withdrawn from the system\\n     * @param to Receipient\\n     * @param quantity Quantity of settlement tokens withdrawn\\n     */\\n    event SettlementWithdrawn(address indexed to, uint256 indexed quantity);\\n\\n    /**\\n     * @notice Indicates that the balance of pool tokens on issue for the pool\\n     *          changed\\n     * @param long New quantity of long pool tokens\\n     * @param short New quantity of short pool tokens\\n     */\\n    event PoolBalancesChanged(uint256 indexed long, uint256 indexed short);\\n\\n    function leverageAmount() external view returns (bytes16);\\n\\n    function poolCommitter() external view returns (address);\\n\\n    function settlementToken() external view returns (address);\\n\\n    function primaryFees() external view returns (uint256);\\n\\n    function secondaryFees() external view returns (uint256);\\n\\n    function oracleWrapper() external view returns (address);\\n\\n    function lastPriceTimestamp() external view returns (uint256);\\n\\n    function poolName() external view returns (string calldata);\\n\\n    function updateInterval() external view returns (uint32);\\n\\n    function shortBalance() external view returns (uint256);\\n\\n    function longBalance() external view returns (uint256);\\n\\n    function frontRunningInterval() external view returns (uint32);\\n\\n    function poolTokens() external view returns (address[2] memory);\\n\\n    function settlementEthOracle() external view returns (address);\\n\\n    // #### Functions\\n    /**\\n     * @notice Configures the pool on deployment. The pools are EIP 1167 clones.\\n     * @dev This should only be able to be run once to prevent abuse of the pool. Use of Openzeppelin Initializable or similar is recommended\\n     * @param initialization The struct Initialization containing initialization data\\n     */\\n    function initialize(Initialization calldata initialization) external;\\n\\n    function poolUpkeep(int256 _oldPrice, int256 _newPrice) external;\\n\\n    function settlementTokenTransferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external;\\n\\n    function payKeeperFromBalances(address to, uint256 amount) external returns (bool);\\n\\n    function settlementTokenTransfer(address to, uint256 amount) external;\\n\\n    function claimPrimaryFees() external;\\n\\n    function claimSecondaryFees() external;\\n\\n    /**\\n     * @notice Transfer pool tokens from pool to user\\n     * @param isLongToken True if transferring long pool token; False if transferring short pool token\\n     * @param to Address of account to transfer to\\n     * @param amount Amount of pool tokens being transferred\\n     * @dev Only callable by the associated `PoolCommitter` contract\\n     * @dev Only callable when the market is *not* paused\\n     */\\n    function poolTokenTransfer(\\n        bool isLongToken,\\n        address to,\\n        uint256 amount\\n    ) external;\\n\\n    function setNewPoolBalances(uint256 _longBalance, uint256 _shortBalance) external;\\n\\n    /**\\n     * @return _latestPrice The oracle price\\n     * @return _data The oracleWrapper's metadata. Implementations can choose what data to return here\\n     * @return _lastPriceTimestamp The timestamp of the last upkeep\\n     * @return _updateInterval The update frequency for this pool\\n     * @dev To save gas so PoolKeeper does not have to make three external calls\\n     */\\n    function getUpkeepInformation()\\n        external\\n        view\\n        returns (\\n            int256 _latestPrice,\\n            bytes memory _data,\\n            uint256 _lastPriceTimestamp,\\n            uint256 _updateInterval\\n        );\\n\\n    function getOraclePrice() external view returns (int256);\\n\\n    function intervalPassed() external view returns (bool);\\n\\n    function balances() external view returns (uint256 _shortBalance, uint256 _longBalance);\\n\\n    function setKeeper(address _keeper) external;\\n\\n    function updateFeeAddress(address account) external;\\n\\n    function updateSecondaryFeeAddress(address account) external;\\n\\n    function burnTokens(\\n        uint256 tokenType,\\n        uint256 amount,\\n        address burner\\n    ) external;\\n}\\n\",\"keccak256\":\"0x7aaf0368d3bd0875843b63d4dd066caefe54a69552f7d88904b923d1d9a69d51\",\"license\":\"CC-BY-NC-ND-4.0\"},\"contracts/interfaces/IOracleWrapper.sol\":{\"content\":\"//SPDX-License-Identifier: CC-BY-NC-ND-4.0\\npragma solidity 0.8.7;\\n\\n/// @title The oracle wrapper contract interface\\ninterface IOracleWrapper {\\n    function oracle() external view returns (address);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function deployer() external view returns (address);\\n\\n    // #### Functions\\n\\n    /**\\n     * @notice Returns the current price for the asset in question\\n     * @return The latest price\\n     */\\n    function getPrice() external view returns (int256);\\n\\n    /**\\n     * @return _price The latest round data price\\n     * @return _data The metadata. Implementations can choose what data to return here\\n     */\\n    function getPriceAndMetadata() external view returns (int256 _price, bytes memory _data);\\n\\n    /**\\n     * @notice Converts from a WAD to normal value\\n     * @return Converted non-WAD value\\n     */\\n    function fromWad(int256 wad) external view returns (int256);\\n\\n    /**\\n     * @notice Updates the underlying oracle state and returns the new price\\n     * @dev Spot oracles must implement but it will be a no-op\\n     */\\n    function poll() external returns (int256);\\n}\\n\",\"keccak256\":\"0x754e2e7cf390f4acae43b4340289465677a3214cfc28d8ea1bb5f07bd74abd4e\",\"license\":\"CC-BY-NC-ND-4.0\"},\"contracts/libraries/PoolSwapLibrary.sol\":{\"content\":\"//SPDX-License-Identifier: CC-BY-NC-ND-4.0\\npragma solidity 0.8.7;\\n\\nimport \\\"abdk-libraries-solidity/ABDKMathQuad.sol\\\";\\n\\n/// @title Library for various useful (mostly) mathematical functions\\nlibrary PoolSwapLibrary {\\n    /// ABDKMathQuad-formatted representation of the number one\\n    bytes16 public constant ONE = 0x3fff0000000000000000000000000000;\\n\\n    /// ABDKMathQuad-formatted representation of negative zero\\n    bytes16 private constant NEGATIVE_ZERO = 0x80000000000000000000000000000000;\\n\\n    /// Maximum number of decimal places supported by this contract\\n    /// (ABDKMathQuad defines this but it's private)\\n    uint256 public constant MAX_DECIMALS = 18;\\n\\n    /// Maximum precision supportable via wad arithmetic (for this contract)\\n    uint256 public constant WAD_PRECISION = 10**18;\\n\\n    /// Information required to update a given user's aggregated balance\\n    struct UpdateData {\\n        bytes16 longPrice;\\n        bytes16 shortPrice;\\n        bytes16 mintingFeeRate;\\n        uint256 currentUpdateIntervalId;\\n        uint256 updateIntervalId;\\n        uint256 longMintSettlement;\\n        uint256 longBurnPoolTokens;\\n        uint256 shortMintSettlement;\\n        uint256 shortBurnPoolTokens;\\n        uint256 longBurnShortMintPoolTokens;\\n        uint256 shortBurnLongMintPoolTokens;\\n        bytes16 burnFee;\\n    }\\n\\n    /// Information about the result of calculating a user's updated aggregate balance\\n    struct UpdateResult {\\n        uint256 _newLongTokens; // Quantity of long pool tokens post-application\\n        uint256 _newShortTokens; // Quantity of short pool tokens post-application\\n        uint256 _longSettlementFee; // The fee taken from ShortBurnLongMint commits\\n        uint256 _shortSettlementFee; // The fee taken from ShortBurnLongMint commits\\n        uint256 _newSettlementTokens; // Quantity of settlement tokens post\\n    }\\n\\n    /// Information required to perform a price change (of the underlying asset)\\n    struct PriceChangeData {\\n        int256 oldPrice;\\n        int256 newPrice;\\n        uint256 longBalance;\\n        uint256 shortBalance;\\n        bytes16 leverageAmount;\\n        bytes16 fee;\\n    }\\n\\n    /**\\n     * @notice Calculates the ratio between two numbers\\n     * @dev Rounds any overflow towards 0. If either parameter is zero, the ratio is 0\\n     * @param _numerator The \\\"parts per\\\" side of the equation. If this is zero, the ratio is zero\\n     * @param _denominator The \\\"per part\\\" side of the equation. If this is zero, the ratio is zero\\n     * @return the ratio, as an ABDKMathQuad number (IEEE 754 quadruple precision floating point)\\n     */\\n    function getRatio(uint256 _numerator, uint256 _denominator) public pure returns (bytes16) {\\n        // Catch the divide by zero error.\\n        if (_denominator == 0) {\\n            return 0;\\n        }\\n        return ABDKMathQuad.div(ABDKMathQuad.fromUInt(_numerator), ABDKMathQuad.fromUInt(_denominator));\\n    }\\n\\n    /**\\n     * @notice Multiplies two numbers\\n     * @param x The number to be multiplied by `y`\\n     * @param y The number to be multiplied by `x`\\n     */\\n    function multiplyBytes(bytes16 x, bytes16 y) external pure returns (bytes16) {\\n        return ABDKMathQuad.mul(x, y);\\n    }\\n\\n    /**\\n     * @notice Performs a subtraction on two bytes16 numbers\\n     * @param x The number to be subtracted by `y`\\n     * @param y The number to subtract from `x`\\n     */\\n    function subtractBytes(bytes16 x, bytes16 y) external pure returns (bytes16) {\\n        return ABDKMathQuad.sub(x, y);\\n    }\\n\\n    /**\\n     * @notice Performs an addition on two bytes16 numbers\\n     * @param x The number to be added with `y`\\n     * @param y The number to be added with `x`\\n     */\\n    function addBytes(bytes16 x, bytes16 y) external pure returns (bytes16) {\\n        return ABDKMathQuad.add(x, y);\\n    }\\n\\n    /**\\n     * @notice Gets the short and long balances after the keeper rewards have been paid out\\n     *         Keeper rewards are paid proportionally to the short and long pool\\n     * @dev Assumes shortBalance + longBalance >= reward\\n     * @param reward Amount of keeper reward\\n     * @param shortBalance Short balance of the pool\\n     * @param longBalance Long balance of the pool\\n     * @return shortBalanceAfterFees Short balance of the pool after the keeper reward has been paid\\n     * @return longBalanceAfterFees Long balance of the pool after the keeper reward has been paid\\n     */\\n    function getBalancesAfterFees(\\n        uint256 reward,\\n        uint256 shortBalance,\\n        uint256 longBalance\\n    ) external pure returns (uint256, uint256) {\\n        bytes16 ratioShort = getRatio(shortBalance, shortBalance + longBalance);\\n\\n        uint256 shortFees = convertDecimalToUInt(multiplyDecimalByUInt(ratioShort, reward));\\n\\n        uint256 shortBalanceAfterFees = shortBalance - shortFees;\\n        uint256 longBalanceAfterFees = longBalance - (reward - shortFees);\\n\\n        // Return shortBalance and longBalance after rewards are paid out\\n        return (shortBalanceAfterFees, longBalanceAfterFees);\\n    }\\n\\n    /**\\n     * @notice Compares two decimal numbers\\n     * @param x The first number to compare\\n     * @param y The second number to compare\\n     * @return -1 if x < y, 0 if x = y, or 1 if x > y\\n     */\\n    function compareDecimals(bytes16 x, bytes16 y) public pure returns (int8) {\\n        return ABDKMathQuad.cmp(x, y);\\n    }\\n\\n    /**\\n     * @notice Converts an integer value to a compatible decimal value\\n     * @param amount The amount to convert\\n     * @return The amount as a IEEE754 quadruple precision number\\n     */\\n    function convertUIntToDecimal(uint256 amount) external pure returns (bytes16) {\\n        return ABDKMathQuad.fromUInt(amount);\\n    }\\n\\n    /**\\n     * @notice Converts a raw decimal value to a more readable uint256 value\\n     * @param ratio The value to convert\\n     * @return The converted value\\n     */\\n    function convertDecimalToUInt(bytes16 ratio) public pure returns (uint256) {\\n        return ABDKMathQuad.toUInt(ratio);\\n    }\\n\\n    /**\\n     * @notice Multiplies a decimal and an unsigned integer\\n     * @param a The first term\\n     * @param b The second term\\n     * @return The product of a*b as a decimal\\n     */\\n    function multiplyDecimalByUInt(bytes16 a, uint256 b) public pure returns (bytes16) {\\n        return ABDKMathQuad.mul(a, ABDKMathQuad.fromUInt(b));\\n    }\\n\\n    /**\\n     * @notice Divides two unsigned integers\\n     * @param a The dividend\\n     * @param b The divisor\\n     * @return The quotient\\n     */\\n    function divUInt(uint256 a, uint256 b) private pure returns (bytes16) {\\n        return ABDKMathQuad.div(ABDKMathQuad.fromUInt(a), ABDKMathQuad.fromUInt(b));\\n    }\\n\\n    /**\\n     * @notice Divides two integers\\n     * @param a The dividend\\n     * @param b The divisor\\n     * @return The quotient\\n     */\\n    function divInt(int256 a, int256 b) public pure returns (bytes16) {\\n        return ABDKMathQuad.div(ABDKMathQuad.fromInt(a), ABDKMathQuad.fromInt(b));\\n    }\\n\\n    /**\\n     * @notice Multiply an integer by a fraction\\n     * @notice number * numerator / denominator\\n     * @param number The number with which the fraction calculated from `numerator` and `denominator` will be multiplied\\n     * @param numerator The numerator of the fraction being multipled with `number`\\n     * @param denominator The denominator of the fraction being multipled with `number`\\n     * @return The result of multiplying number with numerator/denominator, as an integer\\n     */\\n    function mulFraction(\\n        uint256 number,\\n        uint256 numerator,\\n        uint256 denominator\\n    ) public pure returns (uint256) {\\n        if (denominator == 0) {\\n            return 0;\\n        }\\n        bytes16 multiplyResult = ABDKMathQuad.mul(ABDKMathQuad.fromUInt(number), ABDKMathQuad.fromUInt(numerator));\\n        bytes16 result = ABDKMathQuad.div(multiplyResult, ABDKMathQuad.fromUInt(denominator));\\n        return convertDecimalToUInt(result);\\n    }\\n\\n    /**\\n     * @notice Calculates the loss multiplier to apply to the losing pool. Includes the power leverage\\n     * @param ratio The ratio of new price to old price\\n     * @param direction The direction of the change. -1 if it's decreased, 0 if it hasn't changed, and 1 if it's increased\\n     * @param leverage The amount of leverage to apply\\n     * @return The multiplier\\n     */\\n    function getLossMultiplier(\\n        bytes16 ratio,\\n        int8 direction,\\n        bytes16 leverage\\n    ) public pure returns (bytes16) {\\n        // If decreased:  2 ^ (leverage * log2[(1 * new/old) + [(0 * 1) / new/old]])\\n        //              = 2 ^ (leverage * log2[(new/old)])\\n        // If increased:  2 ^ (leverage * log2[(0 * new/old) + [(1 * 1) / new/old]])\\n        //              = 2 ^ (leverage * log2([1 / new/old]))\\n        //              = 2 ^ (leverage * log2([old/new]))\\n        return\\n            ABDKMathQuad.pow_2(\\n                ABDKMathQuad.mul(leverage, ABDKMathQuad.log_2(direction < 0 ? ratio : ABDKMathQuad.div(ONE, ratio)))\\n            );\\n    }\\n\\n    /**\\n     * @notice Calculates the amount to take from the losing pool\\n     * @param lossMultiplier The multiplier to use\\n     * @param balance The balance of the losing pool\\n     */\\n    function getLossAmount(bytes16 lossMultiplier, uint256 balance) public pure returns (uint256) {\\n        return\\n            ABDKMathQuad.toUInt(\\n                ABDKMathQuad.mul(ABDKMathQuad.sub(ONE, lossMultiplier), ABDKMathQuad.fromUInt(balance))\\n            );\\n    }\\n\\n    /**\\n     * @notice Calculates the effect of a price change. This involves calculating how many funds to transfer from the losing pool to the other.\\n     * @dev This function should be called by the LeveragedPool\\n     * @dev The value transfer is calculated using a sigmoid function\\n     * @dev The sigmoid function used is defined as follows:\\n     *          when newPrice >= oldPrice\\n     *              losing_pool_multiplier = 2 / (1 + e^(-2 * L * (1 - (newPrice / oldPrice)))) - 1\\n     *          when newPrice < oldPrice\\n     *              losing_pool_multiplier = 2 / (1 + e^(-2 * L * (1 - (oldPrice / newPrice)))) - 1\\n     *          where\\n     *              e = euler's number\\n     *              L = leverage\\n     *              newPrice = the new oracle price\\n     *              oldPrice = the previous oracle price\\n     * @param longBalance Settlement token balance on the long side of the pool before the price change\\n     * @param shortBalance Settlement token balance on the short side of the pool before the price change\\n     * @param leverageAmount The leverage of the pool\\n     * @param oldPrice The previous price\\n     * @param newPrice The new price\\n     * @param fee The pool's annualised protocol fee\\n     * @return Resulting long balance\\n     * @return Resulting short balance\\n     * @return Resulting fees taken from long balance\\n     * @return Resulting fees taken from short balance\\n     */\\n    function calculateValueTransfer(\\n        uint256 longBalance,\\n        uint256 shortBalance,\\n        bytes16 leverageAmount,\\n        int256 oldPrice,\\n        int256 newPrice,\\n        bytes16 fee\\n    )\\n        external\\n        pure\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        // Copy into a struct (otherwise stack gets too deep)\\n        PriceChangeData memory priceChangeData = PoolSwapLibrary.PriceChangeData(\\n            oldPrice,\\n            newPrice,\\n            longBalance,\\n            shortBalance,\\n            leverageAmount,\\n            fee\\n        );\\n        // Calculate fees from long and short sides\\n        uint256 longFeeAmount = convertDecimalToUInt(\\n            multiplyDecimalByUInt(priceChangeData.fee, priceChangeData.longBalance)\\n        ) / PoolSwapLibrary.WAD_PRECISION;\\n        uint256 shortFeeAmount = convertDecimalToUInt(\\n            multiplyDecimalByUInt(priceChangeData.fee, priceChangeData.shortBalance)\\n        ) / PoolSwapLibrary.WAD_PRECISION;\\n\\n        priceChangeData.shortBalance -= shortFeeAmount;\\n        priceChangeData.longBalance -= longFeeAmount;\\n\\n        uint256 sumBeforePriceChange = priceChangeData.shortBalance + priceChangeData.longBalance;\\n\\n        if (newPrice >= oldPrice && priceChangeData.shortBalance > 0) {\\n            // Price increased\\n            // Using the sigmoid function defined in the function's natspec, move funds from short side to long side\\n            bytes16 ratio = divInt(priceChangeData.oldPrice, priceChangeData.newPrice);\\n            bytes16 poolMultiplier = sigmoid(leverageAmount, ratio);\\n\\n            priceChangeData.longBalance += ABDKMathQuad.toUInt(\\n                ABDKMathQuad.mul(ABDKMathQuad.fromUInt(priceChangeData.shortBalance), poolMultiplier)\\n            );\\n            priceChangeData.shortBalance = ABDKMathQuad.toUInt(\\n                ABDKMathQuad.mul(\\n                    ABDKMathQuad.fromUInt(priceChangeData.shortBalance),\\n                    ABDKMathQuad.sub(ONE, poolMultiplier)\\n                )\\n            );\\n        } else if (newPrice < oldPrice && priceChangeData.longBalance > 0) {\\n            // Price decreased\\n            // Using the sigmoid function defined in the function's natspec, move funds from long side to short side\\n            bytes16 ratio = divInt(priceChangeData.newPrice, priceChangeData.oldPrice);\\n            bytes16 poolMultiplier = sigmoid(leverageAmount, ratio);\\n\\n            priceChangeData.shortBalance += ABDKMathQuad.toUInt(\\n                ABDKMathQuad.mul(ABDKMathQuad.fromUInt(priceChangeData.longBalance), poolMultiplier)\\n            );\\n            priceChangeData.longBalance = ABDKMathQuad.toUInt(\\n                ABDKMathQuad.mul(\\n                    ABDKMathQuad.fromUInt(priceChangeData.longBalance),\\n                    ABDKMathQuad.sub(ONE, poolMultiplier)\\n                )\\n            );\\n        }\\n\\n        if (sumBeforePriceChange > priceChangeData.longBalance + priceChangeData.shortBalance) {\\n            // Move dust into winning side\\n            // This is only ever 1 wei (negligible)\\n            if (newPrice > oldPrice) {\\n                priceChangeData.longBalance +=\\n                    sumBeforePriceChange -\\n                    (priceChangeData.longBalance + priceChangeData.shortBalance);\\n            } else {\\n                priceChangeData.shortBalance +=\\n                    sumBeforePriceChange -\\n                    (priceChangeData.longBalance + priceChangeData.shortBalance);\\n            }\\n        }\\n\\n        return (priceChangeData.longBalance, priceChangeData.shortBalance, longFeeAmount, shortFeeAmount);\\n    }\\n\\n    /**\\n     * @notice Use a sigmoid function to determine the losing pool multiplier.\\n     * @return The losing pool multiplier, represented as an ABDKMathQuad IEEE754 quadruple-precision binary floating-point numbers\\n     * @dev The returned value is used in `calculateValueTransfer` as the portion to move from the losing side into the winning side\\n     */\\n    function sigmoid(bytes16 leverage, bytes16 ratio) private pure returns (bytes16) {\\n        /**\\n         * denominator = 1 + e ^ (-2 * leverage * (1 - ratio))\\n         */\\n        bytes16 denominator = ABDKMathQuad.mul(ABDKMathQuad.fromInt(-2), leverage);\\n        denominator = ABDKMathQuad.mul(denominator, ABDKMathQuad.sub(ONE, ratio));\\n        denominator = ABDKMathQuad.add(ONE, ABDKMathQuad.exp(denominator));\\n        bytes16 numerator = ABDKMathQuad.add(ONE, ONE); // 2\\n        return ABDKMathQuad.sub((ABDKMathQuad.div(numerator, denominator)), ONE);\\n    }\\n\\n    /**\\n     * @notice Returns true if the given timestamp is BEFORE the frontRunningInterval starts\\n     * @param subjectTime The timestamp for which you want to calculate if it was beforeFrontRunningInterval\\n     * @param lastPriceTimestamp The timestamp of the last price update\\n     * @param updateInterval The interval between price updates\\n     * @param frontRunningInterval The window of time before a price update in which users can have their commit executed from\\n     */\\n    function isBeforeFrontRunningInterval(\\n        uint256 subjectTime,\\n        uint256 lastPriceTimestamp,\\n        uint256 updateInterval,\\n        uint256 frontRunningInterval\\n    ) public pure returns (bool) {\\n        return lastPriceTimestamp + updateInterval - frontRunningInterval > subjectTime;\\n    }\\n\\n    /**\\n     * @notice Calculates the update interval ID that a commitment should be placed in.\\n     * @param timestamp Current block.timestamp\\n     * @param lastPriceTimestamp The timestamp of the last price update\\n     * @param frontRunningInterval The frontrunning interval of a pool - The amount of time before an update interval that you must commit to get included in that update\\n     * @param updateInterval The frequency of a pool's updates\\n     * @param currentUpdateIntervalId The current update interval's ID\\n     * @dev Note that the timestamp parameter is required to be >= lastPriceTimestamp\\n     * @return The update interval ID in which a commit being made at time timestamp should be included\\n     */\\n    function appropriateUpdateIntervalId(\\n        uint256 timestamp,\\n        uint256 lastPriceTimestamp,\\n        uint256 frontRunningInterval,\\n        uint256 updateInterval,\\n        uint256 currentUpdateIntervalId\\n    ) external pure returns (uint256) {\\n        require(lastPriceTimestamp <= timestamp, \\\"timestamp in the past\\\");\\n        if (frontRunningInterval <= updateInterval) {\\n            // This is the \\\"simple\\\" case where we either want the current update interval or the next one\\n            if (isBeforeFrontRunningInterval(timestamp, lastPriceTimestamp, updateInterval, frontRunningInterval)) {\\n                // We are before the frontRunning interval\\n                return currentUpdateIntervalId;\\n            } else {\\n                // Floor of `timePassed / updateInterval` to get the number of intervals passed\\n                uint256 updateIntervalsPassed = (timestamp - lastPriceTimestamp) / updateInterval;\\n                // If 1 update interval has passed, we want to check if we are within the frontrunning interval of currentUpdateIntervalId + 1\\n                uint256 frontRunningIntervalStart = lastPriceTimestamp +\\n                    ((updateIntervalsPassed + 1) * updateInterval) -\\n                    frontRunningInterval;\\n                if (timestamp >= frontRunningIntervalStart) {\\n                    // add an extra update interval because the frontrunning interval has passed\\n                    return currentUpdateIntervalId + updateIntervalsPassed + 1;\\n                } else {\\n                    return currentUpdateIntervalId + updateIntervalsPassed;\\n                }\\n            }\\n        } else {\\n            // frontRunningInterval > updateInterval\\n            // This is the generalised case, where it could be any number of update intervals in the future\\n            // Minimum time is the earliest we could possible execute this commitment (i.e. the current time plus frontrunning interval)\\n            uint256 minimumTime = timestamp + frontRunningInterval;\\n            // Number of update intervals that would have had to have passed.\\n            uint256 updateIntervals = (minimumTime - lastPriceTimestamp) / updateInterval;\\n\\n            return currentUpdateIntervalId + updateIntervals;\\n        }\\n    }\\n\\n    /**\\n     * @notice Gets the number of settlement tokens to be withdrawn based on a pool token burn amount\\n     * @dev Calculates as `balance * amountIn / (tokenSupply + shadowBalance)\\n     * @param tokenSupply Total supply of pool tokens\\n     * @param amountIn Commitment amount of pool tokens going into the pool\\n     * @param balance Balance of the pool (no. of underlying settlement tokens in pool)\\n     * @param pendingBurnPoolTokens Amount of pool tokens being burnt during this update interval\\n     * @return Number of settlement tokens to be withdrawn on a burn\\n     */\\n    function getWithdrawAmountOnBurn(\\n        uint256 tokenSupply,\\n        uint256 amountIn,\\n        uint256 balance,\\n        uint256 pendingBurnPoolTokens\\n    ) external pure returns (uint256) {\\n        // Catch the divide by zero error, or return 0 if amountIn is 0\\n        if ((balance == 0) || (tokenSupply + pendingBurnPoolTokens == 0) || (amountIn == 0)) {\\n            return amountIn;\\n        }\\n        return (balance * amountIn) / (tokenSupply + pendingBurnPoolTokens);\\n    }\\n\\n    /**\\n     * @notice Gets the number of pool tokens to be minted based on existing tokens\\n     * @dev Calculated as (tokenSupply + shadowBalance) * amountIn / balance\\n     * @param tokenSupply Total supply of pool tokens\\n     * @param amountIn Commitment amount of settlement tokens going into the pool\\n     * @param balance Balance of the pool (no. of underlying settlement tokens in pool)\\n     * @param pendingBurnPoolTokens Amount of pool tokens being burnt during this update interval\\n     * @return Number of pool tokens to be minted\\n     */\\n    function getMintAmount(\\n        uint256 tokenSupply,\\n        uint256 amountIn,\\n        uint256 balance,\\n        uint256 pendingBurnPoolTokens\\n    ) external pure returns (uint256) {\\n        // Catch the divide by zero error, or return 0 if amountIn is 0\\n        if (balance == 0 || tokenSupply + pendingBurnPoolTokens == 0 || amountIn == 0) {\\n            return amountIn;\\n        }\\n\\n        return ((tokenSupply + pendingBurnPoolTokens) * amountIn) / balance;\\n    }\\n\\n    /**\\n     * @notice Get the Settlement/PoolToken price, in ABDK IEE754 precision\\n     * @dev Divide the side balance by the pool token's total supply\\n     * @param sideBalance no. of underlying settlement tokens on that side of the pool\\n     * @param tokenSupply Total supply of pool tokens\\n     */\\n    function getPrice(uint256 sideBalance, uint256 tokenSupply) external pure returns (bytes16) {\\n        if (tokenSupply == 0) {\\n            return ONE;\\n        }\\n        return ABDKMathQuad.div(ABDKMathQuad.fromUInt(sideBalance), ABDKMathQuad.fromUInt(tokenSupply));\\n    }\\n\\n    /**\\n     * @notice Calculates the number of pool tokens to mint, given some settlement token amount and a price\\n     * @param price Price of a pool token\\n     * @param amount Amount of settlement tokens being used to mint\\n     * @return Quantity of pool tokens to mint\\n     * @dev Throws if price is zero, or IEEE754 negative zero\\n     * @dev `getMint()`\\n     */\\n    function getMint(bytes16 price, uint256 amount) public pure returns (uint256) {\\n        require(price != 0, \\\"price == 0\\\");\\n        require(price != NEGATIVE_ZERO, \\\"price == negative zero\\\");\\n        return ABDKMathQuad.toUInt(ABDKMathQuad.div(ABDKMathQuad.fromUInt(amount), price));\\n    }\\n\\n    /**\\n     * @notice Calculate the number of settlement tokens to return, based on a price and an amount of pool tokens being burnt\\n     * @param price Price of a pool token\\n     * @param amount Amount of pool tokens being used to burn\\n     * @return Quantity of settlement tokens to return to the user after `amount` pool tokens are burnt.\\n     * @dev amount * price, where amount is in PoolToken and price is in USD/PoolToken\\n     * @dev Throws if price is zero, or IEEE754 negative zero\\n     * @dev `getBurn()`\\n     */\\n    function getBurn(bytes16 price, uint256 amount) public pure returns (uint256) {\\n        require(price != 0, \\\"price == 0\\\");\\n        require(price != NEGATIVE_ZERO, \\\"price == negative zero\\\");\\n        return ABDKMathQuad.toUInt(ABDKMathQuad.mul(ABDKMathQuad.fromUInt(amount), price));\\n    }\\n\\n    /**\\n     * @notice Calculate the amount of settlement tokens to take as the minting fee\\n     * @param feeRate PoolCommitter's mintingFee or burningFee - The amount that is extracted from each mint or burn. Given as the decimal * 10 ^ 18. For example, 60% fee is 0.6 * 10 ^ 18 Fees can be 0.\\n     * @param amount The amount of settlement tokens being committed to mint\\n     */\\n    function mintingOrBurningFee(bytes16 feeRate, uint256 amount) public pure returns (uint256) {\\n        return ABDKMathQuad.toUInt(multiplyDecimalByUInt(feeRate, amount)) / WAD_PRECISION;\\n    }\\n\\n    /**\\n     * @notice Converts from a WAD to normal value\\n     * @param _wadValue wad number\\n     * @param _decimals Quantity of decimal places to support\\n     * @return Converted (non-WAD) value\\n     */\\n    function fromWad(uint256 _wadValue, uint256 _decimals) external pure returns (uint256) {\\n        uint256 scaler = 10**(MAX_DECIMALS - _decimals);\\n        return _wadValue / scaler;\\n    }\\n\\n    /**\\n     * @notice Given an amount of pool tokens to flip to the other side of the pool, calculate the amount of settlement tokens generated from the burn, burn fee, and subsequent minting fee\\n     * @dev Takes out the burn fee before taking out the mint fee.\\n     * @param amount The amount of pool tokens being flipped\\n     * @param burnPrice The price of the pool token being burnt\\n     * @param burningFee Fee rate for pool token burns\\n     * @param mintingFee Fee rate for mints\\n     * @return Amount of settlement tokens used to mint.\\n     * @return The burn fee. This should be given to the side of the pool of the burnt tokens.\\n     * @return The mint fee. This should be given to the side of the pool that is being minted into.\\n     */\\n    function processBurnInstantMintCommit(\\n        uint256 amount,\\n        bytes16 burnPrice,\\n        bytes16 burningFee,\\n        bytes16 mintingFee\\n    )\\n        public\\n        pure\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        // Settlement tokens earned from burning pool tokens (for instant mint)\\n        uint256 mintSettlement = getBurn(burnPrice, amount);\\n        // The burn fee. This should be given to the side of the pool of the burnt tokens.\\n        uint256 burnFee = mintingOrBurningFee(burningFee, mintSettlement);\\n        mintSettlement -= burnFee;\\n\\n        // The mint fee. This should be given to the side of the pool that is being minted into.\\n        uint256 mintFee = mintingOrBurningFee(mintingFee, mintSettlement);\\n        mintSettlement -= mintFee;\\n        return (mintSettlement, burnFee, mintFee);\\n    }\\n\\n    /**\\n     * @notice Calculate the change in a user's balance based on recent commit(s)\\n     * @param data Information needed for updating the balance including prices and recent commit amounts\\n     * @return The UpdateResult struct with the data pertaining to the update of user's aggregate balance\\n     */\\n    function getUpdatedAggregateBalance(UpdateData calldata data) external pure returns (UpdateResult memory) {\\n        UpdateResult memory result = UpdateResult(0, 0, 0, 0, 0);\\n        if (data.updateIntervalId >= data.currentUpdateIntervalId) {\\n            // Update interval has not passed: No change\\n            return result;\\n        }\\n\\n        /**\\n         * Start by looking at the \\\"flip\\\" commitments (either LongBurnShortMint, or ShortBurnLongMint), and determine the amount of settlement tokens were generated from them.\\n         * Then, take the burning fee off them and add that to the relevant side's fee amount. e.g. a ShortBurnLongMint will generate burn fees for the short side.\\n         * Now, we can calculate how much minting fee should be paid by the user. This should then be added to the side which they are minting on.\\n         */\\n        uint256 shortBurnLongMintResult; // Settlement to be included in the long mint\\n        uint256 longBurnShortMintResult; // Settlement to be included in the short mint\\n        if (data.shortBurnLongMintPoolTokens > 0) {\\n            uint256 burnFeeSettlement;\\n            uint256 mintFeeSettlement;\\n            (shortBurnLongMintResult, burnFeeSettlement, mintFeeSettlement) = processBurnInstantMintCommit(\\n                data.shortBurnLongMintPoolTokens,\\n                data.shortPrice,\\n                data.burnFee,\\n                data.mintingFeeRate\\n            );\\n            result._shortSettlementFee += burnFeeSettlement;\\n            result._longSettlementFee += mintFeeSettlement;\\n        }\\n        if (data.longBurnShortMintPoolTokens > 0) {\\n            // Settlement tokens earned from burning long tokens (for instant mint)\\n            longBurnShortMintResult = getBurn(data.longPrice, data.longBurnShortMintPoolTokens);\\n            // The burn fee taken from this burn. This should be given to the long side.\\n            uint256 burnFeeSettlement = mintingOrBurningFee(data.burnFee, longBurnShortMintResult);\\n            longBurnShortMintResult -= burnFeeSettlement;\\n\\n            // The mint fee taken from the subsequent mint\\n            uint256 mintFeeSettlement = mintingOrBurningFee(data.mintingFeeRate, longBurnShortMintResult);\\n            longBurnShortMintResult -= mintFeeSettlement;\\n\\n            result._longSettlementFee += burnFeeSettlement;\\n            result._shortSettlementFee += mintFeeSettlement;\\n        }\\n\\n        /**\\n         * Calculate the new long tokens minted.\\n         * Use amount committed LongMint/ShortMint, as well as settlement tokens generated from ShortBurnLongMint/LongBurnShortMint commits.\\n         */\\n        if (data.longMintSettlement > 0 || shortBurnLongMintResult > 0) {\\n            result._newLongTokens += getMint(data.longPrice, data.longMintSettlement + shortBurnLongMintResult);\\n        }\\n        if (data.shortMintSettlement > 0 || longBurnShortMintResult > 0) {\\n            result._newShortTokens += getMint(data.shortPrice, data.shortMintSettlement + longBurnShortMintResult);\\n        }\\n\\n        /**\\n         * Calculate the settlement tokens earned through LongBurn/ShortBurn commits.\\n         * Once this is calculated, take off the burn fee, and add to the respective side's fee amount.\\n         */\\n        if (data.longBurnPoolTokens > 0) {\\n            // Calculate the amount of settlement tokens earned from burning long tokens\\n            uint256 longBurnResult = getBurn(data.longPrice, data.longBurnPoolTokens);\\n            // Calculate the fee\\n            uint256 longBurnFee = mintingOrBurningFee(data.burnFee, longBurnResult);\\n            result._longSettlementFee += longBurnFee;\\n            // Subtract the fee from settlement token amount\\n            longBurnResult -= longBurnFee;\\n            result._newSettlementTokens += longBurnResult;\\n        }\\n        if (data.shortBurnPoolTokens > 0) {\\n            // Calculate the amount of settlement tokens earned from burning short tokens\\n            uint256 shortBurnResult = getBurn(data.shortPrice, data.shortBurnPoolTokens);\\n            // Calculate the fee\\n            uint256 shortBurnFee = mintingOrBurningFee(data.burnFee, shortBurnResult);\\n            result._shortSettlementFee += shortBurnFee;\\n            // Subtract the fee from settlement token amount\\n            shortBurnResult -= shortBurnFee;\\n            result._newSettlementTokens += shortBurnResult;\\n        }\\n\\n        return result;\\n    }\\n}\\n\",\"keccak256\":\"0xb03e3b47d1bb12966bf15030a1b340f09e573e60012770338468245a1abeb33a\",\"license\":\"CC-BY-NC-ND-4.0\"}},\"version\":1}",
  "bytecode": "0x60a060405234801561001057600080fd5b5060405161132738038061132783398101604081905261002f9161009e565b6001600160a01b0381166100895760405162461bcd60e51b815260206004820152601e60248201527f506f6f6c4b65657065722063616e6e6f74206265203020616464726573730000604482015260640160405180910390fd5b60601b6001600160601b0319166080526100ce565b6000602082840312156100b057600080fd5b81516001600160a01b03811681146100c757600080fd5b9392505050565b60805160601c6112346100f36000396000818161011501526101a501526112346000f3fe608060405234801561001057600080fd5b50600436106100a95760003560e01c8063aea8acb111610071578063aea8acb114610108578063b9c653651461014f578063c9584e6814610162578063cd590b5714610175578063f6bd4a9514610188578063f93019101461019057600080fd5b8063348c2b1f146100ae578063556ede80146100d45780637a458d7a146100de5780639f9a3d9514610108578063aced166114610110575b600080fd5b6100c16100bc366004610ead565b610198565b6040519081526020015b60405180910390f35b6100c16201394381565b6100ef668075782dace9d960c71b81565b6040516001600160801b031990911681526020016100cb565b6100c1600581565b6101377f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b0390911681526020016100cb565b6100c161015d366004610f8d565b610556565b6100c1610170366004610faf565b6105b8565b6100c1610183366004610f06565b61062d565b6100c1606481565b6100c1600d81565b6000336001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000161461020f5760405162461bcd60e51b815260206004820152601560248201527436b9b39739b2b73232b9103737ba1035b2b2b832b960591b60448201526064015b60405180910390fd5b856001600160a01b0316638226f3966040518163ffffffff1660e01b815260040160206040518083038186803b15801561024857600080fd5b505afa15801561025c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102809190610e90565b6001600160a01b031663a11752796040518163ffffffff1660e01b8152600401602060405180830381600087803b1580156102ba57600080fd5b505af19250505080156102ea575060408051601f3d908101601f191682019092526102e791810190610f74565b60015b610369576102f6611140565b806308c379a0141561035d575061030b61115c565b80610316575061035f565b866001600160a01b03167f8a47468bf96478429d382ed6385d9c77fba8b89540cd88199b1b51d5723b11fa8260405161034f9190610ffe565b60405180910390a25061036b565b505b3d6000803e3d6000fd5b505b6000866001600160a01b0316638226f3966040518163ffffffff1660e01b815260040160206040518083038186803b1580156103a657600080fd5b505afa1580156103ba573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103de9190610e90565b6001600160a01b03166398d5fdca6040518163ffffffff1660e01b815260040160206040518083038186803b15801561041657600080fd5b505afa15801561042a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061044e9190610f74565b905060008112156104a15760405162461bcd60e51b815260206004820152601d60248201527f736574746c656d656e74207072696365206d757374206265203e3d20300000006044820152606401610206565b60006104b188888888888761062d565b604051636dc2b27160e01b81526001600160a01b038b811660048301526024820183905291925090891690636dc2b27190604401602060405180830381600087803b1580156104ff57600080fd5b505af1158015610513573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105379190610f52565b1561054557915061054c9050565b6000925050505b9695505050505050565b6000806105638385611053565b61056d90426110ac565b90506000600d61057e83600561108d565b610588919061106b565b610593906005611053565b905060648111156105a9576064925050506105b2565b91506105b29050565b92915050565b6000816105c757506000610626565b60006105d66201394385611053565b905060006105ec6105e7838861108d565b6107f3565b905060006105f9856107f3565b905061062061061b61060b8484610857565b668075782dace9d960c71b610ad4565b610d6a565b93505050505b9392505050565b60008061063b8787856105b8565b905060006106498686610556565b905060006064610659838561108d565b610663919061106b565b61066d9084611053565b905060008a6001600160a01b0316637b9e618d6040518163ffffffff1660e01b815260040160206040518083038186803b1580156106aa57600080fd5b505afa1580156106be573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106e29190610e90565b6001600160a01b031663313ce5676040518163ffffffff1660e01b815260040160206040518083038186803b15801561071a57600080fd5b505afa15801561072e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107529190610fdb565b60405163bf36f0e960e01b81526004810184905260ff919091166024820181905291507358639957c0E526fF4E4Bb1cBfBDFeFdeb16Af2379063bf36f0e99060440160206040518083038186803b1580156107ac57600080fd5b505af41580156107c0573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107e49190610f74565b9b9a5050505050505050505050565b60008161080257506000919050565b81600061080e82610ded565b90506070811015610827578060700382901b915061083a565b607081111561083a576070810382901c91505b613fff0160701b6001600160701b03919091161760801b92915050565b6000617fff60f084811c8216919084901c8116908214156109075780617fff14156108d5576001600160801b031985811690851614156108a257505050600160ff1b811682186105b2565b600160ff1b6001600160801b03198686181614156108c5575050508181176105b2565b5061ffff60ef1b91506105b29050565b600160801b600160ff1b0384166108f6575061ffff60ef1b91506105b29050565b505050600160ff1b811682186105b2565b80617fff141561094357600160801b600160ff1b038516610932575061ffff60ef1b91506105b29050565b505050600160ff1b821681186105b2565b6001600160701b03608086901c168261095f5760019250610966565b600160701b175b6001600160701b03608086901c16826109825760019250610989565b600160701b175b90810290816109b757600160ff1b878718166109a65760006109ac565b600160ff1b5b9450505050506105b2565b928201926000600160e11b8310156109ea57600160e01b8310156109e3576109de83610ded565b6109ed565b60e06109ed565b60e15b90506140708186011015610a08576000945060009250610aa5565b6140e08186011015610a4b57614070851015610a2d57846140700383901c9250610a42565b614070851115610a4257614070850383901b92505b60009450610aa5565b61c0dd8186011115610a6557617fff945060009250610aa5565b6070811115610a7c576070810383901c9250610a8f565b6070811015610a8f578060700383901b92505b6001600160701b03831692506140df8186010394505b82607086901b888a186001607f1b60801b1660801c6001600160801b0316171760801b955050505050506105b2565b6000617fff60f084811c8216919084901c811690821415610b095780617fff14156108f6575061ffff60ef1b91506105b29050565b80617fff1415610b4d576dffffffffffffffffffffffffffff60801b841615610b3c575061ffff60ef1b91506105b29050565b505050808218600160ff1b166105b2565b600160801b600160ff1b038416610b9757600160801b600160ff1b038516610b7f575061ffff60ef1b91506105b29050565b505050808218600160ff1b16617fff60f01b176105b2565b6001600160701b03608085901c1681610bb35760019150610bba565b600160701b175b6001600160701b03608087901c1683610bf9578015610bf4576000610bde82610ded565b6001955060e20393840160711901939190911b90505b610c03565b600160701b1760721b5b818181610c1257610c1261112a565b04905080610c2e57600160ff1b878718166109a65760006109ac565b6001606c1b811015610c4257610c426110fe565b6000600160731b821015610c8157600160721b821015610c7657600160711b821015610c6f576070610c79565b6071610c79565b60725b60ff16610c8a565b610c8a82610ded565b905083614071018186011115610ca857617fff945060009150610d3b565b83818601613ffc011015610cc3576000945060009150610d3b565b83818601613f8c011015610d10578385613ffc011115610cee578385613ffc010382901b9150610d07565b8385613ffc011015610d0757613ffc8585030382901c91505b60009450610d3b565b6070811115610d23576070810382901c91505b6001600160701b038216915083818601613f8d010394505b81607086901b888a186001607f1b60801b1660801c6001600160801b0316171760801b955050505050506105b2565b6000617fff60f083901c16613fff811015610d885750600092915050565b6001607f1b608084901c10610d9c57600080fd5b6140fe811115610dab57600080fd5b600160701b6001600160701b03608085901c161761406f821015610dd55761406f8290031c610626565b61406f8211156106265761406e1982011b9392505050565b6000808211610dfb57600080fd5b6000600160801b8310610e1057608092831c92015b680100000000000000008310610e2857604092831c92015b6401000000008310610e3c57602092831c92015b620100008310610e4e57601092831c92015b6101008310610e5f57600892831c92015b60108310610e6f57600492831c92015b60048310610e7f57600292831c92015b600283106105b25760010192915050565b600060208284031215610ea257600080fd5b8151610626816111e6565b60008060008060008060c08789031215610ec657600080fd5b8635610ed1816111e6565b95506020870135610ee1816111e6565b95989597505050506040840135936060810135936080820135935060a0909101359150565b60008060008060008060c08789031215610f1f57600080fd5b8635610f2a816111e6565b9860208801359850604088013597606081013597506080810135965060a00135945092505050565b600060208284031215610f6457600080fd5b8151801515811461062657600080fd5b600060208284031215610f8657600080fd5b5051919050565b60008060408385031215610fa057600080fd5b50508035926020909101359150565b600080600060608486031215610fc457600080fd5b505081359360208301359350604090920135919050565b600060208284031215610fed57600080fd5b815160ff8116811461062657600080fd5b600060208083528351808285015260005b8181101561102b5785810183015185820160400152820161100f565b8181111561103d576000604083870101525b50601f01601f1916929092016040019392505050565b6000821982111561106657611066611114565b500190565b60008261108857634e487b7160e01b600052601260045260246000fd5b500490565b60008160001904831182151516156110a7576110a7611114565b500290565b6000828210156110be576110be611114565b500390565b601f8201601f1916810167ffffffffffffffff811182821017156110f757634e487b7160e01b600052604160045260246000fd5b6040525050565b634e487b7160e01b600052600160045260246000fd5b634e487b7160e01b600052601160045260246000fd5b634e487b7160e01b600052601260045260246000fd5b600060033d11156111595760046000803e5060005160e01c5b90565b600060443d101561116a5790565b6040516003193d81016004833e81513d67ffffffffffffffff816024840111818411171561119a57505050505090565b82850191508151818111156111b25750505050505090565b843d87010160208285010111156111cc5750505050505090565b6111db602082860101876110c3565b509095945050505050565b6001600160a01b03811681146111fb57600080fd5b5056fea2646970667358221220e3deacb343b3ad07d6fca0f0fc9d58098c03fc13e0044428c760142b7b41eb4f64736f6c63430008070033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100a95760003560e01c8063aea8acb111610071578063aea8acb114610108578063b9c653651461014f578063c9584e6814610162578063cd590b5714610175578063f6bd4a9514610188578063f93019101461019057600080fd5b8063348c2b1f146100ae578063556ede80146100d45780637a458d7a146100de5780639f9a3d9514610108578063aced166114610110575b600080fd5b6100c16100bc366004610ead565b610198565b6040519081526020015b60405180910390f35b6100c16201394381565b6100ef668075782dace9d960c71b81565b6040516001600160801b031990911681526020016100cb565b6100c1600581565b6101377f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b0390911681526020016100cb565b6100c161015d366004610f8d565b610556565b6100c1610170366004610faf565b6105b8565b6100c1610183366004610f06565b61062d565b6100c1606481565b6100c1600d81565b6000336001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000161461020f5760405162461bcd60e51b815260206004820152601560248201527436b9b39739b2b73232b9103737ba1035b2b2b832b960591b60448201526064015b60405180910390fd5b856001600160a01b0316638226f3966040518163ffffffff1660e01b815260040160206040518083038186803b15801561024857600080fd5b505afa15801561025c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102809190610e90565b6001600160a01b031663a11752796040518163ffffffff1660e01b8152600401602060405180830381600087803b1580156102ba57600080fd5b505af19250505080156102ea575060408051601f3d908101601f191682019092526102e791810190610f74565b60015b610369576102f6611140565b806308c379a0141561035d575061030b61115c565b80610316575061035f565b866001600160a01b03167f8a47468bf96478429d382ed6385d9c77fba8b89540cd88199b1b51d5723b11fa8260405161034f9190610ffe565b60405180910390a25061036b565b505b3d6000803e3d6000fd5b505b6000866001600160a01b0316638226f3966040518163ffffffff1660e01b815260040160206040518083038186803b1580156103a657600080fd5b505afa1580156103ba573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103de9190610e90565b6001600160a01b03166398d5fdca6040518163ffffffff1660e01b815260040160206040518083038186803b15801561041657600080fd5b505afa15801561042a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061044e9190610f74565b905060008112156104a15760405162461bcd60e51b815260206004820152601d60248201527f736574746c656d656e74207072696365206d757374206265203e3d20300000006044820152606401610206565b60006104b188888888888761062d565b604051636dc2b27160e01b81526001600160a01b038b811660048301526024820183905291925090891690636dc2b27190604401602060405180830381600087803b1580156104ff57600080fd5b505af1158015610513573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105379190610f52565b1561054557915061054c9050565b6000925050505b9695505050505050565b6000806105638385611053565b61056d90426110ac565b90506000600d61057e83600561108d565b610588919061106b565b610593906005611053565b905060648111156105a9576064925050506105b2565b91506105b29050565b92915050565b6000816105c757506000610626565b60006105d66201394385611053565b905060006105ec6105e7838861108d565b6107f3565b905060006105f9856107f3565b905061062061061b61060b8484610857565b668075782dace9d960c71b610ad4565b610d6a565b93505050505b9392505050565b60008061063b8787856105b8565b905060006106498686610556565b905060006064610659838561108d565b610663919061106b565b61066d9084611053565b905060008a6001600160a01b0316637b9e618d6040518163ffffffff1660e01b815260040160206040518083038186803b1580156106aa57600080fd5b505afa1580156106be573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106e29190610e90565b6001600160a01b031663313ce5676040518163ffffffff1660e01b815260040160206040518083038186803b15801561071a57600080fd5b505afa15801561072e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107529190610fdb565b60405163bf36f0e960e01b81526004810184905260ff9190911660248201819052915073__$1c55304bb94fd620584ae538170217172c$__9063bf36f0e99060440160206040518083038186803b1580156107ac57600080fd5b505af41580156107c0573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107e49190610f74565b9b9a5050505050505050505050565b60008161080257506000919050565b81600061080e82610ded565b90506070811015610827578060700382901b915061083a565b607081111561083a576070810382901c91505b613fff0160701b6001600160701b03919091161760801b92915050565b6000617fff60f084811c8216919084901c8116908214156109075780617fff14156108d5576001600160801b031985811690851614156108a257505050600160ff1b811682186105b2565b600160ff1b6001600160801b03198686181614156108c5575050508181176105b2565b5061ffff60ef1b91506105b29050565b600160801b600160ff1b0384166108f6575061ffff60ef1b91506105b29050565b505050600160ff1b811682186105b2565b80617fff141561094357600160801b600160ff1b038516610932575061ffff60ef1b91506105b29050565b505050600160ff1b821681186105b2565b6001600160701b03608086901c168261095f5760019250610966565b600160701b175b6001600160701b03608086901c16826109825760019250610989565b600160701b175b90810290816109b757600160ff1b878718166109a65760006109ac565b600160ff1b5b9450505050506105b2565b928201926000600160e11b8310156109ea57600160e01b8310156109e3576109de83610ded565b6109ed565b60e06109ed565b60e15b90506140708186011015610a08576000945060009250610aa5565b6140e08186011015610a4b57614070851015610a2d57846140700383901c9250610a42565b614070851115610a4257614070850383901b92505b60009450610aa5565b61c0dd8186011115610a6557617fff945060009250610aa5565b6070811115610a7c576070810383901c9250610a8f565b6070811015610a8f578060700383901b92505b6001600160701b03831692506140df8186010394505b82607086901b888a186001607f1b60801b1660801c6001600160801b0316171760801b955050505050506105b2565b6000617fff60f084811c8216919084901c811690821415610b095780617fff14156108f6575061ffff60ef1b91506105b29050565b80617fff1415610b4d576dffffffffffffffffffffffffffff60801b841615610b3c575061ffff60ef1b91506105b29050565b505050808218600160ff1b166105b2565b600160801b600160ff1b038416610b9757600160801b600160ff1b038516610b7f575061ffff60ef1b91506105b29050565b505050808218600160ff1b16617fff60f01b176105b2565b6001600160701b03608085901c1681610bb35760019150610bba565b600160701b175b6001600160701b03608087901c1683610bf9578015610bf4576000610bde82610ded565b6001955060e20393840160711901939190911b90505b610c03565b600160701b1760721b5b818181610c1257610c1261112a565b04905080610c2e57600160ff1b878718166109a65760006109ac565b6001606c1b811015610c4257610c426110fe565b6000600160731b821015610c8157600160721b821015610c7657600160711b821015610c6f576070610c79565b6071610c79565b60725b60ff16610c8a565b610c8a82610ded565b905083614071018186011115610ca857617fff945060009150610d3b565b83818601613ffc011015610cc3576000945060009150610d3b565b83818601613f8c011015610d10578385613ffc011115610cee578385613ffc010382901b9150610d07565b8385613ffc011015610d0757613ffc8585030382901c91505b60009450610d3b565b6070811115610d23576070810382901c91505b6001600160701b038216915083818601613f8d010394505b81607086901b888a186001607f1b60801b1660801c6001600160801b0316171760801b955050505050506105b2565b6000617fff60f083901c16613fff811015610d885750600092915050565b6001607f1b608084901c10610d9c57600080fd5b6140fe811115610dab57600080fd5b600160701b6001600160701b03608085901c161761406f821015610dd55761406f8290031c610626565b61406f8211156106265761406e1982011b9392505050565b6000808211610dfb57600080fd5b6000600160801b8310610e1057608092831c92015b680100000000000000008310610e2857604092831c92015b6401000000008310610e3c57602092831c92015b620100008310610e4e57601092831c92015b6101008310610e5f57600892831c92015b60108310610e6f57600492831c92015b60048310610e7f57600292831c92015b600283106105b25760010192915050565b600060208284031215610ea257600080fd5b8151610626816111e6565b60008060008060008060c08789031215610ec657600080fd5b8635610ed1816111e6565b95506020870135610ee1816111e6565b95989597505050506040840135936060810135936080820135935060a0909101359150565b60008060008060008060c08789031215610f1f57600080fd5b8635610f2a816111e6565b9860208801359850604088013597606081013597506080810135965060a00135945092505050565b600060208284031215610f6457600080fd5b8151801515811461062657600080fd5b600060208284031215610f8657600080fd5b5051919050565b60008060408385031215610fa057600080fd5b50508035926020909101359150565b600080600060608486031215610fc457600080fd5b505081359360208301359350604090920135919050565b600060208284031215610fed57600080fd5b815160ff8116811461062657600080fd5b600060208083528351808285015260005b8181101561102b5785810183015185820160400152820161100f565b8181111561103d576000604083870101525b50601f01601f1916929092016040019392505050565b6000821982111561106657611066611114565b500190565b60008261108857634e487b7160e01b600052601260045260246000fd5b500490565b60008160001904831182151516156110a7576110a7611114565b500290565b6000828210156110be576110be611114565b500390565b601f8201601f1916810167ffffffffffffffff811182821017156110f757634e487b7160e01b600052604160045260246000fd5b6040525050565b634e487b7160e01b600052600160045260246000fd5b634e487b7160e01b600052601160045260246000fd5b634e487b7160e01b600052601260045260246000fd5b600060033d11156111595760046000803e5060005160e01c5b90565b600060443d101561116a5790565b6040516003193d81016004833e81513d67ffffffffffffffff816024840111818411171561119a57505050505090565b82850191508151818111156111b25750505050505090565b843d87010160208285010111156111cc5750505050505090565b6111db602082860101876110c3565b509095945050505050565b6001600160a01b03811681146111fb57600080fd5b5056fea2646970667358221220e3deacb343b3ad07d6fca0f0fc9d58098c03fc13e0044428c760142b7b41eb4f64736f6c63430008070033",
  "libraries": {
    "PoolSwapLibrary": "0x58639957c0E526fF4E4Bb1cBfBDFeFdeb16Af237"
  },
  "devdoc": {
    "kind": "dev",
    "methods": {
      "keeperGas(uint256,uint256,uint256)": {
        "details": "Adds a constant to `_gasSpent` when calculating actual gas usage",
        "params": {
          "_gasPrice": "Price of a single gas unit (in ETH (wei))",
          "_gasSpent": "Number of gas units spent"
        },
        "returns": {
          "_0": "Keeper's gas compensation"
        }
      },
      "keeperReward(address,uint256,uint256,uint256,uint256,uint256)": {
        "params": {
          "_gasPrice": "Price of a single gas unit (in ETH (wei))",
          "_gasSpent": "Number of gas units spent",
          "_poolInterval": "Pool interval of the given pool",
          "_savedPreviousUpdatedTimestamp": "Last timestamp when the pool's price execution happened"
        },
        "returns": {
          "_0": "Number of settlement tokens to give to the keeper for work performed"
        }
      },
      "keeperTip(uint256,uint256)": {
        "params": {
          "_poolInterval": "Pool interval of the given pool",
          "_savedPreviousUpdatedTimestamp": "Last timestamp when the pool's price execution happened"
        },
        "returns": {
          "_0": "Percent of the `keeperGas` cost to add to payment, as a percent"
        }
      },
      "payKeeper(address,address,uint256,uint256,uint256,uint256)": {
        "params": {
          "_gasPrice": "Price of a single gas unit (in ETH (wei))",
          "_gasSpent": "Number of gas units spent",
          "_keeper": "Address of the EOA upkeeping the pool. This is required since the function is called externally",
          "_pool": "Address of the given pool",
          "_savedPreviousUpdatedTimestamp": "Last timestamp when the pool's price execution happened",
          "_updateInterval": "Pool interval of the given pool"
        }
      }
    },
    "title": "The contract for calculating and executing keeper reward payments",
    "version": 1
  },
  "userdoc": {
    "events": {
      "PoolUpkeepError(address,string)": {
        "notice": "Creates a notification of a failed pool update"
      }
    },
    "kind": "user",
    "methods": {
      "FIXED_GAS_OVERHEAD()": {
        "notice": "Captures fixed gas overhead for performing upkeep that's unreachable by `gasleft()` due to our approach to error handling in that code"
      },
      "keeperGas(uint256,uint256,uint256)": {
        "notice": "Compensation a keeper will receive for their gas expenditure"
      },
      "keeperReward(address,uint256,uint256,uint256,uint256,uint256)": {
        "notice": "Payment keeper receives for performing upkeep on a given pool"
      },
      "keeperTip(uint256,uint256)": {
        "notice": "Tip a keeper will receive for successfully updating the specified pool"
      },
      "payKeeper(address,address,uint256,uint256,uint256,uint256)": {
        "notice": "Pay keeper for upkeep"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}