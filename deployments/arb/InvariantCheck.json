{
    "address": "0x010641702a9E4cdDe6ad774c09449f05DDeA0fF6",
    "abi": [
        {
            "inputs": [
                {
                    "internalType": "address",
                    "name": "_factory",
                    "type": "address"
                }
            ],
            "stateMutability": "nonpayable",
            "type": "constructor"
        },
        {
            "anonymous": false,
            "inputs": [
                {
                    "indexed": false,
                    "internalType": "string",
                    "name": "message",
                    "type": "string"
                }
            ],
            "name": "InvariantsFail",
            "type": "event"
        },
        {
            "anonymous": false,
            "inputs": [],
            "name": "InvariantsHold",
            "type": "event"
        },
        {
            "inputs": [
                {
                    "internalType": "address",
                    "name": "poolToCheck",
                    "type": "address"
                }
            ],
            "name": "checkInvariants",
            "outputs": [],
            "stateMutability": "nonpayable",
            "type": "function"
        },
        {
            "inputs": [],
            "name": "poolFactory",
            "outputs": [
                {
                    "internalType": "contract IPoolFactory",
                    "name": "",
                    "type": "address"
                }
            ],
            "stateMutability": "view",
            "type": "function"
        }
    ],
    "transactionHash": "0x5a293c1c743f568ed2bfa9ce584fa4468393826703c53a25935cb9a929ecfff6",
    "receipt": {
        "to": null,
        "from": "0xCC97EB5651e05D5a0Ae8bcD2813B9DFDaD6F92a5",
        "contractAddress": "0x010641702a9E4cdDe6ad774c09449f05DDeA0fF6",
        "transactionIndex": 0,
        "gasUsed": "6525687",
        "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
        "blockHash": "0xb232b8e297bec787e572aca708d266134179f0555c4179e6fc99a4d668387e5b",
        "transactionHash": "0x5a293c1c743f568ed2bfa9ce584fa4468393826703c53a25935cb9a929ecfff6",
        "logs": [],
        "blockNumber": 13387546,
        "cumulativeGasUsed": "2750927",
        "status": 1,
        "byzantium": true
    },
    "args": ["0x3Feafee6b12C8d2E58c5B118e54C09F9273c6124"],
    "solcInputHash": "4b024dc169a046e6527f075e446ec886",
    "metadata": "{\"compiler\":{\"version\":\"0.8.7+commit.e28d00a7\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"name\":\"InvariantsFail\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"InvariantsHold\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolToCheck\",\"type\":\"address\"}],\"name\":\"checkInvariants\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolFactory\",\"outputs\":[{\"internalType\":\"contract IPoolFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"checkInvariants(address)\":{\"details\":\"This should be called before onlyUnpaused, in case contracts are paused then pause check must happen after.Emits `InvariantsHold` event if invariants hold.\",\"params\":{\"poolToCheck\":\"The LeveragedPool contract to be checked.\"}},\"constructor\":{\"details\":\"Throws if factory address is null\",\"params\":{\"_factory\":\"Address of the associated `PoolFactory` contract\"}}},\"title\":\"The contract for checking invariants and pausing if necessary\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"checkInvariants(address)\":{\"notice\":\"Checks all invariants, and pauses all contracts if         any invariant does not hold.\"},\"constructor\":{\"notice\":\"Constructor\"}},\"notice\":\"Every time certain functions are called, known invariants are checked and if any do not hold, contracts are paused.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/implementation/InvariantCheck.sol\":\"InvariantCheck\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\",\"keccak256\":\"0x027b891937d20ccf213fdb9c31531574256de774bda99d3a70ecef6e1913ed2a\",\"license\":\"MIT\"},\"contracts/implementation/InvariantCheck.sol\":{\"content\":\"//SPDX-License-Identifier: CC-BY-NC-ND-4.0\\npragma solidity 0.8.7;\\n\\nimport \\\"../interfaces/IInvariantCheck.sol\\\";\\nimport \\\"../interfaces/IPoolCommitter.sol\\\";\\nimport \\\"../interfaces/IPausable.sol\\\";\\nimport \\\"../interfaces/ILeveragedPool.sol\\\";\\nimport \\\"../interfaces/IPoolFactory.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/// @title The contract for checking invariants and pausing if necessary\\n/// @notice Every time certain functions are called, known invariants are checked and if any do not hold, contracts are paused.\\ncontract InvariantCheck is IInvariantCheck {\\n    IPoolFactory public immutable poolFactory;\\n\\n    /**\\n     * @notice Constructor\\n     * @param _factory Address of the associated `PoolFactory` contract\\n     * @dev Throws if factory address is null\\n     */\\n    constructor(address _factory) {\\n        require(_factory != address(0), \\\"Factory cannot be null\\\");\\n        poolFactory = IPoolFactory(_factory);\\n    }\\n\\n    /**\\n     * @notice Checks all invariants, and pauses all contracts if\\n     *         any invariant does not hold.\\n     * @dev This should be called before onlyUnpaused, in case contracts are paused then pause check must happen after.\\n     * @dev Emits `InvariantsHold` event if invariants hold.\\n     * @param poolToCheck The LeveragedPool contract to be checked.\\n     */\\n    function checkInvariants(address poolToCheck) external override {\\n        ILeveragedPool pool = ILeveragedPool(poolToCheck);\\n        require(poolFactory.isValidPool(poolToCheck), \\\"Pool is invalid\\\");\\n        IPoolCommitter poolCommitter = IPoolCommitter(pool.poolCommitter());\\n        uint256 poolBalance = IERC20(pool.settlementToken()).balanceOf(poolToCheck);\\n        uint256 pendingMints = poolCommitter.pendingMintSettlementAmount();\\n        uint256 longBalance = pool.longBalance();\\n        uint256 shortBalance = pool.shortBalance();\\n        if (!balanceInvariant(poolBalance, pendingMints, longBalance, shortBalance)) {\\n            pause(IPausable(poolToCheck), IPausable(address(poolCommitter)));\\n            emit InvariantsFail(\\\"Balance invariant fails\\\");\\n        } else {\\n            emit InvariantsHold();\\n        }\\n    }\\n\\n    /**\\n     * @notice Pause both LeveragedPool and PoolCommitter.\\n     * @dev Both parameters must implement the IPausable interface.\\n     * @param pool The LeveragedPool to be paused.\\n     * @param poolCommitter The PoolCommitter to be paused.\\n     */\\n    function pause(IPausable pool, IPausable poolCommitter) internal {\\n        pool.pause();\\n        poolCommitter.pause();\\n    }\\n\\n    /**\\n     * @notice Check that the balance of a pool is equal to or greater than the summation of pending mints, long balance and short balance\\n     * @return true if balance invariant holds. False if not\\n     * @param balance The amount of settlement tokens owned by the leveraged pool\\n     * @param pendingMints The amount of pending mints in the pool\\n     * @param longBalance The balance of the long side of the pool\\n     * @param shortBalance The balance of the short side of the pool\\n     */\\n    function balanceInvariant(\\n        uint256 balance,\\n        uint256 pendingMints,\\n        uint256 longBalance,\\n        uint256 shortBalance\\n    ) internal pure returns (bool) {\\n        return balance >= pendingMints + longBalance + shortBalance;\\n    }\\n}\\n\",\"keccak256\":\"0x6602f720b9cc97d28091de0e65f11b627122df21c5b7e660e8258e7755fc08bd\",\"license\":\"CC-BY-NC-ND-4.0\"},\"contracts/interfaces/IInvariantCheck.sol\":{\"content\":\"//SPDX-License-Identifier: CC-BY-NC-ND-4.0\\npragma solidity 0.8.7;\\n\\n/// @title The contract factory for the keeper and pool contracts. Utilizes minimal clones to keep gas costs low\\ninterface IInvariantCheck {\\n    event InvariantsHold();\\n    event InvariantsFail(string message);\\n\\n    /**\\n     * @notice Checks all invariants, and pauses all contracts if\\n     *         any invariant does not hold.\\n     */\\n    function checkInvariants(address pool) external;\\n}\\n\",\"keccak256\":\"0x108b25ee123c6fe445b11b50cf862832aec2d12b9a6187d7cfd83bf579ee05dc\",\"license\":\"CC-BY-NC-ND-4.0\"},\"contracts/interfaces/ILeveragedPool.sol\":{\"content\":\"//SPDX-License-Identifier: CC-BY-NC-ND-4.0\\npragma solidity 0.8.7;\\n\\n/// @title The pool controller contract interface\\ninterface ILeveragedPool {\\n    // Initialisation parameters for new market\\n    struct Initialization {\\n        address _owner; // Owner of the contract\\n        address _keeper; // The address of the PoolKeeper contract\\n        address _oracleWrapper; // The oracle wrapper for the derivative price feed\\n        address _settlementEthOracle; // The oracle wrapper for the SettlementToken/ETH price feed\\n        address _longToken; // Address of the long pool token\\n        address _shortToken; // Address of the short pool token\\n        address _poolCommitter; // Address of the PoolCommitter contract\\n        address _invariantCheck; // Address of the InvariantCheck contract\\n        string _poolName; // The pool identification name\\n        uint32 _frontRunningInterval; // The minimum number of seconds that must elapse before a commit is forced to wait until the next interval\\n        uint32 _updateInterval; // The minimum number of seconds that must elapse before a commit can be executed\\n        uint16 _leverageAmount; // The amount of exposure to price movements for the pool\\n        uint256 _fee; // The fund movement fee. This amount is extracted from the deposited asset with every update and sent to the fee address. Given as the decimal * 10 ^ 18. For example, 60% fee is 0.6 * 10 ^ 18\\n        address _feeAddress; // The address that the fund movement fee is sent to\\n        address _secondaryFeeAddress; // The address of fee recieved by third party deployers\\n        address _settlementToken; //  The digital asset that the pool accepts. Must have a decimals() function\\n        uint256 _secondaryFeeSplitPercent; // Percent of fees that go to secondary fee address if it exists\\n    }\\n\\n    // #### Events\\n    /**\\n     * @notice Creates a notification when the pool is setup and ready for use\\n     * @param longToken The address of the LONG pair token\\n     * @param shortToken The address of the SHORT pair token\\n     * @param settlementToken The address of the digital asset that the pool accepts\\n     * @param poolName The identification name of the pool\\n     */\\n    event PoolInitialized(\\n        address indexed longToken,\\n        address indexed shortToken,\\n        address settlementToken,\\n        string poolName\\n    );\\n\\n    /**\\n     * @notice Creates a notification when the pool is rebalanced\\n     * @param shortBalanceChange The change of funds in the short side\\n     * @param longBalanceChange The change of funds in the long side\\n     * @param shortFeeAmount Proportional fee taken from short side\\n     * @param longFeeAmount Proportional fee taken from long side\\n     */\\n    event PoolRebalance(\\n        int256 shortBalanceChange,\\n        int256 longBalanceChange,\\n        uint256 shortFeeAmount,\\n        uint256 longFeeAmount\\n    );\\n\\n    /**\\n     * @notice Creates a notification when the pool's price execution fails\\n     * @param startPrice Price prior to price change execution\\n     * @param endPrice Price during price change execution\\n     */\\n    event PriceChangeError(int256 indexed startPrice, int256 indexed endPrice);\\n\\n    /**\\n     * @notice Represents change in fee receiver's address\\n     * @param oldAddress Previous address\\n     * @param newAddress Address after change\\n     */\\n    event FeeAddressUpdated(address indexed oldAddress, address indexed newAddress);\\n\\n    /**\\n     * @notice Represents change in secondary fee receiver's address\\n     * @param oldAddress Previous address\\n     * @param newAddress Address after change\\n     */\\n    event SecondaryFeeAddressUpdated(address indexed oldAddress, address indexed newAddress);\\n\\n    /**\\n     * @notice Represents change in keeper's address\\n     * @param oldAddress Previous address\\n     * @param newAddress Address after change\\n     */\\n    event KeeperAddressChanged(address indexed oldAddress, address indexed newAddress);\\n\\n    /**\\n     * @notice Indicates a payment of fees to the secondary fee address\\n     * @param secondaryFeeAddress The address that got fees paid to it\\n     * @param amount Amount of settlement token paid\\n     */\\n    event SecondaryFeesPaid(address indexed secondaryFeeAddress, uint256 amount);\\n\\n    /**\\n     * @notice Indicates a payment of fees to the primary fee address\\n     * @param feeAddress The address that got fees paid to it\\n     * @param amount Amount of settlement token paid\\n     */\\n    event PrimaryFeesPaid(address indexed feeAddress, uint256 amount);\\n\\n    /**\\n     * @notice Indicates settlement assets have been withdrawn from the system\\n     * @param to Receipient\\n     * @param quantity Quantity of settlement tokens withdrawn\\n     */\\n    event SettlementWithdrawn(address indexed to, uint256 indexed quantity);\\n\\n    /**\\n     * @notice Indicates that the balance of pool tokens on issue for the pool\\n     *          changed\\n     * @param long New quantity of long pool tokens\\n     * @param short New quantity of short pool tokens\\n     */\\n    event PoolBalancesChanged(uint256 indexed long, uint256 indexed short);\\n\\n    function leverageAmount() external view returns (bytes16);\\n\\n    function poolCommitter() external view returns (address);\\n\\n    function settlementToken() external view returns (address);\\n\\n    function primaryFees() external view returns (uint256);\\n\\n    function secondaryFees() external view returns (uint256);\\n\\n    function oracleWrapper() external view returns (address);\\n\\n    function lastPriceTimestamp() external view returns (uint256);\\n\\n    function poolName() external view returns (string calldata);\\n\\n    function updateInterval() external view returns (uint32);\\n\\n    function shortBalance() external view returns (uint256);\\n\\n    function longBalance() external view returns (uint256);\\n\\n    function frontRunningInterval() external view returns (uint32);\\n\\n    function poolTokens() external view returns (address[2] memory);\\n\\n    function settlementEthOracle() external view returns (address);\\n\\n    // #### Functions\\n    /**\\n     * @notice Configures the pool on deployment. The pools are EIP 1167 clones.\\n     * @dev This should only be able to be run once to prevent abuse of the pool. Use of Openzeppelin Initializable or similar is recommended\\n     * @param initialization The struct Initialization containing initialization data\\n     */\\n    function initialize(Initialization calldata initialization) external;\\n\\n    function poolUpkeep(int256 _oldPrice, int256 _newPrice) external;\\n\\n    function settlementTokenTransferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external;\\n\\n    function payKeeperFromBalances(address to, uint256 amount) external returns (bool);\\n\\n    function settlementTokenTransfer(address to, uint256 amount) external;\\n\\n    function claimPrimaryFees() external;\\n\\n    function claimSecondaryFees() external;\\n\\n    /**\\n     * @notice Transfer pool tokens from pool to user\\n     * @param isLongToken True if transferring long pool token; False if transferring short pool token\\n     * @param to Address of account to transfer to\\n     * @param amount Amount of pool tokens being transferred\\n     * @dev Only callable by the associated `PoolCommitter` contract\\n     * @dev Only callable when the market is *not* paused\\n     */\\n    function poolTokenTransfer(\\n        bool isLongToken,\\n        address to,\\n        uint256 amount\\n    ) external;\\n\\n    function setNewPoolBalances(uint256 _longBalance, uint256 _shortBalance) external;\\n\\n    /**\\n     * @return _latestPrice The oracle price\\n     * @return _data The oracleWrapper's metadata. Implementations can choose what data to return here\\n     * @return _lastPriceTimestamp The timestamp of the last upkeep\\n     * @return _updateInterval The update frequency for this pool\\n     * @dev To save gas so PoolKeeper does not have to make three external calls\\n     */\\n    function getUpkeepInformation()\\n        external\\n        view\\n        returns (\\n            int256 _latestPrice,\\n            bytes memory _data,\\n            uint256 _lastPriceTimestamp,\\n            uint256 _updateInterval\\n        );\\n\\n    function getOraclePrice() external view returns (int256);\\n\\n    function intervalPassed() external view returns (bool);\\n\\n    function balances() external view returns (uint256 _shortBalance, uint256 _longBalance);\\n\\n    function setKeeper(address _keeper) external;\\n\\n    function updateFeeAddress(address account) external;\\n\\n    function updateSecondaryFeeAddress(address account) external;\\n\\n    function burnTokens(\\n        uint256 tokenType,\\n        uint256 amount,\\n        address burner\\n    ) external;\\n}\\n\",\"keccak256\":\"0x7aaf0368d3bd0875843b63d4dd066caefe54a69552f7d88904b923d1d9a69d51\",\"license\":\"CC-BY-NC-ND-4.0\"},\"contracts/interfaces/IPausable.sol\":{\"content\":\"//SPDX-License-Identifier: CC-BY-NC-ND-4.0\\npragma solidity 0.8.7;\\n\\n/// @title The pausable contract\\ninterface IPausable {\\n    /**\\n     * @notice Pauses the pool\\n     * @dev Prevents all state updates until unpaused\\n     */\\n    function pause() external;\\n\\n    /**\\n     * @notice Unpauses the pool\\n     * @dev Prevents all state updates until unpaused\\n     */\\n    function unpause() external;\\n\\n    /**\\n     * @return true if paused\\n     */\\n    function paused() external returns (bool);\\n\\n    event Paused();\\n    event Unpaused();\\n}\\n\",\"keccak256\":\"0x33e6187d3d403a66b6de93f1097933f202d8f16d8981d18b6bb168ccdcbad3a3\",\"license\":\"CC-BY-NC-ND-4.0\"},\"contracts/interfaces/IPoolCommitter.sol\":{\"content\":\"//SPDX-License-Identifier: CC-BY-NC-ND-4.0\\npragma solidity 0.8.7;\\n\\n/// @title The interface for the contract that handles pool commitments\\ninterface IPoolCommitter {\\n    /// Type of commit\\n    enum CommitType {\\n        ShortMint, // Mint short tokens\\n        ShortBurn, // Burn short tokens\\n        LongMint, // Mint long tokens\\n        LongBurn, // Burn long tokens\\n        LongBurnShortMint, // Burn Long tokens, then instantly mint in same upkeep\\n        ShortBurnLongMint // Burn Short tokens, then instantly mint in same upkeep\\n    }\\n\\n    function isMint(CommitType t) external pure returns (bool);\\n\\n    function isBurn(CommitType t) external pure returns (bool);\\n\\n    function isLong(CommitType t) external pure returns (bool);\\n\\n    function isShort(CommitType t) external pure returns (bool);\\n\\n    // Pool balances and supplies\\n    struct BalancesAndSupplies {\\n        uint256 newShortBalance;\\n        uint256 newLongBalance;\\n        uint256 longMintPoolTokens;\\n        uint256 shortMintPoolTokens;\\n        uint256 longBurnInstantMintSettlement;\\n        uint256 shortBurnInstantMintSettlement;\\n        uint256 totalLongBurnPoolTokens;\\n        uint256 totalShortBurnPoolTokens;\\n    }\\n\\n    // User aggregate balance\\n    struct Balance {\\n        uint256 longTokens;\\n        uint256 shortTokens;\\n        uint256 settlementTokens;\\n    }\\n\\n    // Token Prices\\n    struct Prices {\\n        bytes16 longPrice;\\n        bytes16 shortPrice;\\n    }\\n\\n    // Commit information\\n    struct Commit {\\n        uint256 amount;\\n        CommitType commitType;\\n        uint40 created;\\n        address owner;\\n    }\\n\\n    // Commit information\\n    struct TotalCommitment {\\n        uint256 longMintSettlement;\\n        uint256 longBurnPoolTokens;\\n        uint256 shortMintSettlement;\\n        uint256 shortBurnPoolTokens;\\n        uint256 shortBurnLongMintPoolTokens;\\n        uint256 longBurnShortMintPoolTokens;\\n    }\\n\\n    // User updated aggregate balance\\n    struct BalanceUpdate {\\n        uint256 _updateIntervalId;\\n        uint256 _newLongTokensSum;\\n        uint256 _newShortTokensSum;\\n        uint256 _newSettlementTokensSum;\\n        uint256 _longSettlementFee;\\n        uint256 _shortSettlementFee;\\n        uint8 _maxIterations;\\n    }\\n\\n    // Track how much of a user's commitments are being done from their aggregate balance\\n    struct UserCommitment {\\n        uint256 longMintSettlement;\\n        uint256 longBurnPoolTokens;\\n        uint256 shortMintSettlement;\\n        uint256 shortBurnPoolTokens;\\n        uint256 shortBurnLongMintPoolTokens;\\n        uint256 longBurnShortMintPoolTokens;\\n        uint256 updateIntervalId;\\n    }\\n\\n    // Track the relevant data when executing a range of update interval's commitments (stack too deep)\\n    struct CommitmentExecutionTracking {\\n        uint256 longTotalSupply;\\n        uint256 shortTotalSupply;\\n        uint256 longTotalSupplyBefore;\\n        uint256 shortTotalSupplyBefore;\\n        uint256 _updateIntervalId;\\n    }\\n\\n    /**\\n     * @notice Creates a notification when a commit is created\\n     * @param user The user making the commitment\\n     * @param amount Amount of the commit\\n     * @param commitType Type of the commit (Short v Long, Mint v Burn)\\n     * @param appropriateUpdateIntervalId Id of update interval where this commit can be executed as part of upkeep\\n     * @param fromAggregateBalance whether or not to commit from aggregate (unclaimed) balance\\n     * @param payForClaim whether or not to request this commit be claimed automatically\\n     * @param mintingFee Minting fee at time of commit creation\\n     */\\n    event CreateCommit(\\n        address indexed user,\\n        uint256 indexed amount,\\n        CommitType indexed commitType,\\n        uint256 appropriateUpdateIntervalId,\\n        bool fromAggregateBalance,\\n        bool payForClaim,\\n        bytes16 mintingFee\\n    );\\n\\n    /**\\n     * @notice Creates a notification when a user's aggregate balance is updated\\n     */\\n    event AggregateBalanceUpdated(address indexed user);\\n\\n    /**\\n     * @notice Creates a notification when the PoolCommitter's leveragedPool address has been updated.\\n     * @param newPool the address of the new leveraged pool\\n     */\\n    event PoolChanged(address indexed newPool);\\n\\n    /**\\n     * @notice Creates a notification when commits for a given update interval are executed\\n     * @param updateIntervalId Unique identifier for the relevant update interval\\n     * @param burningFee Burning fee at the time of commit execution\\n     */\\n    event ExecutedCommitsForInterval(uint256 indexed updateIntervalId, bytes16 burningFee);\\n\\n    /**\\n     * @notice Creates a notification when a claim is made, depositing pool tokens in user's wallet\\n     */\\n    event Claim(address indexed user);\\n\\n    /*\\n     * @notice Creates a notification when the burningFee is updated\\n     */\\n    event BurningFeeSet(uint256 indexed _burningFee);\\n\\n    /**\\n     * @notice Creates a notification when the mintingFee is updated\\n     */\\n    event MintingFeeSet(uint256 indexed _mintingFee);\\n\\n    /**\\n     * @notice Creates a notification when the changeInterval is updated\\n     */\\n    event ChangeIntervalSet(uint256 indexed _changeInterval);\\n\\n    /**\\n     * @notice Creates a notification when the feeController is updated\\n     */\\n    event FeeControllerSet(address indexed _feeController);\\n\\n    // #### Functions\\n\\n    function initialize(\\n        address _factory,\\n        address _autoClaim,\\n        address _factoryOwner,\\n        address _feeController,\\n        address _invariantCheck,\\n        uint256 mintingFee,\\n        uint256 burningFee,\\n        uint256 _changeInterval\\n    ) external;\\n\\n    function commit(bytes32 args) external payable;\\n\\n    function updateIntervalId() external view returns (uint128);\\n\\n    function pendingMintSettlementAmount() external view returns (uint256);\\n\\n    function pendingShortBurnPoolTokens() external view returns (uint256);\\n\\n    function pendingLongBurnPoolTokens() external view returns (uint256);\\n\\n    function claim(address user) external;\\n\\n    function executeCommitments(\\n        uint256 lastPriceTimestamp,\\n        uint256 updateInterval,\\n        uint256 longBalance,\\n        uint256 shortBalance\\n    )\\n        external\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256\\n        );\\n\\n    function updateAggregateBalance(address user) external;\\n\\n    function getAggregateBalance(address user) external view returns (Balance memory _balance);\\n\\n    function getAppropriateUpdateIntervalId() external view returns (uint128);\\n\\n    function setPool(address _leveragedPool) external;\\n\\n    function setBurningFee(uint256 _burningFee) external;\\n\\n    function setMintingFee(uint256 _mintingFee) external;\\n\\n    function setChangeInterval(uint256 _changeInterval) external;\\n\\n    function setFeeController(address _feeController) external;\\n}\\n\",\"keccak256\":\"0x6e61f689295ef4339452ac1ba5347d1e933d2ef231ca5d1a4a89ef94a506234b\",\"license\":\"CC-BY-NC-ND-4.0\"},\"contracts/interfaces/IPoolFactory.sol\":{\"content\":\"//SPDX-License-Identifier: CC-BY-NC-ND-4.0\\npragma solidity 0.8.7;\\n\\n/// @title The contract factory for the keeper and pool contracts. Utilizes minimal clones to keep gas costs low\\ninterface IPoolFactory {\\n    struct PoolDeployment {\\n        string poolName; // The name to identify a pool by\\n        uint32 frontRunningInterval; // The minimum number of seconds that must elapse before a commit can be executed. Must be smaller than or equal to the update interval to prevent deadlock\\n        uint32 updateInterval; // The minimum number of seconds that must elapse before a price change\\n        uint16 leverageAmount; // The amount of exposure to price movements for the pool\\n        address settlementToken; // The digital asset that the pool accepts\\n        address oracleWrapper; // The IOracleWrapper implementation for fetching price feed data\\n        address settlementEthOracle; // The oracle to fetch the price of Ether in terms of the settlement token\\n        address feeController;\\n        // The fee taken for each mint and burn. Fee value as a decimal multiplied by 10^18. For example, 50% is represented as 0.5 * 10^18\\n        uint256 mintingFee; // The fee amount for mints\\n        uint256 changeInterval; // The interval at which the mintingFee in a market either increases or decreases, as per the logic in `PoolCommitter::updateMintingFee`\\n        uint256 burningFee; // The fee amount for burns\\n    }\\n\\n    // #### Events\\n    /**\\n     * @notice Creates a notification when a pool is deployed\\n     * @param pool Address of the new pool\\n     * @param ticker Ticker of the new pool\\n     */\\n    event DeployPool(address indexed pool, address poolCommitter, string ticker);\\n\\n    /**\\n     * @notice Indicates that the InvariantCheck contract has changed\\n     * @param invariantCheck New InvariantCheck contract\\n     */\\n    event InvariantCheckChanged(address indexed invariantCheck);\\n\\n    /**\\n     * @notice Creates a notification when a PoolCommitter is deployed\\n     * @param poolCommitterAddress Address of new PoolCommitter\\n     * @param settlementToken Address of new settlementToken\\n     * @param pool Address of the pool associated with this PoolCommitter\\n     * @param changeInterval The amount that the `mintingFee` will change each update interval, based on `updateMintingFee`, given as a decimal * 10 ^ 18 (same format as `_mintingFee`)\\n     * @param feeController The address that has control over fee parameters\\n     */\\n    event DeployCommitter(\\n        address poolCommitterAddress,\\n        address settlementToken,\\n        address pool,\\n        uint256 changeInterval,\\n        address feeController\\n    );\\n\\n    /**\\n     * @notice Creates a notification when the pool keeper changes\\n     * @param _poolKeeper Address of the new pool keeper\\n     */\\n    event PoolKeeperChanged(address _poolKeeper);\\n\\n    /**\\n     * @notice Indicates that the maximum allowed leverage has changed\\n     * @param leverage New maximum allowed leverage value\\n     */\\n    event MaxLeverageChanged(uint256 indexed leverage);\\n\\n    /**\\n     * @notice Indicates that the receipient of fees has changed\\n     * @param receiver Address of the new receipient of fees\\n     */\\n    event FeeReceiverChanged(address indexed receiver);\\n\\n    /**\\n     * @notice Indicates that the receipient of fees has changed\\n     * @param fee Address of the new receipient of fees\\n     */\\n    event SecondaryFeeSplitChanged(uint256 indexed fee);\\n\\n    /**\\n     * @notice Indicates that the trading fee has changed\\n     * @param fee New trading fee\\n     */\\n    event FeeChanged(uint256 indexed fee);\\n\\n    /**\\n     * @notice Indicates that the AutoClaim contract has changed\\n     * @param autoClaim New AutoClaim contract\\n     */\\n    event AutoClaimChanged(address indexed autoClaim);\\n\\n    /**\\n     * @notice Indicates that the minting and burning fees have changed\\n     * @param mint Minting fee\\n     * @param burn Burning fee\\n     */\\n    event MintAndBurnFeesChanged(uint256 indexed mint, uint256 indexed burn);\\n\\n    /**\\n     * @notice Indicates that the deployment fee has changed\\n     * @param fee New deployment fee\\n     */\\n    event DeploymentFeeChanged(address _token, uint256 fee, address _receiver);\\n\\n    // #### Getters for Globals\\n    function pools(uint256 id) external view returns (address);\\n\\n    function numPools() external view returns (uint256);\\n\\n    function isValidPool(address _pool) external view returns (bool);\\n\\n    function isValidPoolCommitter(address _poolCommitter) external view returns (bool);\\n\\n    function getPoolKeeper() external view returns (address);\\n\\n    // #### Functions\\n    function deployPool(PoolDeployment calldata deploymentParameters) external returns (address);\\n\\n    function setPoolKeeper(address _poolKeeper) external;\\n\\n    function setAutoClaim(address _autoClaim) external;\\n\\n    function setInvariantCheck(address _invariantCheck) external;\\n\\n    function setFeeReceiver(address _feeReceiver) external;\\n\\n    function setFee(uint256 _fee) external;\\n\\n    function setDeploymentFee(\\n        address _token,\\n        uint256 _fee,\\n        address _receiver\\n    ) external;\\n\\n    function setSecondaryFeeSplitPercent(uint256 newFeePercent) external;\\n}\\n\",\"keccak256\":\"0x906764f2ac62f47dd5399c8dd79bd5d34f69f9442873d0a9dbc6008361675155\",\"license\":\"CC-BY-NC-ND-4.0\"}},\"version\":1}",
    "bytecode": "0x60a060405234801561001057600080fd5b5060405161079d38038061079d83398101604081905261002f9161009e565b6001600160a01b0381166100895760405162461bcd60e51b815260206004820152601660248201527f466163746f72792063616e6e6f74206265206e756c6c00000000000000000000604482015260640160405180910390fd5b60601b6001600160601b0319166080526100ce565b6000602082840312156100b057600080fd5b81516001600160a01b03811681146100c757600080fd5b9392505050565b60805160601c6106ac6100f1600039600081816040015260b401526106ac6000f3fe608060405234801561001057600080fd5b50600436106100365760003560e01c80634219dc401461003b5780639e079fc41461007e575b600080fd5b6100627f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b03909116815260200160405180910390f35b61009161008c3660046105bc565b610093565b005b604051635ab78ee160e01b81526001600160a01b03808316600483015282917f000000000000000000000000000000000000000000000000000000000000000090911690635ab78ee19060240160206040518083038186803b1580156100f857600080fd5b505afa15801561010c573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061013091906105fd565b6101725760405162461bcd60e51b815260206004820152600f60248201526e141bdbdb081a5cc81a5b9d985b1a59608a1b604482015260640160405180910390fd5b6000816001600160a01b031663cd39f30f6040518163ffffffff1660e01b815260040160206040518083038186803b1580156101ad57600080fd5b505afa1580156101c1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101e591906105e0565b90506000826001600160a01b0316637b9e618d6040518163ffffffff1660e01b815260040160206040518083038186803b15801561022257600080fd5b505afa158015610236573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061025a91906105e0565b6040516370a0823160e01b81526001600160a01b03868116600483015291909116906370a082319060240160206040518083038186803b15801561029d57600080fd5b505afa1580156102b1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102d5919061061f565b90506000826001600160a01b031663ce6609166040518163ffffffff1660e01b815260040160206040518083038186803b15801561031257600080fd5b505afa158015610326573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061034a919061061f565b90506000846001600160a01b0316637e71fc7d6040518163ffffffff1660e01b815260040160206040518083038186803b15801561038757600080fd5b505afa15801561039b573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103bf919061061f565b90506000856001600160a01b031663ba8d54686040518163ffffffff1660e01b815260040160206040518083038186803b1580156103fc57600080fd5b505afa158015610410573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610434919061061f565b9050610442848484846104ef565b6104bc576104508786610512565b7f32917bd2c7c894d384362f4fd6cb06a49869aaa5b63611e87c07f6b8adcd27676040516104af9060208082526017908201527f42616c616e636520696e76617269616e74206661696c73000000000000000000604082015260600190565b60405180910390a16104e6565b6040517f27b8a8fe1796821b48ac809f0032cf0def9eeff87ffe3c46c5bb7b323d50836f90600090a15b50505050505050565b6000816104fc8486610638565b6105069190610638565b90941015949350505050565b816001600160a01b0316638456cb596040518163ffffffff1660e01b8152600401600060405180830381600087803b15801561054d57600080fd5b505af1158015610561573d6000803e3d6000fd5b50505050806001600160a01b0316638456cb596040518163ffffffff1660e01b8152600401600060405180830381600087803b1580156105a057600080fd5b505af11580156105b4573d6000803e3d6000fd5b505050505050565b6000602082840312156105ce57600080fd5b81356105d98161065e565b9392505050565b6000602082840312156105f257600080fd5b81516105d98161065e565b60006020828403121561060f57600080fd5b815180151581146105d957600080fd5b60006020828403121561063157600080fd5b5051919050565b6000821982111561065957634e487b7160e01b600052601160045260246000fd5b500190565b6001600160a01b038116811461067357600080fd5b5056fea26469706673582212203a85289aa27dd743c846085a5e4113852efe2be9d01ca0fc63635367ac54fcb764736f6c63430008070033",
    "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100365760003560e01c80634219dc401461003b5780639e079fc41461007e575b600080fd5b6100627f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b03909116815260200160405180910390f35b61009161008c3660046105bc565b610093565b005b604051635ab78ee160e01b81526001600160a01b03808316600483015282917f000000000000000000000000000000000000000000000000000000000000000090911690635ab78ee19060240160206040518083038186803b1580156100f857600080fd5b505afa15801561010c573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061013091906105fd565b6101725760405162461bcd60e51b815260206004820152600f60248201526e141bdbdb081a5cc81a5b9d985b1a59608a1b604482015260640160405180910390fd5b6000816001600160a01b031663cd39f30f6040518163ffffffff1660e01b815260040160206040518083038186803b1580156101ad57600080fd5b505afa1580156101c1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101e591906105e0565b90506000826001600160a01b0316637b9e618d6040518163ffffffff1660e01b815260040160206040518083038186803b15801561022257600080fd5b505afa158015610236573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061025a91906105e0565b6040516370a0823160e01b81526001600160a01b03868116600483015291909116906370a082319060240160206040518083038186803b15801561029d57600080fd5b505afa1580156102b1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102d5919061061f565b90506000826001600160a01b031663ce6609166040518163ffffffff1660e01b815260040160206040518083038186803b15801561031257600080fd5b505afa158015610326573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061034a919061061f565b90506000846001600160a01b0316637e71fc7d6040518163ffffffff1660e01b815260040160206040518083038186803b15801561038757600080fd5b505afa15801561039b573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103bf919061061f565b90506000856001600160a01b031663ba8d54686040518163ffffffff1660e01b815260040160206040518083038186803b1580156103fc57600080fd5b505afa158015610410573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610434919061061f565b9050610442848484846104ef565b6104bc576104508786610512565b7f32917bd2c7c894d384362f4fd6cb06a49869aaa5b63611e87c07f6b8adcd27676040516104af9060208082526017908201527f42616c616e636520696e76617269616e74206661696c73000000000000000000604082015260600190565b60405180910390a16104e6565b6040517f27b8a8fe1796821b48ac809f0032cf0def9eeff87ffe3c46c5bb7b323d50836f90600090a15b50505050505050565b6000816104fc8486610638565b6105069190610638565b90941015949350505050565b816001600160a01b0316638456cb596040518163ffffffff1660e01b8152600401600060405180830381600087803b15801561054d57600080fd5b505af1158015610561573d6000803e3d6000fd5b50505050806001600160a01b0316638456cb596040518163ffffffff1660e01b8152600401600060405180830381600087803b1580156105a057600080fd5b505af11580156105b4573d6000803e3d6000fd5b505050505050565b6000602082840312156105ce57600080fd5b81356105d98161065e565b9392505050565b6000602082840312156105f257600080fd5b81516105d98161065e565b60006020828403121561060f57600080fd5b815180151581146105d957600080fd5b60006020828403121561063157600080fd5b5051919050565b6000821982111561065957634e487b7160e01b600052601160045260246000fd5b500190565b6001600160a01b038116811461067357600080fd5b5056fea26469706673582212203a85289aa27dd743c846085a5e4113852efe2be9d01ca0fc63635367ac54fcb764736f6c63430008070033",
    "devdoc": {
        "kind": "dev",
        "methods": {
            "checkInvariants(address)": {
                "details": "This should be called before onlyUnpaused, in case contracts are paused then pause check must happen after.Emits `InvariantsHold` event if invariants hold.",
                "params": {
                    "poolToCheck": "The LeveragedPool contract to be checked."
                }
            },
            "constructor": {
                "details": "Throws if factory address is null",
                "params": {
                    "_factory": "Address of the associated `PoolFactory` contract"
                }
            }
        },
        "title": "The contract for checking invariants and pausing if necessary",
        "version": 1
    },
    "userdoc": {
        "kind": "user",
        "methods": {
            "checkInvariants(address)": {
                "notice": "Checks all invariants, and pauses all contracts if         any invariant does not hold."
            },
            "constructor": {
                "notice": "Constructor"
            }
        },
        "notice": "Every time certain functions are called, known invariants are checked and if any do not hold, contracts are paused.",
        "version": 1
    },
    "storageLayout": {
        "storage": [],
        "types": null
    }
}
